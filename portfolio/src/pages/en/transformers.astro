---
import PostLayout from '@layouts/PostLayout.astro';
import CodeBlockInputCell from '@components/CodeBlockInputCell.astro';
import CodeBlockOutputCell from '@components/CodeBlockOutputCell.astro';

const { metadata_page } = await import('@portfolio/consts.json');
const { colors } = await import('@portfolio/consts.json');
const { svg_paths } = await import('@portfolio/consts.json');

const page_title = 'Transformers â€“ from top to the bottom';
const end_url = 'transformers';
const description = 'Discover transformers ðŸš€. Learn the architecture behind all the new language models. Don\'t ask an AI, come in and learn';
const keywords = 'transformer, transformers, nlp, from top to bottom, attention, multi-head attention, scaled dot product attention, add & norm, positional encoding';
const languaje = 'EN';
const image_path = 'https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/Transformer%20-%20leadspace.webp';
const opening_brace = '{';
const closing_brace = '}';
---

<PostLayout 
    title={page_title}
    languaje={languaje}
    description={description}
    keywords={keywords}
    author={metadata_page.author}
    theme_color={colors.background_color}
    end_url={end_url}
    image_path={image_path}
    image_width=1584
    image_height=633
    image_extension=webp
    article_date=2024-02-23+T00:00:00Z
>

  <section class="post-body">


    <aside class="post-index">
      <a class="anchor-link" href="#Transformer-as-a-black-box"><h2>Transformer as a black box</h2></a>
      <a class="anchor-link" href="#Tokenization"><h2>Tokenization</h2></a>
      <a class="anchor-link" href="#Input-embeddings"><h2>Input embeddings</h2></a>
      <a class="anchor-link" href="#Encoder---decoder"><h2>Encoder - decoder</h2></a>
      <a class="anchor-link" href="#Projection"><h2>Projection</h2></a>
      <a class="anchor-link" href="#Encoder-and-decoder-x6"><h2>Encoder and decoder x6</h2></a>
      <a class="anchor-link" href="#Attention---Feed-forward"><h2>Attention - Feed forward</h2></a>
      <a class="anchor-link" href="#Attention"><h3>Attention</h3></a>
      <a class="anchor-link" href="#Feed-forward"><h3>Feed forward</h3></a>
      <a class="anchor-link" href="#Positonal-encoding"><h2>Positonal encoding</h2></a>
      <a class="anchor-link" href="#Add-&amp;-Norm"><h2>Add &amp; Norm</h2></a>
      <a class="anchor-link" href="#Mechanisms-of-attention"><h2>Mechanisms of attention</h2></a>
      <a class="anchor-link" href="#Multi-head-attention"><h3>Multi-head attention</h3></a>
      <a class="anchor-link" href="#Scale-dot-product-attention"><h3>Scale dot product attention</h3></a>
      <a class="anchor-link" href="#Endocer-scale-dot-product-attention"><h4>Endocer scale dot product attention</h4></a>
      <a class="anchor-link" href="#Matmul"><h5>Matmul</h5></a>
      <a class="anchor-link" href="#Scale"><h5>Scale</h5></a>
      <a class="anchor-link" href="#Mask-(opt)"><h5>Mask (opt)</h5></a>
      <a class="anchor-link" href="#Softmax"><h5>Softmax</h5></a>
      <a class="anchor-link" href="#Matmul"><h5>Matmul</h5></a>
      <a class="anchor-link" href="#Summary"><h5>Summary</h5></a>
      <a class="anchor-link" href="#Decoder-masked-scale-dot-product-attention"><h4>Decoder masked scale dot product attention</h4></a>
      <a class="anchor-link" href="#Why-mask"><h5>Why mask</h5></a>
      <a class="anchor-link" href="#Mask"><h5>Mask</h5></a>
      <a class="anchor-link" href="#Encoder-decoder-scale-dot-product-attention"><h4>Encoder-decoder scale dot product attention</h4></a>
      <a class="anchor-link" href="#Summary"><h2>Summary</h2></a>
    </aside>


    <div class="post-body-content">
      
      <section class="section-block-markdown-cell">
      <h1 id="Transformers---from-top-to-the-bottom">Transformers - from top to the bottom<a class="anchor-link" href="#Transformers---from-top-to-the-bottom"><img decoding="async" class="link-img" width="24px" height="24px" alt="link image 27" src={svg_paths.link_svg_path}/></a></h1>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>In this post we are going to look at how Transformers work from top to bottom.</p>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>This notebook has been automatically translated to make it accessible to more people, please let me know if you see any typos.</p>
      <h2 id="Transformer-as-a-black-box">Transformer as a black box<a class="anchor-link" href="#Transformer-as-a-black-box"><img decoding="async" class="link-img" width="24px" height="24px" alt="link image 28" src={svg_paths.link_svg_path}/></a></h2>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>The transformer architecture was created for the translation problem, so let's explain it for that problem.</p>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>Imagine the transformer as a black box, which takes a sentence in one language and outputs the same sentence translated into another language.</p>
      <p><img decoding="async" onerror="this.parentNode.removeChild(this)" alt="Transformer - black box" src="http://maximofn.com/wp-content/uploads/2024/02/Transformer-black-box.png" width="1200" height="230"/></p>
      </section>
      
      <section class="section-block-markdown-cell">
      <h2 id="Tokenization">Tokenization<a class="anchor-link" href="#Tokenization"><img decoding="async" class="link-img" width="24px" height="24px" alt="link image 29" src={svg_paths.link_svg_path}/></a></h2>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>But as we have seen in the <a href="https://maximofn.com/tokens/">tokens</a> post, language models do not understand words as we do, they need numbers to be able to perform operations. So the original language sentence has to be converted to tokens by a tokenizer, and at the output we need a detokenizer to convert the output tokens to words</p>
      <p><img decoding="async" onerror="this.parentNode.removeChild(this)" alt="Transformer - black box - tokenizers" src="http://maximofn.com/wp-content/uploads/2024/02/Transformer-black-box-tokenizers.png" width="1200" height="152"/></p>
      <p>So the tokenizer creates a sequence of $n_{opening_brace}input-tokens{closing_brace}$ tokens, and the detokenizer receives a sequence of $n_{opening_brace}output-tokens{closing_brace}$ tokens.</p>
      </section>
      
      <section class="section-block-markdown-cell">
      <h2 id="Input-embeddings">Input embeddings<a class="anchor-link" href="#Input-embeddings"><img decoding="async" class="link-img" width="24px" height="24px" alt="link image 30" src={svg_paths.link_svg_path}/></a></h2>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>In the <a href="https://maximofn.com/embeddings/">embeddings</a> post we saw that embeddings are a way of representing words in a vector space. So the input tokens are passed through an embeddings layer to convert them into vectors.</p>
      <p>In a quick summary, the embedding process consists of converting a sequence of numbers (tokens) into a sequence of vectors. So a new vector space is created in which words that have semantic similarity will be close to each other.</p>
      <p><img decoding="async" onerror="this.parentNode.removeChild(this)" alt="word_embedding_3_dimmension" src="http://maximofn.com/wp-content/uploads/2023/12/word_embedding_3_dimmension.webp" width="995" height="825"/></p>
      <p>If we had $n_{opening_brace}input-tokens{closing_brace}$ tokens, we now have $n_{opening_brace}input-tokens{closing_brace}$ vectors. Each of those vectors has a length of $d_{opening_brace}model{closing_brace}$. That is, each token is converted to a vector representing that token in a $d_{opening_brace}model{closing_brace}$$-dimensional vector space.
      Therefore after passing through the embeddings layer, the sequence of $n_{opening_brace}input-tokens{closing_brace}$ tokens becomes an array of ($n_{opening_brace}input-tokens{closing_brace}$$ x $d_{opening_brace}model{closing_brace}$).</p>
      <p><img decoding="async" onerror="this.parentNode.removeChild(this)" alt="Transformer - black box - input embeddings" src="http://maximofn.com/wp-content/uploads/2024/02/Transformer-black-box-input-embeddings.png" width="1200" height="189"/></p>
      </section>
      
      <section class="section-block-markdown-cell">
      <h2 id="Encoder---decoder">Encoder - decoder<a class="anchor-link" href="#Encoder---decoder"><img decoding="async" class="link-img" width="24px" height="24px" alt="link image 31" src={svg_paths.link_svg_path}/></a></h2>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>We have seen the transformer acting as a black box, but in reality the transformer is an architecture that is composed of two parts, an encoder and a decoder.</p>
      <p><img decoding="async" onerror="this.parentNode.removeChild(this)" alt="Transformer - encoder-decoder" src="http://maximofn.com/wp-content/uploads/2024/02/Transformer-encoder-decoder.png" width="911" height="1493"/></p>
      <p>The encoder is in charge of compressing the information of the input sentence, it creates a latent space where the information of the input sentence is compressed. Then, that compressed information enters the decoder, which knows how to convert that compressed information into a phrase of the output language.</p>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>And how does the decoder convert this compressed information into a sentence of the output language? Well, token by token. To understand it better, let's forget about the output tokens for a moment, let's imagine that we have this architecture</p>
      <p>Transformer - encoder-decoder (no detokenizer)](<a href="http://maximofn.com/wp-content/uploads/2024/02/Transformer-encoder-decoder-no-detokenizer.png">http://maximofn.com/wp-content/uploads/2024/02/Transformer-encoder-decoder-no-detokenizer.png</a>)</p>
      <p>That is, the original language sentence is converted to tokens, these tokens are converted to embeddings, which enter the encoder, which compresses the information, the decoder takes it and converts it into words of the output language.</p>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>So the decoder generates a new word at the output at each step.</p>
      <p><img decoding="async" onerror="this.parentNode.removeChild(this)" alt="Transformer - encoder-decoder (no detokenizer)" src="https://raw.githubusercontent.com/maximofn/portafolio/main/images/Transformer%20-%20encoder-decoder%20(no%20detokenizer).gif" width="814" height="1200"/></p>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>But how does the decoder know which word to generate each time? Because it is being passed the phrase it has already translated, and at each step it generates the next word. That is, at each step the decoder receives the phrase it has translated so far, and generates the next word.</p>
      <p>But still, how does it know to generate the first word? Because it is passed a special word that means "start translating", and from there it generates the following words.</p>
      <p>And finally, how does the transformer know that it has to stop generating words? Because when it finishes translating it generates a special word meaning "end of translation", which when it re-enters the transformer makes it not generate any more words.</p>
      <p><img decoding="async" onerror="this.parentNode.removeChild(this)" alt="Transformer - encoder-decoder (not detokenizer) (input)" src="https://raw.githubusercontent.com/maximofn/portafolio/main/images/Transformer%20-%20encoder-decoder%20(no%20detokenizer)%20(input).gif" width="814" height="1200"/></p>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>Now that we have understood it in words, which is simpler, let's put the detokenizer back to the output</p>
      <p><img decoding="async" onerror="this.parentNode.removeChild(this)" alt="Transformer - encoder-decoder" src="http://maximofn.com/wp-content/uploads/2024/02/Transformer-encoder-decoder.png" width="911" height="1493"/></p>
      <p>Therefore the decoder will be generating tokens. To know that it has to start a sentence a special token commonly called <code>SOS</code> (Start Of Sentence) is inserted, and to know that it has to end it generates another special token commonly called <code>EOS</code> (End Of Sentence).</p>
      <p>And just like the encoder, the input token has to go through an embedding layer to convert the tokens into vector representations.</p>
      <p>Assuming that each token is equivalent to one word, the translation process would be as follows</p>
      <p><img decoding="async" onerror="this.parentNode.removeChild(this)" alt="Transformer - encoder-decoder (detokenizer)" src="https://raw.githubusercontent.com/maximofn/portafolio/main/images/Transformer%20-%20encoder-decoder%20(detokenizer).gif" width="775" height="1200"/></p>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>At the moment we have this architecture</p>
      <p><img decoding="async" onerror="this.parentNode.removeChild(this)" alt="Transformer - encoder-decoder (detokenizer)" src="http://maximofn.com/wp-content/uploads/2024/02/Transformer-encoder-decoder-detokenizer-2.png" width="911" height="1568"/></p>
      </section>
      
      <section class="section-block-markdown-cell">
      <h2 id="Projection">Projection<a class="anchor-link" href="#Projection"><img decoding="async" class="link-img" width="24px" height="24px" alt="link image 32" src={svg_paths.link_svg_path}/></a></h2>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>We have said that the decoder receives a token that passes through the embedding layer <code>Output embedding</code>.</p>
      <p>The <code>Output decoder</code> creates a vector for each token, so at the output of the <code>Output decoder</code> we have an array of ($n_{opening_brace}output-tokens{closing_brace}$ x $d_{opening_brace}model{closing_brace}$).</p>
      <p>The decoder performs operations, but outputs an array with the same dimension. So it needs to convert that matrix into a token and it does it by means of a linear layer that generates an array with the same dimension as the possible tokens in the language to be translated (output vocabulary).</p>
      <p>That array corresponds to the logits of each possible token, so it is then passed through a softmax layer that converts those logits into probabilities. That is, we will have the probability that each token is the next token.</p>
      <p><img decoding="async" onerror="this.parentNode.removeChild(this)" alt="Transformer - projection" src="http://maximofn.com/wp-content/uploads/2024/02/Transformer-projection.png" width="874" height="1200"/></p>
      </section>
      
      <section class="section-block-markdown-cell">
      <h2 id="Encoder-and-decoder-x6">Encoder and decoder x6<a class="anchor-link" href="#Encoder-and-decoder-x6"><img decoding="async" class="link-img" width="24px" height="24px" alt="link image 33" src={svg_paths.link_svg_path}/></a></h2>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>In the original paper they use 6 layers for the encoder and another 6 layers for the decoder. There is no reason why there should be 6, I guess they tried several values and this was the one that worked best for them.</p>
      <p>The output of the last encoder is fed to each decoder.</p>
      <p><img decoding="async" onerror="this.parentNode.removeChild(this)" alt="Transformer - encoder-decoder (x6)" src="http://maximofn.com/wp-content/uploads/2024/02/Transformer-encoder-decoder-x6.png" width="504" height="1200"/></p>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>To simplify the diagram we will represent it as follows from now on</p>
      <p><img decoding="async" onerror="this.parentNode.removeChild(this)" alt="Transformer - encoder-decoder (Nx)" src="http://maximofn.com/wp-content/uploads/2024/02/Transformer-encoder-decoder-Nx.png" width="866" height="1200"/></p>
      </section>
      
      <section class="section-block-markdown-cell">
      <h2 id="Attention---Feed-forward">Attention - Feed forward<a class="anchor-link" href="#Attention---Feed-forward"><img decoding="async" class="link-img" width="24px" height="24px" alt="link image 34" src={svg_paths.link_svg_path}/></a></h2>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>Let's start to see what's inside the encoder and decoder. Basically there is an attention mechanism and a feed forward layer.</p>
      <p><img decoding="async" onerror="this.parentNode.removeChild(this)" alt="Transformer - encoder-decoder - attention-ff" src="http://maximofn.com/wp-content/uploads/2024/02/Transformer-encoder-decoder-attention-ff.png" width="689" height="1200"/></p>
      </section>
      
      <section class="section-block-markdown-cell">
      <h3 id="Attention">Attention<a class="anchor-link" href="#Attention"><img decoding="async" class="link-img" width="24px" height="24px" alt="link image 35" src={svg_paths.link_svg_path}/></a></h3>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>We can see that 3 arrows enter in the attention mechanisms. We will see this later when we will see in depth how the attention mechanisms work.</p>
      <p>But for the moment we can say that they are operations that are performed in order to obtain the relationship that exists between tokens (and therefore, the relationship that exists between words).</p>
      <p>Before transformers, recurrent neural networks were used for the translation problem, which consisted of networks that received an input token, processed it and generated another output token. Then a second token was input, processed and another token was output, and so on with all the tokens in the input sequence. The problem with these networks is that when the sentences were very long, when the last tokens were in, the network "forgot" the first tokens. For example in very long sentences, it could happen that the gender of the subject would change throughout the translated sentence. And this is because after many tokens, the network had forgotten whether the subject was masculine or feminine.</p>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>To solve this, the entire sequence is entered into the attention mechanism of the transformers and the relationships (attention) between all the tokens are calculated at once.</p>
      <p>This is very powerful, since in a single calculation the relationship between all the tokens is obtained, no matter how long the sequence is.</p>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>While this is a great advantage and is what has led to transformers now being used in most of the best modern networks, it is also their biggest disadvantage, as the computation of the attention is very computationally expensive. It requires very large matrix multiplications.</p>
      <p>These multiplications are performed between matrices that correspond to the embeddings of each of the tokens by themselves. That is, the matrix representing the embeddings of the tokens is multiplied by itself. In order to perform this multiplication, one of the matrices must be rotated (algebra requirements to be able to multiply matrices). So a matrix is multiplied by itself, if the input sequence has more tokens, the matrices that are multiplied are larger, one in height and one in width, so the memory needed to store these matrices grows quadratically.</p>
      <p>So as the length of the sequences increases, the amount of memory needed to store those matrices grows quadratically. And this is a major limitation today, the amount of memory that GPUs have, which is where these multiplications are usually performed.</p>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>In the encoder, a single layer of attention is used to extract the relationships between the input tokens.</p>
      <p>Two layers of attention are used in the decoder, one to extract the relationships between the output tokens, and the other to extract the relationships between the encoder tokens and the decoder tokens.</p>
      </section>
      
      <section class="section-block-markdown-cell">
      <h3 id="Feed-forward">Feed forward<a class="anchor-link" href="#Feed-forward"><img decoding="async" class="link-img" width="24px" height="24px" alt="link image 36" src={svg_paths.link_svg_path}/></a></h3>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>After the attention layer, the sequence enters a <code>Feed forward</code> layer, which has two purposes</p>
      <ul>
      <li><p>One is to add nonlinearities. As we have explained, attention is achieved by matrix multiplications of the tokens of the input sequences. But if no nonlinear layers are applied to a network, in the end, the whole architecture could be summarized in a few linear computations. So neural networks would not be able to solve nonlinear problems. So this layer is added to add nonlinearity.</p>
      </li>
      <li><p>Another is feature extraction. Although the attention already extracts features, these are features of the relationships between the tokens. But this <code>Feed forward</code> layer is responsible for extracting features from the tokens themselves. That is, features are extracted from each token that are considered important for the problem being solved.</p>
      </li>
      </ul>
      </section>
      
      <section class="section-block-markdown-cell">
      <h2 id="Positonal-encoding">Positonal encoding<a class="anchor-link" href="#Positonal-encoding"><img decoding="async" class="link-img" width="24px" height="24px" alt="link image 37" src={svg_paths.link_svg_path}/></a></h2>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>We have explained that in the attention layer the relations between the tokens are obtained, that this relation is calculated by matrix multiplications and that these multiplications are performed between the embedding matrix by itself. So in the sentences <code>The cat eats fish</code> and <code>The fish eats cat</code>, the relationship between <code>the</code> and <code>cat</code> is the same in both sentences, since the relationship is computed by matrix multiplications of the embeddings of <code>the</code> and <code>cat</code>.</p>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>However, in the first <code>the</code> refers to the <code>cat</code>, while in the second <code>the</code> refers to the <code>fish</code>. So in addition to the relationships between the words we need to have some mechanism that tells us their position in the sentence.</p>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>In the paper they propose to introduce an attention mechanism that is in charge of adding values to the embedding vectors</p>
      <p><img decoding="async" onerror="this.parentNode.removeChild(this)" alt="Transformer - positional encoding" src="http://maximofn.com/wp-content/uploads/2024/02/Transformer-positional-encoding.png" width="887" height="1200"/></p>
      <p>Where the formula for calculating these values is</p>
      <p>Transformer - positional encoding (formula)](<a href="http://maximofn.com/wp-content/uploads/2024/02/Transformer-positional-encoding-formula.png">http://maximofn.com/wp-content/uploads/2024/02/Transformer-positional-encoding-formula.png</a>)</p>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>As this is a bit difficult to understand, let's see what a distribution of values of the <code>positional encoding</code> would look like.</p>
      <p>Transformer - positional encoding (diagram)](<a href="http://maximofn.com/wp-content/uploads/2024/02/Transformer-positional-encoding-diagram.png">http://maximofn.com/wp-content/uploads/2024/02/Transformer-positional-encoding-diagram.png</a>)</p>
      <p>The first token will have the values of the first row (the bottom one) added to it, the second token the values of the second row, and so on, which causes a change in the embeddings as shown in the figure. Seen in two dimensions, the waves that are being added can be seen.</p>
      <p>These waves cause that when attention calculations are performed, closer words have more relationship than more distant words.</p>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>But we can think one thing, if the embedding process consists of creating a vector space in which words with the same semantic meaning are close to each other, wouldn't this relationship be broken if values are added to the embeddings?</p>
      <p>If we look again at the vector space example from before</p>
      <p><img decoding="async" onerror="this.parentNode.removeChild(this)" alt="word_embedding_3_dimmension" src="http://maximofn.com/wp-content/uploads/2023/12/word_embedding_3_dimmension.webp" width="995" height="825"/></p>
      <p>We can see that the values go more or less from -1000 to 1000 on each axis, while the distribution graph</p>
      <p>Transformer - positional encoding (diagram)](<a href="http://maximofn.com/wp-content/uploads/2024/02/Transformer-positional-encoding-diagram.png">http://maximofn.com/wp-content/uploads/2024/02/Transformer-positional-encoding-diagram.png</a>)</p>
      <p>values range from -1 to 1, since this is the range of the sine and cosine functions.</p>
      <p>So we are varying in a range between -1 and 1 the values of the embeddings which are two or three orders of magnitude more, so the variation is going to be very small compared to the value of the embeddings.</p>
      <p>So we already have a way to know the relation of the position of the tokens in the phrase</p>
      </section>
      
      <section class="section-block-markdown-cell">
      <h2 id="Add-&amp;-Norm">Add &amp; Norm<a class="anchor-link" href="#Add-&amp;-Norm"><img decoding="async" class="link-img" width="24px" height="24px" alt="link image 38" src={svg_paths.link_svg_path}/></a></h2>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>Only one high-level block remains, and that is the <code>Add &amp; Norm</code> layers.</p>
      <p><img decoding="async" onerror="this.parentNode.removeChild(this)" alt="Transformer - Add &amp; norm" src="http://maximofn.com/wp-content/uploads/2024/02/Transformer-Add-norm.png" width="780" height="1200"/></p>
      <p>These are layers that are added after each attention layer and each feed forward layer. This layer aggregates the output and input of a layer. This is called residual connections and has the following advantages</p>
      <ul>
      <li><p>During training:</p>
      <ul>
      <li><p>They reduce the gradient fading problem: When a neural network is very large, in the training process, the gradients become smaller and smaller as you go deeper into the layers. This results in the deeper layers not being able to update their weights well. Residual connections allow gradients to pass directly through the layers, which helps keep them large enough so that the model can continue to learn, even in the deepest layers.</p>
      </li>
      <li><p>Enable training of deeper networks: By helping to mitigate the problem of gradient fading, residual connections also facilitate the training of deeper networks, which can lead to better performance.</p>
      </li>
      </ul>
      </li>
      <li><p>During inference:</p>
      <ul>
      <li><p>They allow the transmission of information between different layers: As the residual connections allow the output of each layer to become the sum of the input and output of the layer, information from the deeper layers is transmitted to the higher level layers. This can be beneficial in many tasks, especially where low-level and high-level information can be useful.</p>
      </li>
      <li><p>Improve model robustness: Since residual connections allow layers to learn better in deeper layers, models with residual connections can be more robust to perturbations in the input data.</p>
      </li>
      <li><p>They allow the recovery of lost information: If some information is lost during the transformation in some layer, the residual connections can allow this information to be recovered in the subsequent layers.</p>
      </li>
      </ul>
      </li>
      </ul>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>This layer is called <code>Add &amp; Norm</code>, we have seen the <code>Add</code>, let's see the <code>Norm</code>. The normalization is added so that adding the input and output does not trigger the values.</p>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>We have already seen all the high-level layers of the transformer.</p>
      <p><img decoding="async" onerror="this.parentNode.removeChild(this)" alt="transformer" src="http://maximofn.com/wp-content/uploads/2023/12/transformer-scaled.webp" width="852" height="1200"/></p>
      <p>so we can now look at the most important part of the paper and the one that gives it its name, the attention mechanisms.</p>
      </section>
      
      <section class="section-block-markdown-cell">
      <h2 id="Mechanisms-of-attention">Mechanisms of attention<a class="anchor-link" href="#Mechanisms-of-attention"><img decoding="async" class="link-img" width="24px" height="24px" alt="link image 39" src={svg_paths.link_svg_path}/></a></h2>
      </section>
      
      <section class="section-block-markdown-cell">
      <h3 id="Multi-head-attention">Multi-head attention<a class="anchor-link" href="#Multi-head-attention"><img decoding="async" class="link-img" width="24px" height="24px" alt="link image 40" src={svg_paths.link_svg_path}/></a></h3>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>Before looking at the actual mechanism of attention we have to look at the multi-head attention.</p>
      <p><img decoding="async" onerror="this.parentNode.removeChild(this)" alt="Transformer - multi-head attention" src="http://maximofn.com/wp-content/uploads/2024/02/Transformer-multi-head-attention.png" width="576" height="746"/></p>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>When we have explained the high-level layers, we have seen that in the attention layers there are 3 arrows, these are <code>Q</code>, <code>K</code> and <code>V</code>. They are matrices that correspond to the token information, in the case of the encoder attention mechanism, they correspond to the tokens of the original language sentence, and in the case of the decoder attention layer, they correspond to the tokens of the sentence that has been translated so far and of the encoder output.</p>
      <p>Actually now we don't care about the origin of the tokens, just keep in mind that they correspond to tokens. As we have explained the tokens are converted to embeddings, so <code>Q</code>, <code>K</code> and <code>V</code> are matrices of size ($n_{opening_brace}tokens{closing_brace}$ x $d_{opening_brace}model{closing_brace}$). Normally the embedding dimension ($d_{opening_brace}model{closing_brace}$) is usually a large number, such as 512, 1024, 2048, etc (it does not have to be a power of 2, these are just examples).</p>
      <p>We have explained that embeddings are vector representations of tokens. That is, tokens are converted to vector spaces in which words with similar semantic meaning are close together.</p>
      <p>Therefore, of all these dimensions, some may be related to morphological characteristics, others to syntactic characteristics, others to semantic characteristics, and so on. Therefore, it makes sense to calculate the attention mechanisms between dimensions of embeddings with similar characteristics.</p>
      <p>Recall that attentional mechanisms look for similarity between words, so it makes sense that similarity is sought between similar features.</p>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>Therefore, before calculating the attention mechanisms, the embedding dimensions are separated into groups of similar characteristics, and the attention mechanisms between these groups are calculated.</p>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>And how is this separation done? It would be necessary to look for similar dimensions, but to do this in a space of 512, 1024, 2048, etc. dimensions is very complicated. Besides, it is not possible to know which characteristics are similar and in each case the characteristics that are considered similar will change.</p>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>Linear projections are used to separate the dimensions into groups. That is, the embeddings are passed through linear layers that separate them into groups of similar characteristics. In this way, during the training of the transformer, the weights of the linear layers will change until reaching a point where the grouping is done in an optimal way.</p>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>Now we may have the doubt of how many groups to divide into. In the original paper they are divided into 8 groups, but there is no reason for them to be 8, I guess they tried several values and this was the one that worked best for them.</p>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>Once the embeddings have been divided into similar groups and the attention in the different groups has been calculated, the results are concatenated. This is logical, suppose we have an ebedding of 512 dimensions, and we divide it into 8 groups of 64 dimensions, if we calculate the attention in each of the groups, we will have 8 matrices of attention 64 dimensions, if we concatenate them we will have a matrix of attention 512 dimensions, which is the same dimension that we had at the beginning.</p>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>But concatenation makes all the features belong together. The first 64 dimensions correspond to one feature, the next 64 to another, and so on. So to mix them back together again, a linear layer is passed again that mixes all the features. And that blending is learned during training.</p>
      </section>
      
      <section class="section-block-markdown-cell">
      <h3 id="Scale-dot-product-attention">Scale dot product attention<a class="anchor-link" href="#Scale-dot-product-attention"><img decoding="async" class="link-img" width="24px" height="24px" alt="link image 41" src={svg_paths.link_svg_path}/></a></h3>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>We come to the most important part of the transformer, the attention mechanism, the <code>scaled dot product attention</code>.</p>
      <p><img decoding="async" onerror="this.parentNode.removeChild(this)" alt="Transformer - scaled dot product attention" src="http://maximofn.com/wp-content/uploads/2024/02/Transformer-scaled-dot-product-attention.png" width="684" height="732"/>
      <img decoding="async" onerror="this.parentNode.removeChild(this)" alt="Transformer - scaled dot product attention formula" src="http://maximofn.com/wp-content/uploads/2024/02/Transformer-scaled-dot-product-attention-formula.png" width="1200" height="165"/></p>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>As we have seen, in the Transformer architecture there are three attention mechanisms</p>
      <p><img decoding="async" onerror="this.parentNode.removeChild(this)" alt="transformer" src="http://maximofn.com/wp-content/uploads/2023/12/transformer-scaled.webp" width="852" height="1200"/></p>
      <p>The encoder, the decoder and the encoder-decoder. So let's explain them separately, because although they are almost the same, they have some small differences.</p>
      </section>
      
      <section class="section-block-markdown-cell">
      <h4 id="Endocer-scale-dot-product-attention">Endocer scale dot product attention<a class="anchor-link" href="#Endocer-scale-dot-product-attention"><img decoding="async" class="link-img" width="24px" height="24px" alt="link image 42" src={svg_paths.link_svg_path}/></a></h4>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>Let's take another look at the block diagram and the formula</p>
      <p><img decoding="async" onerror="this.parentNode.removeChild(this)" alt="Transformer - scaled dot product attention" src="http://maximofn.com/wp-content/uploads/2024/02/Transformer-scaled-dot-product-attention.png" width="684" height="732"/>
      <img decoding="async" onerror="this.parentNode.removeChild(this)" alt="Transformer - scaled dot product attention formula" src="http://maximofn.com/wp-content/uploads/2024/02/Transformer-scaled-dot-product-attention-formula.png" width="1200" height="165"/></p>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>First let's understand why there were three arrows entering the attention layers. If we look at the architecture of the transformer, the encoder input is split into three and enters the attention layer</p>
      <p><img decoding="async" onerror="this.parentNode.removeChild(this)" alt="transformer" src="http://maximofn.com/wp-content/uploads/2023/12/transformer-scaled.webp" width="852" height="1200"/></p>
      <p>So <code>K</code>, <code>Q</code> and <code>V</code> are the result of embedding and positional encoding. The same array is put into the attention layer three times. We have to remember that that matrix consisted of a list with all tokens ($n_{opening_brace}tokens{closing_brace}$), and each token was converted into a vector of embeddings of dimension $d_{opening_brace}model{closing_brace}$, so the dimension of the matrix will be ($n_{opening_brace}tokens{closing_brace}$ x $d_{opening_brace}model{closing_brace}$).</p>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>The meaning of <code>K</code>, <code>Q</code> and <code>V</code> comes from the <code>key</code>, <code>query</code> and <code>value</code> databases. The attention mechanism is passed the <code>Q</code> and <code>K</code> arrays, i.e., the question and the key, and the output is the <code>V</code> array, i.e., the answer.</p>
      <p>Let's look at each block separately and we will understand this better.</p>
      </section>
      
      <section class="section-block-markdown-cell">
      <h5 id="Matmul">Matmul<a class="anchor-link" href="#Matmul"><img decoding="async" class="link-img" width="24px" height="24px" alt="link image 43" src={svg_paths.link_svg_path}/></a></h5>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>This block corresponds to the matrix multiplication of the matrices <code>Q</code> and <code>K</code>. But in order to perform this operation it must be done with the transposed matrix of <code>K</code>. Since the two matrices have dimension ($n_{opening_brace}tokens{closing_brace}$ x $d_{opening_brace}model{closing_brace}$), in order to multiply them, the matrix <code>K</code> has to be transposed.</p>
      <p>So we will have a multiplication of a matrix of dimension ($n_{opening_brace}tokens{closing_brace}$$ x $d_{opening_brace}model{closing_brace}$$) by another matrix of dimension ($d_{opening_brace}model{closing_brace}$$ x $n_{opening_brace}tokens{closing_brace}$), so the result will be a matrix of dimension ($n_{opening_brace}tokens{closing_brace}$$ x $n_{opening_brace}tokens{closing_brace}$).</p>
      <p><img decoding="async" onerror="this.parentNode.removeChild(this)" alt="Transformer - matmul" src="http://maximofn.com/wp-content/uploads/2024/02/Transformer-matmul.png" width="1200" height="231"/></p>
      <p>As we can see, the result is a matrix where the diagonal is the multiplication of the embedding of each token by itself, and the rest of the positions are the multiplications between the embeddings of each token.</p>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>Now let's see why this multiplication is done. In the previous post <a href="https://maximofn.com/embeddings-similarity/">Measure of similarity between embeddings</a> we saw that one way to obtain the similarity between two embedding vectors is by calculating the cosine</p>
      <p>In the previous figure it can be seen that the multiplication between the matrices <code>Q</code> and <code>K</code> corresponds to the multiplication of the embeddings of each token. The multiplication between two vectors is performed in the following way</p>
      $$ "\mathbf{opening_brace}U{closing_brace}" = "\cdot \mathbf{opening_brace}V{closing_brace}". \mathbf{opening_brace}V{closing_brace} = \mathbf{opening_brace}U{closing_brace}| \mathbf{opening_brace}V{closing_brace}| \cos(\theta)$$<p>$.</p>
      <p>That is, we have the multiplication of the norms by their cosine. If the vectors were unitary, that is, their norms were 1, the multiplication of two vectors would be equal to the cosine between both vectors, which is one of the measures of similarity between vectors.</p>
      <p>So as in each position of the resulting matrix we have the multiplication between the embedding vectors of each token, in reality, each position of the matrix will represent the similarity between each token.</p>
      <p>Recall what embeddings were, embeddings were vector representations of tokens in a vector space, where tokens with semantic similarity are close together.</p>
      <p>So with this multiplication we have obtained a similarity matrix between the tokens of the phrase</p>
      <p><img decoding="async" onerror="this.parentNode.removeChild(this)" alt="Transformer - matmul - similarity matrix" src="http://maximofn.com/wp-content/uploads/2024/02/Transformer-matmul-similarity-matrix.png" width="1579" height="454"/></p>
      <p>The elements of the diagonal have maximum similarity (green), those of the corners have minimum similarity (red), and the rest of the elements have intermediate similarity.</p>
      </section>
      
      <section class="section-block-markdown-cell">
      <h5 id="Scale">Scale<a class="anchor-link" href="#Scale"><img decoding="async" class="link-img" width="24px" height="24px" alt="link image 44" src={svg_paths.link_svg_path}/></a></h5>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>Let's look again at the scaled dot product attention diagram and its formula</p>
      <p><img decoding="async" onerror="this.parentNode.removeChild(this)" alt="Transformer - scaled dot product attention" src="http://maximofn.com/wp-content/uploads/2024/02/Transformer-scaled-dot-product-attention.png" width="684" height="732"/>
      <img decoding="async" onerror="this.parentNode.removeChild(this)" alt="Transformer - scaled dot product attention formula" src="http://maximofn.com/wp-content/uploads/2024/02/Transformer-scaled-dot-product-attention-formula.png" width="1200" height="165"/></p>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>We had said that if by multiplying <code>Q</code> by <code>K</code> we performed the multiplication between the embedding vectors, and that if those vectors had norm 1, the result would be the similarity between the vectors. But since the vectors do not have norm 1, the result can have very high values, so it is normalized by dividing by the square root of the dimension of the embedding vectors.</p>
      </section>
      
      <section class="section-block-markdown-cell">
      <h5 id="Mask-(opt)">Mask (opt)<a class="anchor-link" href="#Mask-(opt)"><img decoding="async" class="link-img" width="24px" height="24px" alt="link image 45" src={svg_paths.link_svg_path}/></a></h5>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>Masking is optional and is not used in the encoder, so we will not explain it for the moment in order not to confuse the reader.</p>
      <p><img decoding="async" onerror="this.parentNode.removeChild(this)" alt="Transformer - scaled dot product attention" src="http://maximofn.com/wp-content/uploads/2024/02/Transformer-scaled-dot-product-attention.png" width="684" height="732"/>
      <img decoding="async" onerror="this.parentNode.removeChild(this)" alt="Transformer - scaled dot product attention formula" src="http://maximofn.com/wp-content/uploads/2024/02/Transformer-scaled-dot-product-attention-formula.png" width="1200" height="165"/></p>
      </section>
      
      <section class="section-block-markdown-cell">
      <h5 id="Softmax">Softmax<a class="anchor-link" href="#Softmax"><img decoding="async" class="link-img" width="24px" height="24px" alt="link image 46" src={svg_paths.link_svg_path}/></a></h5>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>Although we have divided by the square root of the dimension of the embedding vectors, we could do with the similarity between the embedding vectors going between the values 0 and 1, so to make sure of that, we pass through a softmax layer.</p>
      <p><img decoding="async" onerror="this.parentNode.removeChild(this)" alt="Transformer - scaled dot product attention" src="http://maximofn.com/wp-content/uploads/2024/02/Transformer-scaled-dot-product-attention.png" width="684" height="732"/>
      <img decoding="async" onerror="this.parentNode.removeChild(this)" alt="Transformer - scaled dot product attention formula" src="http://maximofn.com/wp-content/uploads/2024/02/Transformer-scaled-dot-product-attention-formula.png" width="1200" height="165"/></p>
      <p><img decoding="async" onerror="this.parentNode.removeChild(this)" alt="Transformer - matmul - similarity matrix softmax" src="http://maximofn.com/wp-content/uploads/2024/02/Transformer-matmul-similarity-matrix-softmax.png" width="1579" height="454"/></p>
      </section>
      
      <section class="section-block-markdown-cell">
      <h5 id="Matmul">Matmul<a class="anchor-link" href="#Matmul"><img decoding="async" class="link-img" width="24px" height="24px" alt="link image 47" src={svg_paths.link_svg_path}/></a></h5>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>Now that we have a similarity matrix between the embedding vectors, let's multiply it by the <code>V</code> matrix, which represents the embeddings of the tokens.</p>
      <p><img decoding="async" onerror="this.parentNode.removeChild(this)" alt="Transformer - matmul2" src="http://maximofn.com/wp-content/uploads/2024/02/Transformer-matmul2.png" width="1200" height="293"/></p>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>By multiplying, we obtain</p>
      <p><img decoding="async" onerror="this.parentNode.removeChild(this)" alt="Transformer - matmul2 result" src="http://maximofn.com/wp-content/uploads/2024/02/Transformer-matmul2-result.png" width="1200" height="144"/></p>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>We obtain a matrix with a mixture of embeddings with their similarity. In each row we obtain a mixture of the embeddings, where each element of the embedding is weighted according to the similarity of the token of that row with the rest of the tokens.</p>
      <p>In addition we have again a matrix of size ($n_{opening_brace}tokens{closing_brace}$ x $d_{opening_brace}model{closing_brace}$), which is the same dimension we had at the beginning.</p>
      </section>
      
      <section class="section-block-markdown-cell">
      <h5 id="Summary">Summary<a class="anchor-link" href="#Summary"><img decoding="async" class="link-img" width="24px" height="24px" alt="link image 48" src={svg_paths.link_svg_path}/></a></h5>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>In summary, we can say that the <code>scaled dot product attention</code> is a mechanism that calculates the similarity between the tokens of a sentence, and from that similarity, calculates an output matrix that corresponds to a mixture of embeddings weighted according to the similarity of the tokens.</p>
      </section>
      
      <section class="section-block-markdown-cell">
      <h4 id="Decoder-masked-scale-dot-product-attention">Decoder masked scale dot product attention<a class="anchor-link" href="#Decoder-masked-scale-dot-product-attention"><img decoding="async" class="link-img" width="24px" height="24px" alt="link image 49" src={svg_paths.link_svg_path}/></a></h4>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>We look again at the architecture of the transformer</p>
      <p><img decoding="async" onerror="this.parentNode.removeChild(this)" alt="transformer" src="http://maximofn.com/wp-content/uploads/2023/12/transformer-scaled.webp" width="852" height="1200"/></p>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>As we can see in this case the <code>scaled dot product attention</code> has the word <code>masked</code>. First we will explain why this masking is necessary, and then we will see how it is done.</p>
      </section>
      
      <section class="section-block-markdown-cell">
      <h5 id="Why-mask">Why mask<a class="anchor-link" href="#Why-mask"><img decoding="async" class="link-img" width="24px" height="24px" alt="link image 50" src={svg_paths.link_svg_path}/></a></h5>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>As we have said, the transformer was initially conceived as a translator, but in general, it is an architecture to which you put a sequence and you get another sequence. But at the time of training you have to give it the input sequence and the output sequence, and from there the transformer learns to translate.</p>
      <p>On the other hand, we have said that the transformer generates a new token each time. That is, it is given the input sequence in the encoder and a special start sequence token in the decoder, and from there it generates the first token of the output sequence.</p>
      <p>Then the input sequence is put back into the encoder and the token previously generated in the decoder, and from there it generates the second token of the output sequence.</p>
      <p>Then the input sequence is put back into the encoder and the two tokens previously generated in the decoder, and from there it generates the third token of the output sequence.</p>
      <p>And so on until it generates a special end-of-sequence token.</p>
      <p>But in training, as the input and output sequences are put into it all at once, we need to mask the tokens that it has not yet generated so that it cannot see them.</p>
      </section>
      
      <section class="section-block-markdown-cell">
      <h5 id="Mask">Mask<a class="anchor-link" href="#Mask"><img decoding="async" class="link-img" width="24px" height="24px" alt="link image 51" src={svg_paths.link_svg_path}/></a></h5>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>Let's take another look at the block diagram and the formula</p>
      <p><img decoding="async" onerror="this.parentNode.removeChild(this)" alt="Transformer - scaled dot product attention" src="http://maximofn.com/wp-content/uploads/2024/02/Transformer-scaled-dot-product-attention.png" width="684" height="732"/>
      <img decoding="async" onerror="this.parentNode.removeChild(this)" alt="Transformer - scaled dot product attention formula" src="http://maximofn.com/wp-content/uploads/2024/02/Transformer-scaled-dot-product-attention-formula.png" width="1200" height="165"/></p>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>The masking is done after the <code>Scale</code> and before the <code>Softmax</code>. As we need to mask the "future" tokens what can be done is to multiply the resulting <code>Scale</code> matrix by an array that has 0 in the positions we want to mask and 1 in the ones we don`t.</p>
      <p><img decoding="async" onerror="this.parentNode.removeChild(this)" alt="Transformer - Mask" src="http://maximofn.com/wp-content/uploads/2024/02/Transformer-Mask.png" width="1200" height="350"/></p>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>By doing this we get the same matrix as before but with masked positions</p>
      <p><img decoding="async" onerror="this.parentNode.removeChild(this)" alt="Transformer - Mask resutl" src="http://maximofn.com/wp-content/uploads/2024/02/Transformer-Mask-resutl.png" width="1316" height="454"/></p>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>Now the result of the <code>Scaled dot product attention</code> is a matrix with the embeddings of the tokens weighted according to the similarity of the tokens, but with the tokens that should not be masked.</p>
      </section>
      
      <section class="section-block-markdown-cell">
      <h4 id="Encoder-decoder-scale-dot-product-attention">Encoder-decoder scale dot product attention<a class="anchor-link" href="#Encoder-decoder-scale-dot-product-attention"><img decoding="async" class="link-img" width="24px" height="24px" alt="link image 52" src={svg_paths.link_svg_path}/></a></h4>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>We look again at the architecture of the transformer</p>
      <p><img decoding="async" onerror="this.parentNode.removeChild(this)" alt="transformer" src="http://maximofn.com/wp-content/uploads/2023/12/transformer-scaled.webp" width="852" height="1200"/></p>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>We see now that the attention mechanism receives twice the encoder output and once the masked attention of the decoder. So <code>K</code> and <code>V</code> are the encoder output, and <code>Q</code> is the decoder output.</p>
      <p><img decoding="async" onerror="this.parentNode.removeChild(this)" alt="Transformer - scaled dot product attention" src="http://maximofn.com/wp-content/uploads/2024/02/Transformer-scaled-dot-product-attention.png" width="684" height="732"/>
      <img decoding="async" onerror="this.parentNode.removeChild(this)" alt="Transformer - scaled dot product attention formula" src="http://maximofn.com/wp-content/uploads/2024/02/Transformer-scaled-dot-product-attention-formula.png" width="1200" height="165"/></p>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>Therefore in this attention block, first the similarity between the decoder sentence and the encoder sentence is calculated, i.e. the similarity between the sentence that has been translated so far and the original sentence is calculated.</p>
      <p>This similarity is then multiplied by the encoder sentence, i.e. a mixture of the embeddings of the original sentence weighted according to the similarity of the translated sentence so far is obtained.</p>
      </section>
      
      <section class="section-block-markdown-cell">
      <h2 id="Summary">Summary<a class="anchor-link" href="#Summary"><img decoding="async" class="link-img" width="24px" height="24px" alt="link image 53" src={svg_paths.link_svg_path}/></a></h2>
      </section>
      
      <section class="section-block-markdown-cell">
      <p>We have walked through the transformer from the highest level to the lowest level, so you may already have an understanding of how it works.</p>
      <p><img decoding="async" onerror="this.parentNode.removeChild(this)" alt="transformer" src="http://maximofn.com/wp-content/uploads/2023/12/transformer-scaled.webp" width="852" height="1200"/></p>
      <p><img decoding="async" onerror="this.parentNode.removeChild(this)" alt="Transformer - multi-head attention" src="http://maximofn.com/wp-content/uploads/2024/02/Transformer-multi-head-attention.png" width="576" height="746"/>
      <img decoding="async" onerror="this.parentNode.removeChild(this)" alt="Transformer - scaled dot product attention" src="http://maximofn.com/wp-content/uploads/2024/02/Transformer-scaled-dot-product-attention.png" width="684" height="732"/></p>
      </section>
      






    </div>

  </section>

</PostLayout>
