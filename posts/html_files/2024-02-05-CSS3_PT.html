<section class="section-block-markdown-cell">
<h1 id="CSS 3">CSS 3<a class="anchor-link" href="#CSS 3">¶</a></h1>
</section>
<section class="section-block-markdown-cell">
<blockquote>
<p>Aviso: Este post foi traduzido para o português usando um modelo de tradução automática. Por favor, me avise se encontrar algum erro.</p>
</blockquote>
</section>
<section class="section-block-markdown-cell">
<h2 id="Partes do CSS (seletor, propriedades, valores)">Partes do CSS (seletor, propriedades, valores)<a class="anchor-link" href="#Partes do CSS (seletor, propriedades, valores)">¶</a></h2>
</section>
<section class="section-block-markdown-cell">
<p>Em CSS, podem falar de 3 partes principais:</p>
<ul>
  <li><strong>Seletor</strong>: É a parte que seleciona o elemento ao qual será aplicado o estilo.</li>
  <li><strong>Propriedade</strong>: É a parte que define o estilo que será aplicado ao elemento.</li>
  <li><strong>Valor</strong>: É a parte que define o valor da propriedade que será aplicada ao elemento.</li>
</ul>
<p>Para adicionar comentários em CSS usa-se <code>/* comentário */</code>.</p>
<p>A linha que tem <code>propriedade: valor;</code> é chamada de **declaração**.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seletor &#123;<br>propriedade: valor;   /* comentário */<br>&#125;</code></pre></div>
      </section>
</section>
<section class="section-block-markdown-cell">
<h2 id="Seletores">Seletores<a class="anchor-link" href="#Seletores">¶</a></h2>
</section>
<section class="section-block-markdown-cell">
<p>Há vários tipos de seletores:</p>
<ul>
  <li><strong>Seletor universal</strong>: Seleciona todos os elementos da página. Utiliza o asterisco <code>*</code>.</li>
  <li><strong>Seletor de tipo</strong>: Seleciona todos os elementos de um tipo. Utiliza o nome do tipo de elemento. Por exemplo, <code>p</code> seleciona todos os parágrafos.</li>
  <li><strong>Seletor de classe</strong>: Seleciona todos os elementos que tenham uma classe. Utiliza o nome da classe. Por exemplo, <code>.classe</code> seleciona todos os elementos que tenham a classe <code>clase</code>. Isso é útil, porque se quisermos que todos os botões sejam iguais, no HTML colocamos <code>&lt;button class="botao"&gt;</code> e no CSS colocamos <code>.botao &#123; /* estilos */ &#125;</code>. Assim, todos os botões terão os mesmos estilos, e se quisermos que um botão seja diferente, adicionamos outra classe.</li>
  <li><strong>Seletor de pseudo-classe</strong>: Seleciona todos os elementos que tenham uma pseudo-classe. Utiliza-se o nome da pseudo-classe. Por exemplo, <code>:hover</code> seleciona todos os elementos que estejam sendo selecionados pelo mouse. Isso é útil, porque se quisermos que um botão mude de cor quando o mouse estiver em cima, no CSS colocamos <code>.botao:hover &#123; /* estilos */ &#125;</code>. Assim, o botão terá os estilos desejados quando o mouse estiver em cima. Algumas pseudo-classes são:</li>
  <li><code>:hover</code>: Seleciona todos os elementos que estão sendo selecionados pelo mouse.</li>
  <li><code>:active</code>: Seleciona todos os elementos que estão sendo selecionados pelo mouse e estão sendo pressionados.</li>
  <li><code>:focus</code>: Seleciona todos os elementos que estão sendo selecionados pelo mouse e pressionados, e além disso, tenham o foco.</li>
  <li><code>:first-child</code>: Seleciona todos os elementos que sejam o primeiro filho de seu pai. Isso é útil, por exemplo, com os <code>&lt;li&gt;</code> das listas, porque se quisermos que o primeiro elemento da lista tenha um estilo diferente, no css colocamos <code>li:first-child &#123; /* estilos */ &#125;</code>. Assim, o primeiro elemento da lista terá os estilos que desejarmos.</li>
  <li><code>:last-child</code>: Seleciona todos os elementos que sejam o último filho de seu pai. Isso é útil, por exemplo, com os <code>&lt;li&gt;</code> das listas, porque se quisermos que o último elemento da lista tenha um estilo diferente, no css colocamos <code>li:last-child &#123; /* estilos */ &#125;</code>. Assim, o último elemento da lista terá os estilos que desejarmos.</li>
  <li><code>:nth-child(n)</code>: Seleciona todos os elementos que sejam o n-ésimo filho de seu pai. Por exemplo, <code>:nth-child(2)</code> seleciona todos os elementos que sejam o segundo filho de seu pai.</li>
  <li><code>:nth-last-child(n)</code>: Seleciona todos os elementos que sejam o n-ésimo filho de seu pai, começando do final. Por exemplo, <code>:nth-last-child(2)</code> seleciona todos os elementos que sejam o segundo filho de seu pai, começando do final.</li>
  <li><code>:nth-of-type(n)</code>: Seleciona todos os elementos que sejam o n-ésimo filho de seu pai, do mesmo tipo. Por exemplo, <code>:nth-of-type(2)</code> seleciona todos os elementos que sejam o segundo filho de seu pai, do mesmo tipo.</li>
  <li><code>:nth-last-of-type(n)</code>: Seleciona todos os elementos que sejam o n-ésimo filho de seu pai, do mesmo tipo, começando pelo final. Por exemplo, <code>:nth-last-of-type(2)</code> seleciona todos os elementos que sejam o segundo filho de seu pai, do mesmo tipo, começando pelo final.</li>
  <li><code>:first-of-type</code>: Seleciona todos os elementos que sejam o primeiro filho de seu pai, do mesmo tipo.</li>
  <li><code>:last-of-type</code>: Seleciona todos os elementos que sejam o último filho de seu pai, do mesmo tipo.</li>
  <li><code>:only-child</code>: Seleciona todos os elementos que sejam o único filho de seu pai.</li>
  <li><code>:only-of-type</code>: Seleciona todos os elementos que sejam o único filho de seu pai, do mesmo tipo.</li>
  <li><code>:empty</code>: Seleciona todos os elementos que não tenham filhos.</li>
  <li><strong>Selector de id</strong>: Seleciona um elemento que tenha um id. Utiliza o nome do id. Por exemplo, <code>#id</code> seleciona o elemento que tenha o id <code>id</code>. Isso é útil, porque se quisermos que um elemento seja único, no html colocamos <code>&lt;p id="unico"&gt;</code> e no css colocamos <code>#unico &#123; /* estilos */ &#125;</code>. Assim, esse elemento terá os estilos que desejarmos, e se quisermos que outro elemento seja igual, adicionamos outra classe.</li>
  <li><strong>Seletores combinados</strong>: Selecionam elementos que atendam várias condições. Usamos os seletores que quisermos, separados por um espaço. Por exemplo, <code>p .classe</code> seleciona todos os elementos que tenham a classe <code>clase</code> e sejam filhos de um parágrafo. Isso é útil, porque se quisermos que todos os botões que estiverem dentro de um parágrafo sejam iguais, no HTML colocamos <code>&lt;p class="paragrafo_que_quero_alterar"&gt;&lt;button class="botao"&gt;</code> e no CSS colocamos <code>.paragrafo_que_quero_alterar .botao &#123; /* estilos */ &#125;</code>. Assim, todos os botões que estiverem dentro de um parágrafo com a classe <code>paragrafo_que_quero_alterar</code> terão os mesmos estilos, e se quisermos que um botão seja diferente, colocamos outra classe.</li>
  <li><strong>Seletor combinado de primeiro nível</strong>: Selecionam elementos que atendam a várias condições, mas apenas se estiverem no primeiro nível. Utilizamos os seletores que quisermos, separados por um <code>></code>. Por exemplo, <code>p > .classe</code> seleciona todos os elementos que tenham a classe <code>classe</code> e sejam filhos diretos de um parágrafo. Isso é útil porque, se quisermos que todos os botões que estejam dentro de um parágrafo sejam iguais, no HTML colocamos <code>&lt;p class="paragrafo_que_quero_alterar"&gt;&lt;button class="botao"&gt;</code> e no CSS colocamos <code>.paragrafo_que_quero_alterar > .botao &#123; /* estilos */ &#125;</code>. Assim, todos os botões que estejam dentro de um parágrafo com a classe <code>paragrafo_que_quero_alterar</code> terão os mesmos estilos, e se quisermos que um botão seja diferente, adicionamos outra classe.</li>
  <li><strong>Seletor combinado de irmãos</strong>: Selecionam elementos que atendam várias condições, mas apenas se estiverem no mesmo nível. Utilizamos os seletores que quisermos, separados por um <code>~</code>. Por exemplo, <code>p ~ .classe</code> seleciona todos os elementos que tenham a classe <code>classe</code> e estejam no mesmo nível de um parágrafo. Isso é útil porque, se quisermos que todos os botões que estejam no mesmo nível de um parágrafo sejam iguais, no HTML colocamos <code>&lt;p class="paragrafo_que_quero_alterar"&gt;&lt;/p&gt;&lt;button class="botao"&gt;</code> e no CSS colocamos <code>.paragrafo_que_quero_alterar ~ .botao &#123; /* estilos */ &#125;</code>. Assim, todos os botões que estejam no mesmo nível de um parágrafo com a classe <code>paragrafo_que_quero_alterar</code> terão os mesmos estilos. Se quisermos que um botão seja diferente, damos a ele outra classe.</li>
  <li><strong>Seletor de irmãos adjacentes combinados</strong>: Selecionam elementos que atendam várias condições, mas apenas se estiverem no mesmo nível e forem adjacentes. Utilizamos os seletores que quisermos, separados por um <code>+</code>. Por exemplo, <code>p + .classe</code> seleciona todos os elementos que tenham a classe <code>clase</code> e estejam no mesmo nível e sejam adjacentes a um parágrafo. Isso é útil, porque se quisermos que todos os botões que estejam no mesmo nível e sejam adjacentes a um parágrafo sejam iguais, no HTML colocamos <code>&lt;p class="parrafo_que_quiero_cambiar"&gt;&lt;/p&gt;&lt;button class="boton"&gt;</code> e no CSS colocamos <code>.parrafo_que_quiero_cambiar + .boton &#123; /* estilos */ &#125;</code>. Assim, todos os botões que estejam no mesmo nível e sejam adjacentes a um parágrafo com a classe <code>parrafo_que_quiero_cambiar</code> terão os mesmos estilos, e se quisermos que um botão seja diferente, damos outra classe.</li>
</ul>
<p>O normal é usar o seletor de classe, pois assim podemos reutilizar os estilos.</p>
</section>
<section class="section-block-markdown-cell">
<h2 id="Estilos">Estilos<a class="anchor-link" href="#Estilos">¶</a></h2>
</section>
<section class="section-block-markdown-cell">
<h3 id="Cor">Cor<a class="anchor-link" href="#Cor">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>O cor pode ser definido de várias maneiras:</p>
<ul>
  <li><strong>Nome</strong>: Pode ser colocado o nome da cor. Por exemplo, <code>red</code> é vermelho.</li>
  <li><strong>Hexadecimal</strong>: Pode-se colocar a cor em hexadecimal. Por exemplo, <code>#ff0000</code> é vermelho.</li>
</ul>
<p>Se quiser adicionar transparência, pode-se colocar <code>#ff000080</code>, que é vermelho com 50% de transparência.</p>
<p>Se apenas são colocados 3 números, eles se repetem. Por exemplo, <code>#f10</code> é o mesmo que <code>#ff1100</code>. Se quiser adicionar transparência, pode-se colocar <code>#f108</code>, que é o mesmo que <code>#ff110088</code>.</p>
<ul>
  <li><strong>RGB</strong>: Pode-se colocar a cor em RGB. Por exemplo, <code>rgb(255, 0, 0)</code> é vermelho.</li>
</ul>
<p>Se quiser adicionar transparência, pode-se colocar <code>rgb(255 0 0 / 0.5)</code>, que é vermelho com 50% de transparência. Também se pode colocar a transparência em porcentagem, <code>rgb(255 0 0 / 50%)</code>. Pode-se encontrar a transparência de uma forma legada com <code>rgba(255, 0, 0, 0.5)</code>, que é vermelho com 50% de transparência, mas o melhor é utilizar a forma moderna.</p>
<ul>
  <li><strong>HSL</strong>: Pode-se colocar a cor em HSL. Por exemplo, <code>hsl(0, 100%, 50%)</code> é vermelho.</li>
</ul>
<ul>
  <li><strong>OKLCH</strong>: Pode-se colocar a cor em OKLCH. Por exemplo, <code>oklch(0 100% 50%)</code> é vermelho.</li>
</ul>
<p>Em <code>HSL</code> e <code>OKLCH</code> há uma maior escala de cores em comparação com <code>RGB</code>, portanto, se você precisar de mais cores, é melhor usar <code>HSL</code> ou <code>OKLCH</code>.</p>
<p>Também é possível adicionar a transparência adicionando a declaração <code>color:transparent</code>.</p>
</section>
<section class="section-block-markdown-cell">
<h3 id="Cor Color Atual">Cor Color Atual<a class="anchor-link" href="#Cor Color Atual">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Há um valor de cor que é <code>currentColor</code>, que é a cor atual. Por exemplo, se temos um texto e configuramos sua cor para vermelho, e depois adicionamos uma borda a este texto, se colocarmos <code>border: 1px solid currentColor;</code>, a borda será vermelha.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">p &#123;<br>cor: vermelho;<br>borda: 1px sólida correnteColor;<br>&#125;</code></pre></div>
      </section>
</section>
<section class="section-block-markdown-cell">
<h3 id="Heranca">Herança<a class="anchor-link" href="#Heranca">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Quando um estilo é aplicado a um elemento, esse estilo é herdado pelos elementos filhos. Por exemplo, se tivermos um <code>div</code> com um texto, e definirmos a cor vermelha para o <code>div</code>, o texto também será vermelho.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-html">&lt;div&gt;<br>&lt;p&gt;Texto&lt;/p&gt;<br>&lt;/div&gt;</code></pre></div>
      </section>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">div &#123;<br>cor: vermelho;<br>&#125;</code></pre></div>
      </section>
<p>Ao fazer isso, o texto ficará vermelho.</p>
</section>
<section class="section-block-markdown-cell">
<p>Podemos indicar no filho quais estilos são herdados. Por exemplo, suponhamos que temos um pai e um filho</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-html">&lt;div class="pai"&gt;<br>&lt;p class="hijo"&gt;Texto&lt;/p&gt;<br>&lt;/div&gt;</code></pre></div>
      </section>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">.padre &#123;<br>cor: vermelho;<br>&#125;<br><br>.filho &#123;<br>cor: inherit;<br>&#125;</code></pre></div>
      </section>
<p>Ao fazer isso, o texto ficará vermelho, pois o filho herda a cor do pai.</p>
<p>As opções possíveis são:</p>
<ul>
  <li><code>inherit</code>: Herda o estilo do pai.</li>
  <li><code>inicial</code>: Coloca o estilo padrão.</li>
  <li><code>unset</code>: Reseta o estilo</li>
  <li><code>revert</code>: Reverte o estilo</li>
</ul>
<p>Não todos os estilos são herdados, por exemplo, o <code>background</code> não é herdado. Para não listar todos os estilos que são herdados, uma forma de saber é indo ao <code>MDN</code> e verificando se o estilo tem a propriedade <code>Inherited</code> definida como <code>yes</code> (dentro de <code>Formal definition</code>).</p>
</section>
<section class="section-block-markdown-cell">
<h3 id="Fontes">Fontes<a class="anchor-link" href="#Fontes">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Na hora de carregar as fontes, elas podem ser carregadas de várias maneiras:</p>
<ul>
  <li><strong>Local</strong>: Pode carregar uma fonte local. Por exemplo, <code>font-family: Arial;</code> carrega a fonte Arial.</li>
  <li><strong>URL</strong>: Pode carregar uma fonte a partir de uma URL. Por exemplo, <code>font-family: url(https://fonts.googleapis.com/css2?family=Roboto);</code> carrega a fonte Roboto do Google Fonts.</li>
  <li><strong>Genérica</strong>: Pode-se carregar uma fonte genérica. Por exemplo, <code>font-family: sans-serif;</code> carrega uma fonte sem serifa. Esta fonte depende do sistema operativo, então no Windows será Arial, no Mac será Helvetica e no Linux será DejaVu Sans.</li>
</ul>
<p>Várias fontes podem ser carregadas, e se uma não estiver disponível, a próxima é carregada. Por exemplo, <code>font-family: Arial, sans-serif;</code> carrega Arial, e se não estiver disponível, carrega uma fonte sem serifa.</p>
<p>Também é possível carregar uma fonte com vários estilos. Por exemplo, <code>font-family: Arial, sans-serif; font-weight: 700;</code> carrega Arial em negrito, e se não estiver disponível, carrega uma fonte sem serifa em negrito.</p>
<p>Como <code>sans-serif</code> é uma fonte genérica, é ideal colocá-la por último, para que, se a fonte desejada não estiver disponível, seja carregada a genérica.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">p &#123;<br>font-family: url(https://fonts.googleapis.com/css2?family=Roboto), url(https://fonts.googleapis.com/css2?family=Roboto+Slab), Ubuntu, sans-serif;<br>&#125;</code></pre></div>
      </section>
</section>
<section class="section-block-markdown-cell">
<h3 id="Borda e Contorno">Borda e Contorno<a class="anchor-link" href="#Borda e Contorno">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Podemos colocar uma borda em um elemento com <code>border: 1px solid red;</code>. Isso coloca uma borda de 1px de espessura, sólida e vermelha.</p>
<p>Se quisermos colocar uma borda, podemos usar <code>outline: 1px solid red;</code>. Isso coloca uma borda de 1px de espessura, sólida e vermelha.</p>
<p>A diferença entre <code>border</code> e <code>outline</code> é que <code>border</code> ocupa espaço, e <code>outline</code> não. Por exemplo, se tivermos um <code>div</code> com um texto, e colocarmos uma borda, o texto se moverá para que a borda fique visível. Se colocarmos um contorno, o texto não se moverá, porque o contorno não ocupa espaço. Isso pode ser observado se alterarmos o estilo na pseudo-classe <code>:hover</code>. Se colocarmos uma borda, quando passarmos o mouse por cima, o texto se moverá, mas se colocarmos um contorno, o texto não se moverá.</p>
</section>
<section class="section-block-markdown-cell">
<h2 id="Cachoeira">Cachoeira<a class="anchor-link" href="#Cachoeira">¶</a></h2>
</section>
<section class="section-block-markdown-cell">
<p>A cascata é a ordem na qual os estilos são aplicados. A ordem é:</p>
<ol>
  <li>Estilos do usuário: São os estilos que o usuário configurou. Por exemplo, se o usuário tiver configurado que o texto seja de cor vermelha, o texto será vermelho.</li>
  <li>Estilos do autor: São os estilos que o autor configurou. Por exemplo, se o autor configurou que o texto seja de cor azul, o texto será azul.</li>
  <li>Estilos do navegador: São os estilos do navegador. Por exemplo, se o navegador estiver configurado para que o texto seja de cor verde, o texto será verde.</li>
</ol>
<p>Prevalecem os estilos do usuário sobre os do autor, e os do autor sobre os do navegador.</p>
<p>Mas dentro dos estilos do autor, prevalecem os estilos que estão mais abaixo no código. Por exemplo, se tivermos um <code>div</code> com um texto, e colocarmos a cor vermelha, e depois colocarmos a cor azul, o texto será azul.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-html">&lt;div&gt;<br>&lt;p&gt;Texto&lt;/p&gt;<br>&lt;/div&gt;</code></pre></div>
      </section>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">div &#123;cor: vermelho;<br>&#125;<br><br>div &#123;<br>cor: azul;<br>&#125;</code></pre></div>
      </section>
<p>Neste exemplo, o texto será azul. O cor vermelha é substituída pela cor azul.</p>
</section>
<section class="section-block-markdown-cell">
<h3 id="Fallback">Fallback<a class="anchor-link" href="#Fallback">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Um dos benefícios da cascata é que podemos aplicar um estilo muito novo, mas caso o navegador que o usuário esteja utilizando não o suporte, podemos definir um estilo mais antigo antes como precaução. Por exemplo, estilizar a cor com <code>oklch</code> é algo novo, que pode não ser suportado pelo navegador do usuário, por isso podemos definir um estilo mais antigo antes como precaução.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">p &#123;<br>cor: rgb(255, 0, 0);<br>color: oklch(0 100% 50%);<br>&#125;</code></pre></div>
      </section>
<p>Desta forma, o navegador primeiro tentará estilizar com <code>oklch</code>, e se não puder, estilizará com <code>rgb</code>.</p>
</section>
<section class="section-block-markdown-cell">
<h3 id="Especificidade">Especificidade<a class="anchor-link" href="#Especificidade">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Pode ser que um elemento HTML tenha várias formas de se referir a ele. Por exemplo</p>
<div class='highlight'><pre><code class="language-html">&lt;p class="clase" id="id"&gt;Texto&lt;/p&gt;
</code></pre></div>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">p &#123;<br>cor: vermelho;<br>&#125;<br><br>.classe &#123;<br>cor: azul;<br>&#125;<br><br>#id &#123;<br>cor: verde;<br>&#125;</code></pre></div>
      </section>
<p>Neste exemplo, o texto será verde. Isso ocorre porque o seletor de id tem mais especificidade que o seletor de classe, e o seletor de classe tem mais especificidade que o seletor de tipo. Portanto, o seletor de id sobrescreve o seletor de classe, e o seletor de classe sobrescreve o seletor de tipo.</p>
<p>Se tivéssemos no CSS</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">p &#123;<br>cor: vermelho;<br>&#125;<br><br>p.classe &#123;<br>cor: azul;<br>&#125;</code></pre></div>
      </section>
<p>O texto seria azul. Isso acontece porque o seletor de classe tem mais especificidade que o seletor de tipo, portanto, o seletor de classe sobrescreve o seletor de tipo.</p>
</section>
<section class="section-block-markdown-cell">
<p>Os estilos inline têm mais especificidade que os estilos do autor. Por exemplo</p>
<div class='highlight'><pre><code class="language-html">&lt;p style="color: red;"&gt;Texto&lt;/p&gt;
</code></pre></div>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">p &#123;<br>cor: azul;<br>&#125;</code></pre></div>
      </section>
<p>Neste exemplo, o texto será vermelho. Isso ocorre porque o estilo inline tem mais especificidade que o estilo do autor.</p>
</section>
<section class="section-block-markdown-cell">
<p>Se colocar <code>!important</code> no final da declaração, essa declaração terá mais especificidade do que qualquer outra. Por exemplo</p>
<div class='highlight'><pre><code class="language-html">&lt;p class="clase" id="id"&gt;Texto&lt;/p&gt;
</code></pre></div>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">p &#123;<br>cor: vermelho;<br>&#125;<br><br>.classe &#123;<br>cor: azul;<br>&#125;<br><br>#id &#123;<br>cor: verde;<br>&#125;<br><br>p.classe &#123;<br>cor: amarelo !important;<br>&#125;</code></pre></div>
      </section>
<p>Neste exemplo, o texto será amarelo. Isso acontece porque a declaração com <code>!important</code> tem mais especificidade do que qualquer outra.</p>
</section>
<section class="section-block-markdown-cell">
<h2 id="Unidades">Unidades<a class="anchor-link" href="#Unidades">¶</a></h2>
</section>
<section class="section-block-markdown-cell">
<h3 id="Unidades de comprimento">Unidades de comprimento<a class="anchor-link" href="#Unidades de comprimento">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<h4 id="Unidades absolutas">Unidades absolutas<a class="anchor-link" href="#Unidades absolutas">¶</a></h4>
</section>
<section class="section-block-markdown-cell">
<p>Se quisermos definir um tamanho fixo, podemos utilizar unidades absolutas. Por exemplo, <code>px</code> é um pixel, <code>cm</code> é um centímetro, <code>mm</code> é um milímetro, <code>in</code> é uma polegada, <code>pt</code> é um ponto, <code>pc</code> é uma pica.</p>
</section>
<section class="section-block-markdown-cell">
<h4 id="Unidades relativas">Unidades relativas<a class="anchor-link" href="#Unidades relativas">¶</a></h4>
</section>
<section class="section-block-markdown-cell">
<p>No entanto, se quisermos que o tamanho seja relativo, podemos utilizar unidades relativas. Por exemplo, <code>em</code> é o tamanho da fonte, <code>rem</code> é o tamanho da fonte do elemento raiz, <code>vw</code> é a largura da janela, <code>vh</code> é a altura da janela, <code>vmin</code> é a largura ou a altura da janela, dependendo de qual for menor, <code>vmax</code> é a largura ou a altura da janela, dependendo de qual for maior, <code>ch</code> é a largura de um caractere, <code>ex</code> é a altura de uma x, <code>fr</code> é uma fração do espaço disponível.</p>
</section>
<section class="section-block-markdown-cell">
<h2 id="Modelo da caixa">Modelo da caixa<a class="anchor-link" href="#Modelo da caixa">¶</a></h2>
</section>
<section class="section-block-markdown-cell">
<p>Em HTML, tudo são caixas, mas há duas maneiras de ver as caixas: <code>inline</code> e <code>block</code>. Por exemplo, os <code>&#x3C;span&#x3E;</code> são <code>inline</code>, e os <code>&#x3C;div&#x3E;</code> são <code>block</code>.</p>
</section>
<section class="section-block-markdown-cell">
<h3>Caixas <code>inline</code></h3>
</section>
<section class="section-block-markdown-cell">
<p>Quando o elemento é <code>inline</code>, a largura e a altura não podem ser configuradas, e o elemento se comporta como se fosse texto. Por exemplo, se tivermos um <code>span</code> com um texto, e definirmos uma largura e uma altura, a largura e a altura não serão aplicadas, e o elemento se comportará como se fosse texto.</p>
<div class='highlight'><pre><code class="language-html">&lt;span&gt;Texto&lt;/span&gt;
</code></pre></div>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">span &#123;<br>largura: 100px;<br>altura: 100px;&#125;</code></pre></div>
      </section>
<p>Neste exemplo, a largura e a altura não serão aplicadas, e o elemento se comportará como se fosse texto.</p>
</section>
<section class="section-block-markdown-cell">
<p>Além disso, quando o elemento é <code>inline</code>, se vários elementos forem colocados juntos no html, esses elementos serão exibidos juntos. Por exemplo, se tivermos vários <code>span</code> com um texto, e os colocarmos juntos no html, esses elementos serão exibidos juntos.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-html">&lt;span&gt;Texto&lt;/span&gt;<br>&lt;span&gt;Texto&lt;/span&gt;<br>&lt;span&gt;Texto&lt;/span&gt;</code></pre></div>
      </section>
<p>Neste exemplo, os elementos serão exibidos juntos ==> TextoTextoTexto.</p>
</section>
<section class="section-block-markdown-cell">
<p>Mas se quisermos que os elementos sejam exibidos em linhas diferentes, podemos usar <code>display: block;</code>. Por exemplo, se tivermos vários <code>span</code> com um texto, e aplicarmos <code>display: block;</code>, esses elementos serão exibidos em linhas diferentes.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-html">&lt;span&gt;Texto&lt;/span&gt;<br>&lt;span&gt;Texto&lt;/span&gt;<br>&lt;span&gt;Texto&lt;/span&gt;</code></pre></div>
      </section>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">span &#123;<br>exibição: bloco;<br>&#125;</code></pre></div>
      </section>
<p>Neste exemplo, os elementos serão exibidos em linhas diferentes</p>
<p>⬇</p>
<p>Texto</p>
<p>Texto</p>
<p>Texto</p>
</section>
<section class="section-block-markdown-cell">
<h3>Caixas <code>block</code></h3>
</section>
<section class="section-block-markdown-cell">
<p>Quando o elemento é <code>block</code>, a largura e a altura podem ser configuradas, e o elemento se comporta como se fosse um bloco. Por exemplo, se tivermos um <code>div</code> com um texto, e definirmos uma largura e uma altura, a largura e a altura serão aplicadas, e o elemento se comportará como se fosse um bloco.</p>
<div class='highlight'><pre><code class="language-html">&lt;div&gt;Texto&lt;/div&gt;
</code></pre></div>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">div &#123;<br>largura: 100px;<br>altura: 100px;&#125;</code></pre></div>
      </section>
<p>Neste exemplo, a largura e a altura serão aplicadas, e o elemento se comportará como se fosse um bloco.</p>
</section>
<section class="section-block-markdown-cell">
<p>Além disso, quando o elemento é <code>block</code>, se vários elementos forem colocados juntos no HTML, esses elementos serão exibidos um abaixo do outro. Por exemplo, se tivermos vários <code>div</code> com texto e os colocarmos juntos no HTML, esses elementos serão exibidos um abaixo do outro.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-html">&lt;div&gt;Texto&lt;/div&gt;<br>&lt;div&gt;Texto&lt;/div&gt;<br>&lt;div&gt;Texto&lt;/div&gt;</code></pre></div>
      </section>
<p>Neste exemplo, os elementos serão exibidos um abaixo do outro</p>
<p>⬇</p>
<p>Texto</p>
<p>Texto</p>
<p>Texto</p>
</section>
<section class="section-block-markdown-cell">
<p>Mas se quisermos que os elementos sejam exibidos na mesma linha, podemos usar <code>display: inline;</code>. Por exemplo, se tivermos vários <code>div</code> com um texto, e colocarmos <code>display: inline;</code>, esses elementos serão exibidos na mesma linha.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-html">&lt;div&gt;Texto&lt;/div&gt;<br>&lt;div&gt;Texto&lt;/div&gt;<br>&lt;div&gt;Texto&lt;/div&gt;</code></pre></div>
      </section>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">div &#123;<br>exibição: inline;<br>&#125;</code></pre></div>
      </section>
<p>Neste exemplo, os elementos serão exibidos na mesma linha ==> TextoTextoTexto.</p>
</section>
<section class="section-block-markdown-cell">
<h3 id="Margin, Border, Padding e Content">Margin, Border, Padding e Content<a class="anchor-link" href="#Margin, Border, Padding e Content">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Agora que sabemos que em HTML tudo são caixas, podemos ver que cada caixa tem 4 partes:</p>
<ul>
  <li><strong>Margem</strong>: É o espaço entre a caixa e as outras caixas.</li>
  <li><strong>Borda</strong>: É a borda da caixa.</li>
  <li><strong>Padding</strong>: É o espaço entre a borda e o conteúdo.- <strong>Conteúdo</strong>: É o conteúdo da caixa.</li>
</ul>
<img src="https://web.dev/static/learn/css/box-model/image/un-diagrama-que-muestra-l-a71d29fe924e.svg?hl=es" alt="Margin, Border, Padding e Content">
</section>
<section class="section-block-markdown-cell">
<p>Todas essas propriedades podem ser configuradas. Por exemplo, se temos um <code>div</code> com um texto, e definimos uma largura e uma altura, a largura e a altura serão aplicadas, e o elemento se comportará como se fosse um bloco.</p>
<div class='highlight'><pre><code class="language-html">&lt;div&gt;Texto&lt;/div&gt;
</code></pre></div>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">div &#123;<br>largura: 100px;<br>altura: 100px;<br>margin: 10px;<br>borda: 10px sólida vermelha;<br>padding: 10px;<br>&#125;</code></pre></div>
      </section>
<p>Como são propriedades de tamanho, podem ser colocadas unidades de comprimento. Por exemplo:</p>
<ul>
  <li>Se quisermos que a margem seja de 10 pixels, colocamos <code>margin: 10px;</code>.</li>
  <li>Se quisermos que seja apenas a margem esquerda, colocamos <code>margin-left: 10px;</code>.</li>
  <li>Se quisermos que seja apenas a margem direita, colocamos <code>margin-right: 10px;</code>.</li>
  <li>Se quisermos que seja apenas a margem superior, colocamos <code>margin-top: 10px;</code>.</li>
  <li>Se quisermos que seja apenas a margem inferior, colocamos <code>margin-bottom: 10px;</code>.</li>
  <li>Se quisermos que cada margem tenha um tamanho específico, colocamos <code>margin: 10px 20px 30px 40px;</code>. A ordem é cima, direita, baixo, esquerda, como se fossem as agulhas de um relógio.</li>
  <li>Se quisermos mudar as margens no eixo horizontal e vertical, colocamos <code>margin: 10px 20px;</code>. A ordem é cima e baixo (10px), esquerda e direita (20px).</li>
</ul>
</section>
<section class="section-block-markdown-cell">
<h4 id="Tamanho da caixa ao alterar o padding">Tamanho da caixa ao alterar o padding<a class="anchor-link" href="#Tamanho da caixa ao alterar o padding">¶</a></h4>
</section>
<section class="section-block-markdown-cell">
<p>Se temos um <code>div</code> com um texto, e definirmos uma largura e uma altura, a largura e a altura serão aplicadas, e o elemento se comportará como se fosse um bloco.</p>
<div class='highlight'><pre><code class="language-html">&lt;div&gt;Texto&lt;/div&gt;
</code></pre></div>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">div &#123;<br>largura: 100px;<br>altura: 100px;<br>&#125;</code></pre></div>
      </section>
<p>Desta forma, o <code>div</code> terá uma largura e altura de 100px.</p>
<p>Mas se aplicarmos um padding de 10px, a largura e altura permanecerão as mesmas, mas o tamanho da caixa será de 120px, pois o padding é adicionado à largura e altura.</p>
<div class='highlight'><pre><code class="language-html">&lt;div&gt;Texto&lt;/div&gt;
</code></pre></div>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">div &#123;<br>largura: 100px;<br>altura: 100px;<br>padding: 10px;<br>&#125;</code></pre></div>
      </section>
<p>Desta forma, o <code>div</code> terá uma largura e altura de 100px, mas o tamanho da caixa será de 120px.</p>
</section>
<section class="section-block-markdown-cell">
<h4 id="Tamanho da caixa ao mudar a borda">Tamanho da caixa ao mudar a borda<a class="anchor-link" href="#Tamanho da caixa ao mudar a borda">¶</a></h4>
</section>
<section class="section-block-markdown-cell">
<p>Se temos um <code>div</code> com um texto, e colocamos uma largura e uma altura, a largura e a altura serão aplicadas, e o elemento se comportará como se fosse um bloco.</p>
<div class='highlight'><pre><code class="language-html">&lt;div&gt;Texto&lt;/div&gt;
</code></pre></div>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">div &#123;<br>largura: 100px;<br>altura: 100px;<br>&#125;</code></pre></div>
      </section>
<p>Desta forma, o <code>div</code> terá uma largura e uma altura de 100px.</p>
<p>Mas se nós agora aplicarmos uma borda de 10px, a largura e a altura permanecerão as mesmas, mas o tamanho da caixa será de 120px, pois a borda é adicionada à largura e à altura.</p>
<div class='highlight'><pre><code class="language-html">&lt;div&gt;Texto&lt;/div&gt;
</code></pre></div>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">div &#123;<br>largura: 100px;<br>altura: 100px;<br>borda: 10px sólida vermelha;<br>&#125;</code></pre></div>
      </section>
<p>Desta forma, o <code>div</code> terá uma largura e altura de 100px, mas o tamanho da caixa será de 120px.</p>
</section>
<section class="section-block-markdown-cell">
<h4 id="Tamanho da caixa ao alterar a margem">Tamanho da caixa ao alterar a margem<a class="anchor-link" href="#Tamanho da caixa ao alterar a margem">¶</a></h4>
</section>
<section class="section-block-markdown-cell">
<p>No caso das margens, o tamanho da caixa não muda, mas o espaço entre as caixas sim. Por exemplo, se tivermos dois <code>div</code> com um texto, e colocarmos uma largura e uma altura, a largura e a altura serão aplicadas, e o elemento se comportará como se fosse um bloco.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-html">&lt;div&gt;Texto&lt;/div&gt;<br>&lt;div&gt;Texto&lt;/div&gt;</code></pre></div>
      </section>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">div &#123;<br>largura: 100px;<br>altura: 100px;<br>&#125;</code></pre></div>
      </section>
<p>Desta forma, os <code>div</code> terão uma largura e altura de 100px.</p>
<p>Mas se aplicarmos uma margem de 10px, a largura e altura permanecerão as mesmas, mas o espaço entre os <code>div</code> será de 20px, pois a margem é adicionada ao espaço entre os <code>div</code>.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-html">&lt;div&gt;Texto&lt;/div&gt;<br>&lt;div&gt;Texto&lt;/div&gt;</code></pre></div>
      </section>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">div &#123;<br>largura: 100px;<br>altura: 100px;<br>margin: 10px;<br>&#125;</code></pre></div>
      </section>
<p>Desta forma, os <code>div</code> terão uma largura e altura de 100px, mas o espaço entre os <code>div</code> será de 20px.</p>
</section>
<section class="section-block-markdown-cell">
<h4 id="Tamanho da caixa">Tamanho da caixa<a class="anchor-link" href="#Tamanho da caixa">¶</a></h4>
</section>
<section class="section-block-markdown-cell">
<p>Portanto, o que ocupa a caixa é:</p>
<ul>
  <li>Largura: <code>width + padding + border</code>.</li>
  <li>Altura: <code>height + padding + border</code>.</li>
</ul>
<p>O margem não conta, pois a margem é o espaço entre as caixas.</p>
</section>
<section class="section-block-markdown-cell">
<h3 id="Box-sizing">Box-sizing<a class="anchor-link" href="#Box-sizing">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Por padrão, a propriedade <code>box-sizing</code> está configurada para <code>content-box</code>. Isso significa que a largura e a altura não incluem o padding nem a borda. Por exemplo, se tivermos um <code>div</code> com um texto, e colocarmos uma largura e uma altura, a largura e a altura serão aplicadas, e o elemento se comportará como se fosse um bloco.</p>
<div class='highlight'><pre><code class="language-html">&lt;div&gt;Texto&lt;/div&gt;
</code></pre></div>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">div &#123;<br>largura: 100px;<br>altura: 100px;<br>&#125;</code></pre></div>
      </section>
<p>Desta forma, o <code>div</code> terá uma largura e altura de 100px.</p>
<p>Mas se aplicarmos um padding de 10px, a largura e altura permanecerão, mas o tamanho da caixa será de 120px, pois o padding é adicionado à largura e altura.</p>
<div class='highlight'><pre><code class="language-html">&lt;div&gt;Texto&lt;/div&gt;
</code></pre></div>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">div &#123;<br>largura: 100px;<br>altura: 100px;<br>padding: 10px;<br>&#125;</code></pre></div>
      </section>
<p>Desta forma, o <code>div</code> terá uma largura e altura de 100px, mas o tamanho da caixa será de 120px.</p>
</section>
<section class="section-block-markdown-cell">
<p>Se alterássemos a propriedade <code>box-sizing</code> para <code>border-box</code>, a largura e a altura incluiriam os preenchimentos (padding) e as bordas (border). Por exemplo, se tivermos um <code>div</code> com texto, e definirmos uma largura e uma altura, esses valores serão aplicados, e o elemento se comportará como se fosse um bloco.</p>
<div class='highlight'><pre><code class="language-html">&lt;div&gt;Texto&lt;/div&gt;
</code></pre></div>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">div &#123;<br>largura: 100px;<br>altura: 100px;<br>box-sizing: border-box;<br>&#125;</code></pre></div>
      </section>
<p>Desta forma, o <code>div</code> terá uma largura e altura de 100px.</p>
<p>Mas se nós agora aplicarmos um padding de 10px, a largura e a altura permanecerão, e o tamanho da caixa também será de 100px, pois o padding não é adicionado à largura e à altura.</p>
<div class='highlight'><pre><code class="language-html">&lt;div&gt;Texto&lt;/div&gt;
</code></pre></div>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">div &#123;<br>largura: 100px;<br>altura: 100px;<br>box-sizing: border-box;<br>padding: 10px;<br>&#125;</code></pre></div>
      </section>
<p>Desta forma, o <code>div</code> terá uma largura e altura de 100px, e o tamanho da caixa também será de 100px.</p>
<p>É importante ter em conta que quando a propriedade <code>box-sizing</code> é alterada para <code>border-box</code>, a largura e altura incluem o padding e a borda, portanto não podemos definir uma largura e altura menores que o padding e a borda. Por exemplo, se tivermos um <code>div</code> com texto, e definirmos uma largura e altura, essas medidas serão aplicadas, e o elemento se comportará como se fosse um bloco.</p>
<div class='highlight'><pre><code class="language-html">&lt;div&gt;Texto&lt;/div&gt;
</code></pre></div>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">div &#123;<br>largura: 100px;<br>altura: 100px;<br>box-sizing: border-box;<br>&#125;</code></pre></div>
      </section>
<p>Desta forma, o <code>div</code> terá uma largura e uma altura de 100px.</p>
<p>Mas se agora aplicarmos um padding de 110px, a largura e altura permanecerão as mesmas, mas o tamanho da caixa será de 220px, pois o padding é adicionado à largura e altura.</p>
<div class='highlight'><pre><code class="language-html">&lt;div&gt;Texto&lt;/div&gt;
</code></pre></div>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">div &#123;<br>largura: 100px;<br>altura: 100px;<br>box-sizing: border-box;<br>padding: 110px;<br>&#125;</code></pre></div>
      </section>
<p>Desta forma, o <code>div</code> terá uma largura e altura de 100px, mas o tamanho da caixa será de 220px.</p>
</section>
<section class="section-block-markdown-cell">
<h3 id="Overflow">Overflow<a class="anchor-link" href="#Overflow">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Um dos memes mais famosos do CSS é o seguinte</p>
<img src="https://css-tricks.com/wp-content/uploads/2021/04/css-is-awesome.jpg" alt="CSS é incrível">
<p>E isso acontece quando o tamanho do conteúdo é maior que o tamanho da caixa. Por exemplo, se tivermos um <code>div</code> com texto, e definirmos uma largura e uma altura, a largura e a altura serão aplicadas, e o elemento se comportará como se fosse um bloco.</p>
<div class='highlight'><pre><code class="language-html">&lt;div&gt;Texto&lt;/div&gt;
</code></pre></div>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">div &#123;<br>largura: 100px;<br>altura: 100px;<br>&#125;</code></pre></div>
      </section>
<p>Desta forma, o <code>div</code> terá uma largura e altura de 100px.</p>
<p>Mas se aplicarmos um texto muito longo, o texto sairá da caixa, pois o tamanho do conteúdo é maior que o tamanho da caixa.</p>
<div class='highlight'><pre><code class="language-html">&lt;div&gt;Texto muito longo&lt;/div&gt;
</code></pre></div>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">div &#123;<br>largura: 100px;<br>altura: 100px;<br>&#125;</code></pre></div>
      </section>
<p>Desta forma, o <code>div</code> terá uma largura e altura de 100px, mas o texto sairá da caixa.</p>
</section>
<section class="section-block-markdown-cell">
<p>Isso ocorreu porque na CSS a propriedade <code>overflow</code> está configurada para <code>visible</code>. Isso significa que o conteúdo pode sair da caixa. Mas temos outras opções:</p>
<ul>
  <li><code>hidden</code>: O conteúdo não pode sair da caixa e é cortado.</li>
  <li><code>scroll</code>: O conteúdo não pode sair da caixa, e uma barra de rolagem é adicionada.</li>
  <li><code>auto</code>: O conteúdo não pode sair da caixa, e uma barra de rolagem é adicionada se necessário. Neste caso, depende do dispositivo, porque se o dispositivo tiver uma barra de rolagem, será adicionada uma barra de rolagem, e se o dispositivo não tiver uma barra de rolagem, nenhuma barra de rolagem será adicionada.</li>
</ul>
<p>Entre <code>scroll</code> e <code>auto</code> o recomendado é <code>auto</code>, porque se o dispositivo tiver uma barra de deslocamento, será adicionada uma barra de deslocamento, e se o dispositivo não tiver uma barra de deslocamento, não será adicionada uma barra de deslocamento.</p>
<img src="https://lh3.googleusercontent.com/-tVNmvecB8A4/Ukqdi769oPI/AAAAAAAAAd0/kgisEf3RGRk/s538/CU01038D_1.png" alt="aoverflow">
</section>
<section class="section-block-markdown-cell">
<h3 id="Overflow oculto">Overflow oculto<a class="anchor-link" href="#Overflow oculto">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>No caso de escolher <code>hidden</code>, o conteúdo não pode sair da caixa e é cortado. Neste caso, temos a propriedade <code>text-overflow</code>, que nos permite configurar o que acontece com o texto que ultrapassa a caixa. As opções são:</p>
<ul>
  <li><code>clip</code>: O texto é cortado.</li>
  <li><code>ellipsis</code>: O texto é cortado e <code>...</code> é adicionado ao final do texto.</li>
</ul>
<p>No futuro será possível colocar um símbolo personalizado, mas por enquanto não é possível.</p>
</section>
<section class="section-block-markdown-cell">
<h4 id="Estilizacao da barra">Estilização da barra<a class="anchor-link" href="#Estilizacao da barra">¶</a></h4>
</section>
<section class="section-block-markdown-cell">
<p>Em caso de ter overflow, é possível estilizar a barra, mas é recomendável não estilizar a barra da página e fazer isso apenas em barras de caixas internas. Por exemplo, se na página houver um índice lateral e quisermos alterar o tamanho e a cor da barra para que fique melhor, podemos fazê-lo.</p>
<p>Em <a href="https://scrollbar.app/">scrollbar.app</a> temos um editor para poder estilizar a barra e obter o código necessário</p>
</section>
<section class="section-block-markdown-cell">
<h3 id="Posicao">Posição<a class="anchor-link" href="#Posicao">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Em html os elementos são empilhados, são posicionados por padrão de maneira estática, isso ocorre porque por padrão em CSS eles têm o atributo <code>position</code> com o valor <code>static</code>. Isso significa que o elemento é posicionado de maneira estática e não pode ser movido. Os valores possíveis são</p>
<ul>
  <li><code>static</code>: O elemento é posicionado de forma estática e não pode ser movido.</li>
  <li><code>relative</code>: O elemento é posicionado de maneira relativa e pode ser movido.</li>
  <li><code>absolute</code>: O elemento é posicionado de maneira absoluta e pode ser movido.</li>
  <li><code>fixed</code>: O elemento é posicionado de maneira fixa e pode ser movido.</li>
  <li><code>sticky</code>: O elemento é posicionado de maneira adesiva e pode ser movido.</li>
</ul>
<img src="https://miro.medium.com/v2/resize:fit:600/1*WU2bIP1OCaS71r82S5zFeA.jpeg" alt="Position">
</section>
<section class="section-block-markdown-cell">
<h4 id="Posicao relativa">Posição relativa<a class="anchor-link" href="#Posicao relativa">¶</a></h4>
</section>
<section class="section-block-markdown-cell">
<p>Quando queremos que a posição de um elemento seja relativa a outro usamos <code>position: relative;</code>. Mas temos que colocar <code>position: relative;</code> no pai, e <code>position: absolute;</code> no filho. Por exemplo, se tivermos um <code>div</code> com um texto, e quisermos que o texto esteja no canto superior direito do <code>div</code>, podemos fazer isso.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-html">&lt;div&gt;<br>&lt;p&gt;Texto&lt;/p&gt;<br>&lt;/div&gt;</code></pre></div>
      </section>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">div &#123;<br>posição: relativa;<br>&#125;<br><br>p &#123;posição: absoluta;<br>top: 0;<br>right: 50px;<br>&#125;</code></pre></div>
      </section>
<p>Desta forma, o texto ficará no canto superior direito do <code>div</code>.</p>
</section>
<section class="section-block-markdown-cell">
<h4 id="Posicao absoluta">Posição absoluta<a class="anchor-link" href="#Posicao absoluta">¶</a></h4>
</section>
<section class="section-block-markdown-cell">
<p>Quando o elemento é <code>absolute</code>, o elemento é posicionado de maneira absoluta em relação ao primeiro elemento pai que não seja <code>static</code>. No exemplo anterior, vimos que se tivermos um <code>div</code> com um texto e quisermos que o texto esteja no canto superior direito do <code>div</code>, podemos fazer isso.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-html">&lt;div&gt;<br>&lt;p&gt;Texto&lt;/p&gt;<br>&lt;/div&gt;</code></pre></div>
      </section>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">div &#123;<br>posição: relativa;<br>&#125;<br><br>p &#123;posição: absoluta;<br>top: 0;<br>direita: 50px;<br>&#125;</code></pre></div>
      </section>
<p>Neste exemplo, o <code>div</code> tem <code>position: relative;</code>, portanto o <code>p</code> é posicionado de maneira absoluta em relação ao <code>div</code>, no canto superior direito.</p>
</section>
<section class="section-block-markdown-cell">
<p>Em caso de que não haja nenhum elemento pai que não seja <code>static</code>, o elemento é posicionado de maneira absoluta ao <code>body</code>, ou seja, à página.</p>
<div class='highlight'><pre><code class="language-html">&lt;p&gt;Texto&lt;/p&gt;
</code></pre></div>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">p &#123;<br>posição: absoluta;<br>top: 0;<br>direita: 50px;<br>&#125;</code></pre></div>
      </section>
<p>Neste exemplo, o <code>p</code> não tem nenhum elemento pai que não seja <code>static</code>, portanto o <code>p</code> é posicionado de forma absoluta em relação ao <code>body</code>. Isso significa que ele aparece no canto superior direito da página.</p>
</section>
<section class="section-block-markdown-cell">
<p>Graças às propriedades <code>relative</code> e <code>absolute</code> podemos centralizar um <code>div</code> horizontalmente e verticalmente. Por exemplo, se temos um <code>div</code> com um texto, e queremos que o texto esteja centralizado horizontalmente e verticalmente, podemos fazer isso.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-html">&lt;div&gt;<br>&lt;p&gt;Texto&lt;/p&gt;<br>&lt;/div&gt;</code></pre></div>
      </section>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">div &#123;<br>posição: relativa;<br>&#125;<br><br>p &#123;<br>posição: absoluta;<br>top: 0;<br>direita: 0;<br>fundo: 0;<br>esquerda: 0;<br>margin: auto;<br>&#125;</code></pre></div>
      </section>
<p>Neste exemplo, o <code>div</code> tem <code>position: relative;</code>, portanto o <code>p</code> é posicionado de forma absoluta dentro do <code>div</code>, na esquina superior direita. Além disso, o <code>p</code> possui <code>top: 0;</code>, <code>right: 0;</code>, <code>bottom: 0;</code> e <code>left: 0;</code>, fazendo com que o <code>p</code> ocupe todo o <code>div</code>. Por fim, o <code>p</code> tem <code>margin: auto;</code>, o que centraliza o <code>p</code> horizontalmente e verticalmente.</p>
<p>Esta não é a melhor maneira de centralizar o conteúdo em um <code>div</code>, mas pode ser muito útil em alguns casos, como por exemplo em um modal.</p>
</section>
<section class="section-block-markdown-cell">
<h4 id="Posicao fixa">Posição fixa<a class="anchor-link" href="#Posicao fixa">¶</a></h4>
</section>
<section class="section-block-markdown-cell">
<p>Quando o elemento é <code>fixed</code>, o elemento é posicionado de maneira fixa à janela. É semelhante a <code>absolute</code>, mas em vez de se posicionar ao primeiro elemento pai que não seja <code>static</code>, ele se posiciona à janela. Além disso, se a janela se mover, o elemento se move com ela, ou seja, se fizermos scroll, o elemento sempre estará na mesma posição.</p>
<p>Por exemplo, se tivermos um <code>div</code> com um texto, e quisermos que o texto esteja no canto superior direito da janela, podemos fazer isso.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-html">&lt;div&gt;<br>&lt;p&gt;Texto&lt;/p&gt;<br>&lt;/div&gt;</code></pre></div>
      </section>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">p &#123;<br>posição: fixed;top: 0;<br>direita: 50px;<br>&#125;</code></pre></div>
      </section>
<p>Neste exemplo, o <code>p</code> é posicionado de forma fixa na janela, no canto superior direito, e ao fazer scroll, o <code>p</code> sempre estará na mesma posição.</p>
</section>
<section class="section-block-markdown-cell">
<h4 id="Posicao sticky">Posição sticky<a class="anchor-link" href="#Posicao sticky">¶</a></h4>
</section>
<section class="section-block-markdown-cell">
<p>Quando o elemento é <code>sticky</code>, o elemento é posicionado de maneira adesiva ao primeiro elemento pai que não seja <code>static</code>.</p>
<p>É semelhante a <code>relative</code>, mas quando o elemento chega à parte superior da janela, o elemento é posicionado de forma fixa à janela. Além disso, se a janela se mover, o elemento também se move com ela, ou seja, se fizermos scroll, o elemento sempre estará na mesma posição.</p>
<p>Por exemplo, se tivermos um <code>div</code> com um texto, e quisermos que o texto esteja no canto superior direito do <code>div</code>, podemos fazer isso.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-html">&lt;div&gt;<br>&lt;p&gt;Texto&lt;/p&gt;<br>&lt;/div&gt;</code></pre></div>
      </section>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">div &#123;<br>posição: relativa;<br>&#125;<br><br>p &#123;posição: sticky;<br>top: 0;<br>right: 50px;<br>&#125;</code></pre></div>
      </section>
<p>Neste exemplo, o <code>div</code> tem <code>position: relative;</code>, portanto, o <code>p</code> é posicionado de maneira relativa ao <code>div</code>, no canto superior direito. Além disso, o <code>p</code> tem <code>top: 0;</code>, portanto, o <code>p</code> é posicionado de maneira pegajosa ao <code>div</code>. Isso significa que quando o <code>p</code> chega à parte superior da janela, o <code>p</code> é posicionado de maneira fixa à janela.</p>
<img src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*kyrVMytQd1Dt19D0If5q3Q.gif" alt="sticky">
</section>
<section class="section-block-markdown-cell">
<h3 id="Z-index">Z-index<a class="anchor-link" href="#Z-index">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Como vimos ao alterar o <code>position</code> de um elemento, o elemento é posicionado sobre os demais elementos. Portanto, precisamos ter controle de qual elemento está ou será exibido acima dos demais. Para isso temos a propriedade <code>z-index</code>. Por padrão, todos os elementos têm <code>z-index: auto;</code>, mas podemos alterá-lo. Por exemplo, se tivermos um <code>div</code> com um texto, e quisermos que o texto esteja sobre o <code>div</code>, podemos fazer isso.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-html">&lt;div&gt;<br>&lt;p&gt;Texto&lt;/p&gt;<br>&lt;/div&gt;</code></pre></div>
      </section>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">div &#123;<br>posição: relativa;<br>z-index: 0;<br>&#125;<br><br>p &#123;posição: absoluta;<br>top: 0;<br>right: 50px;<br>z-index: 1;<br>&#125;</code></pre></div>
      </section>
<p>Neste exemplo, o <code>div</code> tem <code>position: relative;</code> e <code>z-index: 0;</code>, portanto o <code>div</code> é posicionado de forma relativa ao <code>div</code>, e o <code>div</code> possui um <code>z-index</code> de 0. Além disso, o <code>p</code> tem <code>position: absolute;</code>, <code>top: 0;</code>, <code>right: 50px;</code> e <code>z-index: 1;</code>, portanto o <code>p</code> é posicionado de forma absoluta ao <code>div</code>, no canto superior direito, e o <code>p</code> possui um <code>z-index</code> de 1. Dessa forma, o <code>p</code> estará sobre o <code>div</code>.</p>
</section>
<section class="section-block-markdown-cell">
<p>Se não for indicado o <code>z-index</code>, os filhos têm um <code>z-index</code> maior que os pais. Mas, por exemplo, no caso de <code>position: sticky;</code>, o <code>z-index</code> do elemento filho é maior que o <code>z-index</code> do seu pai, mas na hora de fazer scroll, se em algum momento coincidir o filho com outro pai, o outro pai estará por cima.</p>
<p>Se quisermos que esse filho apareça acima dos outros pais, podemos controlar com o <code>z-index</code>.</p>
<p>No curso de CSS da Google](https://web.dev/learn/css/z-index?hl=es-419) é possível ver muito bem como funciona o <code>z-index</code>.</p>
</section>
<section class="section-block-markdown-cell">
<h2 id="Flexbox e Grid">Flexbox e Grid<a class="anchor-link" href="#Flexbox e Grid">¶</a></h2>
</section>
<section class="section-block-markdown-cell">
<p>Há duas maneiras de fazer layouts em CSS, com <code>flexbox</code> e com <code>grid</code>. <code>Flexbox</code> é mais antigo, e <code>grid</code> é mais novo. <code>Flexbox</code> é unidimensional, e <code>grid</code> é bidimensional. <code>Flexbox</code> é para layouts simples, e <code>grid</code> é para layouts complexos.</p>
</section>
<section class="section-block-markdown-cell">
<h2 id="Flexbox">Flexbox<a class="anchor-link" href="#Flexbox">¶</a></h2>
</section>
<section class="section-block-markdown-cell">
<p>Como vimos, temos contêineres que têm <code>display: block;</code>, e contêineres que têm <code>display: inline;</code>. Os primeiros são exibidos em linhas diferentes, e os segundos são exibidos na mesma linha. Portanto, se tivermos vários <code>div</code>s, eles serão exibidos um abaixo do outro, e se tivermos vários <code>span</code>s, eles serão exibidos na mesma linha.</p>
<p>Mas se quisermos que os <code>div</code>s apareçam na mesma linha e de forma flexível, podemos criar um contêiner pai que os contenha e fazer com que o contêiner pai tenha <code>display: flex;</code>.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-html">&lt;section&gt;<br>&lt;div&gt;Texto&lt;/div&gt;<br>&lt;div&gt;Texto&lt;/div&gt;<br>&lt;div&gt;Texto&lt;/div&gt;<br>&lt;/div&gt;</code></pre></div>
      </section>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;<br>display: flex;<br>&#125;</code></pre></div>
      </section>
<p>Desta forma, os <code>div</code>s serão exibidos na mesma linha e de maneira flexível, ou seja, se não couberem na mesma linha, serão colocados na próxima linha.</p>
</section>
<section class="section-block-markdown-cell">
<h3 id="Flex-direction">Flex-direction<a class="anchor-link" href="#Flex-direction">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p><code>Flexbox</code> é unidimensional, portanto só pode configurar uma direção. Por padrão, a propriedade <code>flex-direction</code> está configurada como <code>row</code>. Isso significa que os elementos são exibidos na mesma linha. Mas podemos alterá-lo para <code>column</code>, para que os elementos sejam exibidos em linhas diferentes.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-html">&lt;section&gt;<br>&lt;div&gt;Texto&lt;/div&gt;<br>&lt;div&gt;Texto&lt;/div&gt;<br>&lt;div&gt;Texto&lt;/div&gt;<br>&lt;/section&gt;</code></pre></div>
      </section>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;<br>display: flex;flex-direction: column;<br>&#125;</code></pre></div>
      </section>
<p>Desta forma, os <code>div</code>s serão exibidos em linhas diferentes.</p>
<p>Isso é muito útil para criar layouts responsivos, pois podemos alterar a direção dos elementos dependendo do tamanho da tela.</p>
</section>
<section class="section-block-markdown-cell">
<p>Também podemos indicar a direção, com <code>flex-direction: row-reverse;</code> ou <code>flex-direction: column-reverse;</code>. Por exemplo, se tivermos vários <code>div</code>s, e quisermos que sejam exibidos na mesma linha, mas em sentido contrário, podemos fazer isso.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-html">&lt;section&gt;<br>&lt;div&gt;Texto&lt;/div&gt;<br>&lt;div&gt;Texto&lt;/div&gt;<br>&lt;div&gt;Texto&lt;/div&gt;<br>&lt;/section&gt;</code></pre></div>
      </section>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;<br>display: flex;flex-direction: row-reverse;<br>&#125;</code></pre></div>
      </section>
<p>Desta forma, os <code>div</code>s serão exibidos na mesma linha, mas em sentido contrário.</p>
<p>Isso é muito útil quando queremos ordenar os elementos de maneira inversa, por exemplo, se temos um <code>ul</code> com uma lista, e queremos que a lista seja exibida em sentido contrário, dessa forma não é necessário programar nada e isso pode ser feito com CSS.</p>
</section>
<section class="section-block-markdown-cell">
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/flex-direction.webp" alt="flex-direction">
</section>
<section class="section-block-markdown-cell">
<h3 id="Direcao">Direção<a class="anchor-link" href="#Direcao">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Outra maneira de indicar o sentido da direção é com a propriedade <code>direction</code>. Por padrão, a propriedade <code>direction</code> está configurada como <code>ltr</code>. Isso significa que o sentido da direção é de esquerda para direita. Mas podemos alterá-lo para <code>rtl</code>, para que o sentido da direção seja de direita para esquerda.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-html">&lt;section&gt;<br>&lt;div&gt;Texto&lt;/div&gt;<br>&lt;div&gt;Texto&lt;/div&gt;<br>&lt;div&gt;Texto&lt;/div&gt;<br>&lt;/section&gt;</code></pre></div>
      </section>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;display: flex;<br>direction: rtl;<br>&#125;</code></pre></div>
      </section>
<img src="https://rtlstaging.com/img/flexbox-axis.jpg" alt="direction">
</section>
<section class="section-block-markdown-cell">
<h3 id="Flex-wrap">Flex-wrap<a class="anchor-link" href="#Flex-wrap">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Quando os elementos não cabem na mesma linha, eles são colocados na próxima linha. Mas podemos alterar esse comportamento com a propriedade <code>flex-wrap</code>. Por padrão, a propriedade <code>flex-wrap</code> está configurada como <code>nowrap</code>. Isso significa que os elementos não podem ser colocados na próxima linha. Mas podemos mudá-la para <code>wrap</code>, para que os elementos possam ser colocados na próxima linha.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-html">&lt;section&gt;<br>&lt;div&gt;Texto&lt;/div&gt;<br>&lt;div&gt;Texto&lt;/div&gt;<br>&lt;div&gt;Texto&lt;/div&gt;<br>&lt;/section&gt;</code></pre></div>
      </section>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;<br>display: flex;flex-wrap: wrap;<br>&#125;</code></pre></div>
      </section>
<p>Desta forma, os <code>div</code>s poderão ser colocados na linha seguinte.</p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/flex-wrap.webp" alt="flex-wrap">
</section>
<section class="section-block-markdown-cell">
<h3 id="Flex-flow">Flex-flow<a class="anchor-link" href="#Flex-flow">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Uma maneira de configurar a direção e o wrap dos elementos é com a propriedade <code>flex-flow</code>. Por padrão, a propriedade <code>flex-flow</code> está configurada para <code>row nowrap</code>. Isso significa que os elementos são exibidos na mesma linha e não podem ser colocados na próxima linha. Mas podemos alterá-lo para <code>row wrap</code>, para que os elementos sejam exibidos na mesma linha e possam ser colocados na próxima linha.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-html">&lt;section&gt;<br>&lt;div&gt;Texto&lt;/div&gt;<br>&lt;div&gt;Texto&lt;/div&gt;<br>&lt;div&gt;Texto&lt;/div&gt;<br>&lt;/section&gt;</code></pre></div>
      </section>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;<br>display: flex;flex-flow: row wrap;<br>&#125;</code></pre></div>
      </section>
<p>Desta forma, os <code>div</code>s serão exibidos na mesma linha e poderão ser colocados na próxima linha.</p>
<img src="https://i.stack.imgur.com/6vtqd.png" alt="flex-flow">
</section>
<section class="section-block-markdown-cell">
<h3 id="Flex-grow, Flex-shrink e Flex-basis">Flex-grow, Flex-shrink e Flex-basis<a class="anchor-link" href="#Flex-grow, Flex-shrink e Flex-basis">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Podemos configurar o tamanho dos elementos com as propriedades <code>flex-grow</code>, <code>flex-shrink</code> e <code>flex-basis</code>.</p>
<ul>
  <li><code>flex-grow</code>: Indica se o elemento pode crescer ou não. Por padrão, a propriedade <code>flex-grow</code> está configurada para <code>0</code>, o que significa que o elemento não pode crescer. Mas podemos alterá-la para <code>1</code>, para que o elemento possa crescer.</li>
  <li><code>flex-shrink</code>: Indica se o elemento pode encolher ou não. Por padrão, a propriedade <code>flex-shrink</code> está configurada para <code>1</code>, o que significa que o elemento pode encolher. Mas podemos alterá-la para <code>0</code>, para que o elemento não possa encolher.</li>
  <li><code>flex-basis</code>: Indica o tamanho do elemento. Por padrão, a propriedade <code>flex-basis</code> está configurada como <code>auto</code>, o que significa que o elemento tem um tamanho automático. Mas podemos alterá-lo para <code>100px</code>, para que o elemento tenha um tamanho de 100px.</li>
</ul>
<p>Por exemplo, se temos vários <code>div</code>s, e queremos que o primeiro <code>div</code> tenha um tamanho de 100px, e os demais dividam o espaço restante, podemos fazer isso.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-html">&lt;section&gt;<br>&lt;div&gt;Texto&lt;/div&gt;<br>&lt;div&gt;Texto&lt;/div&gt;<br>&lt;div&gt;Texto&lt;/div&gt;<br>&lt;/section&gt;</code></pre></div>
      </section>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;<br>display: flex;<br>&#125;<br><br>section div:first-child &#123;flex-grow: 0;   /* Como por efeito está a 0, não é necessário colocar */<br>flex-shrink: 0; /* Como por efeito está em 1, não é necessário colocar */<br>flex-basis: 100px;<br>&#125;<br><br>section div &#123;<br>flex-grow: 1;<br>flex-shrink: 1;     /* Como por efeito está em 1, não é necessário colocar */<br>flex-basis: auto;   /* Como por efeito está em auto, não é necessário colocá-lo */<br>&#125;</code></pre></div>
      </section>
<p>Desta forma, o primeiro <code>div</code> terá um tamanho de 100px, e os demais dividirão o espaço restante.</p>
</section>
<section class="section-block-markdown-cell">
<p>Os três valores podem ser modificados de uma vez com a propriedade <code>flex</code>. Por exemplo, se tivermos vários <code>div</code>s, e quisermos que o primeiro <code>div</code> tenha um tamanho de 100px, e os demais se repartam o espaço restante, podemos fazer isso.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-html">&lt;section&gt;<br>&lt;div&gt;Texto&lt;/div&gt;<br>&lt;div&gt;Texto&lt;/div&gt;<br>&lt;div&gt;Texto&lt;/div&gt;<br>&lt;/section&gt;</code></pre></div>
      </section>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;<br>display: flex;<br>&#125;<br><br>section div:first-child &#123;flex: 0 0 100px;<br>&#125;<br><br>section div &#123;<br>flex: 1 1 auto;<br>&#125;</code></pre></div>
      </section>
<p>Desta forma, o primeiro <code>div</code> terá um tamanho de 100px, e os demais dividirão o espaço restante.</p>
</section>
<section class="section-block-markdown-cell">
<p>O também se pode modificar de uma vez com <code>flex: initial;</code>, que é o mesmo que <code>flex: 0 1 auto;</code>. Ou com <code>flex: auto;</code>, que é o mesmo que <code>flex: 1 1 auto;</code>. Ou com <code>flex: none;</code>, que é o mesmo que <code>flex: 0 0 auto;</code>. Ou com <code>flex: 1;</code>, que é o mesmo que <code>flex: 1 1 0%;</code>.</p>
</section>
<section class="section-block-markdown-cell">
<p>Outra forma de modificar <code>flex</code> é colocando números, que indicarão o espaço relativo do contêiner. Por exemplo, se tivermos vários <code>div</code>s, e quisermos que o primeiro tenha o dobro do espaço do segundo, e o segundo tenha o dobro do espaço do terceiro, podemos fazer isso.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-html">&lt;section&gt;<br>&lt;div&gt;Texto&lt;/div&gt;<br>&lt;div&gt;Texto&lt;/div&gt;<br>&lt;div&gt;Texto&lt;/div&gt;<br>&lt;/section&gt;</code></pre></div>
      </section>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;<br>display: flex;<br>&#125;<br><br>section div:first-child &#123;<br>flex: 4;<br>&#125;<br>section div:nth-child(2) &#123;<br>flex: 4;<br>&#125;<br><br>section div:nth-child(3) &#123;<br>flex: 1;<br>&#125;</code></pre></div>
      </section>
<p>Desta forma, o primeiro <code>div</code> terá o dobro do espaço do segundo, e o segundo terá o dobro do espaço do terceiro.</p>
</section>
<section class="section-block-markdown-cell">
<h3 id="Ordem">Ordem<a class="anchor-link" href="#Ordem">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Podemos ordenar os elementos dentro de um contêiner com a propriedade <code>order</code>. Por padrão, a propriedade <code>order</code> está configurada para <code>0</code>. Mas podemos alterá-la para <code>1</code>, para que o elemento fique depois dos elementos que têm <code>order: 0;</code>. Ou podemos alterá-la para <code>-1</code>, para que o elemento fique antes dos elementos que têm <code>order: 0;</code>.</p>
<p>É como o <code>z-index</code>, mas para a ordem dos elementos. Quanto maior for o <code>order</code>, mais tarde será posicionado o elemento. Por exemplo, se tivermos vários <code>div</code>s, e quisermos que o primeiro <code>div</code> seja posicionado após o segundo, podemos fazer isso.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-html">&lt;section&gt;<br>&lt;div&gt;Texto 1&lt;/div&gt;<br>&lt;div&gt;Texto 2&lt;/div&gt;<br>&lt;div&gt;Texto 3&lt;/div&gt;<br>&lt;/section&gt;</code></pre></div>
      </section>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;<br>display: flex;<br>&#125;<br><br>section div:first-child &#123;<br>ordem: 1;<br>&#125;<br><br>section div &#123;ordem: 0;<br>&#125;</code></pre></div>
      </section>
<p>O resultado será</p>
<p>Texto 2</p>
<p>Por favor, forneça o texto markdown que deseja que eu traduzza para o português.</p>
<p>Texto 1</p>
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a7d45de6a88466ca3f98f4f0505f4d7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="order">
</section>
<section class="section-block-markdown-cell">
<h3 id="Justificar-conteudo">Justificar-conteúdo<a class="anchor-link" href="#Justificar-conteudo">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Como <code>Flexbox</code> é unidimensional, podemos configurar o alinhamento dos itens do contêiner no eixo do <code>Flexbox</code> do contêiner. Isso significa que, se o eixo do <code>Flexbox</code> do contêiner for horizontal, podemos configurar o alinhamento dos itens do contêiner no eixo horizontal. E se o eixo do <code>Flexbox</code> do contêiner for vertical, podemos configurar o alinhamento dos itens do contêiner no eixo vertical.</p>
<p>Os possíveis valores são:</p>
<ul>
  <li><code>flex-start</code>: Os elementos são justificados no início do eixo do <code>Flexbox</code> do contêiner.</li>
  <li><code>flex-end</code>: Os elementos são justificados ao final do eixo do <code>Flexbox</code> do contêiner.</li>
  <li><code>center</code>: Os elementos são justificados no centro do eixo do <code>Flexbox</code> do contêiner.</li>
  <li><code>space-between</code>: Os elementos são justificados com o mesmo espaço entre eles. Não há espaço nos lados do primeiro e último elemento.</li>
  <li><code>space-around</code>: Os elementos são justificados com o mesmo espaço ao redor deles.</li>
  <li><code>space-evenly</code>: Os elementos são justificados com o mesmo espaço entre eles e ao redor deles. Isso significa que é semelhante a <code>space-between</code>, mas aos lados do primeiro e último elemento há espaço. O espaço nos lados é o mesmo que o espaço entre os elementos.</li>
</ul>
<img src="https://css-tricks.com/wp-content/uploads/2018/10/justify-content.svg" alt="justify-content">
</section>
<section class="section-block-markdown-cell">
<h3 id="Espaco">Espaço<a class="anchor-link" href="#Espaco">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Suponha que temos vários elementos dentro de um contêiner e colocamos <code>justify-content: center;</code>. Isso fará com que os elementos estejam centralizados no contêiner, mas grudados uns nos outros. Se quisermos que haja um espaço entre os elementos, podemos colocar <code>gap: 10px;</code>. Dessa forma, haverá um espaço de 10px entre os elementos.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-html">&lt;section&gt;<br>&lt;div&gt;Texto 1&lt;/div&gt;<br>&lt;div&gt;Texto 2&lt;/div&gt;<br>&lt;div&gt;Texto 3&lt;/div&gt;<br>&lt;/section&gt;</code></pre></div>
      </section>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;<br>display: flex;<br>justify-content: center;<br>gap: 10px;<br>&#125;</code></pre></div>
      </section>
<p>I'm unable to view images directly. However, if you can describe the image or provide details about it, I'd be happy to help you with any questions or information you're looking for!</p>
</section>
<section class="section-block-markdown-cell">
<h3 id="Alinhar-itens">Alinhar-itens<a class="anchor-link" href="#Alinhar-itens">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Até agora vimos como distribuir os elementos no eixo principal do <code>Flexbox</code>. Mas, o que acontece com o eixo secundário? Para isso temos a propriedade <code>align-items</code>. Esta propriedade nos permite alinhar os elementos no eixo secundário do <code>Flexbox</code>.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-html">&lt;section&gt;<br>&lt;div&gt;Texto 1&lt;/div&gt;<br>&lt;div&gt;Texto 2&lt;/div&gt;<br>&lt;div&gt;Texto 3&lt;/div&gt;<br>&lt;/section&gt;</code></pre></div>
      </section>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;display: flex;<br>align-items: center;<br>&#125;</code></pre></div>
      </section>
<img src="https://css-tricks.com/wp-content/uploads/2018/10/align-items.svg" alt="align-items">
</section>
<section class="section-block-markdown-cell">
<h3 id="Alinhar-conteudo">Alinhar-conteúdo<a class="anchor-link" href="#Alinhar-conteudo">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Com <code>align-content</code> podemos alinhar o conteúdo do contêiner no eixo secundário. Esta propriedade é semelhante a <code>align-items</code>, mas em vez de alinhar os elementos, alinha o conteúdo do contêiner.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-html">&lt;section&gt;<br>&lt;div&gt;Texto 1&lt;/div&gt;<br>&lt;div&gt;Texto 2&lt;/div&gt;<br>&lt;div&gt;Texto 3&lt;/div&gt;<br>&lt;/section&gt;</code></pre></div>
      </section>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;<br>display: flex;align-content: center;<br>flex-wrap: wrap;<br>altura: 200px;<br>&#125;</code></pre></div>
      </section>
<img src="https://css-tricks.com/wp-content/uploads/2018/10/align-content.svg" alt="align-content">
</section>
<section class="section-block-markdown-cell">
<h3 id="Align-content vs Align-items">Align-content vs Align-items<a class="anchor-link" href="#Align-content vs Align-items">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Como pode haver confusão entre <code>align-content</code> e <code>align-items</code>, vamos ver um exemplo para ver a diferença entre ambas as propriedades.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-html">&lt;section&gt;<br>&lt;div&gt;Texto 1&lt;/div&gt;<br>&lt;div&gt;Texto 2&lt;/div&gt;<br>&lt;div&gt;Texto 3&lt;/div&gt;<br>&lt;div&gt;Texto 4&lt;/div&gt;<br>&lt;div&gt;Texto 5&lt;/div&gt;<br>&lt;div&gt;Texto 6&lt;/div&gt;<br>&lt;div&gt;Texto 7&lt;/div&gt;<br>&lt;div&gt;Texto 8&lt;/div&gt;<br>&lt;div&gt;Texto 9&lt;/div&gt;<br>&lt;/section&gt;</code></pre></div>
      </section>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;<br>display: flex;<br>align-items: center;<br>align-content: center;<br>flex-wrap: wrap;<br>altura: 200px;<br>&#125;</code></pre></div>
      </section>
<p>Com <code>align-items</code> alinhamos os elementos no eixo secundário, enquanto com <code>align-content</code> alinhamos o conteúdo do contêiner no eixo secundário. Isso significa que com <code>align-items</code> alinhamos os elementos entre si, enquanto com <code>align-content</code> alinhamos o conteúdo do contêiner. No exemplo anterior, podemos ver que com <code>align-items</code> os elementos se alinham entre si, enquanto com <code>align-content</code> o conteúdo do contêiner se alinha no eixo secundário.</p>
</section>
<section class="section-block-markdown-cell">
<h3 id="Alinhar-se">Alinhar-se<a class="anchor-link" href="#Alinhar-se">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Às vezes, precisamos alinhar um elemento no eixo secundário de forma diferente do restante dos elementos. Para isso, temos a propriedade <code>align-self</code>. Esta propriedade nos permite alinhar um elemento no eixo secundário de forma diferente do restante dos elementos.</p>
<p>Até agora alinhávamos os elementos no pai, mas com <code>align-self</code> podemos alinhar um elemento no eixo secundário de forma diferente do restante dos elementos.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-html">&lt;section&gt;<br>&lt;div&gt;Texto 1&lt;/div&gt;<br>&lt;div&gt;Texto 2&lt;/div&gt;<br>&lt;div&gt;Texto 3&lt;/div&gt;<br>&lt;/section&gt;</code></pre></div>
      </section>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;<br>display: flex;<br>align-items: center;<br>&#125;<br><br>section div:nth-child(2) &#123;<br>align-self: flex-end;<br>&#125;</code></pre></div>
      </section>
<img src="https://css-tricks.com/wp-content/uploads/2018/10/align-self.svg" alt="align-self">
</section>
<section class="section-block-markdown-cell">
<h3 id="Pratica de Flexbox">Prática de Flexbox<a class="anchor-link" href="#Pratica de Flexbox">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Um bom recurso para praticar Flexbox é <a href="https://flexboxfroggy.com/#es">Flexbox Froggy</a>.</p>
</section>
<section class="section-block-markdown-cell">
<h2 id="Grade">Grade<a class="anchor-link" href="#Grade">¶</a></h2>
</section>
<section class="section-block-markdown-cell">
<p>Se precisarmos criar um layout mais complexo, podemos utilizar <code>Grid</code>. <code>Grid</code> é um sistema de grade bidimensional que nos permite criar layouts mais complexos do que com <code>Flexbox</code>.</p>
<img src="https://miro.medium.com/v2/resize:fit:860/1*FifZUGz97Onmb7RUOairbg.png" alt="grid">
</section>
<section class="section-block-markdown-cell">
<h3 id="Conteiner grid">Contêiner grid<a class="anchor-link" href="#Conteiner grid">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Vamos ver um exemplo de como fazer layout com <code>Grid</code>. Para isso, vamos usar a seguinte estrutura HTML.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-html">&lt;section&gt;<br>&lt;div&gt;Texto 1&lt;/div&gt;<br>&lt;div&gt;Texto 2&lt;/div&gt;<br>&lt;div&gt;Texto 3&lt;/div&gt;<br>&lt;div&gt;Texto 4&lt;/div&gt;<br>&lt;div&gt;Texto 5&lt;/div&gt;<br>&lt;div&gt;Texto 6&lt;/div&gt;<br>&lt;div&gt;Texto 7&lt;/div&gt;<br>&lt;div&gt;Texto 8&lt;/div&gt;<br>&lt;div&gt;Texto 9&lt;/div&gt;<br>&lt;/section&gt;</code></pre></div>
      </section>
<p>Para criar um <code>Grid</code> precisamos criar um contêiner com a propriedade <code>display: grid</code>, lembremos que por padrão os contêineres têm <code>display:block</code>. Este contêiner é conhecido como <code>Grid container</code>.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;<br>display: grid;<br>&#125;</code></pre></div>
      </section>
<p>Este código criará um <code>Grid</code> com uma única coluna e tantas linhas quantos itens tivermos.</p>
</section>
<section class="section-block-markdown-cell">
<p>Se quisermos mudar o número de colunas, podemos usar a propriedade <code>grid-template-columns</code>. Esta propriedade nos permite definir o número de colunas que terá nosso <code>Grid</code>. Para definir o número de colunas podemos usar unidades de medida como <code>px</code>, <code>em</code>, <code>rem</code>, <code>fr</code>, etc.</p>
<p>Vão ser criadas tantas colunas quantas unidades de medida definirmos. No exemplo seguinte, vamos criar 3 colunas de 100px cada uma.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;<br>display: grid;<br>grid-template-columns: 100px 100px 100px;&#125;</code></pre></div>
      </section>
<p>Com este exemplo, criamos uma <code>Grid</code> com 3 colunas de 100px cada uma.</p>
</section>
<section class="section-block-markdown-cell">
<p>Podemos definir a largura de uma das colunas com <code>auto</code> e o resto com uma medida, desta forma a coluna com <code>auto</code> se adaptará ao conteúdo, enquanto as demais colunas terão a largura que lhes tenhamos definido.</p>
<p>Ao colocar <code>auto</code>, será o navegador quem decidirá a largura da coluna com base no espaço disponível no contêiner e no espaço ocupado pelo conteúdo da coluna.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;<br>display: grid;<br>grid-template-columns: auto 100px 100px;<br>&#125;</code></pre></div>
      </section>
<p>A primeira coluna se adaptará ao conteúdo, enquanto as outras duas terão uma largura de 100px.</p>
<p>Se definirmos duas colunas com <code>auto</code>, o navegador distribuirá o espaço entre as duas colunas, mas não necessariamente será o mesmo espaço para cada coluna, pois, como dissemos, o espaço dependerá do espaço do contêiner e do espaço do conteúdo.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;<br>display: grid;<br>grid-template-columns: auto auto 100px;<br>&#125;</code></pre></div>
      </section>
<p>Neste exemplo, as duas primeiras colunas se ajustarão ao conteúdo, enquanto a terceira terá uma largura de 100px.</p>
</section>
<section class="section-block-markdown-cell">
<h3 id="Fracao">Fração<a class="anchor-link" href="#Fracao">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Há uma unidade de medida que só existe em <code>Grid</code> e é <code>fr</code>. Esta unidade de medida nos permite definir a largura das colunas com base no espaço disponível no contêiner.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;<br>display: grid;<br>grid-template-columns: 1fr 1fr 1fr;<br>&#125;</code></pre></div>
      </section>
<p>Neste exemplo, as três colunas terão a mesma largura, pois o espaço disponível no contêiner será distribuído igualmente entre as três colunas.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;display: grid;<br>grid-template-columns: 1fr 2fr 1fr;<br>&#125;</code></pre></div>
      </section>
<p>Neste exemplo, a segunda coluna terá o dobro da largura das outras duas, pois o espaço disponível no contêiner será distribuído entre as três colunas, mas a segunda coluna terá o dobro de espaço em relação às outras duas.</p>
</section>
<section class="section-block-markdown-cell">
<p>Podemos fazer o mesmo com as linhas, para isso usamos a propriedade <code>grid-template-rows</code>.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;<br>display: grid;<br>grid-template-columns: 1fr 2fr 1fr;grid-template-rows: 1fr 2fr 1fr;<br>&#125;</code></pre></div>
      </section>
</section>
<section class="section-block-markdown-cell">
<h3 id="Grade vazia">Grade vazia<a class="anchor-link" href="#Grade vazia">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Dissemos que podemos dividir a <code>Grid</code> em colunas e linhas, para isso colocamos tantas unidades de medida quantas colunas ou linhas quisermos. Mas o que acontece se colocarmos mais unidades de medida do que precisamos.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-html">&lt;section&gt;<br>&lt;div&gt;Texto 1&lt;/div&gt;<br>&lt;div&gt;Texto 2&lt;/div&gt;<br>&lt;div&gt;Texto 3&lt;/div&gt;<br>&lt;div&gt;Texto 4&lt;/div&gt;<br>&lt;div&gt;Texto 5&lt;/div&gt;<br>&lt;div&gt;Texto 6&lt;/div&gt;<br>&lt;div&gt;Texto 7&lt;/div&gt;<br>&lt;div&gt;Texto 8&lt;/div&gt;<br>&lt;div&gt;Texto 9&lt;/div&gt;<br>&lt;/section&gt;</code></pre></div>
      </section>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;<br>display: grid;<br>grid-template-columns: 1fr 1fr 1fr 1fr;<br>grid-template-rows: 1fr 1fr 1fr 1fr;<br>&#125;</code></pre></div>
      </section>
<p>Neste exemplo, será criada uma <code>Grid</code> com 4 colunas e 4 linhas, mas temos apenas 9 elementos, enquanto criamos uma grade de 16 elementos. O que acontece com os 7 elementos sobrando? O navegador os cria vazios.</p>
</section>
<section class="section-block-markdown-cell">
<h3 id="Grid-auto-rows">Grid-auto-rows<a class="anchor-link" href="#Grid-auto-rows">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Se a hora de criar o <code>Grid</code> só definirmos o valor de <code>grid-template-columns</code>, o navegador criará as linhas necessárias para as colunas que definimos, mas as criará com o tamanho padrão, ou seja, com o tamanho do conteúdo.</p>
<p>Se quisermos definir o tamanho das linhas, podemos usar a propriedade <code>grid-auto-rows</code>. Esta propriedade nos permite definir o tamanho das linhas que são criadas por padrão.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;<br>display: grid;<br>grid-template-columns: 1fr 1fr 1fr 1fr;<br>grid-auto-rows: 100px;<br>&#125;</code></pre></div>
      </section>
<p>Neste exemplo, será criado um <code>Grid</code> com 4 colunas e tantas linhas quantos elementos tivermos, mas o tamanho das linhas será de 100px.</p>
</section>
<section class="section-block-markdown-cell">
<p>Suponhamos que também definimos <code>grid-template-rows</code>, mas definimos o tamanho das primeiras linhas e não de todas as linhas necessárias, com <code>grid-auto-rows</code> podemos definir o tamanho das linhas que faltam.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;<br>display: grid;<br>grid-template-columns: 1fr 1fr 1fr 1fr;<br>grid-template-rows: 100px 100px;<br>grid-auto-rows: 50px;<br>&#125;</code></pre></div>
      </section>
<p>Neste exemplo, será criado um <code>Grid</code> com 4 colunas e tantas linhas quantos elementos tivermos, mas o tamanho das duas primeiras linhas será de 100px, enquanto o tamanho do resto das linhas será de 50px.</p>
<p>Isso é muito útil quando não sabemos quantos elementos vamos ter, pois podemos definir o tamanho das primeiras linhas e o tamanho das linhas que são criadas por padrão.</p>
</section>
<section class="section-block-markdown-cell">
<h3 id="Repetir">Repetir<a class="anchor-link" href="#Repetir">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Vamos imaginar que queremos criar um <code>Grid</code> com 100 colunas e todas do mesmo tamanho. Teríamos que escrever 100 vezes a unidade de medida que queremos usar. Para evitar isso, podemos utilizar a propriedade <code>repeat</code>.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;<br>display: grid;<br>grid-template-columns: repeat(100, 1fr);<br>&#125;</code></pre></div>
      </section>
<p>Com <code>repeat</code> podemos definir o número de colunas que queremos e a unidade de medida que queremos utilizar.</p>
</section>
<section class="section-block-markdown-cell">
<p>Podemos usar <code>repeat</code> com subpartes da grade. Por exemplo, imaginemos que queremos criar novamente 100 colunas, mas queremos que a primeira e a última coluna tenham uma largura de 100px e o resto das colunas tenham uma largura de 1fr.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;<br>display: grid;<br>grid-template-columns: 100px repeat(98, 1fr) 100px;<br>&#125;</code></pre></div>
      </section>
</section>
<section class="section-block-markdown-cell">
<p>Agora suponhamos que temos um padrão de colunas que se repete a cada 3 colunas. Podemos utilizar <code>repeat</code> para definir esse padrão.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;<br>display: grid;<br>grid-template-columns: repeat(3, 100px 1fr);<br>&#125;</code></pre></div>
      </section>
<p>Desta forma criamos uma grade de 6 colunas, onde o padrão se repete a cada 2 colunas.</p>
</section>
<section class="section-block-markdown-cell">
<h3 id="minmax">minmax<a class="anchor-link" href="#minmax">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Talvez não saibamos o tamanho exato de uma linha ou uma coluna, mas o que queremos é que ela ocupe um tamanho entre um mínimo e um máximo. Para isso, podemos utilizar a propriedade <code>minmax</code>.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;<br>display: grid;<br>grid-template-columns: minmax(100px, 1fr) 1fr 1fr 1fr;<br>&#125;</code></pre></div>
      </section>
<p>Neste exemplo queremos que cada coluna tenha 25% da largura do contêiner, mas que a primeira coluna tenha uma largura mínima de 100px. Ou seja, se o espaço ocupado pela primeira coluna for menor que 100px, a coluna terá uma largura de 100px, mas se o espaço ocupado pela primeira coluna for maior que 100px, a coluna terá uma largura de 25% do contêiner.</p>
<p>Isso é muito útil, por exemplo, quando temos um índice no lado da página e queremos que ele ocupe uma largura mínima, mas que se o espaço disponível for maior, ele ocupe o espaço que lhe cabe.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-html">&lt;div&gt;<br>&lt;aside&gt;Índice&lt;/aside&gt;<br>&lt;main&gt;Conteúdo&lt;/main&gt;<br>&lt;/div&gt;</code></pre></div>
      </section>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">div &#123;<br>display: grid;<br>grid-template-columns: minmax(100px, 1fr) 5fr;<br>&#125;</code></pre></div>
      </section>
<p>Desta forma, o índice terá uma largura mínima de 100px, mas se o espaço disponível for maior, o índice ocupará o espaço que lhe cabe.</p>
</section>
<section class="section-block-markdown-cell">
<h3 id="Grid-column-gap e Grid-row-gap">Grid-column-gap e Grid-row-gap<a class="anchor-link" href="#Grid-column-gap e Grid-row-gap">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Se quisermos adicionar um espaço entre as colunas ou entre as linhas, podemos utilizar as propriedades <code>grid-column-gap</code> e <code>grid-row-gap</code>.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;<br>display: grid;<br>grid-template-columns: repeat(3, 100px);<br>grid-column-gap: 20px;<br>&#125;</code></pre></div>
      </section>
<p>Neste exemplo, criamos um <code>Grid</code> com 3 colunas de 100px cada uma e um espaço de 20px entre as colunas.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;display: grid;<br>grid-template-columns: repeat(3, 100px);<br>grid-row-gap: 20px;<br>&#125;</code></pre></div>
      </section>
<p>Neste exemplo criamos um <code>Grid</code> com 3 colunas de 100px cada uma e um espaço de 20px entre as linhas.</p>
</section>
<section class="section-block-markdown-cell">
<p>Podemos definir o espaço entre as colunas e as linhas com a propriedade <code>grid-gap</code>.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;<br>display: grid;<br>grid-template-columns: repeat(3, 100px);<br>grid-gap: 20px 10px;<br>&#125;</code></pre></div>
      </section>
<p>Neste exemplo, criamos um <code>Grid</code> com 3 colunas de 100px cada uma e um espaçamento de 20px entre as colunas e um espaçamento de 10px entre as linhas.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;display: grid;<br>grid-template-columns: repeat(3, 100px);<br>grid-gap: 20px;<br>&#125;</code></pre></div>
      </section>
<p>Neste exemplo criamos um <code>Grid</code> com 3 colunas de 100px cada uma e um espaço de 20px entre as colunas e as linhas.</p>
</section>
<section class="section-block-markdown-cell">
<h3 id="Auto-fill e Auto-fit">Auto-fill e Auto-fit<a class="anchor-link" href="#Auto-fill e Auto-fit">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Com <code>auto-fill</code> e <code>auto-fit</code> podemos criar um <code>Grid</code> com um número de colunas ou linhas que se adapte ao espaço disponível no contêiner, assim podemos tornar o <code>Grid</code> responsivo.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;<br>display: grid;<br>grid-template-columns: repeat(auto-fill, 100px);<br>&#125;</code></pre></div>
      </section>
<p>Neste exemplo, serão criadas tantas colunas quantas couberem no contêiner, mas cada coluna terá uma largura de 100px.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;display: grid;<br>grid-template-columns: repeat(auto-fit, 100px);<br>&#125;</code></pre></div>
      </section>
<p>Neste exemplo, serão criadas tantas colunas quantas couberem no contêiner, mas cada coluna terá uma largura de 100px e, se houver espaço sobrando no contêiner, o espaço será distribuído entre as colunas.</p>
</section>
<section class="section-block-markdown-cell">
<p>Agora podemos torná-lo mais completo</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;<br>display: grid;<br>grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));<br>&#125;</code></pre></div>
      </section>
<p>Neste exemplo, serão criadas tantas colunas quantas couberem no contêiner, mas cada coluna terá uma largura mínima de 100px e, se houver espaço sobrando no contêiner, o espaço será distribuído entre as colunas. À medida que reduzirmos o tamanho do navegador, as colunas irão se adaptar ao espaço disponível, até que chegue um momento em que, para caberem, deveriam ter uma largura menor de 100px, por isso uma coluna será eliminada e o espaço será redistribuído entre as colunas restantes.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;<br>display: grid;<br>grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));<br>grid-gap: 20px;<br>&#125;</code></pre></div>
      </section>
<p>Neste exemplo, serão criadas tantas colunas quantas couberem no contêiner, mas cada coluna terá uma largura mínima de 100px e, se houver espaço sobrando no contêiner, o espaço será distribuído entre as colunas e haverá um espaçamento de 20px entre as colunas.</p>
</section>
<section class="section-block-markdown-cell">
<h3 id="Auto-preenchimento vs Auto-ajuste">Auto-preenchimento vs Auto-ajuste<a class="anchor-link" href="#Auto-preenchimento vs Auto-ajuste">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>A diferença entre <code>auto-fill</code> e <code>auto-fit</code> é que <code>auto-fill</code> cria tantas colunas ou linhas quanto couberem no contêiner, enquanto <code>auto-fit</code> cria tantas colunas ou linhas quanto couberem no contêiner, mas se houver espaço sobrando no contêiner, o espaço será distribuído entre as colunas ou linhas.</p>
<p>Isto é, <code>auto-fill</code> cria tantas colunas ou linhas quantas couberem no contêiner, mas se houver espaço sobrando no contêiner, o espaço não será distribuído entre as colunas ou linhas, enquanto <code>auto-fit</code> cria tantas colunas ou linhas quantas couberem no contêiner, mas se houver espaço sobrando no contêiner, o espaço será distribuído entre as colunas ou linhas.</p>
</section>
<section class="section-block-markdown-cell">
<h3 id="Grid-column-start e Grid-column-end (grade flexivel)">Grid-column-start e Grid-column-end (grade flexível)<a class="anchor-link" href="#Grid-column-start e Grid-column-end (grade flexivel)">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Até agora vimos como criar um <code>Grid</code> com colunas e linhas, mas e se quisermos que um elemento ocupe mais de uma coluna ou linha? Para isso temos as propriedades <code>grid-column-start</code> e <code>grid-column-end</code>.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-html">&lt;section&gt;<br>&lt;div&gt;Texto 1&lt;/div&gt;<br>&lt;div&gt;Texto 2&lt;/div&gt;<br>&lt;div&gt;Texto 3&lt;/div&gt;<br>&lt;div&gt;Texto 4&lt;/div&gt;<br>&lt;div&gt;Texto 5&lt;/div&gt;<br>&lt;div&gt;Texto 6&lt;/div&gt;<br>&lt;div&gt;Texto 7&lt;/div&gt;<br>&lt;div&gt;Texto 8&lt;/div&gt;<br>&lt;div&gt;Texto 9&lt;/div&gt;<br>&lt;/section&gt;</code></pre></div>
      </section>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;display: grid;<br>grid-template-columns: repeat(3, 100px);<br>grid-gap: 20px;<br>&#125;<br><br>section div:nth-child(2) &#123;<br>grid-column-start: 1;<br>grid-column-end: 3;<br>&#125;</code></pre></div>
      </section>
<p>Neste exemplo, criamos um <code>Grid</code> com 3 colunas de 100px cada uma e um espaço de 20px entre as colunas. O segundo elemento ocupa da primeira coluna até a terceira coluna.</p>
</section>
<section class="section-block-markdown-cell">
<p>Também podemos dizer o início e o fim da coluna com a propriedade <code>grid-column</code>.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;<br>display: grid;<br>grid-template-columns: repeat(3, 100px);<br>grid-gap: 20px;<br>&#125;<br><br>section div:nth-child(2) &#123;<br>grid-column: 1 / 3;<br>&#125;</code></pre></div>
      </section>
<p>Neste exemplo, criamos um <code>Grid</code> com 3 colunas de 100px cada uma e um espaçamento de 20px entre as colunas. O segundo elemento ocupa da primeira coluna até a terceira coluna.</p>
</section>
<section class="section-block-markdown-cell">
<p>Se não quisermos dizer onde deve terminar, mas quantas colunas devem ser ocupadas, podemos usar a propriedade <code>span</code>.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;<br>display: grid;<br>grid-template-columns: repeat(3, 100px);<br>grid-gap: 20px;<br>&#125;<br><br>section div:nth-child(2) &#123;grid-column-start: 1;<br>grid-column-end: span 2;<br>&#125;</code></pre></div>
      </section>
<p>Neste exemplo, criamos um <code>Grid</code> com 3 colunas de 100px cada uma e um espaço de 20px entre as colunas. O segundo elemento ocupa da primeira coluna até a segunda coluna, ou seja, ocupa duas colunas.</p>
</section>
<section class="section-block-markdown-cell">
<p>Se quisermos posicioná-los no final, mas não soubermos quantas colunas existem, podemos utilizar números negativos.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;<br>display: grid;<br>grid-template-columns: repeat(3, 100px);<br>grid-gap: 20px;<br>&#125;<br><br>section div:nth-child(2) &#123;grid-column-start: 1;<br>grid-column-end: -1;<br>&#125;</code></pre></div>
      </section>
<p>Neste exemplo criamos um <code>Grid</code> com 3 colunas de 100px cada uma e um espaço de 20px entre as colunas. O segundo elemento ocupa da primeira coluna até a última coluna, ou seja, ocupa as três colunas.</p>
</section>
<section class="section-block-markdown-cell">
<h3 id="Grid-row-start e Grid-row-end (grade flexivel)">Grid-row-start e Grid-row-end (grade flexível)<a class="anchor-link" href="#Grid-row-start e Grid-row-end (grade flexivel)">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Podemos fazer o mesmo com as linhas, para isso temos as propriedades <code>grid-row-start</code> e <code>grid-row-end</code>.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-html">&lt;section&gt;<br>&lt;div&gt;Texto 1&lt;/div&gt;<br>&lt;div&gt;Texto 2&lt;/div&gt;<br>&lt;div&gt;Texto 3&lt;/div&gt;<br>&lt;div&gt;Texto 4&lt;/div&gt;<br>&lt;div&gt;Texto 5&lt;/div&gt;<br>&lt;div&gt;Texto 6&lt;/div&gt;<br>&lt;div&gt;Texto 7&lt;/div&gt;<br>&lt;div&gt;Texto 8&lt;/div&gt;<br>&lt;div&gt;Texto 9&lt;/div&gt;<br>&lt;/section&gt;</code></pre></div>
      </section>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;display: grid;<br>grid-template-columns: repeat(3, 100px);<br>grid-gap: 20px;<br>&#125;<br><br>section div:nth-child(2) &#123;<br>grid-row-start: 1;<br>grid-row-end: 3;<br>&#125;</code></pre></div>
      </section>
<p>Neste exemplo, criamos um <code>Grid</code> com 3 colunas de 100px cada uma e um espaço de 20px entre as colunas. O segundo elemento ocupa da primeira linha até a terceira linha.</p>
</section>
<section class="section-block-markdown-cell">
<p>Também podemos dizer o início e o fim da linha com a propriedade <code>grid-row</code>.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;<br>display: grid;<br>grid-template-columns: repeat(3, 100px);<br>grid-gap: 20px;<br>&#125;<br>section div:nth-child(2) &#123;<br>grid-row: 1 / 3;<br>&#125;</code></pre></div>
      </section>
</section>
<section class="section-block-markdown-cell">
<p>Assim como antes, se não quisermos dizer onde deve terminar, mas quantas linhas devem ser ocupadas, podemos usar a propriedade <code>span</code>.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;<br>display: grid;<br>grid-template-columns: repeat(3, 100px);<br>grid-gap: 20px;<br>&#125;<br><br>section div:nth-child(2) &#123;grid-row-start: 1;<br>grid-row-end: span 2;<br>&#125;</code></pre></div>
      </section>
<p>Neste exemplo, criamos um <code>Grid</code> com 3 colunas de 100px cada uma e um espaço de 20px entre as colunas. O segundo elemento ocupa da primeira linha até a segunda linha, ou seja, ocupa duas linhas.</p>
</section>
<section class="section-block-markdown-cell">
<p>Se quisermos posicioná-los no final, mas não sabemos quantas linhas existem, podemos utilizar números negativos.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;<br>display: grid;<br>grid-template-columns: repeat(3, 100px);<br>grid-gap: 20px;<br>&#125;<br><br>section div:nth-child(2) &#123;grid-row-start: 1;<br>grid-row-end: -1;<br>&#125;</code></pre></div>
      </section>
<p>Neste exemplo criamos um <code>Grid</code> com 3 colunas de 100px cada uma e um espaço de 20px entre as colunas. O segundo elemento ocupa da primeira linha até a última linha, ou seja, ocupa as três linhas.</p>
</section>
<section class="section-block-markdown-cell">
<h3 id="Sobreposicao de elementos">Sobreposição de elementos<a class="anchor-link" href="#Sobreposicao de elementos">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Podemos posicionar os elementos de forma que se sobreponham uns aos outros.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-html">&lt;section&gt;<br>&lt;div&gt;Texto 1&lt;/div&gt;<br>&lt;div&gt;Texto 2&lt;/div&gt;<br>&lt;div&gt;Texto 3&lt;/div&gt;<br>&lt;div&gt;Texto 4&lt;/div&gt;<br>&lt;div&gt;Texto 5&lt;/div&gt;<br>&lt;div&gt;Texto 6&lt;/div&gt;<br>&lt;div&gt;Texto 7&lt;/div&gt;<br>&lt;div&gt;Texto 8&lt;/div&gt;<br>&lt;div&gt;Texto 9&lt;/div&gt;<br>&lt;/section&gt;</code></pre></div>
      </section>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;<br>display: grid;<br>grid-template-columns: repeat(3, 100px);<br>grid-gap: 20px;<br>&#125;<br><br>section div:first-child &#123;<br>grid-column-start: 1;<br>grid-column-end: 2;<br>grid-row-start: 1;<br>grid-row-end: 2;<br>&#125;<br><br>section div:nth-child(2) &#123;<br>grid-column-start: 1;<br>grid-column-end: 2;<br>grid-row-start: 1;<br>grid-row-end: 2;<br>&#125;</code></pre></div>
      </section>
<p>Neste exemplo, criamos um <code>Grid</code> com 3 colunas de 100px cada uma e um espaço de 20px entre as colunas. O primeiro elemento ocupa da primeira coluna até a segunda coluna e da primeira linha até a segunda linha. O segundo elemento ocupa da primeira coluna até a segunda coluna e da primeira linha até a segunda linha.</p>
</section>
<section class="section-block-markdown-cell">
<p>Para controlar qual dos elementos se sobrepõe ao outro, podemos utilizar a propriedade <code>z-index</code>.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;<br>display: grid;<br>grid-template-columns: repeat(3, 100px);<br>grid-gap: 20px;<br>&#125;<br><br>section div:first-child &#123;<br>grid-column-start: 1;<br>grid-column-end: 2;<br>grid-row-start: 1;<br>grid-row-end: 2;<br>z-index: 1;<br>&#125;<br><br>section div:nth-child(2) &#123;<br>grid-column-start: 1;<br>grid-column-end: 2;<br>grid-row-start: 1;<br>grid-row-end: 2;<br>z-index: 2;<br>&#125;</code></pre></div>
      </section>
<p>Neste exemplo criamos um <code>Grid</code> com 3 colunas de 100px cada uma e um espaço de 20px entre as colunas. O primeiro elemento ocupa da primeira coluna até a segunda coluna e da primeira linha até a segunda linha. O segundo elemento ocupa da primeira coluna até a segunda coluna e da primeira linha até a segunda linha. Como o segundo elemento tem um <code>z-index</code> maior que o primeiro elemento, o segundo elemento se sobrepõe ao primeiro.</p>
</section>
<section class="section-block-markdown-cell">
<h3 id="Layouts com Grid">Layouts com Grid<a class="anchor-link" href="#Layouts com Grid">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Agora que conhecemos as propriedades básicas de <code>Grid</code>, vamos ver como podemos criar layouts com <code>Grid</code>.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-html">&lt;header&gt;Cabeçalho&lt;/header&gt;<br>&lt;aside&gt;Aparte&lt;/aside&gt;<br>&lt;main&gt;Principal&lt;/main&gt;<br>&lt;footer&gt;Rodapé&lt;/footer&gt;</code></pre></div>
      </section>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">body &#123;<br>display: grid;<br>grid-template-columns: 1fr 1fr 1fr;<br>grid-template-rows: 35px 1fr 100px;<br>min-height: 100vh;<br>&#125;<br><br>cabeçalho &#123;<br>grid-column: 1 / -1;<br>&#125;<br>main &#123;<br>grid-column: span 2;<br>&#125;<br><br>footer &#123;<br>grid-column: 1 / -1;<br>&#125;</code></pre></div>
      </section>
<p>Neste exemplo criamos um <code>Grid</code> com 3 colunas e 3 linhas. A primeira linha tem uma altura de 35px, a segunda linha ocupa o resto do espaço disponível e a terceira linha tem uma altura de 100px. O header ocupa desde a primeira coluna até a última coluna, o main ocupa desde a primeira coluna até a segunda coluna e o footer ocupa desde a primeira coluna até a última coluna.</p>
<p>Nós colocamos <code>min-height: 100vh</code> para que o <code>Grid</code> ocupe 100% da altura da tela, pois se não colocarmos isso, o <code>Grid</code> só ocupará a altura do conteúdo.</p>
</section>
<section class="section-block-markdown-cell">
<p>No entanto, na hora de visualizar o CSS, é difícil entendê-lo, então podemos usar a propriedade <code>grid-area</code>.</p>
</section>
<section class="section-block-markdown-cell">
<h3 id="Grid-area">Grid-area<a class="anchor-link" href="#Grid-area">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Podemos dar um nome a cada uma das áreas do <code>Grid</code> e depois usar esse nome para posicionar os elementos.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-html">&lt;header&gt;Cabeçalho&lt;/header&gt;<br>&lt;aside&gt;Aparte&lt;/aside&gt;<br>&lt;main&gt;Principal&lt;/main&gt;<br>&lt;footer&gt;Rodapé&lt;/footer&gt;</code></pre></div>
      </section>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">corpo &#123;<br>display: grid;<br>grid-template-columns: 1fr 1fr 1fr;<br>grid-template-rows: 35px 1fr 100px;<br>min-height: 100vh;<br>grid-template-areas:<br>"header header header"<br>"conteúdo da barra lateral conteúdo"<br>"rodapé rodapé rodapé";<br>&#125;<br><br>cabeçalho &#123;<br>grid-area: cabeçalho;&#125;<br><br>main &#123;<br>grid-area: conteúdo;<br>&#125;<br><br>footer &#123;<br>grid-area: rodapé;<br>&#125;<br><br>aside &#123;<br>grid-area: barra-lateral;<br>&#125;</code></pre></div>
      </section>
<p>Como demos nomeado cada uma das áreas do <code>Grid</code>, podemos usar esse nome para posicionar os elementos. Dessa forma, é mais fácil entender o CSS.</p>
</section>
<section class="section-block-markdown-cell">
<p>Se quiséssemos torná-lo responsivo, apenas teríamos que alterar o <code>Grid</code> e o resto do CSS permaneceria igual.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">corpo &#123;<br>display: grid;<br>grid-template-columns: 1fr 1fr 1fr;<br>grid-template-rows: 35px 1fr 100px;<br>min-height: 100vh;<br>grid-template-areas:<br>"cabeçalho cabeçalho cabeçalho"<br>"conteúdo da barra lateral conteúdo"<br>"rodapé rodapé rodapé";<br>&#125;<br><br>@media (width &lt; 400px) &#123;<br>corpo &#123;<br>grid-template-columns: 1fr;<br>grid-template-rows: 35px 1fr 100px;<br>grid-template-areas:<br>"cabeçalho cabeçalho barra lateral"<br>"conteúdo conteúdo conteúdo"<br>"rodapé rodapé rodapé";<br>&#125;<br>cabeçalho &#123;<br>grid-area: cabeçalho;<br>&#125;<br><br>main &#123;<br>grid-area: conteúdo;<br>&#125;<br><br>footer &#123;<br>grid-area: rodapé;<br>&#125;<br><br>aside &#123;<br>grid-area: barra-lateral;<br>&#125;</code></pre></div>
      </section>
<p>Agora fizemos com que, quando visualizemos em um dispositivo grande, o sidebar esteja à esquerda e o conteúdo à direita, mas quando visualizarmos em um dispositivo pequeno, o sidebar esteja acima e o conteúdo abaixo.</p>
</section>
<section class="section-block-markdown-cell">
<p>Suponhamos que queremos que em uma área não haja nada, podemos colocar um ponto.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">corpo &#123;<br>display: grid;<br>grid-template-columns: 1fr 1fr 1fr;<br>grid-template-rows: 35px 1fr 100px;<br>min-height: 100vh;<br>grid-template-areas:<br>"cabeçalho cabeçalho cabeçalho"<br>"barra lateral . conteúdo"<br>"rodapé rodapé rodapé";<br>&#125;<br><br>@media (largura &lt; 400px) &#123;<br>corpo &#123;<br>grid-template-columns: 1fr;<br>grid-template-rows: 35px 1fr 100px;<br>grid-template-areas:<br>"cabeçalho cabeçalho barra lateral"<br>"conteúdo conteúdo conteúdo"<br>"rodapé rodapé rodapé";<br>&#125;<br>cabeçalho &#123;<br>grid-area: cabeçalho;<br>&#125;<br><br>main &#123;<br>grid-area: conteúdo;<br>&#125;<br><br>footer &#123;<br>grid-area: rodapé;<br>&#125;<br><br>aside &#123;<br>grid-area: barra-lateral;<br>&#125;</code></pre></div>
      </section>
<p>Agora em telas grandes há um espaço entre a barra lateral e o conteúdo.</p>
</section>
<section class="section-block-markdown-cell">
<h3 id="Justify-items, Align-items, Justify-content e Align-content">Justify-items, Align-items, Justify-content e Align-content<a class="anchor-link" href="#Justify-items, Align-items, Justify-content e Align-content">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Podemos alinhar o conteúdo e os elementos de um <code>Grid</code> com as propriedades <code>justify-items</code>, <code>align-items</code>, <code>justify-content</code> e <code>align-content</code>.</p>
<img src="https://miro.medium.com/v2/resize:fit:1080/1*y9RuktkbVshp7lmVmZrbeQ.png" alt="grid justify">
</section>
<section class="section-block-markdown-cell">
<h4 id="Justificar-itens">Justificar-itens<a class="anchor-link" href="#Justificar-itens">¶</a></h4>
</section>
<section class="section-block-markdown-cell">
<p>Podemos alinhar os elementos no eixo X do <code>Grid</code> com a propriedade <code>justify-items</code>.</p>
<p>Os valores que podemos utilizar são:</p>
<ul>
  <li><code>start</code>: alinha os elementos no início do eixo principal.</li>
  <li><code>end</code>: alinha os elementos ao final do eixo principal.</li>
  <li><code>center</code>: alinha os elementos no centro do eixo principal.</li>
  <li><code>stretch</code>: estica os elementos para que ocupem todo o espaço disponível no eixo principal.</li>
</ul>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-html">&lt;section&gt;<br>&lt;div&gt;Texto 1&lt;/div&gt;<br>&lt;div&gt;Texto 2&lt;/div&gt;<br>&lt;div&gt;Texto 3&lt;/div&gt;&lt;/section&gt;</code></pre></div>
      </section>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;<br>display: grid;<br>justify-items: center;<br>&#125;</code></pre></div>
      </section>
</section>
<section class="section-block-markdown-cell">
<h4 id="Justificar-se">Justificar-se<a class="anchor-link" href="#Justificar-se">¶</a></h4>
</section>
<section class="section-block-markdown-cell">
<p>Com <code>justify-items</code> alinhamos todos os elementos no eixo principal do <code>Grid</code>, mas com <code>justify-self</code> podemos alinhar um elemento no eixo principal do <code>Grid</code> de forma diferente ao restante dos elementos.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-html">&lt;section&gt;<br>&lt;div&gt;Texto 1&lt;/div&gt;<br>&lt;div&gt;Texto 2&lt;/div&gt;<br>&lt;div&gt;Texto 3&lt;/div&gt;<br>&lt;/section&gt;</code></pre></div>
      </section>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;<br>display: grid;<br>justify-items: center;&#125;<br><br>section div:nth-child(2) &#123;<br>justify-self: end;<br>&#125;</code></pre></div>
      </section>
<p>It looks like you've shared an image, but I'm not able to view or interpret the contents of images directly. If you could provide a description of what's in the image or any specific details you'd like to discuss, I'd be happy to help!</p>
</section>
<section class="section-block-markdown-cell">
<h4 id="Alinhar-itens">Alinhar-itens<a class="anchor-link" href="#Alinhar-itens">¶</a></h4>
</section>
<section class="section-block-markdown-cell">
<p>É muito semelhante a <code>justify-items</code>, mas em vez de alinhar os elementos no eixo X, ele os alinha no eixo Y.</p>
<p>Os valores que podemos utilizar são:</p>
<ul>
  <li><code>start</code>: alinha os elementos no início do eixo secundário.</li>
  <li><code>end</code>: alinha os elementos ao final do eixo secundário.</li>
  <li><code>center</code>: alinha os elementos no centro do eixo secundário.</li>
  <li><code>stretch</code>: estica os elementos para que ocupem todo o espaço disponível no eixo secundário.</li>
</ul>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-html">&lt;section&gt;<br>&lt;div&gt;Texto 1&lt;/div&gt;<br>&lt;div&gt;Texto 2&lt;/div&gt;<br>&lt;div&gt;Texto 3&lt;/div&gt;&lt;/section&gt;</code></pre></div>
      </section>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;<br>display: grid;<br>align-items: center;<br>&#125;</code></pre></div>
      </section>
</section>
<section class="section-block-markdown-cell">
<h4 id="Alinhar-se">Alinhar-se<a class="anchor-link" href="#Alinhar-se">¶</a></h4>
</section>
<section class="section-block-markdown-cell">
<p>Com <code>align-items</code> alinhamos todos os elementos no eixo secundário do <code>Grid</code>, mas com <code>align-self</code> podemos alinhar um elemento no eixo secundário do <code>Grid</code> de forma diferente do restante dos elementos.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-html">&lt;section&gt;<br>&lt;div&gt;Texto 1&lt;/div&gt;<br>&lt;div&gt;Texto 2&lt;/div&gt;<br>&lt;div&gt;Texto 3&lt;/div&gt;<br>&lt;/section&gt;</code></pre></div>
      </section>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;<br>display: grid;<br>align-items: center;&#125;<br><br>section div:nth-child(2) &#123;<br>align-self: end;<br>&#125;</code></pre></div>
      </section>
<p>I'm unable to view or interpret images directly. Could you provide a description of the image or the context in which it's being used? I'd be happy to help with any questions or information related to it!</p>
</section>
<section class="section-block-markdown-cell">
<h4 id="Place-content">Place-content<a class="anchor-link" href="#Place-content">¶</a></h4>
</section>
<section class="section-block-markdown-cell">
<p>Se quisermos usar <code>justify-content</code> e <code>align-content</code> ao mesmo tempo, podemos usar <code>place-content</code>.</p>
<p>Os valores que podemos utilizar são:</p>
<ul>
  <li><code>start</code>: alinha os elementos no início do eixo principal e secundário.</li>
  <li><code>end</code>: alinha os elementos ao final do eixo principal e secundário.</li>
  <li><code>center</code>: alinha os elementos no centro do eixo principal e secundário.</li>
  <li><code>stretch</code>: estica os elementos para que ocupem todo o espaço disponível nos eixos principal e secundário.</li>
</ul>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-html">&lt;section&gt;<br>&lt;div&gt;Texto 1&lt;/div&gt;<br>&lt;div&gt;Texto 2&lt;/div&gt;<br>&lt;div&gt;Texto 3&lt;/div&gt;&lt;/section&gt;</code></pre></div>
      </section>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;<br>display: grid;<br>place-content: center;<br>&#125;</code></pre></div>
      </section>
</section>
<section class="section-block-markdown-cell">
<h3 id="Pratica de Grid">Prática de Grid<a class="anchor-link" href="#Pratica de Grid">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Um bom recurso para praticar Grid é <a href="https://cssgridgarden.com/">Grid Garden</a>.</p>
</section>
<section class="section-block-markdown-cell">
<h2 id="Centralizar um div">Centralizar um div<a class="anchor-link" href="#Centralizar um div">¶</a></h2>
</section>
<section class="section-block-markdown-cell">
<p>Até agora vimos 3 formas de centralizar um <code>div</code>:</p>
<ul>
  <li>Com <code>position: absolute</code>.</li>
  <li>Com <code>display: flex</code>.</li>
  <li>Com <code>display: grid</code>.</li>
</ul>
</section>
<section class="section-block-markdown-cell">
<h2 id="Animacoes">Animações<a class="anchor-link" href="#Animacoes">¶</a></h2>
</section>
<section class="section-block-markdown-cell">
<p>Dentro das animações existem dois tipos: as <code>transições</code> e as <code>animações</code></p>
</section>
<section class="section-block-markdown-cell">
<h3 id="Transicoes">Transições<a class="anchor-link" href="#Transicoes">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Nas transições, alteramos um elemento de um estado inicial para um estado objetivo.</p>
</section>
<section class="section-block-markdown-cell">
<p>Suponhamos que temos o seguinte círculo</p>
<div class='highlight'><pre><code class="language-html">&lt;div class="pulser"&gt;&lt;/div&gt;
</code></pre></div>
<p>E seu css</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">.pulso &#123;<br>largura: 30px;<br>altura: 30px;<br>background-color: #09f;<br>border-radius: 50%;<br>posição: relativa;<br>&#125;</code></pre></div>
      </section>
<p>Os elementos HTML podem ter estados, por exemplo o estado <code>hover</code>, que é quando o usuário passa o cursor sobre o elemento.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">.pulser:hover &#123;<br>escala: 2;<br>background: roxo;<br>box-shadow: 0 0 10px roxo;<br>&#125;</code></pre></div>
      </section>
<p>Ao fazer <code>scale</code> fazemos com que o tamanho aumente, mas ocupando o mesmo espaço. No entanto, se tivéssemos alterado o <code>width</code> e o <code>height</code>, o botão teria mudado de lugar.</p>
</section>
<section class="section-block-markdown-cell">
<h4 id="Transicao">Transição<a class="anchor-link" href="#Transicao">¶</a></h4>
</section>
<section class="section-block-markdown-cell">
<p>O que acontece é que, se agora passarmos o mouse sobre o círculo, o estado muda de repente, então aqui é onde entra a <code>transição</code>, que é como indicamos ao CSS como o estado deve ser modificado. Por exemplo, se quisermos que a transição dure 1 segundo</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">.pulso &#123;<br>largura: 30px;<br>altura: 30px;<br>background-color: #09f;<br>border-radius: 50%;<br>posição: relativa;<br>transição: 1s;<br>&#125;</code></pre></div>
      </section>
</section>
<section class="section-block-markdown-cell">
<p>É importante colocar a transição em <code>.pulser</code> e não em <code>.pulser:hover</code> porque, caso contrário, a transição não seria aplicada ao voltar ao estado inicial. Isso significa que quando passarmos o mouse sobre o círculo veremos a transição, mas quando retirarmos o mouse do círculo não haverá uma transição de volta, e sim uma mudança abrupta para o estado inicial.</p>
</section>
<section class="section-block-markdown-cell">
<p>O que se quer transicionar <code>transition-property</code></p>
</section>
<section class="section-block-markdown-cell">
<p>Com o anterior, seria feita uma transição de cor, tamanho e fundo, mas se não quisermos que ocorra uma transição de tudo, podemos indicá-lo através de <code>transition-property</code>.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">.pulso &#123;<br>largura: 30px;<br>altura: 30px;<br>background-color: #09f;<br>border-radius: 50%;<br>posição: relativa;transição: 1s;<br>transition-property: background-color, scale;<br>&#125;</code></pre></div>
      </section>
<p>Desta forma, apenas será feita a transição de <code>background-color</code> e <code>scale</code></p>
</section>
<section class="section-block-markdown-cell">
<h4 id="Transicoes suaves">Transições suaves<a class="anchor-link" href="#Transicoes suaves">¶</a></h4>
</section>
<section class="section-block-markdown-cell">
<p>A transição padrão é feita de maneira linear, mas se quisermos alterá-la, podemos fazer isso usando <code>transition-timing-function</code>.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">.pulso &#123;<br>largura: 30px;<br>altura: 30px;<br>background-color: #09f;<br>border-radius: 50%;<br>posição: relativa;<br>transição: 1s;<br>transition-property: background-color, scale;<br>transition-timing-function: ease-in-out;<br>&#125;</code></pre></div>
      </section>
<p>Desta forma, a transição será mais suave no início e no fim. Os possíveis valores são os seguintes:</p>
<ul>
  <li>linear</li>
  <li>facilidade</li>
  <li>facilidade-de-entrada</li>
  <li>facilidade-de-saída</li>
  <li>entrada-saída-suave</li>
  <li>cubic-bezier(n,n,n,n)</li>
</ul>
</section>
<section class="section-block-markdown-cell">
<h4 id="Transicoes passo a passo">Transições passo a passo<a class="anchor-link" href="#Transicoes passo a passo">¶</a></h4>
</section>
<section class="section-block-markdown-cell">
<p>Se quisermos que a animação seja feita em vários passos, podemos usar <code>steps(n)</code>, onde <code>n</code> é o número de passos que queremos que tenha a animação.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">.pulso &#123;<br>largura: 30px;<br>altura: 30px;<br>background-color: #09f;<br>border-radius: 50%;<br>posição: relativa;<br>transição: 1s;<br>transition-property: background-color, scale;<br>transition-timing-function: steps(5);<br>&#125;</code></pre></div>
      </section>
<p>Desta forma, a transição será realizada em 5 etapas durante um segundo.</p>
</section>
<section class="section-block-markdown-cell">
<h4 id="Controle total da transicao com cubic-bezier">Controle total da transição com cubic-bezier<a class="anchor-link" href="#Controle total da transicao com cubic-bezier">¶</a></h4>
</section>
<section class="section-block-markdown-cell">
<p>Para poder controlar perfeitamente a transição podemos usar <code>cubic-bezier(n,n,n,n)</code>, onde <code>n</code> é um número entre 0 e 1 que indica a posição do ponto no eixo X e Y</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">.pulso &#123;<br>largura: 30px;<br>altura: 30px;<br>background-color: #09f;<br>border-radius: 50%;<br>posição: relativa;<br>transição: 1s;<br>transition-property: background-color, scale;<br>transition-timing-function: cubic-bezier(0.1, 0.7, 1.0, 0.1);<br>&#125;</code></pre></div>
      </section>
</section>
<section class="section-block-markdown-cell">
<p>Com <code>delay</code> podemos indicar o tempo que tem que passar até que se inicie a transição</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">.pulso &#123;<br>largura: 30px;<br>altura: 30px;<br>background-color: #09f;<br>border-radius: 50%;<br>posição: relativa;<br>transição: 1s;<br>transition-property: background-color, scale;<br>transition-timing-function: cubic-bezier(0.1, 0.7, 1.0, 0.1);<br>transition-delay: 1s;<br>&#125;</code></pre></div>
      </section>
<p>Com o <code>delay</code> é possível fazer animações de carregamento, por exemplo</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-html">&lt;section&gt;<br>Faça hover para mostrar os elementos<br>&lt;div class="pulser"&gt;&lt;/div&gt;<br>&lt;div class="pulser"&gt;&lt;/div&gt;<br>&lt;div class="pulser"&gt;&lt;/div&gt;<br>&lt;/section&gt;</code></pre></div>
      </section>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;<br>display: flex;<br>flex-direction: column;<br>align-items: center;<br>justify-content: center;<br>altura: 100vh;<br>&#125;<br><br>.pulso &#123;<br>largura: 30px;<br>altura: 30px;<br>border-radius: 50%;<br>posição: relativa;<br>posição: relativa;<br>opacidade: 0;<br>transição: 2s;<br>transition-timing-function: ease;<br>&#125;<br><br>seção &#123;<br>display: flex;<br>gap: 16px;<br>justify-content: center;<br>align-items: center;<br>&#125;<br><br>section:hover .pulser &#123;<br>opacidade: 1;<br>&#125;<br><br>.pulser:first-child &#123;<br>transition-delay: 0s;<br>&#125;<br><br>.pulso:nth-child(2) &#123;<br>transition-delay: 300ms;<br>&#125;<br><br>.pulser:last-child &#123;<br>transition-delay: 600ms;<br>&#125;</code></pre></div>
      </section>
</section>
<section class="section-block-markdown-cell">
<p>Em <a href="https://easings.co/">easings.co</a> podemos ver e configurar as transições</p>
</section>
<section class="section-block-markdown-cell">
<h4 id="Tudo em uma linha">Tudo em uma linha<a class="anchor-link" href="#Tudo em uma linha">¶</a></h4>
</section>
<section class="section-block-markdown-cell">
<p>Em <code>.pulser</code> colocamos <code>transition</code> e <code>transition-timing-function</code>, mas também podemos colocar tudo em uma linha.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">.pulso &#123;<br>largura: 30px;<br>altura: 30px;<br>background-color: #09f;<br>border-radius: 50%;<br>posição: relativa;<br>transição: fundo 300ms ease-in-out 2s;<br>&#125;</code></pre></div>
      </section>
<p>Com isso, o que lhe dissemos é para animar o <code>background</code> por 300ms, com uma transição suave no início e no fim, e esperar 2 segundos antes de começar a transição.</p>
<p>Se quisermos especificar vários elementos, podemos fazer isso da seguinte maneira</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">.pulso &#123;<br>largura: 30px;<br>altura: 30px;<br>background-color: #09f;<br>border-radius: 50%;<br>posição: relativa;<br>transição: fundo 300ms ease-in-out 2s, escala 1s ease-in-out 1s;<br>&#125;</code></pre></div>
      </section>
</section>
<section class="section-block-markdown-cell">
<h4 id="O que transicionar?">O que transicionar?<a class="anchor-link" href="#O que transicionar?">¶</a></h4>
</section>
<section class="section-block-markdown-cell">
<p>Na hora de adicionar transições, pode-se procurar o que pode ser transitado em <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_animated_properties">Animatable CSS properties</a>, mas para não perder tempo buscando, o melhor é transitar propriedades com sentido, por exemplo algo que pode ser transitado é uma cor, um tamanho, etc.</p>
<p>O ideal é fazer transições de propriedades com estados intermediários, por exemplo, uma fonte não possui um estado intermediário e não faz sentido fazer uma transição de uma fonte para outra.</p>
</section>
<section class="section-block-markdown-cell">
<h4 id="Transicoes diferentes no inicio e no fim">Transições diferentes no início e no fim<a class="anchor-link" href="#Transicoes diferentes no inicio e no fim">¶</a></h4>
</section>
<section class="section-block-markdown-cell">
<p>Antes dissemos que é preciso colocar as transições no elemento e não no hover, porque dessa forma a transição só será visível quando o mouse estiver sobre o elemento e não quando você retirar o mouse. Bem, se quisermos ter animações diferentes no início e no final, podemos aproveitar isso. No elemento, colocaremos a transição final e no hover, a inicial.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">.pulso &#123;<br>largura: 30px;<br>altura: 30px;<br>background-color: #09f;<br>border-radius: 50%;<br>posição: relativa;<br>transição: fundo 300ms ease-in-out<br>&#125;<br><br>.pulser:hover &#123;escala: 2;<br>background: roxo;<br>box-shadow: 0 0 10px roxo;<br>transição: 1s;<br>transition-duration: 1s;<br>&#125;</code></pre></div>
      </section>
<p>Desta forma, quando passarmos o mouse sobre o elemento, haverá uma transição de 300 ms e quando retirarmos o mouse, a transição será de 1 segundo.</p>
</section>
<section class="section-block-markdown-cell">
<h4 id="Acessibilidade">Acessibilidade<a class="anchor-link" href="#Acessibilidade">¶</a></h4>
</section>
<section class="section-block-markdown-cell">
<p>Há pessoas que podem ficar tontas com as transições, então podemos adicionar uma media query para removê-las.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">@media (prefers-reduced-motion: reduce) &#123;<br>.pulso &#123;<br>transição: none;&#125;<br>&#125;</code></pre></div>
      </section>
</section>
<section class="section-block-markdown-cell">
<h3 id="Animacoes">Animações<a class="anchor-link" href="#Animacoes">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>As transições são as animações quando interagimos com os elementos, mas nas animações não precisamos interagir com o elemento, podem ser executadas sozinhas. Por exemplo, o botão típico que a cada certo tempo muda e se move para que você saiba que precisa pressioná-lo.</p>
</section>
<section class="section-block-markdown-cell">
<h4 id="Keyframes">Keyframes<a class="anchor-link" href="#Keyframes">¶</a></h4>
</section>
<section class="section-block-markdown-cell">
<p>Voltamos ao exemplo da bola azul e removemos todas as transições</p>
<div class='highlight'><pre><code class="language-html">&lt;div class="pulser"&gt;&lt;/div&gt;
</code></pre></div>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">.pulso &#123;<br>largura: 30px;<br>altura: 30px;background-color: #09f;<br>border-radius: 50%;<br>&#125;</code></pre></div>
      </section>
</section>
<section class="section-block-markdown-cell">
<p>Temos que indicar ao CSS que queremos fazer uma animação, para isso usamos <code>@keyframes</code> e damos um nome à animação</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">@keyframes move &#123;<br>&#125;</code></pre></div>
      </section>
<p>Agora temos que dizer de onde começa este quadro, para isso usamos <code>from</code> e onde termina, para isso usamos <code>to</code></p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">@keyframes move &#123;<br>do &#123;<br>&#125;<br>para &#123;<br>&#125;<br>&#125;</code></pre></div>
      </section>
<p>Agora temos que indicar quais propriedades queremos que mudem, por exemplo a posição</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">@keyframes move &#123;<br>do &#123;<br>transform: translateX(0);<br>&#125;<br>para &#123;<br>transform: translateX(100px);<br>&#125;<br>&#125;</code></pre></div>
      </section>
<p>Desta forma, quando entrarmos na página, a bola azul se moverá 100px para a direita.</p>
</section>
<section class="section-block-markdown-cell">
<h4 id="Depois">Depois<a class="anchor-link" href="#Depois">¶</a></h4>
</section>
<section class="section-block-markdown-cell">
<p>Em um elemento pode-se colocar um <code>after</code> que é um elemento que é colocado após o elemento principal.</p>
<div class='highlight'><pre><code class="language-html">&lt;div class="pulser"&gt;&lt;/div&gt;
</code></pre></div>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">.pulso &#123;<br>largura: 30px;<br>altura: 30px;<br>background-color: blue;<br>border-radius: 50%;<br>&#125;<br><br>.pulso::after &#123;<br>conteúdo: &#39;&#39;;<br>posição: absoluta;<br>largura: 100%;<br>altura: 100%;<br>top: 0;<br>esquerda: 0;<br>background-color: blue;<br>border-radius: 50%;<br>z-index: -1;<br>&#125;</code></pre></div>
      </section>
<p>Isso faz colocar um círculo azul atrás do círculo azul, então agora temos dois círculos azuis.</p>
<p>Agora definimos os keyframes</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">@keyframes move &#123;<br>0% &#123;<br>opacidade: 0;<br>&#125;<br>50% &#123;<br>escala: 1.5;<br>opacidade: 40%;<br>&#125;<br>100% &#123;<br>opacidade: 60%;<br>&#125;<br>&#125;</code></pre></div>
      </section>
<p>E como já definimos os keyframes, agora só precisamos indicar ao CSS que queremos que a animação seja executada.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">.pulso::after &#123;<br>conteúdo: &#39;&#39;;<br>posição: absoluta;<br>largura: 100%;<br>altura: 100%;<br>top: 0;<br>esquerda: 0;<br>background-color: azul;<br>border-radius: 50%;<br>z-index: -1;<br>    <br>animation-name: pulso;<br>animation-duration: 2s;<br>animation-timing-function: ease-in-out;<br>&#125;</code></pre></div>
      </section>
<p>Agora, quando a página for carregada, parecerá que o círculo azul está batendo.</p>
</section>
<section class="section-block-markdown-cell">
<p>Mas só se produz uma vez, para que se produza mais vezes precisamos adicionar <code>animation-iteration-count</code></p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">.pulser::after &#123;<br>conteúdo: &#39;&#39;;<br>posição: absoluta;<br>largura: 100%;<br>altura: 100%;<br>top: 0;<br>esquerda: 0;<br>background-color: azul;<br>border-radius: 50%;<br>z-index: -1;<br>    <br>animation-name: pulso;<br>animation-duration: 2s;<br>animation-timing-function: ease-in-out;<br>animation-iteration-count: infinite;<br>&#125;</code></pre></div>
      </section>
<p>Agora será produzido de forma infinita</p>
</section>
<section class="section-block-markdown-cell">
<h4 id="Movimento">Movimento<a class="anchor-link" href="#Movimento">¶</a></h4>
</section>
<section class="section-block-markdown-cell">
<p>Podemos fazer com que um elemento se mova</p>
<div class='highlight'><pre><code class="language-html">&lt;div class="pulser"&gt;&lt;/div&gt;
</code></pre></div>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">.pulso &#123;<br>largura: 30px;<br>altura: 30px;<br>background-color: azul;<br>border-radius: 50%;<br>posição: relativa;<br>&#125;<br><br>.pulso::after &#123;<br>conteúdo: &#39;&#39;;<br>posição: absoluta;<br>width: 100%;<br>altura: 100%;<br>top: 0;<br>esquerda: 0;<br>background-color: blue;<br>border-radius: 50%;<br>z-index: -1;<br>    <br>animation-name: mover;<br>duração-da-animação: 2s;<br>animation-iteration-count: infinite;<br>animation-timing-function: linear;<br>&#125;<br><br>@keyframes move &#123;<br>do &#123;<br>transform: translateX(0);<br>&#125;<br>para &#123;<br>transform: translateX(100px);<br>&#125;<br>&#125;</code></pre></div>
      </section>
<p>Agora a bola azul se moverá 100px para a direita</p>
</section>
<section class="section-block-markdown-cell">
<h4 id="Endereco">Endereço<a class="anchor-link" href="#Endereco">¶</a></h4>
</section>
<section class="section-block-markdown-cell">
<p>Para que a bola azul se mova para a esquerda, basta fazer <code>animation-direction: reverse</code></p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">.pulso::after &#123;<br>conteúdo: &#39;&#39;;<br>posição: absoluta;<br>largura: 100%;<br>altura: 100%;<br>top: 0;<br>esquerda: 0;<br>background-color: blue;<br>border-radius: 50%;z-index: -1;<br>    <br>animation-name: mover;<br>animation-duration: 2s;<br>animation-iteration-count: infinite;<br>animation-timing-function: linear;<br>animation-direction: reverse;<br>&#125;</code></pre></div>
      </section>
</section>
<section class="section-block-markdown-cell">
<p>Se quisermos que a bola vá de um lado para o outro, temos que colocar <code>animation-direction: alternate</code></p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">.pulso::after &#123;<br>conteúdo: &#39;&#39;;<br>posição: absoluta;<br>largura: 100%;<br>altura: 100%;<br>top: 0;<br>esquerda: 0;<br>background-color: blue;<br>border-radius: 50%;z-index: -1;<br>    <br>animation-name: mover;<br>duração-da-animação: 2s;<br>animation-iteration-count: infinite;<br>animation-timing-function: linear;<br>animation-direction: alternate;<br>&#125;</code></pre></div>
      </section>
</section>
<section class="section-block-markdown-cell">
<h4 id="Pausar animacoes">Pausar animações<a class="anchor-link" href="#Pausar animacoes">¶</a></h4>
</section>
<section class="section-block-markdown-cell">
<p>Imagine que você tem cartões que possuem animações. Talvez você queira que quando o mouse passe por cima do cartão, a animação pare. Para isso, podemos usar <code>animation-play-state: paused</code>.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">.card:hover &#123;<br>animation-play-state: paused;&#125;</code></pre></div>
      </section>
</section>
<section class="section-block-markdown-cell">
<h4 id="Aninhamento CSS">Aninhamento CSS<a class="anchor-link" href="#Aninhamento CSS">¶</a></h4>
</section>
<section class="section-block-markdown-cell">
<p>Nós declaramos no CSS as propriedades do pulser e as propriedades quando se faz hover, mas tudo pode ser feito junto.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">.pulso &#123;<br>largura: 30px;<br>altura: 30px;<br>background-color: azul;<br>border-radius: 50%;<br>posição: relativa;<br>    <br>&amp;::after &#123;<br>conteúdo: &#39;&#39;;<br>posição: absoluta;<br>largura: 100%;<br>altura: 100%;<br>top: 0;<br>esquerda: 0;<br>background-color: blue;<br>border-radius: 50%;<br>z-index: -1;<br>        <br>animation-name: mover;<br>animation-duration: 2s;<br>animation-iteration-count: infinite;<br>animation-timing-function: linear;<br>animation-direction: alternate;<br>&#125;<br>    <br>&amp;:hover::after &#123;<br>animation-play-state: paused;<br>&#125;<br>&#125;</code></pre></div>
      </section>
</section>
<section class="section-block-markdown-cell">
<h4 id="Como terminar as animacoes">Como terminar as animações<a class="anchor-link" href="#Como terminar as animacoes">¶</a></h4>
</section>
<section class="section-block-markdown-cell">
<p>Se temos uma animação que só é executada uma vez, por exemplo, a bola azul se movendo para a direita, quando a animação terminar, ela voltará bruscamente à sua posição inicial. Para evitar isso, podemos usar <code>animation-fill-mode: forwards</code></p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">.pulso::after &#123;<br>conteúdo: &#39;&#39;;<br>posição: absoluta;<br>largura: 100%;<br>altura: 100%;<br>top: 0;<br>esquerda: 0;<br>background-color: blue;<br>border-radius: 50%;<br>z-index: -1;<br>    <br>animation-name: mover;<br>animation-duration: 2s;<br>animation-timing-function: linear;<br>animation-direction: alternate;<br>animation-fill-mode: forwards;<br>&#125;</code></pre></div>
      </section>
<p>Desta forma, quando a animação terminar, a bola azul ficará na posição final.</p>
<p>Se colocarmos <code>backwards</code> em vez de <code>forwards</code>, a animação começará do estado final.</p>
<p>Se colocarmos <code>both</code>, a animação começará do estado inicial e terminará no estado final.</p>
</section>
<section class="section-block-markdown-cell">
<h4 id="Tudo em uma linha">Tudo em uma linha<a class="anchor-link" href="#Tudo em uma linha">¶</a></h4>
</section>
<section class="section-block-markdown-cell">
<p>Temos um monte de propriedades (<code>animation-name</code>, <code>animation-duration</code>, <code>animation-timing-function</code>, <code>animation-direction</code>, <code>animation-fill-mode</code>), mas podem ser colocadas todas em uma linha. Tudo o que foi mencionado acima poderia ser escrito assim</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">.pulso::after &#123;<br>conteúdo: &#39;&#39;;<br>posição: absoluta;<br>largura: 100%;<br>altura: 100%;<br>top: 0;<br>esquerda: 0;background-color: blue;<br>border-radius: 50%;<br>z-index: -1;<br>    <br>animation: mover 2s linear alternate forwards;<br>&#125;</code></pre></div>
      </section>
</section>
<section class="section-block-markdown-cell">
<p>Podemos criar várias animações</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">.pulser::after &#123;<br>conteúdo: &#39;&#39;;<br>posição: absoluta;<br>width: 100%;<br>altura: 100%;<br>top: 0;<br>esquerda: 0;<br>background-color: azul;<br>border-radius: 50%;<br>z-index: -1;<br>    <br>animação:<br>mover 2s linear alternate forwards,<br>aumentar 1s linear 2s both;<br>&#125;</code></pre></div>
      </section>
<p>Mas como a animação <code>agrandar</code> não existe, nós a criamos com keyframes</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">@keyframes ampliar &#123;<br>0% &#123;<br>transform: scale: 1;<br>&#125;<br>25% &#123;<br>transform: scale: 1.5;<br>&#125;<br>50% &#123;<br>transform: scale: 2;<br>&#125;<br>75% &#123;<br>transform: scale: 1.6;<br>&#125;<br>100% &#123;<br>transform: scale: 2;<br>&#125;<br>&#125;</code></pre></div>
      </section>
<p>Vai ser reproduzida uma após a outra, porque foi adicionado um delay de 2 segundos ao <code>agrandar</code>, que é o tempo que dura a primeira animação. Mas se quisermos que seja ao mesmo tempo, temos que remover o delay.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">.pulser::after &#123;<br>conteúdo: &#39;&#39;;<br>posição: absoluta;<br>largura: 100%;<br>altura: 100%;<br>top: 0;<br>esquerda: 0;<br>background-color: azul;<br>border-radius: 50%;<br>z-index: -1;<br>    <br>animação:<br>mover 2s linear alternate forwards,<br>aumentar 1s linear both;<br>&#125;</code></pre></div>
      </section>
</section>
<section class="section-block-markdown-cell">
<h4 id="Animacoes com scroll">Animações com scroll<a class="anchor-link" href="#Animacoes com scroll">¶</a></h4>
</section>
<section class="section-block-markdown-cell">
<h5 id="Exemplo de barra de progresso">Exemplo de barra de progresso<a class="anchor-link" href="#Exemplo de barra de progresso">¶</a></h5>
</section>
<section class="section-block-markdown-cell">
<p>Por exemplo, se quisermos fazer uma barra que vá aumentando de tamanho à medida que descemos pela página</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-html">&lt;section&gt;<br>&lt;div id="barra"&gt;&lt;/div&gt;<br>&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit<br>&lt;/p&gt;<br>&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit<br>&lt;/p&gt;<br>&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit&lt;/p&gt;<br>&lt;/p&gt;<br>&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit<br>&lt;/p&gt;<br>&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit<br>&lt;/p&gt;<br>&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit&lt;/p&gt;<br>&lt;/p&gt;<br>&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit<br>&lt;/p&gt;<br>&lt;/section&gt;</code></pre></div>
      </section>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;<br>display: flex;<br>flex-direction: column;<br>align-items: center;<br>justify-content: center;<br>altura: 100vh;<br>&#125;<br><br>#barra &#123;<br>posição: fixed;<br>top: 0;<br>largura: 0%;<br>background-color: red;<br>altura: 1em;<br><br>animation: barra-grow auto linear;<br>animation-timeline: scroll(root block);<br>&#125;<br><br>@keyframes barra-grow &#123;<br>do &#123;<br>largura: 0%;<br>&#125;<br>do &#123;<br>largura: 100%;<br>&#125;<br>&#125;</code></pre></div>
      </section>
<p>Como em <code>animation</code> colocamos um tempo de <code>auto</code> para saber quanto tempo a animação deve durar, o navegador olhará para <code>animation-timeline</code>, onde indicamos que ele deve prestar atenção ao scroll. Dentro da função <code>scroll</code> indicamos em qual elemento ele deve prestar atenção, no nosso caso colocamos <code>root</code> porque queremos o scroll da página, mas poderia ser qualquer outro elemento da página. Além disso, temos que indicar se queremos que ele preste atenção no scroll vertical ou horizontal, no nosso caso colocamos <code>block</code> porque queremos que ele preste atenção no scroll vertical (<code>block</code> é o valor padrão, portanto, se quiser, não precisa colocá-lo).</p>
</section>
<section class="section-block-markdown-cell">
<h5 id="Exemplo de cabecalho que muda de cor">Exemplo de cabeçalho que muda de cor<a class="anchor-link" href="#Exemplo de cabecalho que muda de cor">¶</a></h5>
</section>
<section class="section-block-markdown-cell">
<p>Se quisermos que, quando fizermos scroll, o header mude de cor</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-html">&lt;header&gt;<br>&lt;navegação&gt;<br>&lt;ul&gt;<br>&lt;li&gt;Início&lt;/li&gt;<br>&lt;li&gt;Sobre&lt;/li&gt;<br>&lt;li&gt;Contato&lt;/li&gt;<br>&lt;/ul&gt;<br>&lt;/nav&gt;<br>&lt;/header&gt;</code></pre></div>
      </section>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">cabeçalho &#123;<br>posição: sticky;<br>top: 0;<br>largura: 100%;<br>background-color: white;<br>box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);<br>z-index: 2;<br>animation: header-color linear both;<br>animation-timeline: scroll(root block);<br>&#125;<br><br>@keyframes header-color &#123;<br>do &#123;<br>cor de fundo: branco;<br>&#125;<br>para &#123;<br>background-color: cinza;<br>backdrop-filter: blur(5px);<br>cor: branco;<br>&#125;<br>&#125;</code></pre></div>
      </section>
</section>
<section class="section-block-markdown-cell">
<p>Mas fazendo assim, a animação do header só termina quando se chega ao final da página, mas nós queremos que ela termine quando é feito um pouco de scroll. Para isso, removemos o <code>both</code> do <code>animation</code> e colocamos <code>animation-range: 0 200px</code> para que a animação termine quando for feito um scroll de 200 px, ou seja, estamos dizendo que a animação vai dos 0 px até os 200 px.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">cabeçalho &#123;<br>posição: sticky;<br>top: 0;<br>largura: 100%;<br>cor de fundo: branco;<br>box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);<br>z-index: 2;<br><br>animation: header-color linear;<br>animation-timeline: scroll(root);<br>animation-range: 0 200px;<br>&#125;</code></pre></div>
      </section>
</section>
<section class="section-block-markdown-cell">
<h5 id="Exemplo de galeria de imagens">Exemplo de galeria de imagens<a class="anchor-link" href="#Exemplo de galeria de imagens">¶</a></h5>
</section>
<section class="section-block-markdown-cell">
<p>Vamos imaginar que temos um monte de imagens e queremos que, ao fazer scroll, elas vão aparecendo.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-html">&lt;section&gt;<br>&lt;img src="img1.jpg" alt="imagem 1"&gt;<br>&lt;img src="img2.jpg" alt="imagem 2"&gt;<br>&lt;img src="img3.jpg" alt="imagem 3"&gt;<br>&lt;img src="img4.jpg" alt="imagem 4"&gt;<br>&lt;img src="img5.jpg" alt="imagem 5"&gt;<br>&lt;img src="img6.jpg" alt="imagem 6"&gt;<br>&lt;img src="img7.jpg" alt="imagem 7"&gt;<br>&lt;img src="img8.jpg" alt="imagem 8"&gt;<br>&lt;img src="img9.jpg" alt="imagem 9"&gt;<br>&lt;img src="img10.jpg" alt="imagem 10"&gt;<br>&lt;/section&gt;</code></pre></div>
      </section>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-css">seção &#123;<br>display: grid;<br>grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));<br>gap: 16px;<br>&#125;<br><br>img &#123;<br>largura: 100%;<br>altura: auto;<br>opacidade: 0;<br>animation: aparecer linear both;<br>animation-timeline: view()<br>animation-range: entrada 20% cobertura 30%;<br>&#125;<br><br>@keyframes aparecer &#123;<br>do &#123;<br>opacidade: 0;<br>&#125;<br>para &#123;<br>opacidade: 1;<br>&#125;<br>&#125;</code></pre></div>
      </section>
<p>Com <code>animation-timeline: view()</code> estamos dizendo para fazer a animação quando a imagem estiver visível na tela e com <code>animation-range: entry 20% cover 30%</code> estamos dizendo que a animação deve começar quando a imagem ocupar 20% da tela e terminar quando ocupar 30% da tela.</p>
<p>Ao colocar <code>both</code> em <code>animation</code>, estamos dizendo que a animação deve ocorrer tanto ao aparecer quanto ao desaparecer, ou seja, quando a imagem aparece, vemos a animação, mas quando ela desaparece, também vemos a animação ao contrário, isto é, a imagem vai gradualmente de uma opacidade de 1 para 0.</p>
</section>