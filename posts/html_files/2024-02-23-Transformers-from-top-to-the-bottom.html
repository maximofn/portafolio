<section class="section-block-markdown-cell">
<h1 id="Transformers - from top to the bottom">Transformers - from top to the bottom<a class="anchor-link" href="#Transformers - from top to the bottom">¶</a></h1>
</section>
<section class="section-block-markdown-cell">
<p>En este post vamos a ver cómo funcionan los Transformers de arriba a abajo.</p>
</section>
<section class="section-block-markdown-cell">
<h2 id="Transformer como una caja negra">Transformer como una caja negra<a class="anchor-link" href="#Transformer como una caja negra">¶</a></h2>
</section>
<section class="section-block-markdown-cell">
<p>La arquitectura transformer se creó para el problema de traducción, por lo que vamos a explicarlo para ese problema</p>
</section>
<section class="section-block-markdown-cell">
<p>Imaginemos el transformer como una caja negra, a la que le entra una frase en un idioma y saca la misma frase traducida en otro idioma.</p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/Transformer-black-box.webp" alt="Transformer - black box">
</section>
<section class="section-block-markdown-cell">
<h2 id="Tokenizacion">Tokenización<a class="anchor-link" href="#Tokenizacion">¶</a></h2>
</section>
<section class="section-block-markdown-cell">
<p>Pero como hemos visto en el post de <a href="https://maximofn.com/tokens/">tokens</a>, los modelos de lenguaje no entienden las palabras como nosotros, sino que necesitan números para poder realizar las operaciones. Por lo que la frase en el idioma original se tiene que convertir a tokens mediante un tokenizador, y a la salida necesitamos un detokenizador para convertir los tokens de salida a palabras</p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/Transformer-black-box-tokenizers.webp" alt="Transformer - black box - tokenizers">
<p>De modo que el tokenizador crea una secuencia de <span class="math-inline">n<sub>input-tokens</sub></span> tokens, y el detokenizador recibe una secuencia de <span class="math-inline">n<sub>output-tokens</sub></span> tokens.</p>
</section>
<section class="section-block-markdown-cell">
<h2 id="Input embeddings">Input embeddings<a class="anchor-link" href="#Input embeddings">¶</a></h2>
</section>
<section class="section-block-markdown-cell">
<p>En el post de <a href="https://maximofn.com/embeddings/">embeddings</a> vimos que los embeddings son una forma de representar las palabras en un espacio vectorial. Por lo que los tokens de entrada se pasan por una capa de embeddings para convertirlos en vectores.</p>
<p>En un resumen rápido, el proceso de embedding consiste en convertir una secuencia de números (tokens) en una secuencia de vectores. De manera que se crea un nuevo espacio vectorial en el que las palabras que tengan similitud semántica estarán cerca.</p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/word_embedding_3_dimmension.webp" alt="word_embedding_3_dimmension">
<p>Si teníamos <span class="math-inline">n<sub>input-tokens</sub></span> tokens, ahora tenemos <span class="math-inline">n<sub>input-tokens</sub></span> vectores. Cada uno de esos vectores tiene una longitud de <span class="math-inline">d<sub>model</sub></span>. Es decir, cada token se convierte a un vector que representa ese token en un espacio vectorial de <span class="math-inline">d<sub>model</sub></span> dimensiones.</p>
<p>Por tanto después de pasar por la capa de embeddings, la secuencia de <span class="math-inline">n<sub>input-tokens</sub></span> tokens se convierte en una matriz de (<span class="math-inline">n<sub>input-tokens</sub></span> x <span class="math-inline">d<sub>model</sub></span>).</p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/Transformer-black-box-input-embeddings.webp" alt="Transformer - black box - input embeddings">
</section>
<section class="section-block-markdown-cell">
<h2 id="Encoder - decoder">Encoder - decoder<a class="anchor-link" href="#Encoder - decoder">¶</a></h2>
</section>
<section class="section-block-markdown-cell">
<p>Hemos visto el transformer actuando como una caja negra, pero en realidad el transformer es una arquitectura que se compone de dos partes, un encoder y un decoder.</p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/Transformer-encoder-decoder.png" alt="Transformer - encoder-decoder">
<p>El encoder se encarga de comprimir la información de la frase de entrada, crea un espacio latente donde está esa información de la frase de entrada es comprimida. A continuación, esa información comprimida entra al decoder, que sabe convertir esa información comprimida en una frase del idioma de salida.</p>
</section>
<section class="section-block-markdown-cell">
<p>Y ¿cómo convierte el decoder esa información comprimida en una frase del idioma de salida? Pues token a token. Para entenderlo mejor vamos a olvidarnos de los tokens de salida por un momento, vamos a imaginar que tenemos esta arquitectura</p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/Transformer-encoder-decoder-no-detokenizer.webp" alt="Transformer - encoder-decoder (no detokenizer)">
<p>Es decir, la frase del idioma original se convierte a tokens, estos tokens se convierten a embeddings, que entran al encoder, este comprime la información, el decoder la coge y la convierte en palabras del idioma de salida</p>
</section>
<section class="section-block-markdown-cell">
<p>De modo que el decoder va generando una palabra nueva a la salida en cada paso</p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/Transformer%20-%20encoder-decoder%20(no%20detokenizer).gif" alt="Transformer - encoder-decoder (no detokenizer)">
</section>
<section class="section-block-markdown-cell">
<p>Pero ¿cómo sabe el decoder cúal es la palabra que tiene que generar cada vez? Porque se le está pasando la frase que ya ha traducido, y en cada paso va generando la siguiente palabra. Es decir, en cada paso el decoder recibe la frase que ha traducido hasta el momento, y genera la siguiente palabra.</p>
<p>Pero aun así, ¿cómo sabe que tiene que generar la primera palabra? Porque se le pasa una palabra especial que significa "empezar a traducir", y a partir de ahí va generando las siguientes palabras.</p>
<p>Y por último, ¿cómo sabe el transformer que tiene que dejar de generar palabras? Porque cuando termina de traducir genera una palabra especial que significa "fin de la traducción", que cuando vuelve a entrar en el transformer hace que no genere más palabras.</p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/Transformer%20-%20encoder-decoder%20(no%20detokenizer)%20(input).gif" alt="Transformer - encoder-decoder (no detokenizer) (input)">
</section>
<section class="section-block-markdown-cell">
<p>Ahora que lo hemos entendido con palabras, que es más sencillo, vamos a volver a colocar el detokenizador a la salida</p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/Transformer-encoder-decoder.png" alt="Transformer - encoder-decoder">
<p>Por tanto el decoder irá generando tokens. Para saber que tiene que empezar una frase se le mete un token especial comunmente llamado <code>SOS</code> (Start Of Sentence), y para saber que tiene que terminar genera otro token especial comunmente llamado <code>EOS</code> (End Of Sentence).</p>
<p>Y al igual que el encoder, el token de entrada tiene que pasar por una capa de embedding para convertir los tokens en representaciones vectoriales.</p>
<p>Suponiendo que cada token equivale a una palabra, el proceso de traducción sería el siguiente</p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/Transformer%20-%20encoder-decoder%20(detokenizer).gif" alt="Transformer - encoder-decoder (detokenizer)">
</section>
<section class="section-block-markdown-cell">
<p>De momento tenemos esta arquitectura</p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/Transformer-encoder-decoder-detokenizer-2.webp" alt="Transformer - encoder-decoder (detokenizer)">
</section>
<section class="section-block-markdown-cell">
<h2 id="Projection">Projection<a class="anchor-link" href="#Projection">¶</a></h2>
</section>
<section class="section-block-markdown-cell">
<p>Hemos dicho que al decoder le entra un token que pasa por la capa de embedding <code>Output embedding</code>.</p>
<p>El <code>Output decoder</code> crea un vector por cada token, por lo que a la salida del <code>Output decoder</code> tenemos una matriz de (<span class="math-inline">n<sub>output-tokens</sub></span> x <span class="math-inline">d<sub>model</sub></span>).</p>
<p>El decoder hace operaciones, pero saca una matriz con la misma dimensión. Así de necesita convertir esa matriz en un token y eso lo hace mediante una capa lineal que a la salida genera un array con la misma dimensión que los posibles tokens que hay en el lenguaje al que se quiere traducir (vocabulario de salida).</p>
<p>Ese array corresponde a los logits de cada posible token, por lo que a continuación se pasa por una capa softmax que convierte esos logits en probabilidades. Es decir, tendremos la probabilidad de que cada token sea el siguiente token.</p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/Transformer-projection.webp" alt="Transformer - projection">
</section>
<section class="section-block-markdown-cell">
<h2 id="Encoder y decoder x6">Encoder y decoder x6<a class="anchor-link" href="#Encoder y decoder x6">¶</a></h2>
</section>
<section class="section-block-markdown-cell">
<p>En el paper original usan 6 capas para el encoder y otras 6 capas para el decoder. No hay ninguna razón para que sean 6, supongo que probaron varios valores y este fue el que mejor les funcionó.</p>
<p>A cada uno de los decoder le entra la salida del último encoder</p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/Transformer-encoder-decoder-x6.webp" alt="Transformer - encoder-decoder (x6)">
</section>
<section class="section-block-markdown-cell">
<p>Para simplificar el diagrama, lo representaremos así a partir de ahora</p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/Transformer-encoder-decoder-Nx.webp" alt="Transformer - encoder-decoder (Nx)">
</section>
<section class="section-block-markdown-cell">
<h2 id="Attention - Feed forward">Attention - Feed forward<a class="anchor-link" href="#Attention - Feed forward">¶</a></h2>
</section>
<section class="section-block-markdown-cell">
<p>Vamos a ir empezando a ver qué ha dentro del encoder y el decoder. Básicamente lo que hay es un mecanismo de atención y una capa feed forward.</p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/Transformer-encoder-decoder-attention-ff.webp" alt="Transformer - encoder-decoder - attention-ff">
</section>
<section class="section-block-markdown-cell">
<h3 id="Atencion">Atención<a class="anchor-link" href="#Atencion">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Podemos ver que en los mecanismos de atención entran 3 flechas. Esto ya lo veremos más adelante cuando veamos en profundidad cómo funcionan los mecanismos de atención.</p>
<p>Pero de momento podemos decir que son operaciones que se realizan para poder obtener la relación que existe entre los tokens (y por tanto, la relación que existe entre las palabras).</p>
<p>Antes de los transformers, para el problema de traducción se usaban las redes neuronales recurrentes, que consistían en redes a las que les entraba un token, lo procesaban y generaban otro token de salida. A continuación le entraba un segundo token, lo procesaban y sacaban otro token, y así sucesivamente con todos los tokens de la secuencia de entrada. El problema de estas redes es que cuando las frases eran muy largas, cuando se estaba en los últimos tokens, la red se "olvidaba" de los primeros tokens. Por ejemplo en frases muy largas, podría pasar que se cambiase el género del sujeto a lo largo de la frase traducida. Y esto es porque después de muchos tokens, la red se había olvidado si el sujeto era masculino o femenino.</p>
</section>
<section class="section-block-markdown-cell">
<p>Para solucionar esto, en el mecanismo de atención de los transformers entra la secuencia entera y de una sola vez se calculan las relaciones (atención) entre todos los tokens.</p>
<p>Esto es muy potente, ya que en un solo cálculo se obtiene la relación entre todos los tokens, sea lo larga que sea la secuencia.</p>
</section>
<section class="section-block-markdown-cell">
<p>Aunque esto es una gran ventaja y es lo que ha hecho que los transformers ahora se utilicen en la mayoría de las mejores redes modernas, también es su mayor desventaja, ya que el cálculo de la atención es muy costoso computacionalmente. Ya que requiere unas multiplicaciones matriciales muy grandes.</p>
<p>Esas multiplicaciones se realizan entre matrices que corresponden a los embeddings de cada uno de los tokens por ellas mismas. Es decir, la matriz que representa los embeddings de los tokens se multiplica por ella misma. Para poder realizar esta multiplicación hay que rotar una de las matrices (requisitos del álgebra para poder multiplicar matrices). Así que se multiplica una matriz por ella misma, si la secuencia de entrada tiene más tokens, las matrices que se multiplican son más grandes, una en alto y otra en ancho, por lo que la memoria necesaria para almacenar esas matrices crece de forma cuadrática.</p>
<p>Por lo tanto, a medida que aumenta la longitud de las secuencias, la cantidad de memoria necesaria para almacenar esas matrices crece de forma cuadrática. Y esto es un gran limitante a día de hoy, la cantidad de memoria que tienen las GPUs, que es donde se suelen realizar esas multiplicaciones.</p>
</section>
<section class="section-block-markdown-cell">
<p>En el encoder se usa una sola capa de atención para sacar las relaciones entre los tokens de entrada</p>
<p>En el decoder se utilizan dos capas de atención, una para sacar las relaciones entre los tokens de salida, y otra para sacar las relaciones entre los tokens del encoder y los del decoder.</p>
</section>
<section class="section-block-markdown-cell">
<h3 id="Feed forward">Feed forward<a class="anchor-link" href="#Feed forward">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Después de la capa de atención, la secuencia entra en una capa <code>Feed forward</code> que tiene dos propósitos</p>
<ul>
  <li>Uno es añadir no linealidades. Como hemos explicado, la atención se consigue mediante multiplicaciones matriciales de los tokens de las secuencias de entrada. Pero si a una red no se le aplican capas no lineales, al final, toda la arquitectura se podría resumir en unos pocos cálculos lineales. Por lo que las redes neuronales no podrían resolver problemas no lineales. De modo que se añade esta capa para añadir no linealidad</li>
</ul>
<ul>
  <li>Otro es la extracción de características. Aunque la atención ya extrae características, estas son características de las relaciones entre los tokens. Pero esta capa <code>Feed forward</code> se encarga de extraer características de los tokens en sí. Es decir, de cada token se extraen características que se consideran importantes para el problema que se está resolviendo.</li>
</ul>
</section>
<section class="section-block-markdown-cell">
<h2 id="Positional encoding">Positional encoding<a class="anchor-link" href="#Positional encoding">¶</a></h2>
</section>
<section class="section-block-markdown-cell">
<p>Hemos explicado que en la capa de atención se obtienen las relaciones entre los tokens, que esa relación se calcula mediante multiplicaciones matriciales y que esas multiplicaciones se realizan entre la matriz de embeddings por ella misma. Por lo que en las frases <code>El gato come pescado</code> y <code>El pescado come gato</code>, la relación entre <code>el</code> y <code>gato</code> es la misma en ambas frases, ya que la relación se calcula mediante multiplicaciones matriciales de los embeddings de <code>el</code> y <code>gato</code>.</p>
</section>
<section class="section-block-markdown-cell">
<p>Sin embargo, en la primera <code>el</code> se refiere a el <code>gato</code>, mientras que en la segunda <code>el</code> se refiere a el <code>pescado</code>. Por lo que además de las relaciones entre las palabras necesitamos tener algún mecanismo que nos indique su posición en la frase.</p>
</section>
<section class="section-block-markdown-cell">
<p>En el paper proponen meter un mecanismo de atención que se encarga de sumar unos valores a los vectores de embedding</p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/Transformer-positional-encoding.webp" alt="Transformer - positional encoding">
<p>Dónde la fórmula para calcular esos valores es</p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/Transformer-positional-encoding-formula.webp" alt="Transformer - positional encoding (formula)">
</section>
<section class="section-block-markdown-cell">
<p>Como esto así en frío es un poco difícil de entender, vamos a ver cómo sería una distribución de valores del <code>positional encoding</code></p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/Transformer-positional-encoding-diagram.webp" alt="Transformer - positional encoding (diagram)">
<p>Al primer token se le van a sumar los valores de la primera fila (la de más abajo), al segundo token los de la segunda fila, y así sucesivamente, lo que provocan un cambio en los embeddings como se ve en la figura. Visto en dos dimensiones se aprecian las ondas que se van sumando.</p>
<p>Estas ondas hacen que, cuando se realizan los cálculos de atención, las palabras más cercanas tengan más relación que las palabras más lejanas.</p>
</section>
<section class="section-block-markdown-cell">
<p>Pero podemos pensar una cosa, si el proceso de embedding consiste en crear un espacio vectorial en el que las palabras con el mismo significado semántico estén cerca, ¿no se estaría rompiendo esa relación si se suman valores a los embeddings?</p>
<p>Si nos fijamos de nuevo en el ejemplo de espacio vectorial de antes</p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/word_embedding_3_dimmension.webp" alt="word_embedding_3_dimmension">
<p>Podemos ver que los valores van más o menos de -1000 a 1000 en cada eje, mientras que la gráfica de distribución</p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/Transformer-positional-encoding-diagram.webp" alt="Transformer - positional encoding (diagram)">
<p>Los valores van de -1 a 1, ya que es el rango de las funciones seno y coseno.</p>
<p>Por lo tanto, estamos variando en un rango de entre -1 y 1 los valores de los embeddings que tienen dos o tres órdenes de magnitud más, por lo que la variación va a ser muy pequeña en comparación con el valor de los embeddings.</p>
<p>De modo que ya tenemos una manera de saber la relación de la posición de los tokens en la frase</p>
</section>
<section class="section-block-markdown-cell">
<h2 id="Add & Norm">Add & Norm<a class="anchor-link" href="#Add & Norm">¶</a></h2>
</section>
<section class="section-block-markdown-cell">
<p>Solo nos queda un bloque de alto nivel, y son las capas <code>Add &amp; Norm</code></p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/Transformer-Add-norm.webp" alt="Transformer - Add & norm">
<p>Estas son capas que se añaden después de cada capa de atención y de cada capa feed forward. Esta capa suma la salida y la entrada de una capa. A esto se llama conexiones residuales y tiene las siguientes ventajas</p>
<ul>
  <li>Durante el entrenamiento:</li>
</ul>
<ul>
  <li>Reducen el problema del desvanecimiento del gradiente: Cuando una red neuronal es muy grande, en el proceso de entrenamiento, los gradientes se van haciendo cada vez más pequeños según se profundizan en las capas. Esto hace que las capas más profundas no puedan actualizar bien sus pesos. Las conexiones residuales permiten el paso de los gradientes directamente a través de las capas, lo que ayuda a mantenerlos lo suficientemente grandes para que el modelo pueda seguir aprendiendo, incluso en las capas más profundas.</li>
</ul>
<ul>
  <li>Permiten el entrenamiento de redes más profundas: Al ayudar a mitigar el problema del desvanecimiento del gradiente, las conexiones residuales también facilitan el entrenamiento de redes más profundas, lo cual puede llevar a un mejor rendimiento.</li>
</ul>
<ul>
  <li>Durante la inferencia:</li>
</ul>
<ul>
  <li>Permiten la transmisión de información entre diferentes capas: Como las conexiones residuales permiten que la salida de cada capa se convierta en la suma de la entrada y la salida de la capa, la información de las capas más profundas se transmita a las capas de más alto nivel. Esto puede ser beneficioso en muchas tareas, especialmente en las que la información de bajo y alto nivel puede ser útil.</li>
</ul>
<ul>
  <li>Mejoran la robustez del modelo: Dado que las conexiones residuales permiten que las capas aprendan mejor en las capas más profundas, los modelos con conexiones residuales pueden ser más robustos a perturbaciones en los datos de entrada.</li>
</ul>
<ul>
  <li>Permiten la recuperación de información perdida: Si alguna información se pierde durante la transformación en alguna capa, las conexiones residuales pueden permitir que esta información sea recuperada en las capas posteriores.</li>
</ul>
</section>
<section class="section-block-markdown-cell">
<p>Esta capa se llama <code>Add &amp; Norm</code>, hemos visto el <code>Add</code>, veamos el <code>Norm</code>. La normalización se añade para que, al sumar la entrada y la salida, no se disparen los valores.</p>
</section>
<section class="section-block-markdown-cell">
<p>Ya hemos visto todas las capas de alto nivel del transformer</p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/transformer-scaled.webp" alt="transformer">
<p>Por lo que podemos entrar a ver la parte más importante y que le da nombre al paper, los mecanismos de atención.</p>
</section>
<section class="section-block-markdown-cell">
<h2 id="Mecanismos de atencion">Mecanismos de atención<a class="anchor-link" href="#Mecanismos de atencion">¶</a></h2>
</section>
<section class="section-block-markdown-cell">
<h3 id="Multi-head attention">Multi-head attention<a class="anchor-link" href="#Multi-head attention">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Antes de ver el verdadero mecanismo de atención, tenemos que ver el multi-head attention</p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/Transformer-multi-head-attention.webp" alt="Transformer - multi-head attention">
</section>
<section class="section-block-markdown-cell">
<p>Cuando hemos explicado las capas de alto nivel, hemos visto que en las capas de atención entraban 3 flechas, estas son <code>Q</code>, <code>K</code> y <code>V</code>. Son matrices que corresponden a la información de los tokens, en el caso del mecanismo de atención del encoder, corresponden a los tokens de la frase del idioma original, y en el caso de la capa de atención del decoder, corresponden a los tokens de la frase que se ha traducido hasta el momento y de la salida del encoder.</p>
<p>En realidad ahora nos da igual el origen de los tokens, solo quédate con la idea de que corresponden a tokens. Como hemos explicado los tokens se convierten a embeddings, por lo que <code>Q</code>, <code>K</code> y <code>V</code> son matrices de tamaño (<span class="math-inline">n<sub>tokens</sub></span> x <span class="math-inline">d<sub>model</sub></span>). Normalmente la dimensión del embedding (<span class="math-inline">d<sub>model</sub></span>) suele ser un número grande, como 512, 1024, 2048, etc (no tiene por qué ser una potencia de 2, son solo ejemplos).</p>
<p>Hemos explicado que los embeddings son representaciones vectoriales de los tokens. Es decir, los tokens se convierten a espacios vectoriales en los que las palabras con significado semántico similar están cerca.</p>
<p>Por tanto, de todas esas dimensiones, unas pueden estar relacionadas con características morfológicas, otras con características sintácticas, otras con características semánticas, etc. Por lo que tiene sentido que se calculen los mecanismos de atención entre dimensiones de los embeddings de características similares.</p>
<p>Recordemos que los mecanismos de atención buscan similitud entre palabras, por lo que tiene sentido que se busque similitud entre características semejantes.</p>
</section>
<section class="section-block-markdown-cell">
<p>Es por esto, que antes de calcular los mecanismos de atención se separan las dimensiones de los embeddings en grupos de características similares, y se calculan los mecanismos de atención entre esos grupos.</p>
</section>
<section class="section-block-markdown-cell">
<p>¿Y cómo se hace esta separación? Habria que buscar las dimensiones similares, pero hacer esto en un espacio de 512, 1024, 2048, etc dimensiones es muy complicado. Además que no se puede saber que características son similares y que en cada caso cambiaran las características que se consideran similares.</p>
</section>
<section class="section-block-markdown-cell">
<p>Por lo que se utilizan proyecciones lineales para separar las dimensiones en grupos. Es decir, se pasan los embeddings por capas lineales que los separan en grupos de características similares. De esta manera, durante el entrenamiento del transformer irán cambiando los pesos de las capas lineales hasta llegar a un punto en el que la agrupación se haga de una manera óptima.</p>
</section>
<section class="section-block-markdown-cell">
<p>Ahora podemos tener la duda de en cuántos grupos dividir. En el paper original se dividen en 8 grupos, pero no hay ninguna razón para que sean 8, supongo que probaron varios valores y este fue el que mejor les funcionó.</p>
</section>
<section class="section-block-markdown-cell">
<p>Una vez se han dividido los embeddings en grupos similares y se ha calculado la atención en los distintos grupos se concatenan los resultados. Esto es lógico, supongamos que tenemos un embedding de 512 dimensiones, y lo dividimos en 8 grupos de 64 dimensiones, si calculamos la atención en cada uno de los grupos, tendremos 8 matrices de atención de 64 dimensiones, si las concatenamos tendremos una matriz de atención de 512 dimensiones, que es la misma dimensión que teníamos al principio.</p>
</section>
<section class="section-block-markdown-cell">
<p>Pero la concatenación hace que todas las características estén juntas. Las primeras 64 dimensiones corresponden a una característica, las siguientes 64 a otra, y así sucesivamente. Así que para volver a mezclarlas se vuelve a pasar una capa lineal que mezcla todas las características. Y esa mezcla se va aprendiendo durante el entrenamiento.</p>
</section>
<section class="section-block-markdown-cell">
<h3 id="Scale dot product attention">Scale dot product attention<a class="anchor-link" href="#Scale dot product attention">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Llegamos a la parte más importante del transformer, el mecanismo de atención, el <code>scaled dot product attention</code></p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/Transformer-scaled-dot-product-attention.webp" alt="Transformer - scaled dot product attention">
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/Transformer-scaled-dot-product-attention-formula.webp" alt="Transformer - scaled dot product attention formula">
</section>
<section class="section-block-markdown-cell">
<p>Como hemos visto, en la arquitectura del Transformer hay tres mecanismos de atención</p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/transformer-scaled.webp" alt="transformer">
<p>El del encoder, el del decoder y el del encoder-decoder. Así que vamos a explicarlos por separado, porque aunque son casi iguales, tienen unas pequeñas diferencias</p>
</section>
<section class="section-block-markdown-cell">
<h4 id="Encoder scale dot product attention">Encoder scale dot product attention<a class="anchor-link" href="#Encoder scale dot product attention">¶</a></h4>
</section>
<section class="section-block-markdown-cell">
<p>Vamos a ver otra vez el diagrama de bloques y la fórmula</p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/Transformer-scaled-dot-product-attention.webp" alt="Transformer - scaled dot product attention">
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/Transformer-scaled-dot-product-attention-formula.webp" alt="Transformer - scaled dot product attention formula">
</section>
<section class="section-block-markdown-cell">
<p>Primero vamos a entender por qué entran tres flechas a las capas de atención. Si vemos la arquitectura del transformer, la entrada del encoder se divide en tres y entra a la capa de atención</p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/transformer-scaled.webp" alt="transformer">
<p>Por lo que <code>K</code>, <code>Q</code> y <code>V</code> son el resultado del embedding y el positional encoding. Se mete a la capa de atención la misma matriz tres veces. Tenemos que recordar que esa matriz consistía en una lista con todos los tokens (<span class="math-inline">n<sub>tokens</sub></span>), y cada token se convertía en un vector de embeddings de dimensión <span class="math-inline">d<sub>model</sub></span>, por lo que la dimensión de la matriz será (<span class="math-inline">n<sub>tokens</sub></span> x <span class="math-inline">d<sub>model</sub></span>).</p>
</section>
<section class="section-block-markdown-cell">
<p>El significado de <code>K</code>, <code>Q</code> y <code>V</code> proviene de las bases de datos <code>key</code>, <code>query</code> y <code>value</code>. Al mecanismo de atención se le pasan las matrices <code>Q</code> y <code>K</code>, es decir, se le pasa la pregunta y la clave, y a la salida se obtiene la matriz <code>V</code>, es decir, la respuesta.</p>
<p>Vamos a ver cada bloque por separado y entenderemos mejor esto</p>
</section>
<section class="section-block-markdown-cell">
<h5 id="Matmul">Matmul<a class="anchor-link" href="#Matmul">¶</a></h5>
</section>
<section class="section-block-markdown-cell">
<p>Este bloque corresponde a la multiplicación matricial de las matrices <code>Q</code> y <code>K</code>. Pero para poder realizar esta operación hay que hacerla con la matriz transpuesta de <code>K</code>. Ya que como las dos matrices tienen dimensión (<span class="math-inline">n<sub>tokens</sub></span> x <span class="math-inline">d<sub>model</sub></span>), para poder multiplicarlas, la matriz <code>K</code> tiene que estar traspuesta.</p>
<p>Por lo que tendremos una multiplicación de una matriz de dimensión (<span class="math-inline">n<sub>tokens</sub></span> x <span class="math-inline">d<sub>model</sub></span>) por otra matriz de dimensión (<span class="math-inline">d<sub>model</sub></span> x <span class="math-inline">n<sub>tokens</sub></span>), por lo que el resultado será una matriz de dimensión (<span class="math-inline">n<sub>tokens</sub></span> x <span class="math-inline">n<sub>tokens</sub></span>).</p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/Transformer-matmul.webp" alt="Transformer - matmul">
<p>Como podemos ver, el resultado es una matriz donde la diagonal es la multiplicación del embedding de cada token por sí mismo, y el resto de posiciones son las multiplicaciones entre los embeddings de cada token.</p>
</section>
<section class="section-block-markdown-cell">
<p>Ahora vamos a ver por qué se hace esta multiplicación. En en alterior post <a href="https://maximofn.com/embeddings-similarity/">Medida de similitud entre embeddings</a> vimos que una manera de obtener la similitud entre dos vectores de embeddings es mediante el cálculo del coseno</p>
<p>En la figura anterior se puede ver que la multiplicación entre las matrices <code>Q</code> y <code>K</code> corresponde a la multiplicación de los embeddings de cada token. La multiplicación entre dos vectores se realiza de la siguiente manera</p>
<p><span class="math-display">\mathbf&#123;U&#125; · \mathbf&#123;V&#125; = |\mathbf&#123;U&#125;| · |\mathbf&#123;V&#125;| \cos(&theta;)</span></p>
<p>Es decir, tenemos la multiplicación de las normas por su coseno. Si los vectores fuesen unitarios, es decir, que sus normas sean 1, la multiplicación de dos vectores sería igual al coseno entre ambos vectores, que es una de las medidas de similitud entre vectores.</p>
<p>Por lo tanto, como en cada posición de la matriz resultante tenemos la multiplicación entre los vectores de embeddings de cada token, en realidad, cada posición de la matriz representará la similitud entre cada token.</p>
<p>Recordemos lo que eran los embeddings, los embeddings eran representaciones vectoriales de los tokens en un espacio vectorial, donde los tokens con similitud semántica están cerca.</p>
<p>De modo que con esta multiplicación hemos obtenido una matriz de similitud entre los tokens de la frase</p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/Transformer-matmul-similarity-matrix.webp" alt="Transformer - matmul - similarity matrix">
<p>Los elementos de la diagonal tienen máxima similitud (verde), los de las esquinas tienen mínima similitud (rojo), y el resto de elementos tienen similitud intermedia.</p>
</section>
<section class="section-block-markdown-cell">
<h5 id="Scale">Scale<a class="anchor-link" href="#Scale">¶</a></h5>
</section>
<section class="section-block-markdown-cell">
<p>Volvemos a ver el diagrama del scaled dot product attention y su fórmula</p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/Transformer-scaled-dot-product-attention.webp" alt="Transformer - scaled dot product attention">
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/Transformer-scaled-dot-product-attention-formula.webp" alt="Transformer - scaled dot product attention formula">
</section>
<section class="section-block-markdown-cell">
<p>Habíamos dicho que si al multiplicar <code>Q</code> por <code>K</code> realizábamos la multiplicación entre los vectores de embeddings, y que si esos vectores tuviesen norma 1, el resultado sería la similitud entre los vectores. Pero como los vectores no tienen norma 1, el resultado puede tener valores muy altos, por lo que se normaliza dividiendo por la raíz cuadrada de la dimensión de los vectores de embeddings.</p>
</section>
<section class="section-block-markdown-cell">
<h5 id="Mask (opt)">Mask (opt)<a class="anchor-link" href="#Mask (opt)">¶</a></h5>
</section>
<section class="section-block-markdown-cell">
<p>El enmascaramiento es opcional y en el encoder no se usa, por lo que de momento no lo explicamos para no liar</p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/Transformer-scaled-dot-product-attention.webp" alt="Transformer - scaled dot product attention">
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/Transformer-scaled-dot-product-attention-formula.webp" alt="Transformer - scaled dot product attention formula">
</section>
<section class="section-block-markdown-cell">
<h5 id="Softmax">Softmax<a class="anchor-link" href="#Softmax">¶</a></h5>
</section>
<section class="section-block-markdown-cell">
<p>Aunque hemos dividido por la raíz cuadrada de la dimensión de los vectores de embeddings, nos vendría muy bien que la similitud entre los vectores de embeddings vaya entre los valores 0 y 1, así que para asegurarnos eso, pasamos por una capa softmax.</p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/Transformer-scaled-dot-product-attention.webp" alt="Transformer - scaled dot product attention">
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/Transformer-scaled-dot-product-attention-formula.webp" alt="Transformer - scaled dot product attention formula">
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/Transformer-matmul-similarity-matrix-softmax.webp" alt="Transformer - matmul - similarity matrix softmax">
</section>
<section class="section-block-markdown-cell">
<h5 id="Matmul">Matmul<a class="anchor-link" href="#Matmul">¶</a></h5>
</section>
<section class="section-block-markdown-cell">
<p>Ahora que tenemos una matriz de similitud entre los vectores de embeddings, vamos a multiplicarla por la matriz <code>V</code>, que representa los embeddings de los tokens.</p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/Transformer-matmul2.webp" alt="Transformer - matmul2">
</section>
<section class="section-block-markdown-cell">
<p>Haciendo la multiplicación obtenemos</p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/Transformer-matmul2-result.webp" alt="Transformer - matmul2 result">
</section>
<section class="section-block-markdown-cell">
<p>Obtenemos una matriz con una mezcla de los embeddings con su similitud. En cada fila obtenemos una mezcla de los embeddings, donde cada elemento del embedding está ponderado en función de la similitud del token de esa fila con el resto de tokens.</p>
<p>Además volvemos a tener una matriz de tamaño (<span class="math-inline">n<sub>tokens</sub></span> x <span class="math-inline">d<sub>model</sub></span>), que es la misma dimensión que teníamos al principio.</p>
</section>
<section class="section-block-markdown-cell">
<h5 id="Resumen">Resumen<a class="anchor-link" href="#Resumen">¶</a></h5>
</section>
<section class="section-block-markdown-cell">
<p>En resumen, podemos decir que el <code>scaled dot product attention</code> es un mecanismo que calcula la similitud entre los tokens de una frase, y a partir de esa similitud, calcula una matriz de salida que corresponde a una mezcla de embeddings ponderada en función de la similitud de los tokens.</p>
</section>
<section class="section-block-markdown-cell">
<h4 id="Decoder masked scale dot product attention">Decoder masked scale dot product attention<a class="anchor-link" href="#Decoder masked scale dot product attention">¶</a></h4>
</section>
<section class="section-block-markdown-cell">
<p>Volvemos a ver la arquitectura del transformer</p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/transformer-scaled.webp" alt="transformer">
</section>
<section class="section-block-markdown-cell">
<p>Como vemos en este caso el <code>scaled dot product attention</code> tiene la palabra <code>masked</code>. Primero vamos a explicar el porqué de la necesidad de este enmascaramiento, y después veremos cómo se hace.</p>
</section>
<section class="section-block-markdown-cell">
<h5 id="¿Por que enmascarar?">¿Por qué enmascarar?<a class="anchor-link" href="#¿Por que enmascarar?">¶</a></h5>
</section>
<section class="section-block-markdown-cell">
<p>Como hemos dicho el transformer se ideó inicialmente como un traductor, pero en general, es una arquitectura a la que le metes una secuencia y te saca otra secuencia. Pero a la hora del entrenamiento hay que darle la secuencia de entrada y la secuencia de salida, y a partir de ahí el transformer aprende a traducir.</p>
<p>Por otro lado hemos dicho que el transformer va generando un token nuevo cada vez. Es decir, se le pasa la secuencia de entrada en el encoder y un token especial de inicio de secuencia en el decoder, y a partir de ahí genera el primer token de la secuencia de salida.</p>
<p>A continuación se le vuelve a meter la secuencia de entrada en el encoder y el token que previamente había generado en el decoder, y a partir de ahí genera el segundo token de la secuencia de salida.</p>
<p>A continuación se le vuelve a meter la secuecia de entrada en el encoder y los dos tokens que previamente había generado en el decoder, y a partir de ahí genera el tercer token de la secuencia de salida.</p>
<p>Y así sucesivamente hasta que genera un token especial de fin de secuencia.</p>
<p>Pero en el entrenamiento, como se le mete la secuencia de entrada y de salida de golpe, necesitamos enmascarar los tokens que aún no ha generado para que no pueda verlos.</p>
</section>
<section class="section-block-markdown-cell">
<h5 id="Mask">Mask<a class="anchor-link" href="#Mask">¶</a></h5>
</section>
<section class="section-block-markdown-cell">
<p>Vamos a ver otra vez el diagrama de bloques y la fórmula</p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/Transformer-scaled-dot-product-attention.webp" alt="Transformer - scaled dot product attention">
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/Transformer-scaled-dot-product-attention-formula.webp" alt="Transformer - scaled dot product attention formula">
</section>
<section class="section-block-markdown-cell">
<p>El enmascaramiento se realiza después del <code>Scale</code> y antes de la <code>Softmax</code>. Como necesitamos enmascarar los tokens "futuros" lo que se puede hacer es multiplicar la matriz resultante del <code>Scale</code> por una matriz que tenga 0 en las posiciones que queremos enmascarar y 1 en las que no.</p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/Transformer-Mask.webp" alt="Transformer - Mask">
</section>
<section class="section-block-markdown-cell">
<p>Haciendo esto obtenemos la misma matriz que antes, pero con posiciones enmascaradas</p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/Transformer-Mask-resutl.webp" alt="Transformer - Mask resutl">
</section>
<section class="section-block-markdown-cell">
<p>Ahora el resultado del <code>Scaled dot product attention</code> es una matriz con los embeddings de los tokens ponderados en función de la similitud de los tokens, pero con los tokens que no se deberían ver enmascarados.</p>
</section>
<section class="section-block-markdown-cell">
<h4 id="Encoder-decoder scale dot product attention">Encoder-decoder scale dot product attention<a class="anchor-link" href="#Encoder-decoder scale dot product attention">¶</a></h4>
</section>
<section class="section-block-markdown-cell">
<p>Volvemos a ver la arquitectura del transformer</p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/transformer-scaled.webp" alt="transformer">
</section>
<section class="section-block-markdown-cell">
<p>Vemos ahora que al mecanismo de atención entran dos veces la salida del encoder y una vez la masked attention del decoder. Por lo que <code>K</code> y <code>V</code> son la salida del encoder, y <code>Q</code> es la salida del decoder.</p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/Transformer-scaled-dot-product-attention.webp" alt="Transformer - scaled dot product attention">
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/Transformer-scaled-dot-product-attention-formula.webp" alt="Transformer - scaled dot product attention formula">
</section>
<section class="section-block-markdown-cell">
<p>Por tanto en este bloque de atención, primero se calcula la similitud entre la sentencia del decoder y la sentencia del encoder, es decir, se calcula la similitud entre la frase que se ha traducido hasta el momento y la frase original.</p>
<p>A continuación se multiplica esta similitud por la sentencia del encoder, es decir, se obtiene una mezcla de los embeddings de la frase original ponderada en función de la similitud de la frase traducida hasta el momento.</p>
</section>
<section class="section-block-markdown-cell">
<h2 id="Resumen">Resumen<a class="anchor-link" href="#Resumen">¶</a></h2>
</section>
<section class="section-block-markdown-cell">
<p>Hemos recorrido el transformer desde el más alto nivel hasta el más bajo nivel, por lo que ya puedes tener una comprensión de cómo funciona.</p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/transformer-scaled.webp" alt="transformer">
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/Transformer-multi-head-attention.webp" alt="Transformer - multi-head attention">
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/Transformer-scaled-dot-product-attention.webp" alt="Transformer - scaled dot product attention">
</section>