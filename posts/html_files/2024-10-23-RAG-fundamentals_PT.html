<section class="section-block-markdown-cell">
<h1 id="RAG: Fundamentos e RAG ingenuo">RAG: Fundamentos e RAG ingênuo<a class="anchor-link" href="#RAG: Fundamentos e RAG ingenuo">¶</a></h1>
</section>
<section class="section-block-markdown-cell">
<blockquote>
<p>Aviso: Este post foi traduzido para o português usando um modelo de tradução automática. Por favor, me avise se encontrar algum erro.</p>
</blockquote>
</section>
<section class="section-block-markdown-cell">
<p>Neste post, vamos ver em que consiste a técnica de <code>RAG</code> (<code>Retrieval Augmented Generation</code>) e como ela pode ser implementada em um modelo de linguagem. Além disso, faremos isso com a arquitetura de RAG mais básica, chamada <code>naive RAG</code>.</p>
</section>
<section class="section-block-markdown-cell">
<p>Para que saia免费, em vez de usar uma conta da OpenAI (como você verá na maioria dos tutoriais), vamos usar o <code>API inference</code> do Hugging Face, que tem um free tier de 1000 requisições por dia, o que é mais do que suficiente para fazer este post.</p>
<p>(Note: There was a mistake in the translation. "免费" is Chinese for "free". The correct Portuguese word should be used instead.)</p>
<p>Here's the corrected version:</p>
<p>Para que saia grátis, em vez de usar uma conta da OpenAI (como você verá na maioria dos tutoriais), vamos usar o <code>API inference</code> do Hugging Face, que tem um free tier de 1000 requisições por dia, o que é mais do que suficiente para fazer este post.</p>
</section>
<section class="section-block-markdown-cell">
<h2 id="Configuração da API Inference do Hugging Face">Configuração da <code>API Inference</code> do Hugging Face<a class="anchor-link" href="#Configuração da API Inference do Hugging Face">¶</a></h2>
</section>
<section class="section-block-markdown-cell">
<p>Para poder usar a <code>API Inference</code> da HuggingFace, o primeiro que você precisa é ter uma conta na HuggingFace. Uma vez que você tenha, é necessário ir para <a href="https://huggingface.co/settings/keys">Access tokens</a> nas configurações do seu perfil e gerar um novo token.</p>
<p>Temos que dar um nome. No meu caso, vou chamá-lo de <code>rag-fundamentos</code> e ativar a permissão <code>Make calls to serverless Inference API</code>. Isso criará um token que teremos que copiar.</p>
</section>
<section class="section-block-markdown-cell">
<p>Para gerenciar o token, vamos a criar um arquivo no mesmo caminho em que estamos trabalhando chamado ".env" e vamos colocar o token que copiamos no arquivo da seguinte maneira:</p>
<div class='highlight'><pre><code class="language-bash">RAG_FUNDAMENTOS_TÉCNICAS_AVANÇADAS_TOKEN="hf_...."
</code></pre></div>
</section>
<section class="section-block-markdown-cell">
<p>Agora, para poder obter o token, precisamos ter instalado <code>dotenv</code>, que instalamos através de</p>
<div class='highlight'><pre><code class="language-bash">pip install python-dotenv
</code></pre></div>
<p>E executamos o seguinte</p>
</section>
<section class="section-block-code-cell-">
<div class="input-code">
<div class="highlight hl-ipython3"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">dotenv</span>
<span class="w"> </span>
<span class="n">dotenv</span><span class="o">.</span><span class="n">load_dotenv</span><span class="p">()</span>
<span class="w"> </span>
<span class="n">RAG_FUNDAMENTALS_ADVANCE_TECHNIQUES_TOKEN</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s2">&quot;RAG_FUNDAMENTALS_ADVANCE_TECHNIQUES_TOKEN&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section class="section-block-markdown-cell">
<p>Agora que temos um token, criamos um cliente. Para isso, precisamos ter a biblioteca <code>huggingface_hub</code> instalada. A instalamos através do conda ou pip.</p>
<div class='highlight'><pre><code class="language-bash">conda install -c conda-forge huggingface_hub
</code></pre></div>
<p>o</p>
<div class='highlight'><pre><code class="language-bash">pip install --upgrade huggingface_hub
</code></pre></div>
</section>
<section class="section-block-markdown-cell">
<p>Agora temos que escolher qual modelo vamos usar. Você pode ver os modelos disponíveis na página de <a href="https://huggingface.co/docs/api-inference/supported-models">Supported models</a> da documentação da <code>API Inference</code> do Hugging Face.</p>
<p>Como na hora de escrever o post, o melhor disponível é <code>Qwen2.5-72B-Instruct</code>, vamos usar esse modelo.</p>
</section>
<section class="section-block-code-cell-">
<div class="input-code">
<div class="highlight hl-ipython3"><pre><span></span><span class="n">MODEL</span> <span class="o">=</span> <span class="s2">&quot;Qwen/Qwen2.5-72B-Instruct&quot;</span>
</pre></div>
</div>
</section>
<section class="section-block-markdown-cell">
<p>Agora podemos criar o cliente</p>
</section>
<section class="section-block-code-cell-">
<div class="input-code">
<div class="highlight hl-ipython3"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">huggingface_hub</span><span class="w"> </span><span class="kn">import</span> <span class="n">InferenceClient</span>
<span class="w"> </span>
<span class="n">client</span> <span class="o">=</span> <span class="n">InferenceClient</span><span class="p">(</span><span class="n">api_key</span><span class="o">=</span><span class="n">RAG_FUNDAMENTALS_ADVANCE_TECHNIQUES_TOKEN</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">MODEL</span><span class="p">)</span>
<span class="n">client</span>
</pre></div>
</div>
</section>
<section class="section-block-code-cell-">
<div class="output-wrapper">
<div class="output-area">
<div class="prompt"></div>
<div class="output-subarea-output-stream-output-stdout-output-text">
<pre>&amp;lt;InferenceClient(model=&#x27;Qwen/Qwen2.5-72B-Instruct&#x27;, timeout=None)&amp;gt;
</pre>
</div>
</div>
</div>
</section>
<section class="section-block-markdown-cell">
<p>Fazemos um teste para ver se funciona</p>
</section>
<section class="section-block-code-cell-">
<div class="input-code">
<div class="highlight hl-ipython3"><pre><span></span><span class="n">message</span> <span class="o">=</span> <span class="p">[</span>
<span class="w">	</span><span class="p">{</span> <span class="s2">&quot;role&quot;</span><span class="p">:</span> <span class="s2">&quot;user&quot;</span><span class="p">,</span> <span class="s2">&quot;content&quot;</span><span class="p">:</span> <span class="s2">&quot;Hola, qué tal?&quot;</span> <span class="p">}</span>
<span class="p">]</span>
<span class="w"> </span>
<span class="n">stream</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">chat</span><span class="o">.</span><span class="n">completions</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
<span class="w">	</span><span class="n">messages</span><span class="o">=</span><span class="n">message</span><span class="p">,</span> 
<span class="w">	</span><span class="n">temperature</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
<span class="w">	</span><span class="n">max_tokens</span><span class="o">=</span><span class="mi">1024</span><span class="p">,</span>
<span class="w">	</span><span class="n">top_p</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span>
<span class="w">	</span><span class="n">stream</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
<span class="w"> </span>
<span class="n">response</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">choices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">message</span><span class="o">.</span><span class="n">content</span>
<span class="nb">print</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section class="section-block-code-cell-">
<div class="output-wrapper">
<div class="output-area">
<div class="prompt"></div>
<div class="output-subarea-output-stream-output-stdout-output-text">
<pre>¡Hola! Estoy bien, gracias por preguntar. ¿Cómo estás tú? ¿En qué puedo ayudarte hoy?
</pre>
</div>
</div>
</div>
</section>
<section class="section-block-markdown-cell">
<h2 id="O que é RAG?">O que é <code>RAG</code>?<a class="anchor-link" href="#O que é RAG?">¶</a></h2>
</section>
<section class="section-block-markdown-cell">
<p><code>RAG</code> são as siglas de <code>Retrieval Augmented Generation</code>, é uma técnica criada para obter informações de documentos. Embora os LLMs possam ser muito poderosos e ter muito conhecimento, nunca serão capazes de responder sobre documentos privados, como relatórios da sua empresa, documentação interna, etc. Por isso foi criado o <code>RAG</code>, para poder usar esses LLMs nessa documentação privada.</p>
<img src="https://images.maximofn.com/RAG.webp" alt="O que é RAG?">
</section>
<section class="section-block-markdown-cell">
<p>A ideia consiste em um usuário fazer uma pergunta sobre essa documentação privada, o sistema é capaz de obter a parte da documentação onde está a resposta para essa pergunta, passa-se ao LLM a pergunta e a parte da documentação e o LLM gera a resposta para o usuário.</p>
</section>
<section class="section-block-markdown-cell">
<h3 id="Como a informacao e armazenada?">Como a informação é armazenada?<a class="anchor-link" href="#Como a informacao e armazenada?">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>É sabido, e se você não sabia, vou te contar agora, que os LLMs têm um limite de informação que podem receber, a isso se chama janela de contexto. Isso é devido às arquiteturas internas dos LLMs que, no momento, não vêm ao caso. Mas o importante é que não se pode passar um documento e uma pergunta assim, porque é provável que o LLM não seja capaz de processar toda essa informação.</p>
<p>Nos casos em que se passa mais informação do que o contexto da sua janela permite, geralmente acontece que o LLM não presta atenção ao final da entrada. Imagine que você pergunte ao LLM algo sobre seu documento, e essa informação esteja no final do documento e o LLM não a leia.</p>
<p>Por isso, o que se faz é dividir a documentação em blocos chamados <code>chunk</code>s. Dessa forma, a documentação é armazenada em um monte de <code>chunk</code>s, que são pedaços dessa documentação. Assim, quando o usuário faz uma pergunta, o <code>chunk</code> no qual está a resposta para essa pergunta é passado ao LLM.</p>
<p>Além de dividir a documentação em <code>chunk</code>s, esses são convertidos em embeddings, que são representações numéricas dos <code>chunk</code>s. Isso é feito porque os LLMs na verdade não entendem texto, mas sim números, e os <code>chunk</code>s são convertidos em números para que o LLM possa entendê-los. Se quiser entender mais sobre os embeddings, você pode ler meu post sobre <a href="https://www.maximofn.com/transformers">transformers</a> no qual explico como funcionam os transformers, que é a arquitetura por trás dos LLMs. Você também pode ler meu post sobre <a href="https://www.maximofn.com/chromadb">ChromaDB</a> onde explico como os embeddings são armazenados em um banco de dados vetorial. E seria interessante você ler meu post sobre a biblioteca <a href="https://www.maximofn.com/hugging-face-tokenizers">HuggingFace Tokenizers</a> na qual se explica como o texto é tokenizado, que é o passo anterior à geração dos embeddings.</p>
<img src="https://images.maximofn.com/RAG-embeddings.webp" alt="RAG - embeddings">
</section>
<section class="section-block-markdown-cell">
<h3 id="Como obter o chunk correto?">Como obter o <code>chunk</code> correto?<a class="anchor-link" href="#Como obter o chunk correto?">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Dissemos que a documentação é dividida em <code>chunk</code>s e o <code>chunk</code> no qual está a resposta à pergunta do usuário é passado para o LLM. Mas, como se sabe em qual <code>chunk</code> está a resposta? Para isso, convertemos a pergunta do usuário em um embedding e calculamos a similaridade entre o embedding da pergunta e os embeddings dos <code>chunk</code>s. Dessa forma, o <code>chunk</code> com maior similaridade é o que é passado para o LLM.</p>
<img src="https://images.maximofn.com/rag-chunk_retreival.webp" alt="">
</section>
<section class="section-block-markdown-cell">
<h3 id="Vamos revisar o que é RAG">Vamos revisar o que é <code>RAG</code><a class="anchor-link" href="#Vamos revisar o que é RAG">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>De um lado temos o <code>retrieval</code>, que é obter o <code>chunk</code> correto da documentação, do outro lado temos o <code>augmented</code>, que é passar para o LLM a pergunta do usuário e o <code>chunk</code>, e por último temos o <code>generation</code>, que é obter a resposta gerada pelo LLM.</p>
</section>
<section class="section-block-markdown-cell">
<h2 id="Base de dados vetorial">Base de dados vetorial<a class="anchor-link" href="#Base de dados vetorial">¶</a></h2>
</section>
<section class="section-block-markdown-cell">
<p>Vimos que a documentação se divide em <code>chunk</code>s e é armazenada em um banco de dados vetorial, portanto precisamos usar um. Para este post, vou usar <a href="https://www.trychroma.com/">ChromaDB</a>, que é um banco de dados vetorial bastante usado e, além disso, tenho um <a href="https://www.maximofn.com/chromadb">post</a> no qual explico como ele funciona.</p>
</section>
<section class="section-block-markdown-cell">
<p>Então primeiro precisamos instalar a biblioteca do ChromaDB, para isso a instalamos com Conda ou com pip</p>
<div class='highlight'><pre><code class="language-bash">conda install conda-forge::chromadb
</code></pre></div>
<p>o</p>
<div class='highlight'><pre><code class="language-bash">pip install chromadb
</code></pre></div>
</section>
<section class="section-block-markdown-cell">
<h3 id="Funcao de embedding">Função de embedding<a class="anchor-link" href="#Funcao de embedding">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Como dissemos, tudo vai se basear em embeddings. Portanto, o primeiro passo é criar uma função para obter embeddings de um texto. Vamos usar o modelo <code>sentence-transformers/all-MiniLM-L6-v2</code>.</p>
</section>
<section class="section-block-code-cell-">
<div class="input-code">
<div class="highlight hl-ipython3"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">chromadb.utils.embedding_functions</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">embedding_functions</span>
<span class="w"> </span>
<span class="n">EMBEDDING_MODEL</span> <span class="o">=</span> <span class="s2">&quot;sentence-transformers/all-MiniLM-L6-v2&quot;</span>
<span class="w">      </span>
<span class="n">huggingface_ef</span> <span class="o">=</span> <span class="n">embedding_functions</span><span class="o">.</span><span class="n">HuggingFaceEmbeddingFunction</span><span class="p">(</span>
<span class="w">    </span><span class="n">api_key</span><span class="o">=</span><span class="n">RAG_FUNDAMENTALS_ADVANCE_TECHNIQUES_TOKEN</span><span class="p">,</span>
<span class="w">    </span><span class="n">model_name</span><span class="o">=</span><span class="n">EMBEDDING_MODEL</span>
<span class="p">)</span>
</pre></div>
</div>
</section>
<section class="section-block-markdown-cell">
<p>Testamos a função de embedding</p>
</section>
<section class="section-block-code-cell-">
<div class="input-code">
<div class="highlight hl-ipython3"><pre><span></span><span class="n">embedding</span> <span class="o">=</span> <span class="n">huggingface_ef</span><span class="p">([</span><span class="s2">&quot;Hello, how are you?&quot;</span><span class="p">,])</span>
<span class="n">embedding</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
</pre></div>
</div>
</section>
<section class="section-block-code-cell-">
<div class="output-wrapper">
<div class="output-area">
<div class="prompt"></div>
<div class="output-subarea-output-stream-output-stdout-output-text">
<pre>(384,)
</pre>
</div>
</div>
</div>
</section>
<section class="section-block-markdown-cell">
<p>Obtemos um embedding de dimensão 384. Embora a missão deste post não seja explicar os embeddings, em resumo, nossa função de embedding categorizou a frase <code>Hello, how are you?</code> em um espaço de 384 dimensões.</p>
</section>
<section class="section-block-markdown-cell">
<h3 id="Cliente ChromaDB">Cliente ChromaDB<a class="anchor-link" href="#Cliente ChromaDB">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Agora que temos nossa função de embedding, podemos criar um cliente de ChromaDB.</p>
</section>
<section class="section-block-markdown-cell">
<p>Primeiro criamos uma pasta onde será salva a base de dados vetorial</p>
</section>
<section class="section-block-code-cell-">
<div class="input-code">
<div class="highlight hl-ipython3"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">pathlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Path</span>
<span class="w">      </span>
<span class="n">chroma_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;chromadb_persisten_storage&quot;</span><span class="p">)</span>
<span class="n">chroma_path</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section class="section-block-markdown-cell">
<p>Agora criamos o cliente</p>
</section>
<section class="section-block-code-cell-">
<div class="input-code">
<div class="highlight hl-ipython3"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">chromadb</span><span class="w"> </span><span class="kn">import</span> <span class="n">PersistentClient</span>
<span class="w"> </span>
<span class="n">chroma_client</span> <span class="o">=</span> <span class="n">PersistentClient</span><span class="p">(</span><span class="n">path</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">chroma_path</span><span class="p">))</span>
</pre></div>
</div>
</section>
<section class="section-block-markdown-cell">
<h3 id="Colecao">Coleção<a class="anchor-link" href="#Colecao">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Quando temos o cliente do ChromaDB, a próxima coisa que precisamos fazer é criar uma coleção. Uma coleção é um conjunto de vetores, no nosso caso os <code>chunks</code> da documentação.</p>
</section>
<section class="section-block-markdown-cell">
<p>O criamos indicando a função de embedding que vamos usar</p>
</section>
<section class="section-block-code-cell-">
<div class="input-code">
<div class="highlight hl-ipython3"><pre><span></span><span class="n">collection_name</span> <span class="o">=</span> <span class="s2">&quot;document_qa_collection&quot;</span>
<span class="n">collection</span> <span class="o">=</span> <span class="n">chroma_client</span><span class="o">.</span><span class="n">get_or_create_collection</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">collection_name</span><span class="p">,</span> <span class="n">embedding_function</span><span class="o">=</span><span class="n">huggingface_ef</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section class="section-block-markdown-cell">
<h2 id="Carregamento de documentos">Carregamento de documentos<a class="anchor-link" href="#Carregamento de documentos">¶</a></h2>
</section>
<section class="section-block-markdown-cell">
<p>Agora que criamos a base de dados vetorial, temos que dividir a documentação em <code>chunks</code> e salvá-los na base de dados vetorial.</p>
</section>
<section class="section-block-markdown-cell">
<h3 id="Funcao de carregamento de documentos">Função de carregamento de documentos<a class="anchor-link" href="#Funcao de carregamento de documentos">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Primeiro criamos uma função para carregar todos os documentos <code>.txt</code> de um diretório</p>
</section>
<section class="section-block-code-cell-">
<div class="input-code">
<div class="highlight hl-ipython3"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">load_one_document_from_directory</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span> <span class="n">file</span><span class="p">):</span>
<span class="w">    </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span> <span class="n">file</span><span class="p">),</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="w">        </span><span class="k">return</span> <span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="n">file</span><span class="p">,</span> <span class="s2">&quot;text&quot;</span><span class="p">:</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()}</span>
<span class="w"> </span>
<span class="k">def</span><span class="w"> </span><span class="nf">load_documents_from_directory</span><span class="p">(</span><span class="n">directory</span><span class="p">):</span>
<span class="w">    </span><span class="n">documents</span> <span class="o">=</span> <span class="p">[]</span>
<span class="w">    </span><span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">directory</span><span class="p">):</span>
<span class="w">        </span><span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.txt&quot;</span><span class="p">):</span>
<span class="w">            </span><span class="n">documents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">load_one_document_from_directory</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span> <span class="n">file</span><span class="p">))</span>
<span class="w">    </span><span class="k">return</span> <span class="n">documents</span>
</pre></div>
</div>
</section>
<section class="section-block-markdown-cell">
<h3 id="Função para dividir a documentação em chunks">Função para dividir a documentação em <code>chunk</code>s<a class="anchor-link" href="#Função para dividir a documentação em chunks">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Uma vez que temos os documentos, os dividimos em <code>chunks</code></p>
</section>
<section class="section-block-code-cell-">
<div class="input-code">
<div class="highlight hl-ipython3"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">split_text</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">chunk_size</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">chunk_overlap</span><span class="o">=</span><span class="mi">20</span><span class="p">):</span>
<span class="w">    </span><span class="n">chunks</span> <span class="o">=</span> <span class="p">[]</span>
<span class="w">    </span><span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
<span class="w">    </span><span class="k">while</span> <span class="n">start</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
<span class="w">        </span><span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">chunk_size</span>
<span class="w">        </span><span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">])</span>
<span class="w">        </span><span class="n">start</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">chunk_overlap</span>
<span class="w">    </span><span class="k">return</span> <span class="n">chunks</span>
</pre></div>
</div>
</section>
<section class="section-block-markdown-cell">
<h3 id="Função para gerar embeddings de um chunk">Função para gerar embeddings de um <code>chunk</code><a class="anchor-link" href="#Função para gerar embeddings de um chunk">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Agora que temos os <code>chunk</code>s, geramos os <code>embedding</code>s de cada um deles.</p>
</section>
<section class="section-block-markdown-cell">
<p>Mais tarde veremos por que, mas para gerar os embeddings vamos fazer isso localmente e não através da API do Hugging Face. Para isso, precisamos ter instalado <a href="https://pytorch.org">PyTorch</a> e <code>sentence-transformers</code>, para isso fazemos</p>
<div class='highlight'><pre><code class="language-bash">pip install -U sentence-transformers
</code></pre></div>
</section>
<section class="section-block-code-cell-">
<div class="input-code">
<div class="highlight hl-ipython3"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">sentence_transformers</span><span class="w"> </span><span class="kn">import</span> <span class="n">SentenceTransformer</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="w"> </span>
<span class="n">device</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">&quot;cuda&quot;</span> <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">()</span> <span class="k">else</span> <span class="s2">&quot;cpu&quot;</span><span class="p">)</span>
<span class="w"> </span>
<span class="n">embedding_model</span> <span class="o">=</span> <span class="n">SentenceTransformer</span><span class="p">(</span><span class="n">EMBEDDING_MODEL</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
<span class="w"> </span>
<span class="k">def</span><span class="w"> </span><span class="nf">get_embeddings</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
<span class="w">    </span><span class="k">try</span><span class="p">:</span>
<span class="w">        </span><span class="n">embedding</span> <span class="o">=</span> <span class="n">embedding_model</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span> <span class="n">embedding</span>
<span class="w">    </span><span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
<span class="w">        </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section class="section-block-markdown-cell">
<p>Vamos testar agora essa função de embeddings localmente</p>
</section>
<section class="section-block-code-cell-">
<div class="input-code">
<div class="highlight hl-ipython3"><pre><span></span><span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;Hello, how are you?&quot;</span>
<span class="n">embedding</span> <span class="o">=</span> <span class="n">get_embeddings</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
<span class="n">embedding</span><span class="o">.</span><span class="n">shape</span>
</pre></div>
</div>
</section>
<section class="section-block-code-cell-">
<div class="output-wrapper">
<div class="output-area">
<div class="prompt"></div>
<div class="output-subarea-output-stream-output-stdout-output-text">
<pre>(384,)
</pre>
</div>
</div>
</div>
</section>
<section class="section-block-markdown-cell">
<p>Vemos que obtemos um embedding da mesma dimensão que quando o fazíamos com a API do Hugging Face</p>
</section>
<section class="section-block-markdown-cell">
<p>O modelo <code>sentence-transformers/all-MiniLM-L6-v2</code> tem apenas 22M de parâmetros, portanto você será capaz de executá-lo em qualquer GPU. Mesmo se não tiver GPU, você ainda poderá executá-lo em uma CPU.</p>
</section>
<section class="section-block-markdown-cell">
<p>O LLM que vamos a usar para gerar as respostas, que é o <code>Qwen2.5-72B-Instruct</code>, como seu nome indica, é um modelo de 72B de parâmetros, por isso este modelo não pode ser executado em qualquer GPU e em uma CPU seria impensável devido à lentidão. Por isso, este LLM sim o usaremos através da API, mas na hora de gerar os <code>embedding</code>s podemos fazer localmente sem problema.</p>
</section>
<section class="section-block-markdown-cell">
<h3 id="Documentos com os quais vamos testar">Documentos com os quais vamos testar<a class="anchor-link" href="#Documentos com os quais vamos testar">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Para fazer todas essas verificações, baixei o conjunto de dados <a href="https://www.kaggle.com/datasets/harshsinghal/aws-case-studies-and-blogs">aws-case-studies-and-blogs</a> e o coloquei na pasta <code>rag-txt_dataset</code>. Com os seguintes comandos, explico como baixá-lo e descompactá-lo.</p>
</section>
<section class="section-block-markdown-cell">
<p>Criamos a pasta onde vamos baixar os documentos</p>
</section>
<section class="section-block-code-cell-">
<div class="input-code">
<div class="highlight hl-ipython3"><pre><span></span><span class="err">!</span><span class="n">mkdir</span> <span class="n">rag_txt_dataset</span>
</pre></div>
</div>
</section>
<section class="section-block-markdown-cell">
<p>Baixamos o <code>.zip</code> com os documentos</p>
</section>
<section class="section-block-code-cell-">
<div class="input-code">
<div class="highlight hl-ipython3"><pre><span></span><span class="err">!</span><span class="n">curl</span> <span class="o">-</span><span class="n">L</span> <span class="o">-</span><span class="n">o</span> <span class="o">./</span><span class="n">rag_txt_dataset</span><span class="o">/</span><span class="n">archive</span><span class="o">.</span><span class="n">zip</span> <span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">www</span><span class="o">.</span><span class="n">kaggle</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">api</span><span class="o">/</span><span class="n">v1</span><span class="o">/</span><span class="n">datasets</span><span class="o">/</span><span class="n">download</span><span class="o">/</span><span class="n">harshsinghal</span><span class="o">/</span><span class="n">aws</span><span class="o">-</span><span class="n">case</span><span class="o">-</span><span class="n">studies</span><span class="o">-</span><span class="ow">and</span><span class="o">-</span><span class="n">blogs</span>
</pre></div>
</div>
</section>
<section class="section-block-code-cell-">
<div class="output-wrapper">
<div class="output-area">
<div class="prompt"></div>
<div class="output-subarea-output-stream-output-stdout-output-text">
<pre>&#x20;&#x20;% Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;Dload  Upload   Total   Spent    Left  Speed
&#x20;&#x20;0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0
100 1430k  100 1430k    0     0  1082k      0  0:00:01  0:00:01 --:--:-- 2440k
</pre>
</div>
</div>
</div>
</section>
<section class="section-block-markdown-cell">
<p>Descompactamos o .zip</p>
</section>
<section class="section-block-code-cell-">
<div class="input-code">
<div class="highlight hl-ipython3"><pre><span></span><span class="err">!</span><span class="n">unzip</span> <span class="n">rag_txt_dataset</span><span class="o">/</span><span class="n">archive</span><span class="o">.</span><span class="n">zip</span> <span class="o">-</span><span class="n">d</span> <span class="n">rag_txt_dataset</span>
</pre></div>
</div>
</section>
<section class="section-block-code-cell-">
<div class="output-wrapper">
<div class="output-area">
<div class="prompt"></div>
<div class="output-subarea-output-stream-output-stdout-output-text">
<pre>Archive:  rag_txt_dataset/archive.zip
&#x20;&#x20;inflating: rag_txt_dataset/23andMe Case Study _ Life Sciences _ AWS.txt  
&#x20;&#x20;inflating: rag_txt_dataset/36 new or updated datasets on the Registry of Open Data_ AI analysis-ready datasets and more _ AWS Public Sector Blog.txt  
&#x20;&#x20;inflating: rag_txt_dataset/54gene _ Case Study _ AWS.txt  
&#x20;&#x20;inflating: rag_txt_dataset/6sense Case Study.txt  
&#x20;&#x20;inflating: rag_txt_dataset/ADP Developed an Innovative and Secure Digital Wallet in a Few Months Using AWS Services _ Case Study _ AWS.txt  
&#x20;&#x20;inflating: rag_txt_dataset/AEON Case Study.txt  
&#x20;&#x20;inflating: rag_txt_dataset/ALTBalaji _ Amazon Web Services.txt  
&#x20;&#x20;inflating: rag_txt_dataset/AWS Case Study - Ineos Team UK.txt  
&#x20;&#x20;inflating: rag_txt_dataset/AWS Case Study - StreamAMG.txt  
&#x20;&#x20;inflating: rag_txt_dataset/AWS Case Study_ Creditsafe.txt  
&#x20;&#x20;inflating: rag_txt_dataset/AWS Case Study_ Immowelt.txt  
&#x20;&#x20;inflating: rag_txt_dataset/AWS Customer Case Study _ Kepler Provides Effective Monitoring of Elderly Care Home Residents Using AWS _ AWS.txt  
&#x20;&#x20;inflating: rag_txt_dataset/AWS announces 21 startups selected for the AWS generative AI accelerator _ AWS Startups Blog.txt  
&#x20;&#x20;inflating: rag_txt_dataset/AWS releases smart meter data analytics _ AWS for Industries.txt  
&#x20;&#x20;inflating: rag_txt_dataset/Accelerate Time to Business Value Using Amazon SageMaker at Scale with NatWest Group _ Case Study _ AWS.txt  
&#x20;&#x20;inflating: rag_txt_dataset/Accelerate Your Analytics Journey on AWS with DXC Analytics and AI Platform _ AWS Partner Network (APN) Blog.txt  
&#x20;&#x20;...
&#x20;&#x20;inflating: rag_txt_dataset/Zomato Saves Big by Using AWS Graviton2 to Power Data-Driven Business Insights.txt  
&#x20;&#x20;inflating: rag_txt_dataset/Zoox Case Study _ Automotive _ AWS.txt  
&#x20;&#x20;inflating: rag_txt_dataset/e-banner Streamlines Its Contact Center Operations and Facilitates a Fully Remote Workforce with Amazon Connect _ e-banner Case Study _ AWS.txt  
&#x20;&#x20;inflating: rag_txt_dataset/iptiQ Case Study.txt  
&#x20;&#x20;inflating: rag_txt_dataset/mod.io Provides Low Latency Gamer Experience Globally on AWS _ Case Study _ AWS.txt  
&#x20;&#x20;inflating: rag_txt_dataset/myposter Case Study.txt
</pre>
</div>
</div>
</div>
</section>
<section class="section-block-markdown-cell">
<p>Apagamos o .zip</p>
</section>
<section class="section-block-code-cell-">
<div class="input-code">
<div class="highlight hl-ipython3"><pre><span></span><span class="err">!</span><span class="n">rm</span> <span class="n">rag_txt_dataset</span><span class="o">/</span><span class="n">archive</span><span class="o">.</span><span class="n">zip</span>
</pre></div>
</div>
</section>
<section class="section-block-markdown-cell">
<p>Vamos ver o que ficou.</p>
</section>
<section class="section-block-code-cell-">
<div class="input-code">
<div class="highlight hl-ipython3"><pre><span></span><span class="err">!</span><span class="n">ls</span> <span class="n">rag_txt_dataset</span>
</pre></div>
</div>
</section>
<section class="section-block-code-cell-">
<div class="output-wrapper">
<div class="output-area">
<div class="prompt-output-prompt">Out[]:</div>
<div class="output-text-output-subareaoutput_execute_result">
<pre>&#x27;23andMe Case Study _ Life Sciences _ AWS.txt&#x27;
&#x27;36 new or updated datasets on the Registry of Open Data_ AI analysis-ready datasets and more _ AWS Public Sector Blog.txt&#x27;
&#x27;54gene _ Case Study _ AWS.txt&#x27;
&#x27;6sense Case Study.txt&#x27;
&#x27;Accelerate Time to Business Value Using Amazon SageMaker at Scale with NatWest Group _ Case Study _ AWS.txt&#x27;
&#x27;Accelerate Your Analytics Journey on AWS with DXC Analytics and AI Platform _ AWS Partner Network (APN) Blog.txt&#x27;
&#x27;Accelerating customer onboarding using Amazon Connect _ NCS Case Study _ AWS.txt&#x27;
&#x27;Accelerating Migration at Scale Using AWS Application Migration Service with 3M Company _ Case Study _ AWS.txt&#x27;
&#x27;Accelerating Time to Market Using AWS and AWS Partner AccelByte _ Omeda Studios Case Study _ AWS.txt&#x27;
&#x27;Achieving Burstable Scalability and Consistent Uptime Using AWS Lambda with TiVo _ Case Study _ AWS.txt&#x27;
&#x27;Acrobits Uses Amazon Chime SDK to Easily Create Video Conferencing Application Boosting Collaboration for Global Users _ Acrobits Case Study _ AWS.txt&#x27;
&#x27;Actuate AI Case study.txt&#x27;
&#x27;ADP Developed an Innovative and Secure Digital Wallet in a Few Months Using AWS Services _ Case Study _ AWS.txt&#x27;
&#x27;Adzuna doubles its email open rates using Amazon SES _ Adzuna Case Study _ AWS.txt&#x27;
&#x27;AEON Case Study.txt&#x27;
&#x27;ALTBalaji _ Amazon Web Services.txt&#x27;
&#x27;Amanotes Stays on Beat by Delivering Simple Music Games to Millions Worldwide on AWS.txt&#x27;
&#x27;Amazon OpenSearch Services vector database capabilities explained _ AWS Big Data Blog.txt&#x27;
&#x27;Anghami Case Study.txt&#x27;
&#x27;Announcing enhanced table extractions with Amazon Textract _ AWS Machine Learning Blog.txt&#x27;
...
&#x27;What Will Generative AI Mean for Your Business_ _ AWS Cloud Enterprise Strategy Blog.txt&#x27;
&#x27;Which Recurring Business Processes Can Small and Medium Businesses Automate_ _ AWS Smart Business Blog.txt&#x27;
 Windsor.txt
&#x27;Wireless Car Case Study _ AWS IoT Core _ AWS.txt&#x27;
&#x27;Yamato Logistics (HK) case study.txt&#x27;
&#x27;Zomato Saves Big by Using AWS Graviton2 to Power Data-Driven Business Insights.txt&#x27;
&#x27;Zoox Case Study _ Automotive _ AWS.txt&#x27;</pre>
</div>
</div>
</div>
</section>
<section class="section-block-markdown-cell">
<p>A criar os <code>chunk</code>s!</p>
</section>
<section class="section-block-markdown-cell">
<p>Listamos os documentos com a função que havíamos criado</p>
</section>
<section class="section-block-code-cell-">
<div class="input-code">
<div class="highlight hl-ipython3"><pre><span></span><span class="n">dataset_path</span> <span class="o">=</span> <span class="s2">&quot;rag_txt_dataset&quot;</span>
<span class="n">documents</span> <span class="o">=</span> <span class="n">load_documents_from_directory</span><span class="p">(</span><span class="n">dataset_path</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section class="section-block-markdown-cell">
<p>Verificamos que fizemos corretamente.</p>
</section>
<section class="section-block-code-cell-">
<div class="input-code">
<div class="highlight hl-ipython3"><pre><span></span><span class="k">for</span> <span class="n">document</span> <span class="ow">in</span> <span class="n">documents</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">10</span><span class="p">]:</span>
<span class="w">    </span><span class="nb">print</span><span class="p">(</span><span class="n">document</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>
</pre></div>
</div>
</section>
<section class="section-block-code-cell-">
<div class="output-wrapper">
<div class="output-area">
<div class="prompt"></div>
<div class="output-subarea-output-stream-output-stdout-output-text">
<pre>Run Jobs at Scale While Optimizing for Cost Using Amazon EC2 Spot Instances with ActionIQ _ ActionIQ Case Study _ AWS.txt
Recommend and dynamically filter items based on user context in Amazon Personalize _ AWS Machine Learning Blog.txt
Windsor.txt
Bank of Montreal Case Study _ AWS.txt
The Mill Adventure Case Study.txt
Optimize software development with Amazon CodeWhisperer _ AWS DevOps Blog.txt
Announcing enhanced table extractions with Amazon Textract _ AWS Machine Learning Blog.txt
THREAD _ Life Sciences _ AWS.txt
Deep Pool Optimizes Software Quality Control Using Amazon QuickSight _ Deep Pool Case Study _ AWS.txt
Upstox Saves 1 Million Annually Using Amazon S3 Storage Lens _ Upstox Case Study _ AWS.txt
</pre>
</div>
</div>
</div>
</section>
<section class="section-block-markdown-cell">
<p>Agora criamos os <code>chunk</code>s.</p>
</section>
<section class="section-block-code-cell-">
<div class="input-code">
<div class="highlight hl-ipython3"><pre><span></span><span class="n">chunked_documents</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">document</span> <span class="ow">in</span> <span class="n">documents</span><span class="p">:</span>
<span class="w">    </span><span class="n">chunks</span> <span class="o">=</span> <span class="n">split_text</span><span class="p">(</span><span class="n">document</span><span class="p">[</span><span class="s2">&quot;text&quot;</span><span class="p">])</span>
<span class="w">    </span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">chunks</span><span class="p">):</span>
<span class="w">        </span><span class="n">chunked_documents</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">document</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;text&quot;</span><span class="p">:</span> <span class="n">chunk</span><span class="p">})</span>
</pre></div>
</div>
</section>
<section class="section-block-code-cell-">
<div class="input-code">
<div class="highlight hl-ipython3"><pre><span></span><span class="nb">len</span><span class="p">(</span><span class="n">chunked_documents</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section class="section-block-code-cell-">
<div class="output-wrapper">
<div class="output-area">
<div class="prompt"></div>
<div class="output-subarea-output-stream-output-stdout-output-text">
<pre>3611
</pre>
</div>
</div>
</div>
</section>
<section class="section-block-markdown-cell">
<p>Como vemos, há 3611 <code>chunk</code>s. Como o limite diário da API do Hugging Face são 1000 chamadas na conta gratuita, se quisermos criar embeddings de todos os <code>chunk</code>s, acabaríamos com as chamadas disponíveis e além disso não poderíamos criar embeddings de todos os <code>chunk</code>s</p>
</section>
<section class="section-block-markdown-cell">
<p>Reiteramos, este modelo de embeddings é muito pequeno, com apenas 22M de parâmetros, portanto pode ser executado em quase qualquer computador, mais rápido ou mais devagar, mas pode ser executado.</p>
</section>
<section class="section-block-markdown-cell">
<p>Como só vamos a criar os embeddings dos <code>chunk</code>s uma vez, mesmo que não tenhamos um computador muito potente e leve muito tempo, apenas será executado uma vez. Depois, quando quisermos fazer perguntas sobre a documentação, geraremos os embeddings do prompt com a API da Hugging Face e usaremos o LLM com a API. Portanto, só teremos que passar pelo processo de geração dos embeddings dos <code>chunk</code>s uma vez.</p>
</section>
<section class="section-block-markdown-cell">
<p>Geramos os embeddings dos <code>chunk</code>s</p>
</section>
<section class="section-block-markdown-cell">
<p>Última biblioteca que precisaremos instalar. Como o processo de geração dos embeddings dos <code>chunk</code>s será lento, vamos instalar <code>tqdm</code> para mostrar uma barra de progresso. Instalamos com Conda ou pip, conforme sua preferência.</p>
<div class='highlight'><pre><code class="language-bash">conda install conda-forge::tqdm
</code></pre></div>
<p>o</p>
<div class='highlight'><pre><code class="language-bash">pip install tqdm
</code></pre></div>
</section>
<section class="section-block-markdown-cell">
<p>Geramos os embeddings dos <code>chunk</code>s</p>
</section>
<section class="section-block-code-cell-">
<div class="input-code">
<div class="highlight hl-ipython3"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">tqdm</span>
<span class="w"> </span>
<span class="n">progress_bar</span> <span class="o">=</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span><span class="n">chunked_documents</span><span class="p">)</span>
<span class="w"> </span>
<span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">progress_bar</span><span class="p">:</span>
<span class="w">    </span><span class="n">embedding</span> <span class="o">=</span> <span class="n">get_embeddings</span><span class="p">(</span><span class="n">chunk</span><span class="p">[</span><span class="s2">&quot;text&quot;</span><span class="p">])</span>
<span class="w">    </span><span class="k">if</span> <span class="n">embedding</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="n">chunk</span><span class="p">[</span><span class="s2">&quot;embedding&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">embedding</span>
<span class="w">    </span><span class="k">else</span><span class="p">:</span>
<span class="w">        </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error with document </span><span class="si">{</span><span class="n">chunk</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section class="section-block-code-cell-">
<div class="output-wrapper">
<div class="output-area">
<div class="prompt"></div>
<div class="output-subarea-output-stream-output-stdout-output-text">
<pre>100%|██████████| 3611/3611 [00:16&amp;lt;00:00, 220.75it/s]
</pre>
</div>
</div>
</div>
</section>
<section class="section-block-markdown-cell">
<p>Vemos um exemplo</p>
</section>
<section class="section-block-code-cell-">
<div class="input-code">
<div class="highlight hl-ipython3"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">random</span><span class="w"> </span><span class="kn">import</span> <span class="n">randint</span>
<span class="w"> </span>
<span class="n">idx</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunked_documents</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Chunk id: </span><span class="si">{</span><span class="n">chunked_documents</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="s1">&#39;id&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">,</span><span class="se">\n\n</span><span class="s2">text: </span><span class="si">{</span><span class="n">chunked_documents</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="s1">&#39;text&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">,</span><span class="se">\n\n</span><span class="s2">embedding shape: </span><span class="si">{</span><span class="n">chunked_documents</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="s1">&#39;embedding&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section class="section-block-code-cell-">
<div class="output-wrapper">
<div class="output-area">
<div class="prompt"></div>
<div class="output-subarea-output-stream-output-stdout-output-text">
<pre>Chunk id: BNS Group Case Study _ Amazon Web Services.txt_0,

text: Reducing Virtual Machines from 40 to 12
The founders of BNS had been contemplating a migration from the company’s on-premises data center to the public cloud and observed a growing demand for cloud-based operations among current and potential BNS customers.
Français
Configures security according to cloud best practices
Clive Pereira, R&amp;amp;D director at BNS Group, explains, “The database that records Praisal’s SMS traffic resides in Praisal’s AWS environment. Praisal can now run complete analytics across its data and gain insights into what’s happening with its SMS traffic, which is a real game-changer for the organization.”  
Español
 AWS ISV Accelerate Program
 Receiving Strategic, Foundational Support from ISV Specialists
 Learn More
The value that AWS places on the ISV stream sealed the deal in our choice of cloud provider.” 
日本語
&#x20;&#x20;Contact Sales 
BNS is an Australian software provider focused on secure enterprise SMS and fax messaging. Its software runs on the Windows platform and is l,

embedding shape: (384,)
</pre>
</div>
</div>
</div>
</section>
<section class="section-block-markdown-cell">
<h3 id="Carregar os chunks na base de dados vetorial">Carregar os <code>chunk</code>s na base de dados vetorial<a class="anchor-link" href="#Carregar os chunks na base de dados vetorial">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Uma vez que temos todos os chunks gerados, os carregamos na base de dados vetorial. Voltamos a usar <code>tqdm</code> para mostrar uma barra de progresso, pois isso também será lento.</p>
</section>
<section class="section-block-code-cell-">
<div class="input-code">
<div class="highlight hl-ipython3"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">tqdm</span>
<span class="w"> </span>
<span class="n">progress_bar</span> <span class="o">=</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span><span class="n">chunked_documents</span><span class="p">)</span>
<span class="w"> </span>
<span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">progress_bar</span><span class="p">:</span>
<span class="w">    </span><span class="n">collection</span><span class="o">.</span><span class="n">upsert</span><span class="p">(</span>
<span class="w">        </span><span class="n">ids</span><span class="o">=</span><span class="p">[</span><span class="n">chunk</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]],</span>
<span class="w">        </span><span class="n">documents</span><span class="o">=</span><span class="n">chunk</span><span class="p">[</span><span class="s2">&quot;text&quot;</span><span class="p">],</span>
<span class="w">        </span><span class="n">embeddings</span><span class="o">=</span><span class="n">chunk</span><span class="p">[</span><span class="s2">&quot;embedding&quot;</span><span class="p">],</span>
<span class="w">    </span><span class="p">)</span>
</pre></div>
</div>
</section>
<section class="section-block-code-cell-">
<div class="output-wrapper">
<div class="output-area">
<div class="prompt"></div>
<div class="output-subarea-output-stream-output-stdout-output-text">
<pre>100%|██████████| 3611/3611 [00:59&amp;lt;00:00, 60.77it/s]
</pre>
</div>
</div>
</div>
</section>
<section class="section-block-markdown-cell">
<h2 id="Perguntas">Perguntas<a class="anchor-link" href="#Perguntas">¶</a></h2>
</section>
<section class="section-block-markdown-cell">
<p>Agora que temos a base de dados vetorial, podemos fazer perguntas à documentação. Para isso, precisamos de uma função que nos retorne o <code>chunk</code> correto.</p>
</section>
<section class="section-block-markdown-cell">
<h3 id="Obter o chunk correto">Obter o <code>chunk</code> correto<a class="anchor-link" href="#Obter o chunk correto">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Agora precisamos de uma função que nos retorne o <code>chunk</code> correto, vamos criá-la</p>
</section>
<section class="section-block-code-cell-">
<div class="input-code">
<div class="highlight hl-ipython3"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">get_top_k_documents</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
<span class="w">    </span><span class="n">results</span> <span class="o">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">query_texts</span><span class="o">=</span><span class="n">query</span><span class="p">,</span> <span class="n">n_results</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span> <span class="n">results</span>
</pre></div>
</div>
</section>
<section class="section-block-markdown-cell">
<p>Por último, criamos uma <code>query</code>.</p>
<p>Para gerar a query, selecionei aleatoriamente o documento <code>Using Amazon EC2 Spot Instances and Karpenter to Simplify and Optimize Kubernetes Infrastructure _ Neeva Case Study _ AWS.txt</code>, passei-o para um LLM e pedi que gerasse uma pergunta sobre o documento. A pergunta que foi gerada é</p>
<div class='highlight'><pre><code class="language-text">Como a Neeva utilizou o Karpenter e as Instâncias Spot do Amazon EC2 para melhorar sua gestão de infraestrutura e otimização de custos?
</code></pre></div>
<p>Então obtemos os <code>chunks</code> mais relevantes diante dessa pergunta.</p>
</section>
<section class="section-block-code-cell-">
<div class="input-code">
<div class="highlight hl-ipython3"><pre><span></span><span class="n">query</span> <span class="o">=</span> <span class="s2">&quot;How did Neeva use Karpenter and Amazon EC2 Spot Instances to improve its infrastructure management and cost optimization?&quot;</span>
<span class="n">top_chunks</span> <span class="o">=</span> <span class="n">get_top_k_documents</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="n">query</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section class="section-block-markdown-cell">
<p>Vamos a ver quais <code>chunk</code>s nos foram devolvidos</p>
</section>
<section class="section-block-code-cell-">
<div class="input-code">
<div class="highlight hl-ipython3"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">top_chunks</span><span class="p">[</span><span class="s2">&quot;ids&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])):</span>
<span class="w">    </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Rank </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">top_chunks</span><span class="p">[</span><span class="s1">&#39;ids&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">, distance: </span><span class="si">{</span><span class="n">top_chunks</span><span class="p">[</span><span class="s1">&#39;distances&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section class="section-block-code-cell-">
<div class="output-wrapper">
<div class="output-area">
<div class="prompt"></div>
<div class="output-subarea-output-stream-output-stdout-output-text">
<pre>Rank 1: Using Amazon EC2 Spot Instances and Karpenter to Simplify and Optimize Kubernetes Infrastructure _ Neeva Case Study _ AWS.txt_0, distance: 0.29233667254447937
Rank 2: Using Amazon EC2 Spot Instances and Karpenter to Simplify and Optimize Kubernetes Infrastructure _ Neeva Case Study _ AWS.txt_5, distance: 0.4007825255393982
Rank 3: Using Amazon EC2 Spot Instances and Karpenter to Simplify and Optimize Kubernetes Infrastructure _ Neeva Case Study _ AWS.txt_1, distance: 0.4317566752433777
Rank 4: Using Amazon EC2 Spot Instances and Karpenter to Simplify and Optimize Kubernetes Infrastructure _ Neeva Case Study _ AWS.txt_6, distance: 0.43832334876060486
Rank 5: Using Amazon EC2 Spot Instances and Karpenter to Simplify and Optimize Kubernetes Infrastructure _ Neeva Case Study _ AWS.txt_4, distance: 0.44625571370124817
</pre>
</div>
</div>
</div>
</section>
<section class="section-block-markdown-cell">
<p>Como eu havia dito, o documento que escolhi aleatoriamente era <code>Using Amazon EC2 Spot Instances and Karpenter to Simplify and Optimize Kubernetes Infrastructure _ Neeva Case Study _ AWS.txt</code> e, como se pode ver, os <code>chunk</code>s que nos foram retornados são desse documento. Isso significa que, dos mais de 3000 <code>chunk</code>s que havia no banco de dados, ele foi capaz de me retornar os <code>chunk</code>s mais relevantes para essa pergunta, parece que isso funciona!</p>
</section>
<section class="section-block-markdown-cell">
<h3 id="Gerar a resposta">Gerar a resposta<a class="anchor-link" href="#Gerar a resposta">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Como já temos os <code>chunk</code>s mais relevantes, passamo-los ao LLM, juntamente com a pergunta, para que ele gere uma resposta.</p>
</section>
<section class="section-block-code-cell-">
<div class="input-code">
<div class="highlight hl-ipython3"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">generate_response</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">relevant_chunks</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">max_tokens</span><span class="o">=</span><span class="mi">1024</span><span class="p">,</span> <span class="n">top_p</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">stream</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="n">context</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">chunk</span> <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">relevant_chunks</span><span class="p">])</span>
<span class="w">    </span><span class="n">prompt</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;You are an assistant for question-answering. You have to answer the following question:</span><span class="se">\n\n</span><span class="si">{</span><span class="n">query</span><span class="si">}</span><span class="se">\n\n</span><span class="s2">Answer the question with the following information:</span><span class="se">\n\n</span><span class="si">{</span><span class="n">context</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="w">    </span><span class="n">message</span> <span class="o">=</span> <span class="p">[</span>
<span class="w">        </span><span class="p">{</span> <span class="s2">&quot;role&quot;</span><span class="p">:</span> <span class="s2">&quot;user&quot;</span><span class="p">,</span> <span class="s2">&quot;content&quot;</span><span class="p">:</span> <span class="n">prompt</span> <span class="p">}</span>
<span class="w">    </span><span class="p">]</span>
<span class="w">    </span><span class="n">stream</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">chat</span><span class="o">.</span><span class="n">completions</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
<span class="w">        </span><span class="n">messages</span><span class="o">=</span><span class="n">message</span><span class="p">,</span> 
<span class="w">        </span><span class="n">temperature</span><span class="o">=</span><span class="n">temperature</span><span class="p">,</span>
<span class="w">        </span><span class="n">max_tokens</span><span class="o">=</span><span class="n">max_tokens</span><span class="p">,</span>
<span class="w">        </span><span class="n">top_p</span><span class="o">=</span><span class="n">top_p</span><span class="p">,</span>
<span class="w">        </span><span class="n">stream</span><span class="o">=</span><span class="n">stream</span><span class="p">,</span>
<span class="w">    </span><span class="p">)</span>
<span class="w">    </span><span class="n">response</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">choices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">message</span><span class="o">.</span><span class="n">content</span>
<span class="w">    </span><span class="k">return</span> <span class="n">response</span>
</pre></div>
</div>
</section>
<section class="section-block-markdown-cell">
<p>Testamos a função</p>
</section>
<section class="section-block-code-cell-">
<div class="input-code">
<div class="highlight hl-ipython3"><pre><span></span><span class="n">response</span> <span class="o">=</span> <span class="n">generate_response</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">top_chunks</span><span class="p">[</span><span class="s2">&quot;documents&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section class="section-block-code-cell-">
<div class="output-wrapper">
<div class="output-area">
<div class="prompt"></div>
<div class="output-subarea-output-stream-output-stdout-output-text">
<pre>Neeva, a cloud-native, ad-free search engine founded in 2019, has leveraged Karpenter and Amazon EC2 Spot Instances to significantly improve its infrastructure management and cost optimization. Here’s how:

### Early Collaboration with Karpenter
In late 2021, Neeva began working closely with the Karpenter team, experimenting with and contributing fixes to an early version of Karpenter. This collaboration allowed Neeva to integrate Karpenter with its Kubernetes dashboard, enabling the company to gather valuable metrics on usage and performance.

### Combining Spot Instances and On-Demand Instances
Neeva runs its jobs on a large scale, which can lead to significant costs. To manage these costs effectively, the company adopted a combination of Amazon EC2 Spot Instances and On-Demand Instances. Spot Instances allow Neeva to bid on unused EC2 capacity, often at a fraction of the On-Demand price, while On-Demand Instances provide the necessary reliability for critical pipelines.

### Flexibility and Instance Diversification
According to Mohit Agarwal, infrastructure engineering lead at Neeva, Karpenter&#x27;s adoption of best practices for Spot Instances, including flexibility and instance diversification, has been crucial. This approach ensures that Neeva can dynamically adjust its compute resources to meet varying workloads while minimizing costs.

### Improved Scalability and Agility
By using Karpenter to provision infrastructure resources for its Amazon EKS clusters, Neeva has achieved several key benefits:
- **Scalability**: Neeva can scale its compute resources up or down as needed, ensuring that it always has the necessary capacity to handle its workloads.
- **Agility**: The company can iterate quickly and democratize infrastructure changes, reducing the time spent on systems administration by up to 100 hours per week.

### Enhanced Development Cycles
The integration of Karpenter and Spot Instances has also accelerated Neeva&#x27;s development cycles. The company can now launch new features and improvements more rapidly, which is essential for maintaining a competitive edge in the search engine market.

### Cost Savings and Budget Control
Using Spot Instances, Neeva has been able to stay within its budget while meeting its performance requirements. This cost optimization is critical for a company that prioritizes user-first experiences and has no competing incentives from advertising.

### Future Plans
Neeva is committed to continuing its innovation and expansion. The company plans to launch in new regions and further improve its search engine, all while maintaining cost efficiency. As Mohit Agarwal notes, &quot;The bulk of our compute is or will be managed using Karpenter going forward.&quot;

### Conclusion
By leveraging Karpenter and Amazon EC2 Spot Instances, Neeva has not only optimized its infrastructure costs but also enhanced its scalability, agility, and development speed. This strategic approach has positioned Neeva to deliver high-quality, ad-free search experiences to its users while maintaining a strong focus on cost control and innovation.
</pre>
</div>
</div>
</div>
</section>
<section class="section-block-markdown-cell">
<p>Quando pedi ao LLM para gerar uma pergunta sobre o documento, também pedi que gerasse a resposta correta. Esta é a resposta que o LLM me deu.</p>
</section>
<section class="section-block-markdown-cell">
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-text">A Neeva utilizou o Karpenter e as Instâncias Spot do Amazon EC2 para melhorar sua gestão de infraestrutura e otimização de custos de várias maneiras:<br><br>Gestão Simplificada de Instâncias:<br><br>Karpenter: Ao adotar o Karpenter, a Neeva simplificou o processo de provisionamento e gerenciamento de recursos computacionais para seus clusters do Amazon EKS. O Karpenter provisiona e desprovisiona instâncias automaticamente com base na carga de trabalho, eliminando a necessidade de configurações manuais e reduzindo a complexidade de compreender diferentes instâncias computacionais.<br>Instâncias Spot: A Neeva utilizou Instâncias Spot do Amazon EC2, que são capacidade não utilizada do EC2 disponível com um desconto significativo (até 90% de economia de custos). Isso permitiu à empresa controlar os custos enquanto atendia aos seus requisitos de desempenho.<br>Escalabilidade Aumentada:<br><br>Karpenter: A capacidade do Karpenter de escalar recursos dinamicamente permitiu que a Neeva iniciasse novas instâncias rapidamente, permitindo que a empresa iterasse com maior velocidade e executasse mais experimentos em menos tempo.<br>Instâncias Spot: O uso de Instâncias Spot proporcionou flexibilidade e diversificação de instâncias, facilitando o escalonamento dos recursos de computação da Neeva de forma eficiente.<br>Produtividade Melhorada:<br><br>Karpenter: Ao democratizar as alterações de infraestrutura, o Karpenter permitiu que qualquer engenheiro modificasse as configurações do Kubernetes, reduzindo a dependência de expertise especializada. Isso economizou até 100 horas por semana de tempo de espera em administração de sistemas para a equipe da Neeva.<br>Instâncias Spot: A capacidade de provisionar e desprovisionar rapidamente Instâncias Spot reduziu os atrasos no pipeline de desenvolvimento, garantindo que os trabalhos não ficassem travados devido à falta de recursos disponíveis.<br>Eficiência Custo:<br><br>Karpenter: As melhores práticas do Karpenter para instâncias Spot, incluindo flexibilidade e diversificação de instâncias, ajudaram a Neeva a usar essas instâncias de forma mais eficaz, permanecendo dentro do orçamento.<br>Instâncias Spot: As economias de custos com o uso de Instâncias Spot permitiram que a Neeva executasse trabalhos em larga escala, como indexação, por quase o mesmo custo, mas em um tempo muito menor. Por exemplo, a Neeva reduziu seus trabalhos de indexação de 18 horas para apenas 3 horas.<br>Melhor Utilização de Recursos:<br><br>Karpenter: O Karpenter proporcionou uma melhor visibilidade sobre o uso de recursos computacionais, permitindo que a Neeva rastreasse e otimizasse seu consumo de recursos mais de perto.<br>Instâncias Spot: A combinação do Karpenter e das Instâncias Spot permitiu que a Neeva executasse modelos de linguagem grandes de forma mais eficiente, melhorando a experiência de busca para seus usuários.<br>Em resumo, a adoção do Karpenter e das Instâncias Spot do Amazon EC2 pela Neeva melhorou significativamente sua gestão de infraestrutura, otimização de custos e eficiência geral no desenvolvimento, permitindo que a empresa oferecesse melhores experiências de pesquisa sem anúncios aos seus usuários.</code></pre></div>
      </section>
</section>
<section class="section-block-markdown-cell">
<p>E esta tem sido a resposta gerada pelo nosso <code>RAG</code></p>
</section>
<section class="section-block-markdown-cell">
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-text">Neeva, um mecanismo de busca nativo em nuvem e sem anúncios fundado em 2019, aproveitou o Karpenter e as Instâncias Spot do Amazon EC2 para melhorar significativamente sua gestão de infraestrutura e otimização de custos. Eis como:<br><br>### Colaboração Inicial com o Karpenter<br>No final de 2021, a Neeva começou a trabalhar em estreita colaboração com a equipe do Karpenter, experimentando e contribuindo com correções para uma versão inicial do Karpenter. Essa colaboração permitiu que a Neeva integrasse o Karpenter ao seu painel do Kubernetes, possibilitando à empresa coletar métricas valiosas sobre uso e desempenho.<br><br>### Combinando Instâncias Spot e Instâncias On-Demand<br>A Neeva executa seus jobs em larga escala, o que pode levar a custos significativos. Para gerenciar esses custos de forma eficaz, a empresa adotou uma combinação de Amazon EC2 Spot Instances e On-Demand Instances. As Spot Instances permitem que a Neeva lance lances sobre capacidade EC2 não utilizada, frequentemente por uma fração do preço On-Demand, enquanto as On-Demand Instances fornecem a necessária confiabilidade para pipelines críticos.<br><br>### Flexibilidade e Diversificação de Instâncias<br>De acordo com Mohit Agarwal, líder de engenharia de infraestrutura da Neeva, a adoção de melhores práticas para Instâncias Spot pelo Karpenter, incluindo flexibilidade e diversificação de instâncias, foi crucial. Essa abordagem garante que a Neeva possa ajustar dinamicamente seus recursos de computação para atender às cargas de trabalho variáveis, minimizando custos.<br><br>### Melhor Escalabilidade e Agilidade<br>Ao usar o Karpenter para provisionar recursos de infraestrutura para seus clusters do Amazon EKS, a Neeva alcançou vários benefícios importantes:<br>- **Escalabilidade**: O Neeva pode escalar seus recursos de computação para cima ou para baixo conforme necessário, garantindo que sempre tenha a capacidade necessária para lidar com suas cargas de trabalho.<br>- **Agilidade**: A empresa pode iterar rapidamente e democratizar as mudanças de infraestrutura, reduzindo o tempo gasto com a administração do sistema em até 100 horas por semana.<br><br>### Ciclos de Desenvolvimento AperfeiçoadosA integração do Karpenter e das Instâncias Spot também acelerou os ciclos de desenvolvimento da Neeva. A empresa agora pode lançar novos recursos e melhorias mais rapidamente, o que é essencial para manter uma vantagem competitiva no mercado de motores de busca.<br><br>### Economia de Custos e Controle Orçamentário<br>Usando Instâncias Spot, a Neeva tem conseguido permanecer dentro do seu orçamento enquanto atende aos seus requisitos de desempenho. Essa otimização de custos é crucial para uma empresa que prioriza experiências centradas no usuário e não possui incentivos conflitantes provenientes da publicidade.<br><br>### Planos Futuros<br>A Neeva está comprometida em continuar sua inovação e expansão. A empresa planeja lançar em novas regiões e melhorar ainda mais seu mecanismo de busca, mantendo a eficiência de custos. Como Mohit Agarwal observa, "A maior parte do nosso compute será gerenciada usando Karpenter a partir de agora."<br><br>### Conclusão<br>Ao aproveitar o Karpenter e as Instâncias Spot do Amazon EC2, a Neeva não apenas otimizou seus custos de infraestrutura, mas também melhorou sua escalabilidade, agilidade e velocidade de desenvolvimento. Esta abordagem estratégica posicionou a Neeva para fornecer experiências de pesquisa de alta qualidade e sem anúncios aos seus usuários, mantendo um forte foco no controle de custos e inovação.</code></pre></div>
      </section>
</section>
<section class="section-block-markdown-cell">
<p>Portanto, podemos concluir que o <code>RAG</code> funcionou corretamente!!!</p>
</section>
<section class="section-block-markdown-cell">
<h2 id="Limites de naive RAG">Limites de naive RAG<a class="anchor-link" href="#Limites de naive RAG">¶</a></h2>
</section>
<section class="section-block-markdown-cell">
<p>Como dissemos, hoje explicamos <code>naive RAG</code>, que é a arquitetura mais simples do RAG, mas tem suas limitações.</p>
</section>
<section class="section-block-markdown-cell">
<img src="https://images.maximofn.com/naive_RAG_architecture.webp" alt="Arquitetura Naive RAG">
</section>
<section class="section-block-markdown-cell">
<p>As limitações desta arquitetura são:</p>
</section>
<section class="section-block-markdown-cell">
<h3 id="Limites na busca de informacoes (retriever)">Limites na busca de informações (retriever)<a class="anchor-link" href="#Limites na busca de informacoes (retriever)">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<ul>
  <li>Conhecimento limitado do contexto e da documentação: Quando o sistema de RAG ingênuo busca os chunks, ele procura aqueles que têm um significado semântico similar ao prompt, mas não é capaz de saber quais são os mais relevantes para a pergunta do usuário, ou quais são os que possuem informações mais atualizadas, ou se sua informação é mais correta do que a de outros chunks. Por exemplo, se um usuário perguntar sobre os problemas dos adoçantes no sistema digestivo, o RAG ingênuo pode retornar documentos sobre adoçantes ou sobre o sistema digestivo, mas não é capaz de saber que os documentos sobre o sistema digestivo são os mais relevantes para a pergunta do usuário. Outro exemplo é se o usuário perguntar sobre os últimos avanços na IA, mas o RAG ingênuo não é capaz de saber quais são os últimos papers da base de dados.</li>
</ul>
<ul>
  <li>Não há uma sincronização entre o retrieval e o gerador. Como vimos, são dois sistemas independentes; de um lado, o retrieval busca os documentos mais semelhantes à pergunta do usuário, e esses documentos são passados ao gerador, que gera uma resposta.</li>
</ul>
<ul>
  <li>Escalabilidade ineficiente para grandes bancos de dados. Como a recuperação busca os documentos com maior similaridade semântica em toda a base de dados, quando esta fica muito grande, podemos ter tempos de pesquisa muito longos.</li>
  <li>Pouca adaptação à pergunta do usuário. Se o usuário fizer uma pergunta que envolva vários documentos, ou seja, não há nenhum documento que contenha toda a informação da pergunta do usuário, o sistema recuperará todos esses documentos e os passará para o gerador, que pode usá-los ou não. Ou, em um caso pior, pode deixar de lado algum documento relevante para gerar a resposta.</li>
</ul>
</section>
<section class="section-block-markdown-cell">
<h3 id="Limites na geracao de respostas (generator)">Limites na geração de respostas (generator)<a class="anchor-link" href="#Limites na geracao de respostas (generator)">¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<ul>
  <li>O modelo poderia alucinar respostas mesmo ao fornecer informações relevantes.</li>
</ul>
<ul>
  <li>O modelo pode estar limitado por questões relacionadas a ódio, discriminação, etc.</li>
</ul>
</section>
<section class="section-block-markdown-cell">
<p>Para ultrapassar esses limites, geralmente são utilizadas técnicas como o</p>
<ul>
  <li>Pré-recuperação: Que inclui técnicas para melhorar a indexação, tornando a busca de informações mais eficiente. Ou técnicas como a melhoria da pergunta do usuário para que o retrieval possa encontrar os documentos mais relevantes.</li>
</ul>
<ul>
  <li>Pós-recuperação: Aqui são utilizadas técnicas como o re-ranqueamento dos documentos, que é uma técnica usada para melhorar a busca por informações relevantes</li>
</ul>
</section>