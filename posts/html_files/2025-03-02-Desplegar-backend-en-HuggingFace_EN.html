<section class="section-block-markdown-cell">
<h1 id="Deploy backend on HuggingFace">Deploy backend on HuggingFace<a class="anchor-link" href="#Deploy backend on HuggingFace">Â¶</a></h1>
</section>
<section class="section-block-markdown-cell">
<blockquote>
<p>Disclaimer: This post has been translated to English using a machine translation model. Please, let me know if you find any mistakes.</p>
</blockquote>
</section>
<section class="section-block-markdown-cell">
<p>In this post, we will see how to deploy a backend on HuggingFace. We will cover two methods: the common way by creating an application with Gradio, and a different option using FastAPI, Langchain, and Docker.</p>
</section>
<section class="section-block-markdown-cell">
<p>For both cases, it will be necessary to have an account on HuggingFace, as we are going to deploy the backend in a HuggingFace space.</p>
</section>
<section class="section-block-markdown-cell">
<h2 id="Deploy backend with Gradio">Deploy backend with Gradio<a class="anchor-link" href="#Deploy backend with Gradio">Â¶</a></h2>
</section>
<section class="section-block-markdown-cell">
<h3 id="Create space">Create space<a class="anchor-link" href="#Create space">Â¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>First of all, we create a new space on Hugging Face.</p>
<ul>
  <li>We put a name, a description, and choose the license.</li>
  <li>We chose Gradio as the type of SDK. When choosing Gradio, templates will appear, so we selected the chatbot template.</li>
  <li>We select the HW on which we are going to deploy the backend, I will choose the free CPU, but you choose what you consider best.</li>
  <li>And finally, we need to choose whether we want to create the space as public or private.</li>
</ul>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/backend-gradio-create-space.webp" alt="backend gradio - create space">
</section>
<section class="section-block-markdown-cell">
<h3 id="Code">Code<a class="anchor-link" href="#Code">Â¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>When creating the space, we can clone it or we can view the files on the Hugging Face page itself. We can see that 3 files have been created: <code>app.py</code>, <code>requirements.txt</code>, and <code>README.md</code>. So let's take a look at what to put in each one.</p>
</section>
<section class="section-block-markdown-cell">
<h4 id="app.py">app.py<a class="anchor-link" href="#app.py">Â¶</a></h4>
</section>
<section class="section-block-markdown-cell">
<p>Here we have the code for the application. Since we chose the chatbot template, we already have a lot done, but we will need to change 2 things: first, the language model and the system prompt.</p>
</section>
<section class="section-block-markdown-cell">
<p>As a language model, I see <code>HuggingFaceH4/zephyr-7b-beta</code>, but we are going to use <code>Qwen/Qwen2.5-72B-Instruct</code>, which is a very capable model.</p>
<p>So, look for the text <code>client = InferenceClient(&quot;HuggingFaceH4/zephyr-7b-beta&quot;)</code> and replace it with <code>client = InferenceClient(&quot;Qwen/Qwen2.5-72B-Instruct&quot;)</code>, or wait until I put all the code later.</p>
</section>
<section class="section-block-markdown-cell">
<p>We will also change the system prompt, which by default is <code>You are a friendly Chatbot.</code>, but since the model is trained mostly in English, it is likely that if you speak to it in another language it will respond in English, so we will change it to <code>You are a friendly Chatbot. Always reply in the language in which the user is writing to you.</code>.</p>
<p>So, look for the text <code>gr.Textbox(value=&quot;You are a friendly Chatbot.&quot;, label=&quot;System message&quot;),</code> and replace it with <code>gr.Textbox(value=&quot;You are a friendly Chatbot. Always reply in the language in which the user is writing to you.&quot;, label=&quot;System message&quot;),</code>, or wait as I am going to put all the code now.</p>
</section>
<section class="section-block-markdown-cell">
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-python">import gradio as gr<br>from huggingface_hub import InferenceClient<br><br>"""<br>For more information on `huggingface_hub` Inference API support, please check the docs: https://huggingface.co/docs/huggingface_hub/v0.22.2/en/guides/inference<br>"""<br>client = InferenceClient("Qwen/Qwen2.5-72B-Instruct")<br><br><br>def respond(<br>&#x20;&#x20;message,<br>&#x20;&#x20;history: list[tuple[str, str]],<br>&#x20;&#x20;system_message,<br>&#x20;&#x20;max_tokens,<br>&#x20;&#x20;temperature,<br>&#x20;&#x20;top_p,<br>):<br>&#x20;&#x20;messages = [&#123;"role": "system", "content": system_message&#125;]<br><br>&#x20;&#x20;for val in history:<br>&#x20;&#x20;&#x20;&#x20;if val[0]:<br>&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;messages.append(&#123;"role": "user", "content": val[0]&#125;)<br>&#x20;&#x20;&#x20;&#x20;if val[1]:<br>&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;messages.append(&#123;"role": "assistant", "content": val[1]&#125;)<br><br>&#x20;&#x20;messages.append(&#123;"role": "user", "content": message&#125;)<br><br>&#x20;&#x20;response = ""<br><br>&#x20;&#x20;for message in client.chat_completion(<br>&#x20;&#x20;&#x20;&#x20;messages,<br>&#x20;&#x20;&#x20;&#x20;max_tokens=max_tokens,<br>&#x20;&#x20;&#x20;&#x20;stream=True,<br>&#x20;&#x20;&#x20;&#x20;temperature=temperature,<br>&#x20;&#x20;&#x20;&#x20;top_p=top_p,<br>&#x20;&#x20;):<br>&#x20;&#x20;&#x20;&#x20;token = message.choices[0].delta.content<br><br>&#x20;&#x20;&#x20;&#x20;response += token<br>&#x20;&#x20;&#x20;&#x20;yield response<br><br><br>"""<br>For information on how to customize the ChatInterface, peruse the gradio docs: https://www.gradio.app/docs/gradio/chatinterface<br>"""<br>demo = gr.ChatInterface(<br>&#x20;&#x20;respond,<br>&#x20;&#x20;additional_inputs=[<br>&#x20;&#x20;&#x20;&#x20;gr.Textbox(value="You are a friendly Chatbot. Always reply in the language in which the user is writing to you.", label="System message"),<br>&#x20;&#x20;&#x20;&#x20;gr.Slider(minimum=1, maximum=2048, value=512, step=1, label="Max new tokens"),<br>&#x20;&#x20;&#x20;&#x20;gr.Slider(minimum=0.1, maximum=4.0, value=0.7, step=0.1, label="Temperature"),<br>&#x20;&#x20;&#x20;&#x20;gr.Slider(<br>&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;minimum=0.1,<br>&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;maximum=1.0,<br>&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;value=0.95,<br>&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;step=0.05,<br>&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;label="Top-p (nucleus sampling)",<br>&#x20;&#x20;&#x20;&#x20;),<br>&#x20;&#x20;],<br>)<br><br><br>if __name__ == "__main__":<br>&#x20;&#x20;demo.launch()</code></pre></div>
      </section>
</section>
<section class="section-block-markdown-cell">
<h4 id="requirements.txt">requirements.txt<a class="anchor-link" href="#requirements.txt">Â¶</a></h4>
</section>
<section class="section-block-markdown-cell">
<p>This is the file where the dependencies will be written, but for this case it's going to be very simple:</p>
<div class='highlight'><pre><code class="language-txt">huggingface_hub==0.25.2
</code></pre></div>
</section>
<section class="section-block-markdown-cell">
<h4 id="README.md">README.md<a class="anchor-link" href="#README.md">Â¶</a></h4>
</section>
<section class="section-block-markdown-cell">
<p>This is the file where we will put the information about the space. In HuggingFace spaces, at the beginning of the readmes, a code is placed so that HuggingFace knows how to display the thumbnail of the space, which file to use to run the code, SDK version, etc.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-md">---<br>title: SmolLM2<br>emoji: ðŸ’¬<br>colorFrom: yellow<br>colorTo: purple<br>sdk: gradio<br>sdk_version: 5.0.1<br>app_file: app.py<br>pinned: false<br>license: apache-2.0<br>short_description: Gradio SmolLM2 chat<br>---<br><br>An example chatbot using [Gradio](https://gradio.app), [`huggingface_hub`](https://huggingface.co/docs/huggingface_hub/v0.22.2/en/index), and the [Hugging Face Inference API](https://huggingface.co/docs/api-inference/index).</code></pre></div>
      </section>
</section>
<section class="section-block-markdown-cell">
<h3 id="Deployment">Deployment<a class="anchor-link" href="#Deployment">Â¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>If we have cloned the space, we need to make a commit and a push. If we have modified the files in HuggingFace, saving them is enough.</p>
<p>So when the changes are in HuggingFace, we will have to wait a few seconds for the space to build and then we can use it.</p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/backend-gradio-chatbot.webp" alt="backend gradio - chatbot">
</section>
<section class="section-block-markdown-cell">
<h3 id="Backend">Backend<a class="anchor-link" href="#Backend">Â¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Alright, we've created a chatbot, but that wasn't the intention; we came here to build a backend! Stop, stop, look at what it says below the chatbot</p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/backend-gradio-chatbot-edited.webp" alt="backend gradio - Use via API">
</section>
<section class="section-block-markdown-cell">
<p>We can see a text <code>Use via API</code>, where if we click it, a menu with an API opens for us to use the chatbot.</p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/backend%20gradio%20-%20API.webp" alt="backend gradio - API">
</section>
<section class="section-block-markdown-cell">
<p>We see that it provides documentation on how to use the API, both with Python, JavaScript, and bash.</p>
</section>
<section class="section-block-markdown-cell">
<h3 id="API Test">API Test<a class="anchor-link" href="#API Test">Â¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>We use the example Python code.</p>
</section>
<section class="section-block-code-cell-">
<div class="input-code">
<div class="highlight hl-ipython3"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">gradio_client</span><span class="w"> </span><span class="kn">import</span> <span class="n">Client</span>
<span class="w"> </span>
<span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="s2">&quot;Maximofn/SmolLM2&quot;</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span>
<span class="w">	</span><span class="w">	</span><span class="n">message</span><span class="o">=</span><span class="s2">&quot;Hola, Â¿cÃ³mo estÃ¡s? Me llamo MÃ¡ximo&quot;</span><span class="p">,</span>
<span class="w">	</span><span class="w">	</span><span class="n">system_message</span><span class="o">=</span><span class="s2">&quot;You are a friendly Chatbot. Always reply in the language in which the user is writing to you.&quot;</span><span class="p">,</span>
<span class="w">	</span><span class="w">	</span><span class="n">max_tokens</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span>
<span class="w">	</span><span class="w">	</span><span class="n">temperature</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span>
<span class="w">	</span><span class="w">	</span><span class="n">top_p</span><span class="o">=</span><span class="mf">0.95</span><span class="p">,</span>
<span class="w">	</span><span class="w">	</span><span class="n">api_name</span><span class="o">=</span><span class="s2">&quot;/chat&quot;</span>
<span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section class="section-block-code-cell-">
<div class="output-wrapper">
<div class="output-area">
<div class="prompt"></div>
<div class="output-subarea-output-stream-output-stdout-output-text">
<pre>Loaded as API: https://maximofn-smollm2.hf.space âœ”
Â¡Hola MÃ¡ximo! Mucho gusto, estoy bien, gracias por preguntar. Â¿CÃ³mo estÃ¡s tÃº? Â¿En quÃ© puedo ayudarte hoy?
</pre>
</div>
</div>
</div>
</section>
<section class="section-block-markdown-cell">
<p>We are making calls to the <code>InferenceClient</code> API from HuggingFace, so we might wonder, why did we create a backend if we can call the HuggingFace API directly? You will see this in the following section.</p>
</section>
<section class="section-block-code-cell-">
<div class="input-code">
<div class="highlight hl-ipython3"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span>
<span class="w">	</span><span class="w">	</span><span class="n">message</span><span class="o">=</span><span class="s2">&quot;Â¿CÃ³mo me llamo?&quot;</span><span class="p">,</span>
<span class="w">	</span><span class="w">	</span><span class="n">system_message</span><span class="o">=</span><span class="s2">&quot;You are a friendly Chatbot. Always reply in the language in which the user is writing to you.&quot;</span><span class="p">,</span>
<span class="w">	</span><span class="w">	</span><span class="n">max_tokens</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span>
<span class="w">	</span><span class="w">	</span><span class="n">temperature</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span>
<span class="w">	</span><span class="w">	</span><span class="n">top_p</span><span class="o">=</span><span class="mf">0.95</span><span class="p">,</span>
<span class="w">	</span><span class="w">	</span><span class="n">api_name</span><span class="o">=</span><span class="s2">&quot;/chat&quot;</span>
<span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section class="section-block-code-cell-">
<div class="output-wrapper">
<div class="output-area">
<div class="prompt"></div>
<div class="output-subarea-output-stream-output-stdout-output-text">
<pre>Tu nombre es MÃ¡ximo. Â¿Es correcto?
</pre>
</div>
</div>
</div>
</section>
<section class="section-block-markdown-cell">
<p>The Gradio chat template handles the history for us, so that each time we create a new <code>client</code>, a new conversation thread is created.</p>
</section>
<section class="section-block-markdown-cell">
<p>Let's try to create a new client and see if a new conversation thread is created.</p>
</section>
<section class="section-block-code-cell-">
<div class="input-code">
<div class="highlight hl-ipython3"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">gradio_client</span><span class="w"> </span><span class="kn">import</span> <span class="n">Client</span>
<span class="w"> </span>
<span class="n">new_client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="s2">&quot;Maximofn/SmolLM2&quot;</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">new_client</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span>
<span class="w">	</span><span class="w">	</span><span class="n">message</span><span class="o">=</span><span class="s2">&quot;Hola, Â¿cÃ³mo estÃ¡s? Me llamo Luis&quot;</span><span class="p">,</span>
<span class="w">	</span><span class="w">	</span><span class="n">system_message</span><span class="o">=</span><span class="s2">&quot;You are a friendly Chatbot. Always reply in the language in which the user is writing to you.&quot;</span><span class="p">,</span>
<span class="w">	</span><span class="w">	</span><span class="n">max_tokens</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span>
<span class="w">	</span><span class="w">	</span><span class="n">temperature</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span>
<span class="w">	</span><span class="w">	</span><span class="n">top_p</span><span class="o">=</span><span class="mf">0.95</span><span class="p">,</span>
<span class="w">	</span><span class="w">	</span><span class="n">api_name</span><span class="o">=</span><span class="s2">&quot;/chat&quot;</span>
<span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section class="section-block-code-cell-">
<div class="output-wrapper">
<div class="output-area">
<div class="prompt"></div>
<div class="output-subarea-output-stream-output-stdout-output-text">
<pre>Loaded as API: https://maximofn-smollm2.hf.space âœ”
Hola Luis, estoy muy bien, gracias por preguntar. Â¿CÃ³mo estÃ¡s tÃº? Es un gusto conocerte. Â¿En quÃ© puedo ayudarte hoy?
</pre>
</div>
</div>
</div>
</section>
<section class="section-block-markdown-cell">
<p>Now we ask him again what my name is</p>
</section>
<section class="section-block-code-cell-">
<div class="input-code">
<div class="highlight hl-ipython3"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">new_client</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span>
<span class="w">	</span><span class="w">	</span><span class="n">message</span><span class="o">=</span><span class="s2">&quot;Â¿CÃ³mo me llamo?&quot;</span><span class="p">,</span>
<span class="w">	</span><span class="w">	</span><span class="n">system_message</span><span class="o">=</span><span class="s2">&quot;You are a friendly Chatbot. Always reply in the language in which the user is writing to you.&quot;</span><span class="p">,</span>
<span class="w">	</span><span class="w">	</span><span class="n">max_tokens</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span>
<span class="w">	</span><span class="w">	</span><span class="n">temperature</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span>
<span class="w">	</span><span class="w">	</span><span class="n">top_p</span><span class="o">=</span><span class="mf">0.95</span><span class="p">,</span>
<span class="w">	</span><span class="w">	</span><span class="n">api_name</span><span class="o">=</span><span class="s2">&quot;/chat&quot;</span>
<span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section class="section-block-code-cell-">
<div class="output-wrapper">
<div class="output-area">
<div class="prompt"></div>
<div class="output-subarea-output-stream-output-stdout-output-text">
<pre>Te llamas Luis. Â¿Hay algo mÃ¡s en lo que pueda ayudarte?
</pre>
</div>
</div>
</div>
</section>
<section class="section-block-markdown-cell">
<p>As we can see, we have two clients, each with their own conversation thread.</p>
</section>
<section class="section-block-markdown-cell">
<h2 id="Deploy backend with FastAPI, Langchain and Docker">Deploy backend with FastAPI, Langchain and Docker<a class="anchor-link" href="#Deploy backend with FastAPI, Langchain and Docker">Â¶</a></h2>
</section>
<section class="section-block-markdown-cell">
<p>Now we are going to do the same, create a chatbot backend, with the same model, but in this case using FastAPI, Langchain and Docker.</p>
</section>
<section class="section-block-markdown-cell">
<h3 id="Create space">Create space<a class="anchor-link" href="#Create space">Â¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>We need to create a new space, but in this case we will do it differently</p>
<ul>
  <li>We put a name, a description, and choose the license.</li>
  <li>We chose Docker as the type of SDK. When choosing Docker, templates will appear, so we selected a blank template.</li>
  <li>We select the HW on which we will deploy the backend, I will choose the free CPU, but you choose what you consider best.</li>
  <li>And lastly, we need to choose whether we want to create the space as public or private.</li>
</ul>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/backend-docker-create-space.webp" alt="backend docker - create space">
</section>
<section class="section-block-markdown-cell">
<h3 id="Code">Code<a class="anchor-link" href="#Code">Â¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Now, when creating the space, we see that we only have one file, the <code>README.md</code>. So we are going to have to create all the code ourselves.</p>
</section>
<section class="section-block-markdown-cell">
<h4 id="app.py">app.py<a class="anchor-link" href="#app.py">Â¶</a></h4>
</section>
<section class="section-block-markdown-cell">
<p>Let's create the application code</p>
</section>
<section class="section-block-markdown-cell">
<p>Let's start with the necessary libraries</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-python">from fastapi import FastAPI, HTTPException<br>from pydantic import BaseModel<br>from huggingface_hub import InferenceClient<br><br>from langchain_core.messages import HumanMessage, AIMessage<br>from langgraph.checkpoint.memory import MemorySaver<br>from langgraph.graph import START, MessagesState, StateGraph<br><br>import os<br>from dotenv import load_dotenv<br>load_dotenv()</code></pre></div>
      </section>
<p>We load <code>fastapi</code> to create the API routes, <code>pydantic</code> to create the query templates, <code>huggingface_hub</code> to create a language model, <code>langchain</code> to indicate whether messages are from the chatbot or the user, and <code>langgraph</code> to create the chatbot.</p>
<p>We also load <code>os</code> and <code>dotenv</code> to be able to load the environment variables.</p>
</section>
<section class="section-block-markdown-cell">
<p>We load the HuggingFace token</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-python"># HuggingFace token<br>HUGGINGFACE_TOKEN = os.environ.get("HUGGINGFACE_TOKEN", os.getenv("HUGGINGFACE_TOKEN"))</code></pre></div>
      </section>
</section>
<section class="section-block-markdown-cell">
<p>We create the language model</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-python"># Initialize the HuggingFace model<br>model = InferenceClient(<br>model="Qwen/Qwen2.5-72B-Instruct",<br>api_key=os.getenv("HUGGINGFACE_TOKEN")<br>)</code></pre></div>
      </section>
</section>
<section class="section-block-markdown-cell">
<p>We now create a function to call the model</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-python"># Define the function that calls the model<br>def call_model(state: MessagesState):<br>&#x20;&#x20;"""<br>&#x20;&#x20;Call the model with the given messages<br><br>&#x20;&#x20;Args:<br>&#x20;&#x20;&#x20;&#x20;state: MessagesState<br><br>&#x20;&#x20;Returns:<br>&#x20;&#x20;&#x20;&#x20;dict: A dictionary containing the generated text and the thread ID<br>&#x20;&#x20;"""<br>&#x20;&#x20;# Convert LangChain messages to HuggingFace format<br>&#x20;&#x20;hf_messages = []<br>&#x20;&#x20;for msg in state["messages"]:<br>&#x20;&#x20;&#x20;&#x20;if isinstance(msg, HumanMessage):<br>&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;hf_messages.append(&#123;"role": "user", "content": msg.content&#125;)<br>&#x20;&#x20;&#x20;&#x20;elif isinstance(msg, AIMessage):<br>&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;hf_messages.append(&#123;"role": "assistant", "content": msg.content&#125;)<br>    <br>&#x20;&#x20;# Call the API<br>&#x20;&#x20;response = model.chat_completion(<br>&#x20;&#x20;&#x20;&#x20;messages=hf_messages,<br>&#x20;&#x20;&#x20;&#x20;temperature=0.5,<br>&#x20;&#x20;&#x20;&#x20;max_tokens=64,<br>&#x20;&#x20;&#x20;&#x20;top_p=0.7<br>&#x20;&#x20;)<br>    <br>&#x20;&#x20;# Convert the response to LangChain format<br>&#x20;&#x20;ai_message = AIMessage(content=response.choices[0].message.content)<br>&#x20;&#x20;return &#123;"messages": state["messages"] + [ai_message]&#125;</code></pre></div>
      </section>
<p>We convert the messages from LangChain format to HuggingFace format, so we can use the language model.</p>
</section>
<section class="section-block-markdown-cell">
<p>We define a template for the queries</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-python">class QueryRequest(BaseModel):<br>query: str<br>thread_id: str = "default"</code></pre></div>
      </section>
<p>The queries will have a <code>query</code>, the user's message, and a <code>thread_id</code>, which is the identifier of the conversation thread and we will explain later what we use it for.</p>
</section>
<section class="section-block-markdown-cell">
<p>We create a LangGraph graph</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-python"># Define the graph<br>workflow = StateGraph(state_schema=MessagesState)<br><br># Define the node in the graph<br>workflow.add_edge(START, "model")<br>workflow.add_node("model", call_model)<br><br># Add memory<br>memory = MemorySaver()<br>graph_app = workflow.compile(checkpointer=memory)</code></pre></div>
      </section>
<p>With this, we create a LangGraph graph, which is a data structure that allows us to create a chatbot and manages the chatbot's state for us, including, among other things, the message history. This way, we don't have to do it ourselves.</p>
</section>
<section class="section-block-markdown-cell">
<p>We create the FastAPI application</p>
<div class='highlight'><pre><code class="language-python">app = FastAPI(title="LangChain FastAPI", description="API to generate text using LangChain and LangGraph")
</code></pre></div>
</section>
<section class="section-block-markdown-cell">
<p>We create the API endpoints</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-python"># Welcome endpoint<br>@app.get("/")<br>async def api_home():<br>"Welcome endpoint"<br>return &#123;"detail": "Welcome to FastAPI, Langchain, Docker tutorial"&#125;<br><br># Generate endpoint<br>@app.post("/generate")<br>async def generate(request: QueryRequest):<br>"""<br>Endpoint to generate text using the language model<br>    <br>Args:<br>request: QueryRequest<br>query: str<br>thread_id: str = "default"<br><br>Devuelve:<br>dict: A dictionary containing the generated text and the thread ID<br>"""<br>try:<br># Configure the thread ID<br>config = &#123;"configurable": &#123;"thread_id": request.thread_id&#125;&#125;<br>        <br># Create the input message<br>input_messages = [HumanMessage(content=request.query)]<br>        <br># Invoke the graph<br>output = graph_app.invoke(&#123;"messages": input_messages&#125;, config)<br>        <br># Get the model response<br>response = output["messages"][-1].content<br>        <br>return &#123;<br>"generated_text": "response",<br>"thread_id": request.thread_id<br>It seems like you&#39;ve provided an incomplete or incorrect Markdown text to translate. Could you please provide the correct Markdown text that needs translation?<br>except Exception as e:<br>raise HTTPException(status_code=500, detail=f"Error generating text: &#123;str(e)&#125;")</code></pre></div>
      </section>
<p>We have created the endpoint <code>/</code> that will return a text when we access the API, and the endpoint <code>/generate</code> which we will use to generate the text.</p>
<p>If we look at the <code>generate</code> function, we have the variable <code>config</code>, which is a dictionary that contains the <code>thread_id</code>. This <code>thread_id</code> allows us to maintain a message history for each user, so different users can use the same endpoint and have their own message history.</p>
</section>
<section class="section-block-markdown-cell">
<p>Finally, we have the code for the application to run.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-python">if __name__ == "__main__":<br>import uvicorn<br>uvicorn.run(app, host="0.0.0.0", port=7860)</code></pre></div>
      </section>
</section>
<section class="section-block-markdown-cell">
<p>Let's write all the code together</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-python">from fastapi import FastAPI, HTTPException<br>from pydantic import BaseModel<br>from huggingface_hub import InferenceClient<br><br>from langchain_core.messages import HumanMessage, AIMessage<br>from langgraph.checkpoint.memory import MemorySaver<br>from langgraph.graph import START, MessagesState, StateGraph<br><br>import os<br>from dotenv import load_dotenv<br>load_dotenv()<br><br># HuggingFace token<br>HUGGINGFACE_TOKEN = os.environ.get("HUGGINGFACE_TOKEN", os.getenv("HUGGINGFACE_TOKEN"))<br><br># Initialize the HuggingFace model<br>model = InferenceClient(<br>model="Qwen/Qwen2.5-72B-Instruct",<br>api_key=os.getenv("HUGGINGFACE_TOKEN")<br>)<br><br># Define the function that calls the model<br>def call_model(state: MessagesState):<br>"""<br>Llamar al modelo con los mensajes dados<br><br>Args:<br>state: MessagesState<br><br>Devuelve:<br>dict: A dictionary containing the generated text and the thread ID<br>"""<br># Convert LangChain messages to HuggingFace format<br>hf_messages = []<br>for msg in state["messages"]:<br>if isinstance(msg, HumanMessage):<br>hf_messages.append(&#123;"role": "user", "content": msg.content&#125;)<br>elif isinstance(msg, AIMessage):<br>hf_messages.append(&#123;"role": "assistant", "content": msg.content&#125;)<br>    <br># Call the API<br>response = model.chat_completion(<br>messages=hf_messages,<br>temperature=0.5,<br>max_tokens=64,<br>top_p=0.7<br>)<br>    <br># Convert the response to LangChain format<br>ai_message = AIMessage(content=response.choices[0].message.content)<br>return &#123;"messages": state["messages"] + [ai_message]&#125;<br><br># Define the graph<br>workflow = StateGraph(state_schema=MessagesState)<br><br># Define the node in the graph<br>workflow.add_edge(START, "model")<br>workflow.add_node("model", call_model)<br><br># Add memory<br>memory = MemorySaver()<br>graph_app = workflow.compile(checkpointer=memory)<br><br># Define the data model for the request<br>class QueryRequest(BaseModel):<br>query: str<br>thread_id: str = "default"<br><br># Create the FastAPI application<br>app = FastAPI(title="LangChain FastAPI", description="API to generate text using LangChain and LangGraph")<br><br># Welcome endpoint<br>@app.get("/")<br>async def api_home():<br>"Welcome endpoint"<br>return &#123;"detail": "Welcome to FastAPI, Langchain, Docker tutorial"&#125;<br><br># Generate endpoint<br>@app.post("/generate")<br>async def generate(request: QueryRequest):<br>"""<br>Endpoint to generate text using the language model<br>    <br>Args:<br>request: QueryRequest<br>query: str<br>thread_id: str = "default"<br><br>Returns:<br>dict: A dictionary containing the generated text and the thread ID<br>"""<br>try:<br># Configure the thread ID<br>config = &#123;"configurable": &#123;"thread_id": request.thread_id&#125;&#125;<br>        <br># Create the input message<br>input_messages = [HumanMessage(content=request.query)]<br>        <br># Invoke the graph<br>output = graph_app.invoke(&#123;"messages": input_messages&#125;, config)<br>        <br># Get the model response<br>response = output["messages"][-1].content<br>        <br>return &#123;<br>"generated_text": "response,"<br>"thread_id": request.thread_id<br>&#125;<br>except Exception as e:<br>raise HTTPException(status_code=500, detail=f"Error generating text: &#123;str(e)&#125;")<br><br>if __name__ == "__main__":<br>import uvicorn<br>uvicorn.run(app, host="0.0.0.0", port=7860)</code></pre></div>
      </section>
</section>
<section class="section-block-markdown-cell">
<h4 id="Dockerfile">Dockerfile<a class="anchor-link" href="#Dockerfile">Â¶</a></h4>
</section>
<section class="section-block-markdown-cell">
<p>Now we see how to create the Dockerfile</p>
</section>
<section class="section-block-markdown-cell">
<p>First we indicate which image we are going to start from</p>
<div class='highlight'><pre><code class="language-dockerfile">FROM python:3.13-slim
</code></pre></div>
</section>
<section class="section-block-markdown-cell">
<p>Now we create the working directory</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-dockerfile">RUN useradd -m -u 1000 user<br>WORKDIR /app</code></pre></div>
      </section>
</section>
<section class="section-block-markdown-cell">
<p>We copy the file with the dependencies and install</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-dockerfile">COPY --chown=user ./requirements.txt requirements.txt<br>RUN pip install --no-cache-dir --upgrade -r requirements.txt</code></pre></div>
      </section>
</section>
<section class="section-block-markdown-cell">
<p>We copy the rest of the code</p>
<div class='highlight'><pre><code class="language-dockerfile">COPY --chown=user . /app
</code></pre></div>
</section>
<section class="section-block-markdown-cell">
<p>We expose port 7860</p>
<div class='highlight'><pre><code class="language-dockerfile">EXPOSE 7860
</code></pre></div>
</section>
<section class="section-block-markdown-cell">
<p>We create the environment variables</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-dockerfile">RUN --mount=type=secret,id=HUGGINGFACE_TOKEN,mode=0444,required=true \<br>test -f /run/secrets/HUGGINGFACE_TOKEN &amp;&amp; echo "Secret exists!"</code></pre></div>
      </section>
</section>
<section class="section-block-markdown-cell">
<p>Lastly, we indicate the command to run the application</p>
<div class='highlight'><pre><code class="language-dockerfile">CMD ["uvicorn", "app:app", "--host", "0.0.0.0", "--port", "7860"]
</code></pre></div>
</section>
<section class="section-block-markdown-cell">
<p>Now we put it all together</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-dockerfile">FROM python:3.13-slim<br><br>RUN useradd -m -u 1000 user<br>WORKDIR /app<br><br>COPY --chown=user ./requirements.txt requirements.txt<br>RUN pip install --no-cache-dir --upgrade -r requirements.txt<br><br>COPY --chown=user . /app<br><br>EXPOSE 7860<br><br>RUN --mount=type=secret,id=HUGGINGFACE_TOKEN,mode=0444,required=true \<br>test -f /run/secrets/HUGGINGFACE_TOKEN &amp;&amp; echo "Secret exists!"<br><br>CMD ["uvicorn", "app:app", "--host", "0.0.0.0", "--port", "7860"]</code></pre></div>
      </section>
</section>
<section class="section-block-markdown-cell">
<h4 id="requirements.txt">requirements.txt<a class="anchor-link" href="#requirements.txt">Â¶</a></h4>
</section>
<section class="section-block-markdown-cell">
<p>We create the file with the dependencies</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-txt">fastapi<br>uvicorn<br>requests<br>pydantic&gt;=2.0.0<br>langchain<br>langchain-huggingface<br>langchain-core<br>langgraph &gt; 0.2.27<br>python-dotenv.2.11</code></pre></div>
      </section>
</section>
<section class="section-block-markdown-cell">
<h4 id="README.md">README.md<a class="anchor-link" href="#README.md">Â¶</a></h4>
</section>
<section class="section-block-markdown-cell">
<p>Finally, we create the README.md file with information about the space and instructions for HuggingFace.</p>
<pre><code class="language-md">
---
title: SmolLM2 Backend
emoji: ðŸ“Š
colorFrom: yellow
colorTo: red
sdk: docker
pinned: false
license: apache-2.0
short_description: Backend of SmolLM2 chat
app_port: 7860
---

# SmolLM2 Backend

This project implements a FastAPI API that uses LangChain and LangGraph to generate text with the Qwen2.5-72B-Instruct model from HuggingFace.

## Configuration

### In HuggingFace Spaces

This project is designed to run in HuggingFace Spaces. To configure it:

1. Create a new Space in HuggingFace with SDK Docker
2. Configure the `HUGGINGFACE_TOKEN` or `HF_TOKEN` environment variable in the Space configuration:
   - Go to the "Settings" tab of your Space
   - Scroll down to the "Repository secrets" section
   - Add a new variable with the name `HUGGINGFACE_TOKEN` and your token as the value
   - Save the changes

### Local development

For local development:

1. Clone this repository
2. Create a `.env` file in the project root with your HuggingFace token:
   ```
   HUGGINGFACE_TOKEN=your_token_here
   ```
3. Install the dependencies:
   ```
   pip install -r requirements.txt
   ```

## Local execution

```bash
uvicorn app:app --reload
```

The API will be available at `http://localhost:8000`.

## Endpoints

### GET `/`

Welcome endpoint that returns a greeting message.

### POST `/generate`

Endpoint to generate text using the language model.

**Request parameters:**
```json
&#123;
  "query": "Your question here",
  "thread_id": "optional_thread_identifier"
&#125;
```

**Response:**
```json
&#123;
  "generated_text": "Generated text by the model",
  "thread_id": "thread identifier"
&#125;
```

## Docker

To run the application in a Docker container:

```bash
# Build the image
docker build -t smollm2-backend .

# Run the container
docker run -p 8000:8000 --env-file .env smollm2-backend
```

## API documentation

The interactive API documentation is available at:
- Swagger UI: `http://localhost:8000/docs`
- ReDoc: `http://localhost:8000/redoc`
</code></pre>
</section>
<section class="section-block-markdown-cell">
<h3 id="HuggingFace Token">HuggingFace Token<a class="anchor-link" href="#HuggingFace Token">Â¶</a></h3>
<p>If you've noticed in the code and the Dockerfile, we used a HuggingFace token, so we will have to create one. In our HuggingFace account, we create a <a href="https://huggingface.co/settings/tokens/new?tokenType=fineGrained">new token</a>, give it a name, and grant it the following permissions:</p>
<ul>
  <li>Read access to contents of all repos under your personal namespace</li>
  <li>Read access to contents of all repos under your personal namespace</li>
  <li>Make calls to inference providers</li>
  <li>Make calls to Inference Endpoints</li>
</ul>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/backend-docker-token.webp" alt="backend docker - token">
</section>
<section class="section-block-markdown-cell">
<h3 id="Add the token to the space secrets">Add the token to the space secrets<a class="anchor-link" href="#Add the token to the space secrets">Â¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>Now that we have the token, we need to add it to the space. At the top of the app, we will see a button called <code>Settings</code>, we press it and we will be able to see the space configuration section.</p>
<p>If we scroll down, we can see a section where we can add <code>Variables</code> and <code>Secrets</code>. In this case, since we are adding a token, we will add it to the <code>Secrets</code>.</p>
<p>We set the name to <code>HUGGINGFACE_TOKEN</code> and the value of the token.</p>
</section>
<section class="section-block-markdown-cell">
<h3 id="Deployment">Deployment<a class="anchor-link" href="#Deployment">Â¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>If we have cloned the space, we need to make a commit and a push. If we have modified the files in HuggingFace, saving them is enough.</p>
<p>So when the changes are in HuggingFace, we will have to wait a few seconds for the space to be built and then we can use it.</p>
<p>In this case, we have only built a backend, so what we will see when entering the space is what we defined in the endpoint <code>/</code></p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/backend-docker-space.webp" alt="backend docker - space">
</section>
<section class="section-block-markdown-cell">
<h3 id="Backend URL">Backend URL<a class="anchor-link" href="#Backend URL">Â¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>We need to know the URL of the backend to be able to make API calls. To do this, we have to click on the three dots in the top right corner to see the options.</p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/backend-docker-options.webp" alt="backend docker - options">
</section>
<section class="section-block-markdown-cell">
<p>In the drop-down menu, we click on <code>Embed this Space</code>, which will open a window indicating how to embed the space with an iframe and also providing the URL of the space.</p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/backend-docker-embed.webp" alt="backend docker - embed">
</section>
<section class="section-block-markdown-cell">
<p>If we now go to that URL, we will see the same as in space.</p>
</section>
<section class="section-block-markdown-cell">
<h3 id="Documentation">Documentation<a class="anchor-link" href="#Documentation">Â¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>FastAPI, besides being an extremely fast API, has another great advantage: it generates documentation automatically.</p>
</section>
<section class="section-block-markdown-cell">
<p>If we add <code>/docs</code> to the URL we saw earlier, we will be able to see the API documentation with <code>Swagger UI</code>.</p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/backend-docker-swagger-doc.webp" alt="backend docker - swagger doc">
</section>
<section class="section-block-markdown-cell">
<p>We can also add <code>/redoc</code> to the URL to view the documentation with <code>ReDoc</code>.</p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/backend-docker-redoc.webp" alt="backend docker - redoc doc">
</section>
<section class="section-block-markdown-cell">
<h3 id="API Test">API Test<a class="anchor-link" href="#API Test">Â¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>The good thing about <code>Swagger UI</code> documentation is that it allows us to test the API directly from the browser.</p>
</section>
<section class="section-block-markdown-cell">
<p>We add <code>/docs</code> to the URL we obtained, open the dropdown for the <code>/generate</code> endpoint, and click on <code>Try it out</code>. We modify the value of the <code>query</code> and the <code>thread_id</code>, and then press <code>Execute</code>.</p>
<p>In the first case I will put</p>
<ul>
  <li><strong>query</strong>: Hello, how are you? I'm Maximo</li>
  <li><strong>thread_id</strong>: user1</li>
</ul>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/backend-docker-test-API.webp" alt="backend docker - test API">
</section>
<section class="section-block-markdown-cell">
<p>We received the following response: <code>Hello Maximo! I&#x27;m doing very well, thank you for asking. How are you? What can I help you with today?</code></p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/backend-docker-response1-user1.webp" alt="backend docker -response 1 - user1">
</section>
<section class="section-block-markdown-cell">
<p>Let's now try the same question but with a different <code>thread_id</code>, in this case <code>user2</code>.</p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/backend-docker-query1-user2.webp" alt="backend docker - query 1 - user2">
</section>
<section class="section-block-markdown-cell">
<p>And it responds like this <code>Hello Luis! I&#x27;m doing very well, thank you for asking. How are you? What can I help you with today?</code></p>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/backend-docker-response1-user2.webp" alt="backend docker - response 1 - user2">
</section>
<section class="section-block-markdown-cell">
<p>Now we ask for our name with both users and get this</p>
<ul>
  <li>For the user <strong>user1</strong>: <code>Your name is Maximus. Is there anything else I can help you with?</code></li>
  <li>For the user <strong>user2</strong>: <code>You are called Luis. Is there anything else I can help you with today, Luis?</code></li>
</ul>
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/backend-docker-response2-user1.webp" alt="backend docker - response 2 - user1">
<img src="https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/backend-docker-response2-user2.webp" alt="backend docker - response 2 - user2">
</section>
<section class="section-block-markdown-cell">
<h2 id="Deploy backend with Gradio and model running on the server">Deploy backend with Gradio and model running on the server<a class="anchor-link" href="#Deploy backend with Gradio and model running on the server">Â¶</a></h2>
</section>
<section class="section-block-markdown-cell">
<p>The two backends we have created are actually not running a model, but rather making calls to HuggingFace Inference Endpoints. However, you might want everything to run on the server, including the model. It could be that you have fine-tuned an LLM for your use case, so you can no longer make calls to Inference Endpoints.</p>
<p>So let's see how to modify the code of the two backends to run a model on the server and not make calls to Inference Endpoints.</p>
</section>
<section class="section-block-markdown-cell">
<h3 id="Create Space">Create Space<a class="anchor-link" href="#Create Space">Â¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>When creating the space on HuggingFace, we do the same as before: create a new space, give it a name and a description, select Gradio as the SDK, choose the hardware on which we will deploy itâ€”I select the most basic and free hardwareâ€”and choose whether to make it private or public.</p>
</section>
<section class="section-block-markdown-cell">
<h3 id="Code">Code<a class="anchor-link" href="#Code">Â¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>We need to make changes in <code>app.py</code> and <code>requirements.txt</code> so that instead of making calls to Inference Endpoints, the model runs locally.</p>
</section>
<section class="section-block-markdown-cell">
<h4 id="app.py">app.py<a class="anchor-link" href="#app.py">Â¶</a></h4>
</section>
<section class="section-block-markdown-cell">
<p>The changes we have to make are</p>
</section>
<section class="section-block-markdown-cell">
<p>Import <code>AutoModelForCausalLM</code> and <code>AutoTokenizer</code> from the <code>transformers</code> library and import <code>torch</code></p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-python">from transformers import AutoModelForCausalLM, AutoTokenizer<br>import torch</code></pre></div>
      </section>
</section>
<section class="section-block-markdown-cell">
<p>Instead of creating a model using <code>InferenceClient</code>, we create it with <code>AutoModelForCausalLM</code> and <code>AutoTokenizer</code>.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-python"># Load the model and the tokenizer<br>model_name = "HuggingFaceTB/SmolLM2-1.7B-Instruct"<br>tokenizer = AutoTokenizer.from_pretrained(model_name)<br>model = AutoModelForCausalLM.from_pretrained(<br>model_name,<br>torch_dtype=torch.float16,<br>device_map="auto"<br>)</code></pre></div>
      </section>
<p>I use <code>HuggingFaceTB/SmolLM2-1.7B-Instruct</code> because it is a fairly capable model with only 1.7B parameters. Since I chose the most basic hardware, I can't use very large models. If you want to use a larger model, you have two options: use the free hardware and accept that inference will be slower, or use more powerful hardware, but at a cost.</p>
</section>
<section class="section-block-markdown-cell">
<p>Modify the <code>respond</code> function to build the prompt with the necessary structure for the <code>transformers</code> library, tokenize the prompt, perform inference, and detokenize the response.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-python">def respond(<br>message,<br>history: list[tuple[str, str]],<br>It seems like you&#39;ve mentioned a "system_message," but there&#39;s no specific content to translate. If you have a markdown text that needs translation, please provide it and I&#39;ll translate it for you.<br>max_tokens,<br>temperature,<br>top_p,<br>):<br># Build the prompt with the correct format<br>prompt = f"&lt;|system|&gt;\n&#123;system_message&#125;&lt;/s&gt;\n"<br>    <br>for val in history:<br>if val[0]:<br>prompt += f"&lt;|user|&gt;\n&#123;val[0]&#125;&lt;/s&gt;\n"<br>if val[1]:<br>prompt += f"&lt;|assistant|&gt;\n&#123;val[1]&#125;&lt;/s&gt;\n"<br>    <br>prompt += f"&lt;|user|&gt;\n&#123;message&#125;&lt;/s&gt;\n&lt;|assistant|&gt;\n"<br>    <br># Tokenize the prompt<br>inputs = tokenizer(prompt, return_tensors="pt").to(model.device)<br>    <br># Generate the response<br>outputs = model.generate(<br>**inputs,**<br>max_new_tokens=max_tokens,<br>temperature=temperature,<br>top_p=top_p,<br>do_sample=True,<br>pad_token_id=tokenizer.eos_token_id<br>)<br>    <br># Decode the response<br>response = tokenizer.decode(outputs[0], skip_special_tokens=True)<br>    <br># Extract only the assistant&#39;s response part<br>response = response.split("&lt;|assistant|&gt;\n")[-1].strip()<br>    <br>yield response</code></pre></div>
      </section>
</section>
<section class="section-block-markdown-cell">
<p>Here I leave all the code</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-python">import gradio as gr<br>from transformers import AutoModelForCausalLM, AutoTokenizer<br>import torch<br><br>"""<br>For more information on `huggingface_hub` Inference API support, please check the docs: https://huggingface.co/docs/huggingface_hub/v0.22.2/en/guides/inference<br>"""<br><br># Cargar el modelo y el tokenizer<br>model_name = "HuggingFaceTB/SmolLM2-1.7B-Instruct"<br>tokenizer = AutoTokenizer.from_pretrained(model_name)<br>model = AutoModelForCausalLM.from_pretrained(<br>&#x20;&#x20;model_name,<br>&#x20;&#x20;torch_dtype=torch.float16,<br>&#x20;&#x20;device_map="auto"<br>)<br><br>def respond(<br>&#x20;&#x20;message,<br>&#x20;&#x20;history: list[tuple[str, str]],<br>&#x20;&#x20;system_message,<br>&#x20;&#x20;max_tokens,<br>&#x20;&#x20;temperature,<br>&#x20;&#x20;top_p,<br>):<br>&#x20;&#x20;# Construir el prompt con el formato correcto<br>&#x20;&#x20;prompt = f"&lt;|system|&gt;\n&#123;system_message&#125;&lt;/s&gt;\n"<br>    <br>&#x20;&#x20;for val in history:<br>&#x20;&#x20;&#x20;&#x20;if val[0]:<br>&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;prompt += f"&lt;|user|&gt;\n&#123;val[0]&#125;&lt;/s&gt;\n"<br>&#x20;&#x20;&#x20;&#x20;if val[1]:<br>&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;prompt += f"&lt;|assistant|&gt;\n&#123;val[1]&#125;&lt;/s&gt;\n"<br>    <br>&#x20;&#x20;prompt += f"&lt;|user|&gt;\n&#123;message&#125;&lt;/s&gt;\n&lt;|assistant|&gt;\n"<br>    <br>&#x20;&#x20;# Tokenizar el prompt<br>&#x20;&#x20;inputs = tokenizer(prompt, return_tensors="pt").to(model.device)<br>    <br>&#x20;&#x20;# Generar la respuesta<br>&#x20;&#x20;outputs = model.generate(<br>&#x20;&#x20;&#x20;&#x20;**inputs,<br>&#x20;&#x20;&#x20;&#x20;max_new_tokens=max_tokens,<br>&#x20;&#x20;&#x20;&#x20;temperature=temperature,<br>&#x20;&#x20;&#x20;&#x20;top_p=top_p,<br>&#x20;&#x20;&#x20;&#x20;do_sample=True,<br>&#x20;&#x20;&#x20;&#x20;pad_token_id=tokenizer.eos_token_id<br>&#x20;&#x20;)<br>    <br>&#x20;&#x20;# Decodificar la respuesta<br>&#x20;&#x20;response = tokenizer.decode(outputs[0], skip_special_tokens=True)<br>    <br>&#x20;&#x20;# Extraer solo la parte de la respuesta del asistente<br>&#x20;&#x20;response = response.split("&lt;|assistant|&gt;\n")[-1].strip()<br>    <br>&#x20;&#x20;yield response<br><br><br>"""<br>For information on how to customize the ChatInterface, peruse the gradio docs: https://www.gradio.app/docs/gradio/chatinterface<br>"""<br>demo = gr.ChatInterface(<br>&#x20;&#x20;respond,<br>&#x20;&#x20;additional_inputs=[<br>&#x20;&#x20;&#x20;&#x20;gr.Textbox(<br>&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;value="You are a friendly Chatbot. Always reply in the language in which the user is writing to you.", <br>&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;label="System message"<br>&#x20;&#x20;&#x20;&#x20;),<br>&#x20;&#x20;&#x20;&#x20;gr.Slider(minimum=1, maximum=2048, value=512, step=1, label="Max new tokens"),<br>&#x20;&#x20;&#x20;&#x20;gr.Slider(minimum=0.1, maximum=4.0, value=0.7, step=0.1, label="Temperature"),<br>&#x20;&#x20;&#x20;&#x20;gr.Slider(<br>&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;minimum=0.1,<br>&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;maximum=1.0,<br>&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;value=0.95,<br>&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;step=0.05,<br>&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;label="Top-p (nucleus sampling)",<br>&#x20;&#x20;&#x20;&#x20;),<br>&#x20;&#x20;],<br>)<br><br><br>if __name__ == "__main__":<br>&#x20;&#x20;demo.launch()</code></pre></div>
      </section>
</section>
<section class="section-block-markdown-cell">
<h4 id="requirements.txt">requirements.txt<a class="anchor-link" href="#requirements.txt">Â¶</a></h4>
</section>
<section class="section-block-markdown-cell">
<p>In this file, we need to add the new libraries we are going to use, in this case <code>transformers</code>, <code>accelerate</code> and <code>torch</code>. The entire file would be:</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-txt">huggingface_hub==0.25.2<br>gradio&gt;=4.0.0<br>transformers&gt;=4.36.0<br>torch&gt;=2.0.0<br>accelerate&gt;=0.25.0</code></pre></div>
      </section>
</section>
<section class="section-block-markdown-cell">
<h4 id="API Test">API Test<a class="anchor-link" href="#API Test">Â¶</a></h4>
</section>
<section class="section-block-markdown-cell">
<p>We deploy the space and test the API directly.</p>
</section>
<section class="section-block-code-cell-">
<div class="input-code">
<div class="highlight hl-ipython3"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">gradio_client</span><span class="w"> </span><span class="kn">import</span> <span class="n">Client</span>
<span class="w"> </span>
<span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="s2">&quot;Maximofn/SmolLM2_localModel&quot;</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span>
<span class="w">	</span><span class="w">	</span><span class="n">message</span><span class="o">=</span><span class="s2">&quot;Hola, Â¿cÃ³mo estÃ¡s? Me llamo MÃ¡ximo&quot;</span><span class="p">,</span>
<span class="w">	</span><span class="w">	</span><span class="n">system_message</span><span class="o">=</span><span class="s2">&quot;You are a friendly Chatbot. Always reply in the language in which the user is writing to you.&quot;</span><span class="p">,</span>
<span class="w">	</span><span class="w">	</span><span class="n">max_tokens</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span>
<span class="w">	</span><span class="w">	</span><span class="n">temperature</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span>
<span class="w">	</span><span class="w">	</span><span class="n">top_p</span><span class="o">=</span><span class="mf">0.95</span><span class="p">,</span>
<span class="w">	</span><span class="w">	</span><span class="n">api_name</span><span class="o">=</span><span class="s2">&quot;/chat&quot;</span>
<span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section class="section-block-code-cell-">
<div class="output-wrapper">
<div class="output-area">
<div class="prompt"></div>
<div class="output-subarea-output-stream-output-stdout-output-text">
<pre>Loaded as API: https://maximofn-smollm2-localmodel.hf.space âœ”
Hola MÃ¡ximo, soy su Chatbot amable y estoy funcionando bien. Gracias por tu mensaje, me complace ayudarte hoy en dÃ­a. Â¿CÃ³mo puedo servirte?
</pre>
</div>
</div>
</div>
</section>
<section class="section-block-markdown-cell">
<p>I'm surprised how quickly the model responds even on a server without a GPU.</p>
</section>
<section class="section-block-markdown-cell">
<h2 id="Deploy backend with FastAPI, Langchain and Docker and model running on the server">Deploy backend with FastAPI, Langchain and Docker and model running on the server<a class="anchor-link" href="#Deploy backend with FastAPI, Langchain and Docker and model running on the server">Â¶</a></h2>
</section>
<section class="section-block-markdown-cell">
<p>Now we do the same as before, but with FastAPI, LangChain and Docker.</p>
</section>
<section class="section-block-markdown-cell">
<h3 id="Create Space">Create Space<a class="anchor-link" href="#Create Space">Â¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>When creating the space on HuggingFace, we do the same as before: create a new space, give it a name and a description, select Docker as the SDK, choose the hardware on which we are going to deploy itâ€”I select the most basic and free hardwareâ€”and decide whether to make it private or public.</p>
</section>
<section class="section-block-markdown-cell">
<h3 id="Code">Code<a class="anchor-link" href="#Code">Â¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<h4 id="app.py">app.py<a class="anchor-link" href="#app.py">Â¶</a></h4>
</section>
<section class="section-block-markdown-cell">
<p>We no longer import <code>InferenceClient</code> and now import <code>AutoModelForCausalLM</code> and <code>AutoTokenizer</code> from the <code>transformers</code> library and import <code>torch</code>.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-python">from transformers import AutoModelForCausalLM, AutoTokenizer<br>import torch</code></pre></div>
      </section>
</section>
<section class="section-block-markdown-cell">
<p>We instantiate the model and the tokenizer with <code>AutoModelForCausalLM</code> and <code>AutoTokenizer</code>.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-python"># Initialize the model and tokenizer<br>print("Loading model and tokenizer...")<br>device = "cuda" if torch.cuda.is_available() else "cpu"<br>model_name = "HuggingFaceTB/SmolLM2-1.7B-Instruct"<br><br>try:<br># Load the model in BF16 format for better performance and lower memory usage<br>tokenizer = AutoTokenizer.from_pretrained(model_name)<br>    <br>if device == "cuda":<br>print("Using GPU for the model...")<br>model = AutoModelForCausalLM.from_pretrained(<br>model_name,<br>torch_dtype=torch.bfloat16,<br>device_map="auto",<br>low_cpu_mem_usage=True<br>)<br>else:<br>print("Using CPU for the model...")<br>model = AutoModelForCausalLM.from_pretrained(<br>model_name,<br>device_map=&#123;"": device&#125;,<br>torch_dtype=torch.float32<br>)<br><br>print(f"Model successfully loaded on: &#123;device&#125;")<br>except Exception as e:<br>print(f"Error loading the model: &#123;str(e)&#125;")<br>raise</code></pre></div>
      </section>
</section>
<section class="section-block-markdown-cell">
<p>We redefine the <code>call_model</code> function to perform inference with the local model.</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-python"># Define the function that calls the model<br>def call_model(state: MessagesState):<br>&#x20;&#x20;"""<br>&#x20;&#x20;Call the model with the given messages<br><br>&#x20;&#x20;Args:<br>&#x20;&#x20;&#x20;&#x20;state: MessagesState<br><br>&#x20;&#x20;Returns:<br>&#x20;&#x20;&#x20;&#x20;dict: A dictionary containing the generated text and the thread ID<br>&#x20;&#x20;"""<br>&#x20;&#x20;# Convert LangChain messages to chat format<br>&#x20;&#x20;messages = []<br>&#x20;&#x20;for msg in state["messages"]:<br>&#x20;&#x20;&#x20;&#x20;if isinstance(msg, HumanMessage):<br>&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;messages.append(&#123;"role": "user", "content": msg.content&#125;)<br>&#x20;&#x20;&#x20;&#x20;elif isinstance(msg, AIMessage):<br>&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;messages.append(&#123;"role": "assistant", "content": msg.content&#125;)<br>    <br>&#x20;&#x20;# Prepare the input using the chat template<br>&#x20;&#x20;input_text = tokenizer.apply_chat_template(messages, tokenize=False)<br>&#x20;&#x20;inputs = tokenizer.encode(input_text, return_tensors="pt").to(device)<br>    <br>&#x20;&#x20;# Generate response<br>&#x20;&#x20;outputs = model.generate(<br>&#x20;&#x20;&#x20;&#x20;inputs,<br>&#x20;&#x20;&#x20;&#x20;max_new_tokens=512,  # Increase the number of tokens for longer responses<br>&#x20;&#x20;&#x20;&#x20;temperature=0.7,<br>&#x20;&#x20;&#x20;&#x20;top_p=0.9,<br>&#x20;&#x20;&#x20;&#x20;do_sample=True,<br>&#x20;&#x20;&#x20;&#x20;pad_token_id=tokenizer.eos_token_id<br>&#x20;&#x20;)<br>    <br>&#x20;&#x20;# Decode and clean the response<br>&#x20;&#x20;response = tokenizer.decode(outputs[0], skip_special_tokens=True)<br>&#x20;&#x20;# Extract only the assistant&#39;s response (after the last user message)<br>&#x20;&#x20;response = response.split("Assistant:")[-1].strip()<br>    <br>&#x20;&#x20;# Convert the response to LangChain format<br>&#x20;&#x20;ai_message = AIMessage(content=response)<br>&#x20;&#x20;return &#123;"messages": state["messages"] + [ai_message]&#125;</code></pre></div>
      </section>
</section>
<section class="section-block-markdown-cell">
<h4 id="requirements.txt">requirements.txt<a class="anchor-link" href="#requirements.txt">Â¶</a></h4>
</section>
<section class="section-block-markdown-cell">
<p>We need to remove <code>langchain-huggingface</code> and add <code>transformers</code>, <code>accelerate</code> and <code>torch</code> in the <code>requirements.txt</code> file. The file would look like:</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-txt">fastapi<br>uvicorn<br>requests<br>pydantic&gt;=2.0.0<br>langchain&gt;=0.1.0<br>langchain-core&gt;=0.1.10<br>langgraph&gt;=0.2.27<br>python-dotenv&gt;=1.0.0<br>transformers&gt;=4.36.0<br>torch&gt;=2.0.0<br>accelerate&gt;=0.26.0</code></pre></div>
      </section>
</section>
<section class="section-block-markdown-cell">
<h4 id="Dockerfile">Dockerfile<a class="anchor-link" href="#Dockerfile">Â¶</a></h4>
</section>
<section class="section-block-markdown-cell">
<p>We no longer need to have <code>RUN --mount=type=secret,id=HUGGINGFACE_TOKEN,mode=0444,required=true</code> because since the model will be on the server and we won't be making calls to Inference Endpoints, we don't need the token. The file would look like:</p>
<section class="section-block-markdown-cell">
      <div class='highlight'><pre><code class="language-dockerfile">FROM python:3.13-slim<br><br>RUN useradd -m -u 1000 user<br>WORKDIR /app<br><br>COPY --chown=user ./requirements.txt requirements.txt<br>RUN pip install --no-cache-dir --upgrade -r requirements.txt<br><br>COPY --chown=user . /app<br><br>EXPOSE 7860<br><br>CMD ["uvicorn", "app:app", "--host", "0.0.0.0", "--port", "7860"]</code></pre></div>
      </section>
</section>
<section class="section-block-markdown-cell">
<h3 id="API Test">API Test<a class="anchor-link" href="#API Test">Â¶</a></h3>
</section>
<section class="section-block-markdown-cell">
<p>We deploy the space and test the API. In this case, I will test it directly from Python.</p>
</section>
<section class="section-block-code-cell-">
<div class="input-code">
<div class="highlight hl-ipython3"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">requests</span>
<span class="w"> </span>
<span class="n">url</span> <span class="o">=</span> <span class="s2">&quot;https://maximofn-smollm2-backend-localmodel.hf.space/generate&quot;</span>
<span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
<span class="w">    </span><span class="s2">&quot;query&quot;</span><span class="p">:</span> <span class="s2">&quot;Hola, Â¿cÃ³mo estÃ¡s?&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="s2">&quot;thread_id&quot;</span><span class="p">:</span> <span class="s2">&quot;user1&quot;</span>
<span class="p">}</span>
<span class="w"> </span>
<span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">json</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
<span class="k">if</span> <span class="n">response</span><span class="o">.</span><span class="n">status_code</span> <span class="o">==</span> <span class="mi">200</span><span class="p">:</span>
<span class="w">    </span><span class="n">result</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">json</span><span class="p">()</span>
<span class="w">    </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Respuesta:&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="s2">&quot;generated_text&quot;</span><span class="p">])</span>
<span class="w">    </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Thread ID:&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="s2">&quot;thread_id&quot;</span><span class="p">])</span>
<span class="k">else</span><span class="p">:</span>
<span class="w">    </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error:&quot;</span><span class="p">,</span> <span class="n">response</span><span class="o">.</span><span class="n">status_code</span><span class="p">,</span> <span class="n">response</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section class="section-block-code-cell-">
<div class="output-wrapper">
<div class="output-area">
<div class="prompt"></div>
<div class="output-subarea-output-stream-output-stdout-output-text">
<pre>Respuesta: system
You are a friendly Chatbot. Always reply in the language in which the user is writing to you.
user
Hola, Â¿cÃ³mo estÃ¡s?
assistant
Estoy bien, gracias por preguntar. Estoy muy emocionado de la semana que viene.
Thread ID: user1
</pre>
</div>
</div>
</div>
</section>
<section class="section-block-markdown-cell">
<p>This takes a bit longer than the previous one. In reality, it takes the normal time for a model running on a server without a GPU. The odd thing is when we deploy it on Gradio. I don't know what HuggingFace does behind the scenes, or maybe it's just a coincidence.</p>
</section>
<section class="section-block-markdown-cell">
<h2 id="Conclusions">Conclusions<a class="anchor-link" href="#Conclusions">Â¶</a></h2>
</section>
<section class="section-block-markdown-cell">
<p>We have seen how to create a backend with an LLM, both by making calls to the HuggingFace Inference Endpoint and by making calls to a model running locally. We have seen how to do this with Gradio or with FastAPI, Langchain, and Docker.</p>
</section>
<section class="section-block-markdown-cell">
<p>From here you have the knowledge to deploy your own models, even if they are not LLMs, they could be multimodal models. From here you can do whatever you want.</p>
</section>