<?xml version='1.0' encoding='utf-8'?>
<notebook>
  <markdown># Introduction to Python</markdown>
  <markdown> &gt; Disclaimer: This post has been translated to English using a machine translation model. Please, let me know if you find any mistakes.</markdown>
  <markdown>## 1. Summary</markdown>
  <markdown>Let's make a brief introduction to Python, explaining the data types we have, operators, the use of functions and classes. Additionally, we will see how to use iterable objects, how to use modules, etc.

![python](https://images.maximofn.com/icon-python.webp)</markdown>
  <markdown>## 2. Data types in Python</markdown>
  <markdown>There are 7 data types in Python



1. Text type: `str`
2. Numerical: `int`, `float`, `complex`
3. Sequences: `list`, `tuple`, `range`
4. Mapping: `dict`
5. Sets: `set`, `frozenset`
6. Booleans: `bool`
7. Binaries: `bytes`, `bytearray`, `memoryview`

</markdown>
  <markdown>We can get the data type using the `type()` function.</markdown>
  <input_code>type(5.)</input_code>
  <output_code>float</output_code>
  <markdown>Python is a dynamically typed language, which means you can have a variable of one type and then assign it another type.</markdown>
  <input_code>a = 5
type(a)</input_code>
  <output_code>int</output_code>
  <input_code>a = 'MaximoFN'
type(a)</input_code>
  <output_code>str</output_code>
  <markdown>Python types variables for you, but if you want to type them yourself, you can do so.</markdown>
  <input_code>b = int(5.1)
type(b), b</input_code>
  <output_code>(int, 5)</output_code>
  <markdown>Although `b` has been initialized as `5.1`, that is, it should be of type `float`, when we type it as `int`, we see that it is of type `int` and its value is `5`</markdown>
  <markdown>### 2.1. Strings</markdown>
  <markdown>`strings` are sequences of characters, these can be defined with double quotes `"` or single quotes `'`</markdown>
  <input_code>string = "MaximoFN"
string</input_code>
  <output_code>'MaximoFN'</output_code>
  <input_code>string = 'MaximoFN'
string</input_code>
  <output_code>'MaximoFN'</output_code>
  <markdown>To write a very long `string` and not have a line that takes up too much space, it can be introduced on multiple lines</markdown>
  <input_code>string = """Este es un ejemplo de
como estoy introduciendo un string
en varias lineas"""
string</input_code>
  <output_code>'Este es un ejemplo de\ncomo estoy introduciendo un string\nen varias lineas'</output_code>
  <input_code>string = '''Este es un ejemplo de
como estoy introduciendo un string
en varias lineas'''
string</input_code>
  <output_code>'Este es un ejemplo de\ncomo estoy introduciendo un string\nen varias lineas'</output_code>
  <markdown>However, we see that in the middle it has inserted the character indicates a line break. If we use the `print()` function, we will see that it no longer appears.</markdown>
  <input_code>print(string)</input_code>
  <output_code>Este es un ejemplo de
como estoy introduciendo un string
en varias lineas
</output_code>
  <markdown>As we have said, strings are sequences of characters, so we can navigate and iterate through them.</markdown>
  <input_code>for i in range(10):
  # Se indica a la función print que cuando imprima no termine con un salto de 
  # linea para escribir todo en la misma linea
  print(string[i], end='')</input_code>
  <output_code>Este es un</output_code>
  <markdown>We can get the length of our string using the `len()` function.</markdown>
  <input_code>len(string)</input_code>
  <output_code>73</output_code>
  <markdown>Check if there is a specific string within ours</markdown>
  <input_code>'ejemplo' in string</input_code>
  <output_code>True</output_code>
  <markdown>Strings have certain useful attributes, such as converting everything to uppercase.</markdown>
  <input_code>print(string.upper())</input_code>
  <output_code>ESTE ES UN EJEMPLO DE
COMO ESTOY INTRODUCIENDO UN STRING
EN VARIAS LINEAS
</output_code>
  <markdown>all in lowercase</markdown>
  <input_code>print(string.lower())</input_code>
  <output_code>este es un ejemplo de
como estoy introduciendo un string
en varias lineas
</output_code>
  <markdown>Replace characters</markdown>
  <input_code>print(string.replace('o', '@'))</input_code>
  <output_code>Este es un ejempl@ de
c@m@ est@y intr@duciend@ un string
en varias lineas
</output_code>
  <markdown>Get all the words</markdown>
  <input_code>print(string.split())</input_code>
  <output_code>['Este', 'es', 'un', 'ejemplo', 'de', 'como', 'estoy', 'introduciendo', 'un', 'string', 'en', 'varias', 'lineas']
</output_code>
  <markdown>You can see all the string methods in this [link](https://docs.python.org/3.9/library/stdtypes.html#string-methods)</markdown>
  <markdown>Another useful thing that can be done with strings is concatenating them.</markdown>
  <input_code>string1 = 'Maximo'
string2 = 'FN'
string1 + string2</input_code>
  <output_code>'MaximoFN'</output_code>
  <markdown>We previously explained that the character `\n` corresponds to a line break. This special character is part of a series of special characters called `Escape Characters`. Let's look at some others.</markdown>
  <markdown>If we declare a string with double quotes and want to add a double quote inside the string, we use the escape character `\"`</markdown>
  <input_code>print("Este es el blog de \"MaximoFN\"")</input_code>
  <output_code>Este es el blog de "MaximoFN"
</output_code>
  <markdown>The same with the single quote, we add `\'`</markdown>
  <input_code>print('Este es el blog de \'MaximoFN\'')</input_code>
  <output_code>Este es el blog de 'MaximoFN'
</output_code>
  <markdown>Now we have the problem of whether we want to add the `\` character since, as we have seen, it is an `escape character`, so we solve it by putting a double backslash `\`.</markdown>
  <input_code>print('Este es el blog de \\MaximoFN\\')</input_code>
  <output_code>Este es el blog de \MaximoFN\
</output_code>
  <markdown>We have already seen the newline escape character `\n`</markdown>
  <input_code>print('Este es el blog de \nMaximoFN')</input_code>
  <output_code>Este es el blog de 
MaximoFN
</output_code>
  <markdown>If we want to write from the beginning of the line, we add \r</markdown>
  <input_code>print('Esto no se imprimirá \rEste es el blog de MaximoFN')</input_code>
  <output_code>Este es el blog de MaximoFN
</output_code>
  <markdown>If we want to add a large space (indent) we use \t</markdown>
  <input_code>print('Este es el blog de \tMaximoFN')</input_code>
  <output_code>Este es el blog de 	MaximoFN
</output_code>
  <markdown>We can delete a character with `\b`</markdown>
  <input_code>print('Este es el blog de \bMaximoFN')</input_code>
  <output_code>Este es el blog deMaximoFN
</output_code>
  <markdown>We can add the [ASCII](http://www.asciitable.com/) code in octal using `\ooo`</markdown>
  <input_code>print('\115\141\170\151\155\157\106\116')</input_code>
  <output_code>MaximoFN
</output_code>
  <markdown>Or add the [ASCII](http://www.asciitable.com/) code in hexadecimal using `\xhh`</markdown>
  <input_code>print('\x4d\x61\x78\x69\x6d\x6f\x46\x4e')</input_code>
  <output_code>MaximoFN
</output_code>
  <markdown>Lastly, we can convert another type of data into a string</markdown>
  <input_code>n = 5
print(type (n))
string = str(n)
print(type(string))</input_code>
  <output_code>&lt;class 'int'&gt;
&lt;class 'str'&gt;
</output_code>
  <markdown>### 2.2. Numbers</markdown>
  <markdown>#### 2.2.1. Integers</markdown>
  <markdown>Integer numbers</markdown>
  <input_code>n = 5
n, type(n)</input_code>
  <output_code>(5, int)</output_code>
  <markdown>#### 2.2.2. Float</markdown>
  <markdown>Floating-point numbers</markdown>
  <input_code>n = 5.1
n, type(n)</input_code>
  <output_code>(5.1, float)</output_code>
  <markdown>#### 2.2.3. Complex</markdown>
  <markdown>Complex numbers</markdown>
  <input_code>n = 3 + 5j
n, type(n)</input_code>
  <output_code>((3+5j), complex)</output_code>
  <markdown>#### 2.2.4. Conversion</markdown>
  <markdown>Numbers can be converted between types</markdown>
  <input_code>n = 5
n = float(n)
n, type(n)</input_code>
  <output_code>(5.0, float)</output_code>
  <input_code>n = 5.1
n = complex(n)
n, type(n)</input_code>
  <output_code>((5.1+0j), complex)</output_code>
  <input_code>n = 5.1
n = int(n)
n, type(n)</input_code>
  <output_code>(5, int)</output_code>
  <markdown>A complex number cannot be converted to type `int` or type `float`</markdown>
  <markdown>### 2.3. Sequences</markdown>
  <markdown>#### 2.3.1. Lists</markdown>
  <markdown>Lists store multiple items in a variable. They are declared using the `[]` symbols, with items separated by commas.</markdown>
  <input_code>lista = ['item0', 'item1', 'item2', 'item3', 'item4', 'item5']
lista</input_code>
  <output_code>['item0', 'item1', 'item2', 'item3', 'item4', 'item5']</output_code>
  <markdown>We can get the length of a list using the `len()` function.</markdown>
  <input_code>len(lista)</input_code>
  <output_code>6</output_code>
  <markdown>Lists can have items of different types</markdown>
  <input_code>lista = ['item0', 1, True, 5.3, "item4", 5, 6.6]
lista</input_code>
  <output_code>['item0', 1, True, 5.3, 'item4', 5, 6.6]</output_code>
  <markdown>In Python, counting starts from position 0, that is, if we want to get the first element of the list</markdown>
  <input_code>lista[0]</input_code>
  <output_code>'item0'</output_code>
  <markdown>But one of the powerful things about Python is that if we want to access the last position we can use negative indices</markdown>
  <input_code>lista[-1]</input_code>
  <output_code>6.6</output_code>
  <markdown>If instead of the last position in the list we want the penultimate one</markdown>
  <input_code>lista[-2]</input_code>
  <output_code>5</output_code>
  <markdown>If we only want a range of values, for example, from the second to the fifth item, we access them via `[2:5]`</markdown>
  <input_code>lista[2:5]</input_code>
  <output_code>[True, 5.3, 'item4']</output_code>
  <markdown>If the first number in the range is omitted, it means we want from the first item in the list to the indicated item, that is, if we want from the first item to the fifth, we use `[:5]`</markdown>
  <input_code>lista[:5]</input_code>
  <output_code>['item0', 1, True, 5.3, 'item4']</output_code>
  <markdown>If the last number in the range is omitted, it means we want from the indicated item to the last. That is, if we want from the third item to the last, we use `[3:]`.</markdown>
  <input_code>lista[3:]</input_code>
  <output_code>[5.3, 'item4', 5, 6.6]</output_code>
  <markdown>We can also choose the range of items with negative numbers, that is, if we want from the third-to-last to the second-to-last we use `[-3:-1]`. This is useful when you have lists whose length is unknown, but you know you want a range of values from the end, for example, because the list was created with measurements that are being taken and you want to know the last averages.</markdown>
  <input_code>lista[-3:-1]</input_code>
  <output_code>['item4', 5]</output_code>
  <markdown>It can be checked if an item is in the list</markdown>
  <input_code>'item4' in lista</input_code>
  <output_code>True</output_code>
  <markdown>##### 2.3.1.1. Editing lists</markdown>
  <markdown>Lists in Python are dynamic, meaning they can be modified. For example, you can modify the third item.</markdown>
  <input_code>lista[2] = False
lista</input_code>
  <output_code>['item0', 1, False, 5.3, 'item4', 5, 6.6]</output_code>
  <markdown>A range of values can also be modified.</markdown>
  <input_code>lista[1:4] = [1.1, True, 3]
lista</input_code>
  <output_code>['item0', 1.1, True, 3, 'item4', 5, 6.6]</output_code>
  <markdown>Values can be added to the end of the list using the `append()` method.</markdown>
  <input_code>lista.append('item7')
lista</input_code>
  <output_code>['item0', 1.1, True, 3, 'item4', 5, 6.6, 'item7']</output_code>
  <markdown>Or we can insert a value at a specific position using the `insert()` method.</markdown>
  <input_code>lista.insert(2, 'insert')
lista</input_code>
  <output_code>['item0', 1.1, 'insert', True, 3, 'item4', 5, 6.6, 'item7']</output_code>
  <markdown>Lists can be joined using the `extend()` method.</markdown>
  <input_code>lista2 = ['item8', 'item9']
lista.extend(lista2)
lista</input_code>
  <output_code>['item0', 1.1, 'insert', True, 3, 'item4', 5, 6.6, 'item7', 'item8', 'item9']</output_code>
  <markdown>It is not necessary to extend the list using another list; it can be done using another iterable data type in Python (`tuples`, `sets`, `dictionaries`, etc).</markdown>
  <input_code>tupla = ('item10', 'item11')
lista.extend(tupla)
lista</input_code>
  <output_code>['item0',
 1.1,
 'insert',
 True,
 3,
 'item4',
 5,
 6.6,
 'item7',
 'item8',
 'item9',
 'item10',
 'item11']</output_code>
  <markdown>We can remove a specific position using the `pop()` method.</markdown>
  <input_code>lista.pop(2)
lista</input_code>
  <output_code>['item0',
 1.1,
 True,
 3,
 'item4',
 5,
 6.6,
 'item7',
 'item8',
 'item9',
 'item10',
 'item11']</output_code>
  <markdown>If the index is not specified, the last item is removed.</markdown>
  <input_code>lista.pop()
lista</input_code>
  <output_code>['item0', 1.1, True, 3, 'item4', 5, 6.6, 'item7', 'item8', 'item9', 'item10']</output_code>
  <markdown>Or an item can be removed knowing its value using the `remove()` method.</markdown>
  <input_code>lista.remove('item7')
lista</input_code>
  <output_code>['item0', 1.1, True, 3, 'item4', 5, 6.6, 'item8', 'item9', 'item10']</output_code>
  <markdown>With the `del()` function, you can also delete an item from the specified position.</markdown>
  <input_code>del lista[3]
lista</input_code>
  <output_code>['item0', 1.1, True, 'item4', 5, 6.6, 'item8', 'item9', 'item10']</output_code>
  <markdown>If the index is not specified, the entire list is deleted.</markdown>
  <markdown>With the `clear()` method, I empty the list.</markdown>
  <input_code>lista.clear()
lista</input_code>
  <output_code>[]</output_code>
  <markdown>The number of items with a specific value can be obtained using the `count()` method.</markdown>
  <input_code>lista = [5, 4, 6, 5, 7, 8, 5, 3, 1, 5]
lista.count(5)</input_code>
  <output_code>4</output_code>
  <markdown>You can also get the first index of an item with a specific value using the `index()` method.</markdown>
  <input_code>lista = [5, 4, 6, 5, 7, 8, 5, 3, 1, 5]
lista.index(5)</input_code>
  <output_code>0</output_code>
  <markdown>##### 2.3.1.2. List comprehension</markdown>
  <markdown>We can operate through the list</markdown>
  <input_code>fruits = ["apple", "banana", "cherry", "kiwi", "mango"]
newlist = []

# Iteramos por todos los items de la lista
for x in fruits:
  # Si el item contiene el caracter "a" lo añadimos a newlist
  if "a" in x:
    newlist.append(x)

newlist</input_code>
  <output_code>['apple', 'banana', 'mango']</output_code>
  <markdown>Some of the powerful features of Python are `list comprehensions`, which allow you to do everything in one line and make the code more compact.</markdown>
  <input_code>fruits = ["apple", "banana", "cherry", "kiwi", "mango"]

newlist = [x for x in fruits if "a" in x]

newlist</input_code>
  <output_code>['apple', 'banana', 'mango']</output_code>
  <markdown>The syntax is as follows:



```
newlist = [expression for item in iterable if condition == True]
```</markdown>
  <markdown>It can be used to perform operations on the original list</markdown>
  <input_code>newlist = [x.upper() for x in fruits if "a" in x]
newlist</input_code>
  <output_code>['APPLE', 'BANANA', 'MANGO']</output_code>
  <markdown>##### 2.3.1.3. Sorting lists</markdown>
  <markdown>To order lists we use the `sort()` method.</markdown>
  <input_code>lista = [5, 8, 3, 4, 9, 5, 6]
lista.sort()
lista</input_code>
  <output_code>[3, 4, 5, 5, 6, 8, 9]</output_code>
  <markdown>It also sorts them alphabetically</markdown>
  <input_code>lista = ["orange", "mango", "kiwi", "pineapple", "banana"]
lista.sort()
lista</input_code>
  <output_code>['banana', 'kiwi', 'mango', 'orange', 'pineapple']</output_code>
  <markdown>When sorting alphabetically, distinguish between uppercase and lowercase.</markdown>
  <input_code>lista = ["orange", "mango", "kiwi", "Pineapple", "banana"]
lista.sort()
lista</input_code>
  <output_code>['Pineapple', 'banana', 'kiwi', 'mango', 'orange']</output_code>
  <markdown>They can be sorted in descending order using the attribute `reverse = True`</markdown>
  <input_code>lista = [5, 8, 3, 4, 9, 5, 6]
lista.sort(reverse = True)
lista</input_code>
  <output_code>[9, 8, 6, 5, 5, 4, 3]</output_code>
  <markdown>They can be ordered in the way we want using the `key` attribute.</markdown>
  <input_code>def myfunc(n):
  # devuelve el valor absoluto de n - 50
  return abs(n - 50)

lista = [100, 50, 65, 82, 23]
lista.sort(key = myfunc)
lista</input_code>
  <output_code>[50, 65, 23, 82, 100]</output_code>
  <markdown>This can be used, for example, so that when sorting, it does not distinguish between uppercase and lowercase.</markdown>
  <input_code>lista = ["orange", "mango", "kiwi", "Pineapple", "banana"]
lista.sort(key = str.lower)
lista</input_code>
  <output_code>['banana', 'kiwi', 'mango', 'orange', 'Pineapple']</output_code>
  <markdown>The list can be reversed using the `reverse` method.</markdown>
  <input_code>lista = [5, 8, 3, 4, 9, 5, 6]
lista.reverse()
lista</input_code>
  <output_code>[6, 5, 9, 4, 3, 8, 5]</output_code>
  <markdown>##### 2.3.1.4. Copying lists</markdown>
  <markdown>Lists cannot be copied using `list1 = list2`, because if `list1` is modified, `list2` is also modified.</markdown>
  <input_code>lista1 = [5, 8, 3, 4, 9, 5, 6]
lista2 = lista1
lista1[0] = True
lista2</input_code>
  <output_code>[True, 8, 3, 4, 9, 5, 6]</output_code>
  <markdown>So, you have to use the `copy()` method.</markdown>
  <input_code>lista1 = [5, 8, 3, 4, 9, 5, 6]
lista2 = lista1.copy()
lista1[0] = True
lista2</input_code>
  <output_code>[5, 8, 3, 4, 9, 5, 6]</output_code>
  <markdown>Or you have to use the list constructor `list()`</markdown>
  <input_code>lista1 = [5, 8, 3, 4, 9, 5, 6]
lista2 = list(lista1)
lista1[0] = True
lista2</input_code>
  <output_code>[5, 8, 3, 4, 9, 5, 6]</output_code>
  <markdown>##### 2.3.1.5. Concatenating lists</markdown>
  <markdown>Lists can be concatenated using the `+` operator.</markdown>
  <input_code>lista1 = [5, 8, 3, 4, 9, 5, 6]
lista2 = ['a', 'b', 'c']
lista = lista1 + lista2
lista</input_code>
  <output_code>[5, 8, 3, 4, 9, 5, 6, 'a', 'b', 'c']</output_code>
  <markdown>Or using the `extend` method</markdown>
  <input_code>lista1 = [5, 8, 3, 4, 9, 5, 6]
lista2 = ['a', 'b', 'c']
lista1.extend(lista2)
lista1</input_code>
  <output_code>[5, 8, 3, 4, 9, 5, 6, 'a', 'b', 'c']</output_code>
  <markdown>Another way to concatenate is to repeat the tuple X times using the `*` operator</markdown>
  <input_code>lista1 = ['a', 'b', 'c']
lista2 = lista1 * 3
lista2</input_code>
  <output_code>['a', 'b', 'c', 'a', 'b', 'c', 'a', 'b', 'c']</output_code>
  <markdown>#### 2.3.2 Tuples</markdown>
  <markdown>Tuples are similar to lists, they store multiple items in a variable, can contain items of different types, but they cannot be modified or reordered. They are defined using `()`, with items separated by commas.

Since they cannot be modified, tuples execute a bit faster than lists, so if you don't need to modify the data, it's better to use tuples instead of lists.</markdown>
  <input_code>tupla = ('item0', 1, True, 3.3, 'item4', True)
tupla</input_code>
  <output_code>('item0', 1, True, 3.3, 'item4', True)</output_code>
  <markdown>Its length can be obtained using the `len()` function.</markdown>
  <input_code>len (tupla)</input_code>
  <output_code>6</output_code>
  <markdown>To create tuples with a single element, it is necessary to add a comma</markdown>
  <input_code>tupla = ('item0',)
tupla, type(tupla)</input_code>
  <output_code>(('item0',), tuple)</output_code>
  <markdown>To access an element of the tuple, proceed in the same way as with lists.</markdown>
  <input_code>tupla = ('item0', 1, True, 3.3, 'item4', True)
print(tupla[0])
print(tupla[-1])
print(tupla[2:4])
print(tupla[-4:-2])</input_code>
  <output_code>item0
True
(True, 3.3)
(True, 3.3)
</output_code>
  <markdown>We can check if there is an item in the tuple</markdown>
  <input_code>'item4' in tupla</input_code>
  <output_code>True</output_code>
  <markdown>##### 2.3.2.1. Modifying tuples</markdown>
  <markdown>Although tuples are not mutable, they can be modified by converting them to lists, modifying the list, and then converting it back to a tuple.</markdown>
  <input_code>lista = list(tupla)
lista[4] = 'ITEM4'
tupla = tuple(lista)
tupla</input_code>
  <output_code>('item0', 1, True, 3.3, 'ITEM4', True)</output_code>
  <markdown>By converting it to a list, we can make all the modifications seen in lists.</markdown>
  <markdown>What can be done is to delete the complete tuple</markdown>
  <input_code>del tupla

if 'tupla' not in locals():
  print("tupla eliminada")</input_code>
  <output_code>tupla eliminada
</output_code>
  <markdown>##### 2.3.22. Unpack tuples</markdown>
  <markdown>When we create tuples, we are actually packaging data</markdown>
  <input_code>tupla = ('item0', 1, True, 3.3, 'item4', True)
tupla</input_code>
  <output_code>('item0', 1, True, 3.3, 'item4', True)</output_code>
  <markdown>but we can unpack them</markdown>
  <input_code>item0, item1, item2, item3, item4, item5 = tupla
item0, item1, item2, item3, item4, item5</input_code>
  <output_code>('item0', 1, True, 3.3, 'item4', True)</output_code>
  <markdown>If we want to extract fewer elements than the length of the tuple, we add a `*`</markdown>
  <input_code>item0, item1, item2, *item3 = tupla
item0, item1, item2, item3</input_code>
  <output_code>('item0', 1, True, [3.3, 'item4', True])</output_code>
  <markdown>The asterisk `*` can be placed elsewhere if, for example, what we want is the last item.</markdown>
  <input_code>item0, item1, *item2, item5 = tupla
item0, item1, item2, item5</input_code>
  <output_code>('item0', 1, [True, 3.3, 'item4'], True)</output_code>
  <markdown>##### 2.3.23. Concatenating tuples</markdown>
  <markdown>Tuples can be concatenated using the `+` operator</markdown>
  <input_code>tupla1 = ("a", "b" , "c")
tupla2 = (1, 2, 3)

tupla3 = tupla1 + tupla2
tupla3</input_code>
  <output_code>('a', 'b', 'c', 1, 2, 3)</output_code>
  <markdown>Another way to concatenate is to repeat the tuple X times using the `*` operator</markdown>
  <input_code>tupla1 = ("a", "b" , "c")

tupla2 = tupla1 * 3
tupla2</input_code>
  <output_code>('a', 'b', 'c', 'a', 'b', 'c', 'a', 'b', 'c')</output_code>
  <markdown>##### 2.3.24. Tuple Methods</markdown>
  <markdown>Tuples have two methods, the first is the `count()` method which returns the number of times an item appears within the tuple.</markdown>
  <input_code>tupla = (5, 4, 6, 5, 7, 8, 5, 3, 1, 5)
tupla.count(5)</input_code>
  <output_code>4</output_code>
  <markdown>Another method is `index()` which returns the first position of an item within the tuple.</markdown>
  <input_code>tupla = (5, 4, 6, 5, 7, 8, 5, 3, 1, 5)
tupla.index(5)</input_code>
  <output_code>0</output_code>
  <markdown>#### 2.3.3. Range</markdown>
  <markdown>With `range()` we can create a sequence of numbers, starting from 0 (by default), it increments by 1 (by default) and stops before a specified number.



```
range(start, stop, step)
```

</markdown>
  <markdown>For example, if we want a sequence from 0 to 5 (not including 5)</markdown>
  <input_code>for i in range(5):
  print(f'{i} ', end='')</input_code>
  <output_code>0 1 2 3 4 </output_code>
  <markdown>If for example we don't want it to start at 0</markdown>
  <input_code>for i in range(2, 5):
  print(f'{i} ', end='')</input_code>
  <output_code>2 3 4 </output_code>
  <input_code>for i in range(-2, 5):
  print(f'{i} ', end='')</input_code>
  <output_code>-2 -1 0 1 2 3 4 </output_code>
  <markdown>Lastly, if we don't want it to increment by 1, for example, if we want a sequence of even numbers.</markdown>
  <input_code>for i in range(0, 10, 2):
  print(f'{i} ', end='')</input_code>
  <output_code>0 2 4 6 8 </output_code>
  <markdown>### 2.4. Dictionaries</markdown>
  <markdown>Dictionaries are used to store data in `key:value` pairs. They are mutable, unordered, and do not allow duplicates. They are defined using the `{}` symbols. They support items of different data types.</markdown>
  <input_code>diccionario = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964,
  "colors": ["red", "white", "blue"]
}
diccionario</input_code>
  <output_code>{'brand': 'Ford',
 'model': 'Mustang',
 'year': 1964,
 'colors': ['red', 'white', 'blue']}</output_code>
  <markdown>As has been said, duplicates are not allowed.</markdown>
  <input_code>diccionario = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964,
  "year": 2000,
  "colors": ["red", "white", "blue"]
}
diccionario["year"]</input_code>
  <output_code>2000</output_code>
  <markdown>Its length can be obtained using the `len()` function.</markdown>
  <input_code>len(diccionario)</input_code>
  <output_code>4</output_code>
  <markdown>As can be seen, the length is 4 and not 5, since `year` is counted only once.</markdown>
  <markdown>#### 2.4.1. Accessing Items</markdown>
  <markdown>To access an element, we can do so through its `key`</markdown>
  <input_code>diccionario["model"]</input_code>
  <output_code>'Mustang'</output_code>
  <markdown>It can also be accessed using the `get` method.</markdown>
  <input_code>diccionario.get("model")</input_code>
  <output_code>'Mustang'</output_code>
  <markdown>To know all the `key`s of dictionaries, you can use the `keys()` method.</markdown>
  <input_code>diccionario.keys()</input_code>
  <output_code>dict_keys(['brand', 'model', 'year', 'colors'])</output_code>
  <markdown>A variable can be used to point to the `key`s of the dictionary, so that calling it once is necessary</markdown>
  <input_code>diccionario = {
"brand": "Ford",
"model": "Mustang",
"year": 1964
}

# Se declara una vez la variable que apunta a las keys
x = diccionario.keys()
print(x)

# Se añade una nueva key
diccionario["color"] = "white"

# Se consulta la variable que apunta a las key
print(x)</input_code>
  <output_code>dict_keys(['brand', 'model', 'year'])
dict_keys(['brand', 'model', 'year', 'color'])
</output_code>
  <markdown>To get the values from the dictionary, you can use the `values()` method.</markdown>
  <input_code>diccionario.values()</input_code>
  <output_code>dict_values(['Ford', 'Mustang', 1964, 'white'])</output_code>
  <markdown>A variable can be used to point to the `values` of the dictionary, so that calling it once is necessary.</markdown>
  <input_code>diccionario = {
"brand": "Ford",
"model": "Mustang",
"year": 1964
}

# Se declara una vez la variable que apunta a los values
x = diccionario.values()
print(x)

# Se modifica un value
diccionario["year"] = 2020

# Se consulta la variable que apunta a los values
print(x)</input_code>
  <output_code>dict_values(['Ford', 'Mustang', 1964])
dict_values(['Ford', 'Mustang', 2020])
</output_code>
  <markdown>If what you want are the entire `item`s, that is, `key`s and `value`s, you should use the `items()` method.</markdown>
  <input_code>diccionario.items()</input_code>
  <output_code>dict_items([('brand', 'Ford'), ('model', 'Mustang'), ('year', 2020)])</output_code>
  <markdown>A variable can be used to point to the `item`s in the dictionary, so that calling it once is necessary.</markdown>
  <input_code>diccionario = {
"brand": "Ford",
"model": "Mustang",
"year": 1964
}

# Se declara una vez la variable que apunta a los items
x = diccionario.items()
print(x)

# Se modifica un value
diccionario["year"] = 2020

# Se consulta la variable que apunta a los items
print(x)</input_code>
  <output_code>dict_items([('brand', 'Ford'), ('model', 'Mustang'), ('year', 1964)])
dict_items([('brand', 'Ford'), ('model', 'Mustang'), ('year', 2020)])
</output_code>
  <markdown>It can be checked if a `key` exists in the dictionary</markdown>
  <input_code>"model" in diccionario</input_code>
  <output_code>True</output_code>
  <markdown>#### 2.4.2. Modify the items</markdown>
  <markdown>An `item` can be modified by accessing it directly.</markdown>
  <input_code>diccionario = {
"brand": "Ford",
"model": "Mustang",
"year": 1964
}

# Se modifica un item
diccionario["year"] = 2020

diccionario</input_code>
  <output_code>{'brand': 'Ford', 'model': 'Mustang', 'year': 2020}</output_code>
  <markdown>Or it can be modified using the `update()` method.</markdown>
  <input_code>diccionario = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}

# Se modifica un item
diccionario.update({"year": 2020})

diccionario</input_code>
  <output_code>{'brand': 'Ford', 'model': 'Mustang', 'year': 2020}</output_code>
  <markdown>#### 2.4.3. Adding Items</markdown>
  <markdown>An `item` can be added in this way:</markdown>
  <input_code>diccionario = {
"brand": "Ford",
"model": "Mustang",
"year": 1964
}

# Se modifica un item
diccionario["colour"] = "blue"

diccionario</input_code>
  <output_code>{'brand': 'Ford', 'model': 'Mustang', 'year': 1964, 'colour': 'blue'}</output_code>
  <markdown>Or it can be added using the `update()` method.</markdown>
  <input_code>diccionario = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}

# Se modifica un item
diccionario.update({"colour": "blue"})

diccionario</input_code>
  <output_code>{'brand': 'Ford', 'model': 'Mustang', 'year': 1964, 'colour': 'blue'}</output_code>
  <markdown>#### 2.4.4. Remove items</markdown>
  <markdown>An `item` with a specific `key` can be removed using the `pop()` method.</markdown>
  <input_code>diccionario = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}

# Se elimina un item
diccionario.pop("model")

diccionario</input_code>
  <output_code>{'brand': 'Ford', 'year': 1964}</output_code>
  <markdown>Or you can delete an `item` with a specific `key` using `del` by specifying the `key` name between the `[]` symbols.</markdown>
  <input_code>diccionario = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}

# Se elimina un item
del diccionario["model"]

diccionario</input_code>
  <output_code>{'brand': 'Ford', 'year': 1964}</output_code>
  <markdown>The dictionary will raise an error if `del` is used and the `key` of an `item` is not specified.</markdown>
  <input_code>diccionario = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}

# Se elimina un item
del diccionario

if 'diccionario' not in locals():
  print("diccionario eliminado")</input_code>
  <output_code>diccionario eliminado
</output_code>
  <markdown>If what is desired is to remove the last `item` introduced, the `popitem()` method can be used.</markdown>
  <input_code>diccionario = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}

# Se elimina el último item introducido
diccionario.popitem()

diccionario</input_code>
  <output_code>{'brand': 'Ford', 'model': 'Mustang'}</output_code>
  <markdown>If you want to clear the dictionary, you can use the `clear()` method.</markdown>
  <input_code>diccionario = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
diccionario.clear()
diccionario</input_code>
  <output_code>{}</output_code>
  <markdown>#### 2.4.5. Copying dictionaries</markdown>
  <markdown>Dictionaries cannot be copied using `dictionary1 = dictionary2`, because if you modify `dictionary1`, `dictionary2` will also be modified.</markdown>
  <input_code>diccionario1 = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
diccionario2 = diccionario1
diccionario1["year"] = 2000
diccionario2["year"]</input_code>
  <output_code>2000</output_code>
  <markdown>So, you have to use the `copy()` method.</markdown>
  <input_code>diccionario1 = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
diccionario2 = diccionario1.copy()
diccionario1["year"] = 2000
diccionario2["year"]</input_code>
  <output_code>1964</output_code>
  <markdown>Or you have to use the dictionary constructor `dict()`</markdown>
  <input_code>diccionario1 = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
diccionario2 = dict(diccionario1)
diccionario1["year"] = 2000
diccionario2["year"]</input_code>
  <output_code>1964</output_code>
  <markdown>#### 2.4.6. Anidated Dictionaries</markdown>
  <markdown>Dictionaries can have `items` of any data type, even other dictionaries. These types of dictionaries are called `nested` dictionaries.</markdown>
  <input_code>diccionario_nested = {
  "child1" : {
    "name" : "Emil",
    "year" : 2004
  },
  "child2" : {
    "name" : "Tobias",
    "year" : 2007
  },
  "child3" : {
    "name" : "Linus",
    "year" : 2011
  }
}
diccionario_nested</input_code>
  <output_code>{'child1': {'name': 'Emil', 'year': 2004},
 'child2': {'name': 'Tobias', 'year': 2007},
 'child3': {'name': 'Linus', 'year': 2011}}</output_code>
  <input_code>child1 = {
  "name" : "Emil",
  "year" : 2004
}
child2 = {
  "name" : "Tobias",
  "year" : 2007
}
child3 = {
  "name" : "Linus",
  "year" : 2011
}

diccionario_nested = {
  "child1" : child1,
  "child2" : child2,
  "child3" : child3
}

diccionario_nested</input_code>
  <output_code>{'child1': {'name': 'Emil', 'year': 2004},
 'child2': {'name': 'Tobias', 'year': 2007},
 'child3': {'name': 'Linus', 'year': 2011}}</output_code>
  <markdown>#### 2.4.7. Dictionary Methods</markdown>
  <markdown>These are the [methods](https://www.w3schools.com/python/python_dictionaries_methods.asp) that can be used on dictionaries.</markdown>
  <markdown>#### 2.4.8. Dictionary comprehension</markdown>
  <markdown> igual que podemos hacer `list comprehensions` mediante la sintaxis

```python
list comprehension = [expression for item in iterable if condition == True]
```

We can create `dictionary comprehensions` using the following syntax

``` python
dictionary comprehension = {key_expression: value_expression for item in iterable if condition == True}
```

Let's start with an example</markdown>
  <input_code>dictionary_comprehension = {x: x**2 for x in (2, 4, 6) if x &gt; 2}
dictionary_comprehension</input_code>
  <output_code>{4: 16, 6: 36}</output_code>
  <markdown>### 2.5. Sets</markdown>
  <markdown>#### 2.5.1. Set</markdown>
  <markdown>`Sets` are used in Python to store a collection of items in a single variable. They can store items of different types. They are unordered and do not have an index.

They differ from lists in that they have neither order nor index.

They are declared using the symbols `{}`</markdown>
  <markdown>Since `set` is a reserved word in Python, we create a `set` with the name `set_`</markdown>
  <input_code>set_ = {'item0', 1, 5.3, "item4", 5, 6.6}
set_</input_code>
  <output_code>{1, 5, 5.3, 6.6, 'item0', 'item4'}</output_code>
  <markdown>Items cannot be duplicated, if a duplicate item is found, only one is kept.</markdown>
  <input_code>set_ = {'item0', 1, 5.3, "item4", 5, 6.6, 'item0'}
set_</input_code>
  <output_code>{1, 5, 5.3, 6.6, 'item0', 'item4'}</output_code>
  <markdown>The length of the `set` can be obtained using the `len()` function.</markdown>
  <input_code>len(set_)</input_code>
  <output_code>6</output_code>
  <markdown>As can be seen, the length of the set is 6 and not 7, since it remains with only one `'item0'`</markdown>
  <markdown>It can be checked if an item is in the set</markdown>
  <input_code>'item4' in set_</input_code>
  <output_code>True</output_code>
  <markdown>##### 2.5.1.1. Add items</markdown>
  <markdown>An element can be added to a set using the `add()` method.</markdown>
  <input_code>set_.add(8.8)
set_</input_code>
  <output_code>{1, 5, 5.3, 6.6, 8.8, 'item0', 'item4'}</output_code>
  <markdown>Another set can be added using the `update()` method.</markdown>
  <input_code>set2 = {"item5", "item6", 7}
set_.update(set2)
set_</input_code>
  <output_code>{1, 5, 5.3, 6.6, 7, 8.8, 'item0', 'item4', 'item5', 'item6'}</output_code>
  <markdown>Items can also be added from iterable data types in Python.</markdown>
  <input_code>lista = ["item9", 10, 11.2]
set_.update(lista)
set_</input_code>
  <output_code>{1, 10, 11.2, 5, 5.3, 6.6, 7, 8.8, 'item0', 'item4', 'item5', 'item6', 'item9'}</output_code>
  <markdown>##### 2.5.1.2. Remove items</markdown>
  <markdown>An item can be removed using the `remove()` method.</markdown>
  <input_code>set_.remove('item9')
set_</input_code>
  <output_code>{1, 10, 11.2, 5, 5.3, 6.6, 7, 8.8, 'item0', 'item4', 'item5', 'item6'}</output_code>
  <markdown>Or using the `discard()` method</markdown>
  <input_code>set_.discard('item6')
set_</input_code>
  <output_code>{1, 10, 11.2, 5, 5.3, 6.6, 7, 8.8, 'item0', 'item4', 'item5'}</output_code>
  <markdown>The `pop()` method can remove the last item, but since `set`s are unordered, there's no way to know which is the last item. The `pop()` method returns the removed item.</markdown>
  <input_code>print(f"set antes de pop(): {set_}")
eliminado = set_.pop()
print(f"Se ha eliminado {eliminado}")</input_code>
  <output_code>set antes de pop(): {1, 5, 5.3, 6.6, 8.8, 7, 10, 11.2, 'item5', 'item0', 'item4'}
Se ha eliminado 1
</output_code>
  <markdown>The `clear()` method can be used to empty the set.</markdown>
  <input_code>set_.clear()
set_</input_code>
  <output_code>set()</output_code>
  <markdown>Lastly, with `del` you can delete the set</markdown>
  <input_code>del set_

if 'set_' not in locals():
  print("set eliminado")</input_code>
  <output_code>set eliminado
</output_code>
  <markdown>##### 2.5.1.3. Unir ítems</markdown>
  <markdown>a way to unite sets is through the `union()` method</markdown>
  <input_code>set1 = {"a", "b" , "c"}
set2 = {1, 2, 3}
set3 = set1.union(set2)
set3</input_code>
  <output_code>{1, 2, 3, 'a', 'b', 'c'}</output_code>
  <markdown>Another way is through the `update()` method, but this way adds a set to another, it doesn't create a new one.</markdown>
  <input_code>set1 = {"a", "b" , "c"}
set2 = {1, 2, 3}
set1.update(set2)
set1</input_code>
  <output_code>{1, 2, 3, 'a', 'b', 'c'}</output_code>
  <markdown>These methods of union remove the duplicates, but if we want to get the duplicated elements in two sets we can use the `intersection()` method.</markdown>
  <input_code>set1 = {"apple", "banana", "cherry"}
set2 = {"google", "microsoft", "apple"}

set3 = set1.intersection(set2)
set3</input_code>
  <output_code>{'apple'}</output_code>
  <markdown>If we want to get the duplicate elements in two sets, but without creating a new set, we can use the `intersection_update()` method.</markdown>
  <input_code>set1 = {"apple", "banana", "cherry"}
set2 = {"google", "microsoft", "apple"}

set1.intersection_update(set2)
set1</input_code>
  <output_code>{'apple'}</output_code>
  <markdown>Now, if we want to get rid of the duplicates, we can use the `symmetric_difference()` method.

The difference between this and the union of two sets is that in the union, all items are included, but duplicates are only taken once. Now we keep only those that are not duplicated.</markdown>
  <input_code>set1 = {"apple", "banana", "cherry"}
set2 = {"google", "microsoft", "apple"}

set3 = set1.symmetric_difference(set2)
set3</input_code>
  <output_code>{'banana', 'cherry', 'google', 'microsoft'}</output_code>
  <markdown>If we want to remove the duplicates without creating a new set, we use the `symmetric_difference_update()` method.</markdown>
  <input_code>set1 = {"apple", "banana", "cherry"}
set2 = {"google", "microsoft", "apple"}

set1.symmetric_difference_update(set2)
set1</input_code>
  <output_code>{'banana', 'cherry', 'google', 'microsoft'}</output_code>
  <markdown>##### 2.5.1.4. Methods of sets</markdown>
  <markdown>These are the [methods](https://www.w3schools.com/python/python_sets_methods.asp) that can be used with sets.</markdown>
  <markdown>#### 2.5.2. FrozenSet</markdown>
  <markdown>The `frozenset`s are like `set`s but with the safety that they are immutable, just as `tuple`s are like `list`s but immutable. Therefore, we cannot add or remove items.</markdown>
  <markdown>### 2.6. Booleans</markdown>
  <markdown>There are only two booleans in Python: `True` and `False`

</markdown>
  <markdown>The function `bool()` can evaluate if anything is `True` or `False`.</markdown>
  <input_code>print(bool("Hello"))
print(bool(15))
print(bool(0))</input_code>
  <output_code>True
True
False
</output_code>
  <markdown>#### 2.6.1. Other Data Types True and False</markdown>
  <markdown>The following data are `True`:
*   Any string that is not empty
*   Any number except 0
*   Any list, tuple, dictionary, or set that is not empty

</markdown>
  <input_code>print(bool("Hola"))
print(bool(""))</input_code>
  <output_code>True
False
</output_code>
  <input_code>print(bool(3))
print(bool(0))</input_code>
  <output_code>True
False
</output_code>
  <input_code>lista = [1, 2, 3]
print(bool(lista))

lista = []
print(bool(lista))</input_code>
  <output_code>True
False
</output_code>
  <input_code>tupla = (1, 2, 3)
print(bool(tupla))

tupla = ()
print(bool(tupla))</input_code>
  <output_code>True
False
</output_code>
  <input_code>diccionario = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964,
  "colors": ["red", "white", "blue"]
}
print(bool(diccionario))

diccionario.clear()
print(bool(diccionario))</input_code>
  <output_code>True
False
</output_code>
  <input_code>set_ = {'item0', 1, 5.3, "item4", 5, 6.6}
print(bool(set_))

set_.clear()
print(bool(set_))</input_code>
  <output_code>True
False
</output_code>
  <markdown>### 2.7. Binaries</markdown>
  <markdown>#### 2.7.1. Bytes</markdown>
  <markdown>The `bytes` type is an immutable sequence of bytes. It only accepts ASCII characters. Bytes can also be represented using integers whose values must satisfy `0 &lt;= x &lt; 256`.</markdown>
  <markdown>To create a byte type, we must introduce the character `b`</markdown>
  <input_code>byte = b"MaximoFN"
byte</input_code>
  <output_code>b'MaximoFN'</output_code>
  <markdown>It can also be created using its constructor `bytes()`</markdown>
  <input_code>byte = bytes(10)
byte</input_code>
  <output_code>b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'</output_code>
  <input_code>byte = bytes(range(10))
byte</input_code>
  <output_code>b'\x00\x01\x02\x03\x04\x05\x06\x07\x08\t'</output_code>
  <markdown>Bytes can be concatenated using the `+` operator.</markdown>
  <input_code>byte1 = b'DeepMax'
byte2 = b'FN'
byte3 = byte1 + byte2
byte3</input_code>
  <output_code>b'DeepMaxFN'</output_code>
  <markdown>Repetition with the `*` operator</markdown>
  <input_code>byte1 = b'MaximoFN '
byte2 = byte1 * 3
byte2</input_code>
  <output_code>b'MaximoFN MaximoFN MaximoFN '</output_code>
  <markdown>We can check if a character is within the string</markdown>
  <input_code>b'D' in byte1</input_code>
  <output_code>False</output_code>
  <markdown>These are the [methods](httpsplataforma.josedomingo.org/pledin/cursos/python3/curso/u30/#methods-of-bytes-and-bytearray) that can be used with `bytes`.</markdown>
  <markdown>#### 2.7.2. Bytearray</markdown>
  <markdown>The `bytearray`s are the same as `bytes` except that they are mutable.</markdown>
  <input_code>byte_array = bytearray(b'MaximoFN')
byte_array</input_code>
  <output_code>bytearray(b'MaximoFN')</output_code>
  <markdown>#### 2.7.3. MemoryView</markdown>
  <markdown>The `memoryview` objects allow Python code to access the internal data of an object that supports the buffer protocol without making copies.

The `memoryview()` function allows direct read and write access to the byte-oriented data of an object without the need to copy it first. This can result in significant performance gains when working with large objects, as it does not create a copy when slicing.

buffer protocol, it can create another access object to modify large data without copying it. This makes the program use less memory and increase execution speed.</markdown>
  <input_code>byte_array = bytearray('XYZ', 'utf-8')
print(f'Antes de acceder a la memoria: {byte_array}')

mem_view = memoryview(byte_array)

mem_view[2]= 74
print(f'Después de acceder a la memoria: {byte_array}')</input_code>
  <output_code>Antes de acceder a la memoria: bytearray(b'XYZ')
Después de acceder a la memoria: bytearray(b'XYJ')
</output_code>
  <markdown>## 3. Operators</markdown>
  <markdown>### 3.1. Arithmetic Operators</markdown>
  <markdown>Operator sum `+`</markdown>
  <input_code>3 + 5</input_code>
  <output_code>8</output_code>
  <markdown>Operator minus -</markdown>
  <input_code>3 - 5</input_code>
  <output_code>-2</output_code>
  <markdown>Multiplication operator `*`</markdown>
  <input_code>3 * 5</input_code>
  <output_code>15</output_code>
  <markdown>Division operator `/`</markdown>
  <input_code>3 / 5</input_code>
  <output_code>0.6</output_code>
  <markdown>Modulo operator `%`. Returns the remainder of a division.</markdown>
  <input_code>25 % 2</input_code>
  <output_code>1</output_code>
  <markdown>Exponent operator `**`</markdown>
  <input_code>5 ** 2</input_code>
  <output_code>25</output_code>
  <markdown>Integer division operator `//`</markdown>
  <input_code>25 // 2</input_code>
  <output_code>12</output_code>
  <markdown>### 3.2. Comparison Operators</markdown>
  <markdown>Operator is equal `==`</markdown>
  <input_code>1 == 1</input_code>
  <output_code>True</output_code>
  <markdown>Operator is different `!=`</markdown>
  <input_code>1 != 2</input_code>
  <output_code>True</output_code>
  <markdown>Operator is greater than `&gt;`</markdown>
  <input_code>3 &gt; 2</input_code>
  <output_code>True</output_code>
  <markdown>Operator is less than `&lt;`</markdown>
  <input_code>2 &lt; 3</input_code>
  <output_code>True</output_code>
  <markdown>Operator is greater than or equal to `&gt;=`</markdown>
  <input_code>3 &gt;= 3</input_code>
  <output_code>True</output_code>
  <markdown>Operator is less than or equal to `&lt;=`</markdown>
  <input_code>3 &lt;= 3</input_code>
  <output_code>True</output_code>
  <markdown>### 3.3. Logical Operators</markdown>
  <markdown>Operator `and`</markdown>
  <input_code>True and True</input_code>
  <output_code>True</output_code>
  <markdown>Operator `or`</markdown>
  <input_code>True or False</input_code>
  <output_code>True</output_code>
  <markdown>Operator `not`</markdown>
  <input_code>not False</input_code>
  <output_code>True</output_code>
  <markdown>### 3.4. Identity Operators</markdown>
  <markdown>Operator `is`</markdown>
  <input_code>5.3 is 5.3</input_code>
  <output_code>True</output_code>
  <markdown>Operator `is not`</markdown>
  <input_code>5.3 is not 5</input_code>
  <output_code>True</output_code>
  <markdown>### 3.5. Membership Operators</markdown>
  <markdown>Operator `in`</markdown>
  <input_code>x = ["apple", "banana"]

"banana" in x</input_code>
  <output_code>True</output_code>
  <markdown>Operator `not in`</markdown>
  <input_code>x = ["apple", "banana"]

"orange" not in x</input_code>
  <output_code>True</output_code>
  <markdown>### 3.6. Bitwise Operators</markdown>
  <markdown>Operator AND `&amp;`</markdown>
  <input_code>a = 60            # 60 = 0011 1100 
b = 13            # 13 = 0000 1101 

c = a &amp; b;        # 12 = 0000 1100
c</input_code>
  <output_code>12</output_code>
  <markdown>Operator OR `|`</markdown>
  <input_code>a = 60            # 60 = 0011 1100 
b = 13            # 13 = 0000 1101 

c = a | b;        # 61 = 0011 1101
c</input_code>
  <output_code>61</output_code>
  <markdown>XOR operator `^`</markdown>
  <input_code>a = 60            # 60 = 0011 1100 
b = 13            # 13 = 0000 1101 

c = a ^ b;        # 49 = 0011 0001
c</input_code>
  <output_code>49</output_code>
  <markdown>Operator NOT `~`</markdown>
  <input_code>a = 60            # 60 = 0011 1100 

c = ~a;           # -61 = 1100 0011
c</input_code>
  <output_code>-61</output_code>
  <markdown>Left shift operator `&lt;&lt;`</markdown>
  <input_code>a = 60            # 60 = 0011 1100 

c = a &lt;&lt; 2;       # 240 = 1111 0000
c</input_code>
  <output_code>240</output_code>
  <markdown>Right shift operator `&gt;&gt;`</markdown>
  <input_code>a = 60            # 60 = 0011 1100 

c = a &gt;&gt; 2;       # 15 = 0000 1111
c</input_code>
  <output_code>15</output_code>
  <markdown>### 3.7. Assignment Operators</markdown>
  <markdown>Operator `=</markdown>
  <input_code>a = 5
a</input_code>
  <output_code>5</output_code>
  <markdown>Operator `+=`. `x += y` is equivalent to `x = x + y`</markdown>
  <input_code>a += 5
a</input_code>
  <output_code>10</output_code>
  <markdown>Operator `-=`. `x -= y` is equivalentTo`x = x - y`</markdown>
  <input_code>a -= 5
a</input_code>
  <output_code>5</output_code>
  <markdown>Operator `*=`. `x *= y` is equivalent to `x = x * y`</markdown>
  <input_code>a *= 3
a</input_code>
  <output_code>15</output_code>
  <markdown>Operator `/=`. `x /= y` is equivalentTo`x = x / y`</markdown>
  <input_code>a /= 3
a</input_code>
  <output_code>5.0</output_code>
  <markdown>Operator `%=`. `x %= y` is equivalentTo`x = x % y`</markdown>
  <input_code>a = 25
a %= 2
a</input_code>
  <output_code>1</output_code>
  <markdown>Operator `//=`. `x //= y` is equivalent to `x = x // y`</markdown>
  <input_code>a = 25
a //= 2
a</input_code>
  <output_code>12</output_code>
  <markdown>Operator `**=`. `x **=y` is equivalent to `x = x ** y`</markdown>
  <input_code>a = 5
a **= 2
a</input_code>
  <output_code>25</output_code>
  <markdown>Operator `&amp;=`. `x &amp;= y` is equivalent to `x = x &amp; y`</markdown>
  <input_code>a = 60            # 60 = 0011 1100 
b = 13            # 13 = 0000 1101 

a &amp;= b;           # 12 = 0000 1100
a</input_code>
  <output_code>12</output_code>
  <markdown>Operator `|=`. `x |= y` is equivalent to `x = x | y`</markdown>
  <input_code>a = 60            # 60 = 0011 1100 
b = 13            # 13 = 0000 1101 

a |= b;           # 61 = 0011 1101
a</input_code>
  <output_code>61</output_code>
  <markdown>Operator `^=`. `x ^= y` is equivalent to `x = x ^ y`.</markdown>
  <input_code>a = 60            # 60 = 0011 1100 
b = 13            # 13 = 0000 1101 

a ^= b;           # 49 = 0011 0001
a</input_code>
  <output_code>49</output_code>
  <markdown>Operator `&gt;&gt;=`. `x &gt;&gt;= y` is equivalent to `x = x &gt;&gt; y`.</markdown>
  <input_code>a = 60            # 60 = 0011 1100 

a &lt;&lt;= 2;          # 240 = 1111 0000
a</input_code>
  <output_code>240</output_code>
  <markdown>Operator `&lt;&lt;=`. `x &lt;&lt;= y` is equivalent to `x = x &lt;&lt; y`</markdown>
  <input_code>a = 60            # 60 = 0011 1100 

a &gt;&gt;= 2;          # 15 = 0000 1111
a</input_code>
  <output_code>15</output_code>
  <markdown>## 4. Flow Control</markdown>
  <markdown>To be able to use the flow control tools, it is necessary to add a colon `:` and on a new line write the code with indentation.

Unlike other languages, Python requires indentation (white space at the beginning of a line) to define the code inside a control structure.</markdown>
  <markdown>### 4.1. If</markdown>
  <markdown>With `if` we can create conditionals</markdown>
  <input_code>if len('MaximoFN') == 8:
  print('MaximoFN tiene 8 caracteres')</input_code>
  <output_code>MaximoFN tiene 8 caracteres
</output_code>
  <markdown>If we want to createMoreThanOneConditionWeCanUse`elif`</markdown>
  <input_code>if len('MaximoFN') &lt; 8:
  print('MaximoFN tiene menos de 8 caracteres')
elif len('MaximoFN') == 8:
  print('MaximoFN tiene 8 caracteres')</input_code>
  <output_code>MaximoFN tiene 8 caracteres
</output_code>
  <markdown>If what we want is to execute something in case ofNoConditionsMatch, we can use `else`</markdown>
  <input_code>if len('MaximoFN') &lt; 8:
  print('MaximoFN tiene menos de 8 caracteres')
elif len('MaximoFN') &gt; 8:
  print('MaximoFN tiene más de 8 caracteres')
else:
  print('MaximoFN tiene 8 caracteres')</input_code>
  <output_code>MaximoFN tiene 8 caracteres
</output_code>
  <markdown>If we want to write everything in oneLine</markdown>
  <input_code>if len('MaximoFN') == 8: print('MaximoFN tiene 8 caracteres')</input_code>
  <output_code>MaximoFN tiene 8 caracteres
</output_code>
  <markdown>Equal, if we want to write everything in one line, ButWithSeveral conditions</markdown>
  <input_code>print('MaximoFN tiene menos de 8 caracteres') if len('MaximoFN') &lt; 8 else print('MaximoFN tiene más de 8 caracteres') if len('MaximoFN') &gt; 8 else print('MaximoFN tiene 8 caracteres')</input_code>
  <output_code>MaximoFN tiene 8 caracteres
</output_code>
  <markdown>If, for example, we want to create the structure of the `if` without specifying the conditions at the moment, we can use `pass`</markdown>
  <input_code>if len('MaximoFN') &lt; 8:
  print('MaximoFN tiene menos de 8 caracteres')
elif len('MaximoFN') &gt; 8:
  pass
else:
  print('MaximoFN tiene 8 caracteres')</input_code>
  <output_code>MaximoFN tiene 8 caracteres
</output_code>
  <markdown>### 4.2. While</markdown>
  <markdown>The `while` loop executes as long as the condition is `True`</markdown>
  <input_code>i = 0
string = 'MaximoFN'
while len(string) &gt; i:
  print(string[i], end='')
  i += 1</input_code>
  <output_code>MaximoFN</output_code>
  <markdown>If we want the loop to stop under some condition, we use `break`</markdown>
  <input_code>i = 0
string = 'MaximoFN'
while len(string) &gt; i:
  if string[i] == 'F':
    break
  print(string[i], end='')
  i += 1</input_code>
  <output_code>Maximo</output_code>
  <markdown>If we want one of the iterations not to executeForSomeReason, we use `continue`</markdown>
  <input_code>i = 0
string = 'Maximo FN'
while len(string) &gt; i:
  if string[i] == ' ':
    i += 1
    continue
  print(string[i], end='')
  i += 1</input_code>
  <output_code>MaximoFN</output_code>
  <markdown>The `else` block can be executed if the condition of the `while` loop is not `True`</markdown>
  <input_code>i = 0
string = 'MaximoFN'

while len(string) &gt; i:
  print(string[i], end='')
  i += 1
else:
  print("\nSe ha terminado el while")</input_code>
  <output_code>MaximoFN
Se ha terminado el while
</output_code>
  <markdown>### 4.3. For</markdown>
  <markdown>The `for` loop is used to execute code while iterating over an iterable. This iterable can be any Python iterable (`string`, `list`, `tuple`, `range`, `dictionary`, `set`).</markdown>
  <input_code>string = 'MaximoFN'

for x in string:
  print(x, end='')</input_code>
  <output_code>MaximoFN</output_code>
  <input_code>lista = ['M', 'a', 'x', 'i', 'm', 'o', 'F', 'N']

for x in lista:
  print(x, end='')</input_code>
  <output_code>MaximoFN</output_code>
  <input_code>tupla = ('M', 'a', 'x', 'i', 'm', 'o', 'F', 'N')

for x in tupla:
  print(x, end='')</input_code>
  <output_code>MaximoFN</output_code>
  <input_code>string = 'MaximoFN'

for i in range(len(string)):
  print(string[i], end='')</input_code>
  <output_code>MaximoFN</output_code>
  <input_code>diccionario = {
  "letra1": "M",
  "letra2": "a",
  "letra3": "x",
  "letra4": "i",
  "letra5": "m",
  "letra6": "o",
  "letra7": "F",
  "letra8": "N",
}

for x in diccionario.values():
  print(x, end='')</input_code>
  <output_code>MaximoFN</output_code>
  <markdown>Sets can also be iterated, but since they are unordered, there is no control over the order of execution.</markdown>
  <input_code>set_ = {'M', 'a', 'x', 'i', 'm', 'o', 'F', 'N'}

for x in set_:
  print(x, end='')</input_code>
  <output_code>NximoaMF</output_code>
  <markdown>If we want the loop to stop under some condition, we use `break`</markdown>
  <input_code>string = 'MaximoFN'

for x in string:
  if x == 'F':
    break
  print(x, end='') </input_code>
  <output_code>Maximo</output_code>
  <markdown>If we want one of the iterations not to executeForSomeReason, we use `continue`</markdown>
  <input_code>string = 'Maximo FN'

for x in string:
  if x == ' ':
    continue
  print(x, end='') </input_code>
  <output_code>MaximoFN</output_code>
  <markdown>The `else` block can be executed if the condition of the `while` loop is not `True`</markdown>
  <input_code>string = 'MaximoFN'

for x in string:
  print(x, end='') 
else:
  print("\nSe ha terminado el for")</input_code>
  <output_code>MaximoFN
Se ha terminado el for
</output_code>
  <markdown>If forExample we want to create the structure of the `for` loop, at this point, to be able to fill it in later, we can use `pass`</markdown>
  <input_code>string = 'MaximoFN'
for x in string:
  pass
print('Interior del for no codificado')</input_code>
  <output_code>Interior del for no codificado
</output_code>
  <markdown>## 5. Functions</markdown>
  <markdown>A function is a portion of code that can be executed multiple times as needed. It can take arguments and can return data as a result.</markdown>
  <markdown>To define a function, you start with the reserved word `def`, followed by the functionName, parentheses `()`, a colon `:`, and then continue on a new indented line with the function code.</markdown>
  <input_code>def funcion():
  print('MaximoFN')</input_code>
  <markdown>To call the function, it is only necessary to write its name.</markdown>
  <input_code>funcion()</input_code>
  <output_code>MaximoFN
</output_code>
  <markdown>Functions canTakeAnyArgumentsPassedAsParametersAndSeparatedByCommas</markdown>
  <input_code>def funcion(string1, string2):
  print(string1 + ' ' + string2)

funcion("Hola", "MaximoFN")</input_code>
  <output_code>Hola MaximoFN
</output_code>
  <markdown>When calling the function, you must pass it the same number of arguments that were declared; otherwise, you would get an error.

If we don't know the arguments that the functionWillReceive `*args`, it means that a `*` is used before the arguments to indicate that the number ofArguments is variable.

When doing this, you passIt a `tuple` (which is immutable)WithTheArguments</markdown>
  <input_code>def funcion(*argumentos):
  numero_argumentos = len(argumentos)

  for i in range(numero_argumentos):
    print(argumentos[i], end=' ')

funcion("funcion", "con", "varios", "argumentos", "sin", "especificar", "cuantos")</input_code>
  <output_code>funcion con varios argumentos sin especificar cuantos </output_code>
  <markdown>In case you don't know the order of the arguments of a function, you can specify the argument you want to pass by indicating its name.</markdown>
  <input_code>def funcion(argumento1, argumento2, argumento3):
  print(argumento1 + ' '+ argumento2 + ' ' + argumento3)

funcion(argumento3 = "MaximoFN", argumento1 = "Blog", argumento2 = "de")</input_code>
  <output_code>Blog de MaximoFN
</output_code>
  <markdown>In case you want to pass the arguments with their names, butEnCaseOf does notKnow howManyArguments there are to pass, you canUse `**kwargs`. In this case, a dictionary with the arguments will be passed.</markdown>
  <input_code>def funcion(**kargumentos):
  print("Autor del blog: " + kargumentos["autor"])

funcion(blog = "Blog", pertenencia = "de", autor = "MaximoFN")</input_code>
  <output_code>Autor del blog: MaximoFN
</output_code>
  <markdown>If we want some argument to have a default value between the parameters of the function. This way, if the default value is not passed to the function, the argument in the function will have the default value.</markdown>
  <input_code>def funcion(argumento1, argumento2, argumento3 = "MaximoFN"):
  print(argumento1 + ' '+ argumento2 + ' ' + argumento3)

funcion("Blog", "de")</input_code>
  <output_code>Blog de MaximoFN
</output_code>
  <markdown>Any type of data can be passed as an argument. For example, if a `list` is passed as an argument, within the function, that argument will be treated as a `list`.

```markdown
Se puede pasar cualquier tipo de dato como argumento. Por ejemplo, si se pasa una `lista` como argumento, dentro de la función, dicho argumento será tratado como una `lista`.
```

Becomes:

```markdown
Any type of data can be passed as an argument. For example, if a `list` is passed as an argument, within the function, that argument will be treated as a `list`.
```</markdown>
  <input_code>def funcion(argumento):
  longitud_lista = len(argumento)

  for i in range(longitud_lista):
    print(argumento[i], end=' ')

funcion(["Blog", "de", "MaximoFN"])</input_code>
  <output_code>Blog de MaximoFN </output_code>
  <markdown>Functions can return data, this is done using the reserved word `return`.

```markdown
Las funciones pueden devolver datos, esto se hace mediante la palabra reservada `return`
```

```markdown
Functions can return data, this is done using the reserved word `return`.
```</markdown>
  <input_code>def funcion(argumento):
  longitud_lista = len(argumento)
  string = ""

  for i in range(longitud_lista):
    string = string + argumento[i] + ' '

  return string

print(funcion(["Blog", "de", "MaximoFN"]))</input_code>
  <output_code>Blog de MaximoFN 
</output_code>
  <markdown>Can return more than one data</markdown>
  <input_code>def funcion(argumento):
  longitud_lista = len(argumento)
  string0 = argumento[0]
  string1 = argumento[1]
  string2 = argumento[2]

  return string0, string1, string2

dato0, dato1, dato2 = funcion(["Blog", "de", "MaximoFN"])

print(dato0 + ' ' + dato1 + ' ' + dato2)</input_code>
  <output_code>Blog de MaximoFN
</output_code>
  <markdown>If one of the returned data is not of interest, we can skip it using `_`.

```python
a, _, c = some_function()
```

This is a common practice in Python to ignore certain values that are returned but not needed.

---

If one of the returned data is not of interest, we can skip it using `_`.

```python
a, _, c = some_function()
```</markdown>
  <input_code>def funcion(argumento):
  longitud_lista = len(argumento)
  string0 = argumento[0]
  string1 = argumento[1]
  string2 = argumento[2]

  return string0, string1, string2

_, _, dato_de_interes = funcion(["Blog", "de", "MaximoFN"])

print(dato_de_interes)</input_code>
  <output_code>MaximoFN
</output_code>
  <markdown>If, for example, we want to create the structure of the function but do not want to, for the moment, code the interior, we can use `pass`.

```python
def my_function():
    pass
```

---

Si queremos indicar que la función aún no está completa, podemos usar un comentario o `TODO`:

```python
def my_function():
    # TODO: Implementar la lógica de la función
    pass
```</markdown>
  <input_code>def funcion():
  pass

funcion()</input_code>
  <markdown>A function can call itself, this is called recursion or function recursivity.

```markdown
A function can call itself, this is called recursion or function recursivity.
```

Este método es útil para resolver problemas que se pueden descomponer en subproblemas más pequeños y similares al problema original.

```markdown
This method is useful for solving problems that can be broken down into smaller, similar subproblems.
```

Si necesitas más ejemplos o tienes dudas, no dudes en pregar.

```markdown
If you need more examples or have doubts, don't hesitate to ask.
```

For example, we can use this property to calculate the factorial of a number.</markdown>
  <input_code>def factorial(n):
  if n == 0 or n == 1:
    return 1
  else:
    return n * factorial(n-1)

factorial(5)</input_code>
  <output_code>120</output_code>
  <markdown>### 5.1. Built-in functions</markdown>
  <markdown>There is a series of predefined functions in Python that can be used, such as the `abs()` function, which returns the absolute value.

```markdown
There is a series of predefined functions in Python that can be used, such as the `abs()` function, which returns the absolute value.
```</markdown>
  <input_code>abs(-5)</input_code>
  <output_code>5</output_code>
  <markdown>The following is a list of these functions</markdown>
  <input_code>import builtins

dir(builtins)</input_code>
  <output_code>['ArithmeticError',
 'AssertionError',
 'AttributeError',
 'BaseException',
 'BlockingIOError',
 'BrokenPipeError',
 'BufferError',
 'BytesWarning',
 'ChildProcessError',
 'ConnectionAbortedError',
 'ConnectionError',
 'ConnectionRefusedError',
 'ConnectionResetError',
 'DeprecationWarning',
 'EOFError',
 'Ellipsis',
 'EnvironmentError',
 'Exception',
 'False',
 'FileExistsError',
 'FileNotFoundError',
 'FloatingPointError',
 'FutureWarning',
 'GeneratorExit',
 'IOError',
 'ImportError',
 'ImportWarning',
 'IndentationError',
 'IndexError',
 'InterruptedError',
 'IsADirectoryError',
 'KeyError',
 'KeyboardInterrupt',
 'LookupError',
 'MemoryError',
 'ModuleNotFoundError',
 'NameError',
 'None',
 'NotADirectoryError',
 'NotImplemented',
 'NotImplementedError',
 'OSError',
 'OverflowError',
 'PendingDeprecationWarning',
 'PermissionError',
 'ProcessLookupError',
 'RecursionError',
 'ReferenceError',
 'ResourceWarning',
 'RuntimeError',
 'RuntimeWarning',
 'StopAsyncIteration',
 'StopIteration',
 'SyntaxError',
 'SyntaxWarning',
 'SystemError',
 'SystemExit',
 'TabError',
 'TimeoutError',
 'True',
 'TypeError',
 'UnboundLocalError',
 'UnicodeDecodeError',
 'UnicodeEncodeError',
 'UnicodeError',
 'UnicodeTranslateError',
 'UnicodeWarning',
 'UserWarning',
 'ValueError',
 'Warning',
 'ZeroDivisionError',
 '__IPYTHON__',
 '__build_class__',
 '__debug__',
 '__doc__',
 '__import__',
 '__loader__',
 '__name__',
 '__package__',
 '__spec__',
 'abs',
 'all',
 'any',
 'ascii',
 'bin',
 'bool',
 'breakpoint',
 'bytearray',
 'bytes',
 'callable',
 'chr',
 'classmethod',
 'compile',
 'complex',
 'copyright',
 'credits',
 'delattr',
 'dict',
 'dir',
 'display',
 'divmod',
 'enumerate',
 'eval',
 'exec',
 'filter',
 'float',
 'format',
 'frozenset',
 'get_ipython',
 'getattr',
 'globals',
 'hasattr',
 'hash',
 'help',
 'hex',
 'id',
 'input',
 'int',
 'isinstance',
 'issubclass',
 'iter',
 'len',
 'license',
 'list',
 'locals',
 'map',
 'max',
 'memoryview',
 'min',
 'next',
 'object',
 'oct',
 'open',
 'ord',
 'pow',
 'print',
 'property',
 'range',
 'repr',
 'reversed',
 'round',
 'set',
 'setattr',
 'slice',
 'sorted',
 'staticmethod',
 'str',
 'sum',
 'super',
 'tuple',
 'type',
 'vars',
 'zip']</output_code>
  <markdown>### 5.2. Function Documentation</markdown>
  <markdown>We can add an explanation of a function we create by including a comment at the beginning of the function, so when we call the `built-in function` `help()`, it will display that explanation.</markdown>
  <input_code>def funcion():
  "Esta es la explicación de la función"

  None

help(funcion)</input_code>
  <output_code>Help on function funcion in module __main__:

funcion()
    Esta es la explicación de la función

</output_code>
  <markdown>Another option to see the function explanation is to use the function's `__doc__`__doc__` is a built-in attribute that contains the docstring of the function. You can access it like this:

```python
print(my_function.__doc__)
```

- Pros:
  - It's a direct and easy way to access the docstring.
- Cons:
  - It is less readable and less commonly used than the `help()` function.

```python
def my_function():
    """
    This is a sample function to demonstrate the use of `__doc__`.
    """
    pass

print(my_function.__doc__)
```

This will output the docstring of `my_function`.

```python
"""
This is a sample function to demonstrate the use of `__doc__`.
"""
```</markdown>
  <input_code>funcion.__doc__</input_code>
  <output_code>'Esta es la explicación de la función'</output_code>
  <markdown>### 5.3. Decorators</markdown>
  <markdown>Decorators are a Python feature that allows adding new features to a function.

```markdown
# Example of a decorator
def my_decorator(func):
    def wrapper():
        print("Something is happening before the function is called.")
        func()
        print("Something is happening after the function is called.")
    return wrapper

@my_decorator
def say_hello():
    print("Hello!")

say_hello()
```

---

**Note**: This is a basic example of how decorators work in Python. They can be used to modify or enhance the behavior of functions or methods without permanently modifying the original code.

---

If you want to learn more about decorators, you can check the official Python documentation or other resources online.

A decorator function is created that takes another function as a parameter. Then the decorator function adds the new feature to the function it receives.

```python
def my_decorator(func):
    def wrapper():
        print("Something is happening before the function is called.")
        func()
        print("Something is happening after the function is called.")
    return wrapper

@my_decorator
def say_hello():
    print("Hello!")

say_hello()
```

Este es un ejemplo de cómo se ve un decorador básico en Python. La función `my_decorator` toma `func` como parámetro y crea una función `wrapper` que agrega funcionalidades antes y después de llamar a `func`.

Cuando se llama a `say_hello()`, en realidad se está llamando a `wrapper()`</markdown>
  <input_code>def decorador(parametro_funcion):
  """Agrega barritas arriba y abajo de la funcion"""

  def envoltorio():
    """Aplica las barritas al texto"""

    print("==================")
    parametro_funcion()
    print("==================")
      
  return envoltorio

def funcion():
  print("MaximoFN")

funcion_envoltorio = decorador(funcion)

print('Función sin decoradores: ')
funcion()

print('\nFunción con decoradores: ')
funcion_envoltorio()</input_code>
  <output_code>Función sin decoradores: 
MaximoFN

Función con decoradores: 
==================
MaximoFN
==================
</output_code>
  <markdown>But another more powerful way to use decorators is by using `@` and the decorator's name before the function.

```python
@decorator
def function():
    pass
```

Este es un ejemplo de cómo se ve en el código.

```python
@decorator
def example_function():
    print("Esta función está decorada.")
```

Este método es más limpio y legible, especialmente cuando se usan múltiples decoradores.

```python
@decorator1
@decorator2
def another_example_function():
    print("Esta función tiene dos decoradores.")
```

Esto facilita la lectura y el mantenimiento del código, ya que los decoradores se aplican de abajo hacia arriba.

```python
@decorator1
@decorator2
def yet_another_example_function():
    print("Esta función tiene dos decoradores en orden inverso.")
```

Es importante notar que el orden en el que se aplican los decoradores puede afectar el comportamiento de la función decorada.

That is, first the decorator is defined and then a function is called with the defined decorator.
```python
def my_decorator(func):
    def wrapper():
        print("Something is happening before the function is called.")
        func()
        print("Something is happening after the function is called.")
    return wrapper

@my_decorator
def say_hello():
    print("Hello!")

say_hello()
```

- This will output:
```
Something is happening before the function is called.
Hello!
Something is happening after the function is called.
```

---

Es decir, primero se define el decorador y a continuación se llama a una función con el decorador definido.</markdown>
  <input_code>def decorador2(parametro_funcion2):
  """Agrega barritas arriba y abajo de la funcion"""

  def envoltorio2():
    """Aplica las barritas al texto"""

    print("==================")
    parametro_funcion2()
    print("==================")
      
  return envoltorio2

@decorador2
def funcion2():
  print("MaximoFN")

print('Función con decoradores: ')
funcion2()</input_code>
  <output_code>Función con decoradores: 
==================
MaximoFN
==================
</output_code>
  <markdown>### 5.4. `*args` and `**kwargs`</markdown>
  <markdown>`*args` and `**kwargs` are optional arguments that can be used when defining a function in Python. The syntax is as follows:

``` Python
def my_function(arg1, arg2, *args, **kwargs):
    # function code here
```</markdown>
  <markdown>#### 2.5.1. `*args`</markdown>
  <markdown>`*args` is used to pass a variable number of arguments to a function. By using `*args`, you can pass a variable number of arguments to the function without having to specify the exact number of arguments the function needs. The arguments are received in the function as a tuple.</markdown>
  <input_code>def saludo(saludo, *nombres):
    for nombre in nombres:
        print(f"{saludo}, {nombre}")

saludo("Hola", "Alicia", "Roberto", "Carlos")</input_code>
  <output_code>Hola, Alicia
Hola, Roberto
Hola, Carlos
</output_code>
  <markdown>#### 2.5.2. `**kwargs`</markdown>
  <markdown>`**kwargs` is used in the same way, but to send a variable number of keyword arguments to a function. When using `**kwargs`, you can send a variable number of arguments to the function and specify the value of each argument using its name. The arguments are received in the function as a dictionary.</markdown>
  <input_code>def saludo(saludo, **personas):
    for key, value in personas.items():
        print(f"{saludo} {key}, tu edad es {value} años")

saludo("Hola", Juan=22, Maria=32, Pedro=25)</input_code>
  <output_code>Hola Juan, tu edad es 22 años
Hola Maria, tu edad es 32 años
Hola Pedro, tu edad es 25 años
</output_code>
  <markdown>## 6. Additional Functions</markdown>
  <markdown>### 6.1. Lambda functions</markdown>
  <markdown>A *lambda* function is a small anonymous function.

```markdown
una función *lambda* es una pequeña función anónima.
```

```markdown
A *lambda* function is a small anonymous function.
```

Este método es útil para funciones cortas y simples que no necesitan un nombre propio.

A *lambda* function can take any number of arguments, but can only have one expression.

```markdown
A *lambda* function can take any number of arguments, but can only have one expression.
```

This command is already in English, so no translation is needed. However, if you need the entire text in English, here it is:

```markdown
A *lambda* function can take any number of arguments, but can only have one expression.
```

Lambda functions are defined as follows:
```
lambda arguments : expression
```

</markdown>
  <input_code>x = lambda a : a + 10
print(x(5))</input_code>
  <output_code>15
</output_code>
  <input_code>x = lambda a, b, c : a + b + c
print(x(5, 6, 2))</input_code>
  <output_code>13
</output_code>
  <markdown>The power of *lambda* is best demonstrated when you use them as an anonymous function inside another function.

```python
def my_function(n):
    return lambda a, b: (a + b) * n

doubler = my_function(2)
print(doubler(1, 2))  # Output: 6
```

En este ejemplo, `my_function` devuelve una función lambda que toma dos argumentos `a` y `b`, y multiplica su suma por `n`.

4. **Uso en funciones de orden superior**:
   Las funciones lambda son muy útiles cuando se utilizan con funciones de orden superior como `map()`, `filter()`, y `reduce()`.

```python
# Uso con map()
numbers = [1, 2, 3, 4, 5]
squared = list(map(lambda x: x**2, numbers))
print(squared)  # Output: [1, 4, 9, 16, 25]

# Uso con filter()
even_numbers = list(filter(lambda x: x % 2 == 0, numbers))
print(even_numbers)  # Output: [2, 4]

# Uso con reduce()
from functools import reduce
product = reduce(lambda x, y: x * y, numbers)
print(product)  # Output: 120
```

En estos ejemplos, las funciones lambda se utilizan para definir operaciones breves y concisas que se aplican a cada elemento de una lista o para reducir una lista a un solo valor.</markdown>
  <input_code>def myfunc(n):
  return lambda a : a * n

mydoubler = myfunc(2)
mytripler = myfunc(3)

print(f"mydoubler: {mydoubler(11)}")
print(f"mytripler: {mytripler(11)}")</input_code>
  <output_code>mydoubler: 22
mytripler: 33
</output_code>
  <markdown>### 6.2. `map` Function</markdown>
  <markdown>The `map` function allows applying a function to each element of an iterable structure.

```python
# Example usage of map
numbers = [1, 2, 3, 4]
squared = map(lambda x: x**2, numbers)
print(list(squared))  # Output: [1, 4, 9, 16]
```

La función `map` toma dos argumentos: la función que se aplicará y el iterable sobre el cual se aplicará la función. El resultado es un objeto iterable que puede convertirse en una lista u otra estructura de datos.

```python
# Another example
words = ["hello", "world", "python"]
uppercased = map(str.upper, words)
print(list(uppercased))  # Output: ['HELLO', 'WORLD', 'PYTHON']
```

Esta función es muy útil para transformar datos de manera concisa y eficiente.</markdown>
  <input_code>lista = [1, 2, 3]

def funcion_mas_1(valor):
  return valor + 1

lista_modificada = list(map(funcion_mas_1, lista))
lista_modificada</input_code>
  <output_code>[2, 3, 4]</output_code>
  <markdown>This is equivalent to using `list comprehension`</markdown>
  <input_code>lista_modificada = [funcion_mas_1(x) for x in lista]
lista_modificada</input_code>
  <output_code>[2, 3, 4]</output_code>
  <markdown>### 6.3. `filter` Function</markdown>
  <markdown>The `filter` function allows selecting the elements from an iterable structure that meet a condition.

```python
# Example usage of filter
numbers = [1, 2, 3, 4, 5]
even_numbers = filter(lambda x: x % 2 == 0, numbers)
print(list(even_numbers))  # Output: [2, 4]
```

---

La función `filter` es útil para filtrar elementos en una lista o cualquier otra estructura iterable basada en una condiciónThe `filter` function is useful for filtering elements in a list or any other iterable structure based on a condition.</markdown>
  <input_code>lista = [1, 2, 3, 4, 5, 6, 7]

def esPar(valor):
  return valor % 2 == 0

lista_filtrada = list(filter(esPar, lista))
lista_filtrada</input_code>
  <output_code>[2, 4, 6]</output_code>
  <markdown>This is equivalent to using `list comprehension`</markdown>
  <input_code>lista_filtrada = [x for x in lista if esPar(x)]
lista_filtrada</input_code>
  <output_code>[2, 4, 6]</output_code>
  <markdown>### 6.4. `reduce` Function</markdown>
  <markdown>The `reduce` function allows performing accumulative tasks on iterable structures.

```markdown
La función `reduce` permite realizar tareas acumulativas sobre estructuras iterables.
```

Becomes:

```markdown
The `reduce` function allows performing accumulative tasks on iterable structures.
```</markdown>
  <input_code>from functools import reduce

lista = [1, 22, 33]

def acumular(valor, acumulador):
  print(f'valor = {valor}, acumulador = {acumulador}, acumulacion = {valor + acumulador}')
  return valor + acumulador

acumulacion = reduce(acumular, lista)
print(f'\nacumulacion = {acumulacion}')</input_code>
  <output_code>valor = 1, acumulador = 22, acumulacion = 23
valor = 23, acumulador = 33, acumulacion = 56

acumulacion = 56
</output_code>
  <markdown>### 6.5. `zip` Function</markdown>
  <markdown>With the `zip` function, you can combine multiple iterable structures into one, meaning it allows you to group several elements from the structures *A&lt;sub&gt;x&lt;/sub&gt;* into a single structure *B*. The structure *B* is composed of tuples of the elements from the structures *A&lt;sub&gt;x&lt;/sub&gt;*.</markdown>
  <input_code>nombres = ["Manolo", "Andres", "Fernando"]
altura = [181, 178, 180]

my_zip = list(zip(nombres, altura))
my_zip</input_code>
  <output_code>[('Manolo', 181), ('Andres', 178), ('Fernando', 180)]</output_code>
  <markdown>### 65. Generators</markdown>
  <markdown>Suppose we want to iterate over a sequence of numbers, but in a special way that no loop provides. This can be solved with generators. To do this, the generator function should not return the value with `return`, but with `yield` so that it knows it needs to continue iterating.</markdown>
  <input_code>def iterador_custom(N):
    for i in range (N):
        if i % 3 == 0:
            yield i

generador = iterador_custom(20)
for i in generador:
    print(i)</input_code>
  <output_code>0
3
6
9
12
15
18
</output_code>
  <markdown>We just created an iterator for numbers that are multiples of 3</markdown>
  <markdown>### 666. High order functions</markdown>
  <markdown>We can create functions that receive other functions as parameters, so the function that receives another function as a parameter is called a higher-order function (high order function). Let's see an example.</markdown>
  <input_code>def increment(x):
    return x + 1

def hof(f, x):
    return 2*f(x)

print(hof(increment, 3))</input_code>
  <output_code>8
</output_code>
  <markdown>## 7. Classes and Objects</markdown>
  <markdown>Python is an object-oriented programming language. Almost everything in Python is an object, with its attributes and methods.

A class is like an object constructor or a "blueprint" for creating objects.

To create a class, the reserved word `class` is used.</markdown>
  <input_code>class Clase:
  variable = 'MaximoFN'</input_code>
  <markdown>Once the class has been created, an object of that class can be created.</markdown>
  <input_code>objeto = Clase()
Clase.variable</input_code>
  <output_code>'MaximoFN'</output_code>
  <markdown>Normally, classes have an initialization function that runs when an object of the class is created. This function is called *dunder init* and is written as `__init__()`. The *dunder init* function must always be passed the variable `self`, which refers to the class itself, and then any additional variables you want to pass.

This function is usually used to initialize the variables of the classes, or to execute the code that is needed when an object of the class is created.</markdown>
  <input_code>class Persona:
  def __init__(self, nombre, edad):
    self.nombre = nombre
    self.edad = edad

objeto_persona = Persona("Miguel", 36)

print(objeto_persona.nombre)
print(objeto_persona.edad)</input_code>
  <output_code>Miguel
36
</output_code>
  <markdown>In addition to the initial *dunder init* function, more functions can be created. These functions are called *methods* of the class. These *methods* always need to be passed the `self` variable.</markdown>
  <input_code>class Persona:
  def __init__(self, nombre, edad):
    self.nombre = nombre
    self.edad = edad

  def saludar(self):
    print(f'Hola mi nombre es {self.nombre} y tengo {self.edad} años')

objeto_persona = Persona("Miguel", 36)

objeto_persona.saludar()</input_code>
  <output_code>Hola mi nombre es Miguel y tengo 36 años
</output_code>
  <markdown>The variable `self` does not have to be called `self`, it can have any name, but within each class it must always be the same. But by convention, `self` is usually used.</markdown>
  <input_code>class Persona:
  def __init__(yo_mismo, nombre, edad):
    yo_mismo.nombre = nombre
    yo_mismo.edad = edad

  def saludar(yo_mismo):
    print(f'Hola mi nombre es {yo_mismo.nombre} y tengo {yo_mismo.edad} años')

objeto_persona = Persona("Miguel", 36)

objeto_persona.saludar()</input_code>
  <output_code>Hola mi nombre es Miguel y tengo 36 años
</output_code>
  <markdown>Variables of objects can be modified.</markdown>
  <input_code>objeto_persona.nombre = 'Marta'
objeto_persona.saludar()</input_code>
  <output_code>Hola mi nombre es Marta y tengo 36 años
</output_code>
  <markdown>Even removing them</markdown>
  <input_code>del objeto_persona.nombre</input_code>
  <markdown>The entire object can also be deleted.</markdown>
  <input_code>del objeto_persona</input_code>
  <markdown>If, for example, we want to create the structure of the class but do not want to, for now, code the interior, we can use `pass`</markdown>
  <input_code>class Persona:
  pass

objeto_persona = Persona()</input_code>
  <markdown>### 7.1. Inheritance</markdown>
  <markdown>Inheritance allows us to define a class that inherits all the methods and properties from another class.

The **parent class** is the class from which inheritance occurs, also called the **base class**.

The **child class** is the class that inherits from another class, also called the **derived class**.</markdown>
  <markdown>We create a parent class</markdown>
  <input_code>class Persona:
  def __init__(self, nombre, apellido):
    self.nombre = nombre
    self.apellido = apellido

  def imprimir_nombre(self):
    print(f'Me llamo {self.nombre} {self.apellido}')

objeto_padre = Persona("Laura", "Perez")
objeto_padre.imprimir_nombre()</input_code>
  <output_code>Me llamo Laura Perez
</output_code>
  <markdown>To create the child class, you need to indicate between parentheses, when declaring the class, which class it inherits from.</markdown>
  <input_code>class Estudiante(Persona):
  pass</input_code>
  <markdown>And when creating the object of the child class, the parameters that the parent class needs are passed.</markdown>
  <input_code>objeto_hijo = Estudiante("Mariano", "Sanz")
objeto_hijo.imprimir_nombre()</input_code>
  <output_code>Me llamo Mariano Sanz
</output_code>
  <markdown>So far, the child class has inherited the functions from the parent class, but we can modify them by overriding them. For example, by overriding the *dunder init* function.

If the *dunder init* function is rewritten, if we want to call the *dunder init* function of the parent class, we need to call it.

There are two ways to do this, one is through the name of the parent class. In this case, you have to pass it the `self` variable.</markdown>
  <input_code>class Estudiante(Persona):
  def __init__(self, nombre, apellido):
    Persona.__init__(self, nombre, apellido)

objeto_hijo = Estudiante("Mariano", "Sanz")
objeto_hijo.imprimir_nombre()</input_code>
  <output_code>Me llamo Mariano Sanz
</output_code>
  <markdown>Another way is through `super()`, in this case you don't need to pass the `self` variable.</markdown>
  <input_code>class Estudiante(Persona):
  def __init__(self, nombre, apellido):
    super().__init__(nombre, apellido)

objeto_hijo = Estudiante("Mariano", "Sanz")
objeto_hijo.imprimir_nombre()</input_code>
  <output_code>Me llamo Mariano Sanz
</output_code>
  <markdown>By modifying the functions, new code can be added.</markdown>
  <input_code>class Estudiante(Persona):
  def __init__(self, nombre, apellido, curso):
    Persona.__init__(self, nombre, apellido)
    self.curso = curso

  def imprimir_nombre(self):
    Persona.imprimir_nombre(self)
    print(f'Estoy en el curso número {self.curso}')

objeto_hijo = Estudiante("Mariano", "Sanz", 4)
objeto_hijo.imprimir_nombre()</input_code>
  <output_code>Me llamo Mariano Sanz
Estoy en el curso número 4
</output_code>
  <markdown>Lastly, new methods can be added.</markdown>
  <input_code>class Estudiante(Persona):
  def __init__(self, nombre, apellido, curso):
    Persona.__init__(self, nombre, apellido)
    self.curso = curso

  def imprimir_nombre(self):
    Persona.imprimir_nombre(self)
    print(f'Estoy en el curso número {self.curso}')

  def imprimir_estudiante(self):
    print(f"Soy un estudiante del curso número {self.curso}")

objeto_hijo = Estudiante("Mariano", "Sanz", 4)
objeto_hijo.imprimir_nombre()
objeto_hijo.imprimir_estudiante()</input_code>
  <output_code>Me llamo Mariano Sanz
Estoy en el curso número 4
Soy un estudiante del curso número 4
</output_code>
  <markdown>### 7.2. Operator Overloading</markdown>
  <markdown>We can define basic operations, such as addition, between multiple objects of a class. For example, if we have a class that represents a vector, we can define addition and multiplication between objects of that class.</markdown>
  <input_code>class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __add__(self, other):
        return Vector(self.x + other.x, self.y + other.y)
    
    def __mul__(self, other):
        return Vector(self.x * other.x, self.y * other.y)
    
    def __str__(self):
        return f"Vector ({self.x}, {self.y})"

v1 = Vector(1, 2)
v2 = Vector(3, 4)
print(v1 + v2)  # Vector (4, 6)
print(v1 * v2)  # Vector (3, 8)</input_code>
  <output_code>Vector (4, 6)
Vector (3, 8)
</output_code>
  <markdown>All possible operator overloads are:

 * `__add__(self, other)`: overloads the addition operator (`+`).
* `__sub__(self, other)`: overloads the subtraction operator (`-`).
* `__mul__(self, other)`: overloads the multiplication operator (`*`).
* `__truediv__(self, other)`: overloads the division operator (`/`).
* `__floordiv__(self, other)`: overloads the floor division operator (`//`).
 * `__mod__(self, other)`: overloads the modulo operator (`%`).
* `__divmod__(self, other)`: overloads the `divmod()` function.
 * `__pow__(self, other)`: overloads the power operator (`**`).
 * `__lshift__(self, other)`: overloads the left shift operator (`&lt;&lt;`).
* `__rshift__(self, other)`: overloads the right shift operator (`&gt;&gt;`).
* `__and__(self, other)`: overloads the and operator (`&amp;`).
* `__or__(self, other)`: overloads the or operator (`|`).
* `__xor__(self, other)`: overloads the xor operator (`^`).
 * `__lt__(self, other)`: overloads the less than comparison operator (`&lt;`).
* `__le__(self, other)`: overloads the less than or equal to comparison operator (`&lt;=`).
* `__eq__(self, other)`: overloads the equality comparison operator (`==`).
* `__ne__(self, other)`: overloads the not equal to comparison operator (`!=`).
* `__gt__(self, other)`: overloads the greater than comparison operator (`&gt;`).
* `__ge__(self, other)`: overloads the greater than or equal to comparison operator (`&gt;=`).
* `__neg__(self)`: overloads the negation operator (`-`).
* `__pos__(self)`: overloads the unary positive operator (`+`).
 * `__abs__(self)`: overloads the `abs()` function.
* `__invert__(self)`: overloads the inversion operator (`~`).
* `__complex__(self)`: overloads the `complex()` function.
 * `__int__(self)`: overloads the `int()` function.
 * `__float__(self)`: overloads the `float()` function.</markdown>
  <markdown>### 7.3. Custom Iterators</markdown>
  <markdown>As we have seen in section [2 (Python Data Types)](https://maximofn.com/python/#2.-Tipos-de-datos-de-Python), there are some data types that can be iterated over. But we can create our own iterable class, as long as it has the functions `__len__` and `__getitem__`.</markdown>
  <input_code>class custonIterator:
    def __init__(self, n):
        self.items = [i for i in range(n)]
    
    def __len__(self):
        return len(self.items)
    
    def __getitem__(self, index):
        return self.items[index]

iterator = custonIterator(10)
print(len(iterator))  # 10
print(iterator[0])  # 0
print(iterator[1])  # 1</input_code>
  <output_code>10
0
1
</output_code>
  <markdown>Now we can iterate over the object of our class with `for` loops, for example</markdown>
  <input_code>for i in iterator:
    print(i, end=" ")  # 0 1 2 3 4 5 6 7 8 9</input_code>
  <output_code>0 1 2 3 4 5 6 7 8 9 </output_code>
  <markdown>### 7.4. Calling Objects as Functions</markdown>
  <markdown>We might want to call an object of a function as if it were a class. This can be achieved by adding the `__call__` function to the class.</markdown>
  <input_code>class potencia:
    def __init__(self, base):
        self.base = base
    
    def __call__(self, potencia):
        return self.base ** potencia
    
potencia_cuadrado = potencia(2)
print(potencia_cuadrado(3))  # 8</input_code>
  <output_code>8
</output_code>
  <markdown>### 7.5. Private Attributes and Functions</markdown>
  <markdown>When we create a class, we can make some attributes or functions private so they cannot be accessed from outside the class. To do this, you need to add `__` before the attribute or method.</markdown>
  <input_code>class Privados:
    def __init__(self):
        self.publico = "Soy público"
        self.__privado = "Soy privado"
    
    def getPrivado(self):
        return self.__privado
    
    def setPrivado(self, valor):
        self.__privado = valor
    
    def __funcion_privada(self):
        return "Soy una función privada"
    
    def funcion_publica(self):
        return self.__funcion_privada()

privados = Privados()

print("Acceso al atributo publico: ", end="")
try:
    print(f"{privados.publico}")
except:
    print("\tNo se puede acceder al atributo privado")
print("Acceso al atributo privado: ", end="")
try:
    print(f"{privados.__privado}")
except:
    print("\tNo se puede acceder al atributo privado")
print("Acceso al atributo privado mediante el accesor: ", end="")
try:
    print(f"{privados.getPrivado()}")
except:
    print("\tNo se puede acceder al atributo privado mediante el accesor")
print("Llamada a la función privada: ", end="")
try:
    print(f"{privados.__funcion_privada()}")
except:
    print("\tNo se puede llamar a la función privada")
print("Llamada a la función pública: ", end="")
try:
    print(f"{privados.funcion_publica()}")
except:
    print("\tNo se puede llamar a la función pública")</input_code>
  <output_code>Acceso al atributo publico: Soy público
Acceso al atributo privado: 	No se puede acceder al atributo privado
Acceso al atributo privado mediante el accesor: Soy privado
Llamada a la función privada: 	No se puede llamar a la función privada
Llamada a la función pública: Soy una función privada
</output_code>
  <markdown>## 8. Iterators</markdown>
  <markdown>An iterator is an object that contains a countable number of values.

An iterator is an object over which you can iterate, meaning you can traverse all the elements.

Technically, in Python, an iterator is an object that implements the iterator protocol, which consists of the methods __iter__() and __next__().</markdown>
  <markdown>`Lists`, `tuples`, `dictionaries`, and `sets` are all iterable objects. They are iterable containers from which you can get an iterator.

All these objects have an `iter()` method that is used to get an iterator:</markdown>
  <input_code>tupla = ("manzana", "plátano", "cereza")
iterable = iter(tupla)

print(next(iterable))
print(next(iterable))
print(next(iterable))</input_code>
  <output_code>manzana
plátano
cereza
</output_code>
  <input_code>string = "plátano"
iterable = iter(string)

print(next(iterable), end=' ')
print(next(iterable), end=' ')
print(next(iterable), end=' ')
print(next(iterable), end=' ')
print(next(iterable), end=' ')
print(next(iterable), end=' ')
print(next(iterable), end=' ')</input_code>
  <output_code>p l á t a n o </output_code>
  <markdown>The `for` loop actually creates an iterator object and calls the `next()` method on each iteration.</markdown>
  <input_code>tupla = ("manzana", "plátano", "cereza")

for x in tupla:
  print(x)</input_code>
  <output_code>manzana
plátano
cereza
</output_code>
  <input_code>string = "plátano"

for x in string:
  print(x, end=' ')</input_code>
  <output_code>p l á t a n o </output_code>
  <markdown>### 8.1. Create an iterator object</markdown>
  <markdown>To create an object/class as an iterator, you need to implement the methods `__iter__()` and `__next__()`.</markdown>
  <input_code>class Numeros:
  def __iter__(self):
    self.a = 1
    return self

  def __next__(self):
    x = self.a
    self.a += 1
    return x

objeto_iterador = Numeros()
iterador = iter(objeto_iterador)

print(next(iterador), end=' ')
print(next(iterador), end=' ')
print(next(iterador), end=' ')
print(next(iterador), end=' ')
print(next(iterador), end=' ')</input_code>
  <output_code>1 2 3 4 5 </output_code>
  <markdown>The previous example would continue indefinitely if it had enough calls to `next()`, or if it were used in a `for` loop.

To prevent the iteration from continuing forever, we can use the `StopIteration` statement.

In the `__next__()` method, we can add a termination condition to raise an error if the iteration is performed a specific number of times:</markdown>
  <input_code>class Numeros:
  def __iter__(self):
    self.a = 1
    return self

  def __next__(self):
    if self.a &lt;= 20:
      x = self.a
      self.a += 1
      return x
    else:
      raise StopIteration

objeto_iterador = Numeros()
iterador = iter(objeto_iterador)

for x in iterador:
  print(x, end=' ')</input_code>
  <output_code>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 </output_code>
  <markdown>### 8.2. Iterating getting the index and value</markdown>
  <markdown>We can iterate over an iterable object, obtaining its index and value in each iteration using the `enumerate()` method.</markdown>
  <input_code>string = "MaximoFN"

for index, valor in enumerate(string):
  print(f"En la posición {index}, está el caracter {valor}")</input_code>
  <output_code>En la posición 0, está el caracter M
En la posición 1, está el caracter a
En la posición 2, está el caracter x
En la posición 3, está el caracter i
En la posición 4, está el caracter m
En la posición 5, está el caracter o
En la posición 6, está el caracter F
En la posición 7, está el caracter N
</output_code>
  <markdown>### 8.3. Iterating simultaneously over two iterable objects</markdown>
  <markdown>If we have two iterable objects of the same length, we can iterate over both at the same time using the `zip()` method.</markdown>
  <input_code>string1 = 'MaximoFN__'
string2 = 'PythonPost'

if len(string1) == len(string2):
  for valor1, valor2 in zip(string1, string2):
    print(f"En el primer string hay {valor1}, en el segundo string hay {valor2}")</input_code>
  <output_code>En el primer string hay M, en el segundo string hay P
En el primer string hay a, en el segundo string hay y
En el primer string hay x, en el segundo string hay t
En el primer string hay i, en el segundo string hay h
En el primer string hay m, en el segundo string hay o
En el primer string hay o, en el segundo string hay n
En el primer string hay F, en el segundo string hay P
En el primer string hay N, en el segundo string hay o
En el primer string hay _, en el segundo string hay s
En el primer string hay _, en el segundo string hay t
</output_code>
  <markdown>## 9. Variable Scope</markdown>
  <markdown>A variable is only available within the region where it is created. This is called *scope*.</markdown>
  <markdown>### 9.1. Local Scope</markdown>
  <markdown>A variable created within a function belongs to the local scope of that function and can only be used within that function.</markdown>
  <input_code>def funcion():
  x = 300
  print(x)

funcion()</input_code>
  <output_code>300
</output_code>
  <markdown>The variable `x` is not available outside the function, but it is available to any function within it.</markdown>
  <input_code>def funcion():
  x = 300
  def funcion_interna():
    print(x)
  funcion_interna()

funcion()</input_code>
  <output_code>300
</output_code>
  <markdown>### 9.2. Global Scope</markdown>
  <markdown>A variable created in the main body of the Python code is a global variable and belongs to the global scope.

Global variables are available from any scope, global and local.</markdown>
  <input_code>x = 300

def funcion():
  print(f'Ámbito local: {x}')

funcion()

print(f'Ámbito global: {x}')</input_code>
  <output_code>Ámbito local: 300
Ámbito global: 300
</output_code>
  <markdown>If two variables are created, one global and one local, both with the same name, Python will create them as two distinct variables.</markdown>
  <input_code>x = 300

def funcion():
  x = 200
  print(f'Variable local: {x}')

funcion()

print(f'Variable global: {x}')</input_code>
  <output_code>Variable local: 200
Variable global: 300
</output_code>
  <markdown>If a global variable needs to be created, but it is declared in the local scope, the `global` keyword can be used.

The keyword `global` makes the variable global.</markdown>
  <input_code>def funcion():
  global x
  x = 300

funcion()

print(f'Variable global: {x}')</input_code>
  <output_code>Variable global: 300
</output_code>
  <markdown>In addition, the use of the `global` keyword allows making a change to a global variable within a function.</markdown>
  <input_code>x = 300

def funcion():
  global x
  x = 200

funcion()

print(f'Variable global: {x}')</input_code>
  <output_code>Variable global: 200
</output_code>
  <markdown>## 10. Modules</markdown>
  <markdown>A module is a file that contains a set of functions that you want to include in your application.

To create a module, simply save the code you want in a file with the file extension `.py`</markdown>
  <markdown>&gt; Tip: In Jupyter notebooks (Colab is an online Jupyter notebook) if we write the character `!` before a command we can execute terminal commands</markdown>
  <markdown>First, let's see which directory we are in. For that, we use the `pwd` command (*print working directory*).</markdown>
  <input_code>!pwd</input_code>
  <output_code>/home/wallabot/Documentos/web/portafolio/posts
</output_code>
  <markdown>Let's create a folder to create our modules with the `mkdir` (make directory) command.</markdown>
  <input_code>!mkdir introduccion_python</input_code>
  <markdown>Let's see what files are in our folder. We will do this using the `ls` (*list*) command.</markdown>
  <input_code>!ls introduccion_python</input_code>
  <markdown>We see that it is empty, so we create a new `.py` file in which we are going to create our module.</markdown>
  <input_code>%%writefile introduccion_python/modulo1.py

def funcion_del_modulo(nombre):
  print("Hola, " + nombre)</input_code>
  <output_code>Writing introduccion_python/modulo1.py
</output_code>
  <markdown>We check again what files are in our folder</markdown>
  <input_code>!ls introduccion_python</input_code>
  <output_code>modulo1.py  __pycache__
</output_code>
  <markdown>We see that a file `modulo1.py` has been created. We can now use it.</markdown>
  <markdown>To use an external module, you have to use the `import` keyword. To use the functions of the module, you have to put first the name of the module, a `.` and then the name of the function you want to use.</markdown>
  <input_code>import introduccion_python.modulo1

introduccion_python.modulo1.funcion_del_modulo('MaximoFN')</input_code>
  <output_code>Hola, MaximoFN
</output_code>
  <markdown>If we want our module to have a specific name within our code, we can use the word `as`</markdown>
  <input_code>import introduccion_python.modulo1 as mod1

mod1.funcion_del_modulo('MaximoFN')</input_code>
  <output_code>Hola, MaximoFN
</output_code>
  <markdown>If the module has several functions, but we only want to import one, we can do this using the `from` and `import` keywords. The form would be

```
from &lt;module&gt; import &lt;function&gt;
```

In this case, there is no need to specify the module name when calling the function.</markdown>
  <input_code>%%writefile introduccion_python/modulo2.py

def funcion1_del_modulo(nombre):
  print("Hola, " + nombre + ", funcion 1")

def funcion2_del_modulo(nombre):
  print("Hola, " + nombre + ", funcion 2")

def funcion3_del_modulo(nombre):
  print("Hola, " + nombre + ", funcion 3")</input_code>
  <output_code>Writing introduccion_python/modulo2.py
</output_code>
  <input_code>from introduccion_python.modulo2 import funcion2_del_modulo

funcion2_del_modulo('MaximoFN')</input_code>
  <output_code>Hola, MaximoFN, funcion 2
</output_code>
  <markdown>We can not only use modules created by us, but also installed modules (`built-in modules`).

For example, we can use the `platform` module</markdown>
  <input_code>import platform

x = platform.system()
x</input_code>
  <output_code>'Linux'</output_code>
  <markdown>### 10.1. Entry points: files as modules and not as scripts</markdown>
  <markdown>Now let's create a file called `modulo3.py`</markdown>
  <input_code>%%writefile introduccion_python/modulo3.py

print("Hola desde modulo3")

def funcion_del_modulo():
  return "Hola desde la función del modulo3"</input_code>
  <output_code>Overwriting introduccion_python/modulo3.py
</output_code>
  <markdown>If we now import `modulo3.py` to use the `funcion_del_modulo` function, let's see what happens.</markdown>
  <input_code>import introduccion_python.modulo3 as mod3

print(mod3.funcion_del_modulo())</input_code>
  <output_code>Hola desde modulo3
Hola desde la función del modulo3
</output_code>
  <markdown>We see that the `print` from `modulo3.py` has been executed, but that's not what we wanted. This is because when the file is named `modulo3.py`, Python runs it as a script.</markdown>
  <markdown>But what if we want to run `introduccion_python/main.py` as a script?</markdown>
  <input_code>!python introduccion_python/modulo3.py</input_code>
  <output_code>Hola desde modulo3
</output_code>
  <markdown>We see that only the `print` is executed, but not the function `funcion_del_modulo`. If we want the duality of functionality of the file `modulo3.py`, that is, to be able to import it from another module without it executing as a script and to run it standalone and execute the function we want, we use an `entry point`. That is, using the condition `if __name__ == '__main__':` and then specifying what we want to execute. Let's see this with an example, I will rewrite the `modulo3.py` file.</markdown>
  <input_code>%%writefile introduccion_python/modulo3.py

print("Hola desde modulo3")

def funcion_del_modulo():
  return "Hola desde la función del modulo3"

if __name__ == "__main__":
  funcion_del_modulo()</input_code>
  <output_code>Overwriting introduccion_python/modulo3.py
</output_code>
  <markdown>If I now call `main.py` from another module, the `print` will no longer be executed.</markdown>
  <input_code>import introduccion_python.modulo3 as mod3

print(mod3.funcion_del_modulo())</input_code>
  <output_code>Hola desde la función del modulo3
</output_code>
  <markdown>And if I run it as a standalone script, the function `funcion_del_modulo` will be executed.</markdown>
  <input_code>!python introduccion_python/modulo3.py</input_code>
  <output_code>Hola desde modulo3
</output_code>
  <markdown>## 11. Packages</markdown>
  <markdown>In Python we can create our own packages. To do this, we create a folder with the package name.</markdown>
  <input_code>!mkdir mi_paquete_de_python</input_code>
  <markdown>We now create two files inside</markdown>
  <input_code>!touch mi_paquete_de_python/modulo1.py mi_paquete_de_python/modulo2.py</input_code>
  <markdown>And we write in them</markdown>
  <input_code>%%writefile mi_paquete_de_python/modulo1.py

def funcion1():
  print("Hola desde la función 1 del módulo 1")

def funcion2():
    print("Hola desde la función 2 del módulo 1")</input_code>
  <output_code>Overwriting mi_paquete_de_python/modulo1.py
</output_code>
  <input_code>%%writefile mi_paquete_de_python/modulo2.py

def funcion1():
  print("Hola desde la función 1 del módulo 2")

def funcion2():
    print("Hola desde la función 2 del módulo 2")</input_code>
  <output_code>Overwriting mi_paquete_de_python/modulo2.py
</output_code>
  <markdown>Now we can call the functions from our package</markdown>
  <input_code>from mi_paquete_de_python import modulo1 as mod1
from mi_paquete_de_python import modulo2 as mod2

mod1.funcion1()
mod1.funcion2()
mod2.funcion1()
mod2.funcion2()</input_code>
  <output_code>Hola desde la función 1 del módulo 1
Hola desde la función 2 del módulo 1
Hola desde la función 1 del módulo 2
Hola desde la función 2 del módulo 2
</output_code>
  <markdown>But what if our package has dozens of files with functions that we want to use, would we have to import all the files one by one? To avoid this, we can create an `__init__.py` file within the package where all these file imports can be handled.</markdown>
  <input_code>!touch mi_paquete_de_python/__init__.py</input_code>
  <input_code>%%writefile mi_paquete_de_python/__init__.py

import modulo1
import modulo2</input_code>
  <output_code>Overwriting mi_paquete_de_python/__init__.py
</output_code>
  <markdown>Now we can only import our package, which internally has already imported all the modules</markdown>
  <input_code>import mi_paquete_de_python as mi_paquete

mi_paquete.modulo1.funcion1()
mi_paquete.modulo1.funcion2()
mi_paquete.modulo2.funcion1()
mi_paquete.modulo2.funcion2()</input_code>
  <output_code>Hola desde la función 1 del módulo 1
Hola desde la función 2 del módulo 1
Hola desde la función 1 del módulo 2
Hola desde la función 2 del módulo 2
</output_code>
  <markdown>This way we only have to do an `import`</markdown>
  <markdown>## 12. Try... except</markdown>
  <markdown>When an error, or an exception as it is actually called, occurs, Python will normally catch it and generate an error message.

These exceptions can be handled using the `try` and `except` statements.</markdown>
  <input_code>try:
  print(variable_no_declarada)
except:
  print("Ha ocurrido una excepción")</input_code>
  <output_code>Ha ocurrido una excepción
</output_code>
  <markdown>Since the `try` block raises an error, the `except` block will be executed.

Without the `try` block, the program would freeze and generate an error.</markdown>
  <markdown>As many exception blocks as desired can be defined, for example, if a special block of code is to be executed for a special type of error.</markdown>
  <input_code>try:
  print(variable_no_declarada)
except NameError:
  print("La variable \'variable_no_declarada\' no está definida")
except:
  print("Algo inesperado ha ocurrido")</input_code>
  <output_code>La variable 'variable_no_declarada' no está definida
</output_code>
  <markdown>The word `else` can be used to indicate the case where no error has occurred.</markdown>
  <input_code>try:
  print('MaximoFN')
except NameError:
  print("Ha ocurrido una excepción")
else:
  print('Todo OK')</input_code>
  <output_code>MaximoFN
Todo OK
</output_code>
  <markdown>with the `finally` keyword, the code will be executed at the end whether an exception occurred or not</markdown>
  <input_code>try:
  print(variable_no_declarada)
except:
  print("Ha ocurrido una excepción")
finally:
  print("'try except' finallizado")</input_code>
  <output_code>Ha ocurrido una excepción
'try except' finallizado
</output_code>
  <markdown>This can be useful for closing objects and cleaning up resources</markdown>
  <input_code>class Clase:
  variable = 'MaximoFN'

objeto = Clase()

try:
  print(Clase.mi_variable)
except:
  print("Ha ocurrido una excepción")
finally:
  del objeto</input_code>
  <output_code>Ha ocurrido una excepción
</output_code>
  <markdown>### 12.1. Create an exception</markdown>
  <markdown>As a Python developer, you can choose to raise an exception if a condition occurs.

To raise (or generate) an exception, you need to use the keyword `raise`</markdown>
  <input_code>def division(numerador, denominador):
  if denominador == 0:
    raise Exception("El denominador no puede ser 0")
  
  return numerador/denominador

print(division(10, 0))</input_code>
  <output_code>---------------------------------------------------------------------------Exception                                 Traceback (most recent call last)&lt;ipython-input-16-33fb6066fa78&gt; in &lt;module&gt;
      5   return numerador/denominador
      6 
----&gt; 7 print(division(10, 0))
&lt;ipython-input-16-33fb6066fa78&gt; in division(numerador, denominador)
      1 def division(numerador, denominador):
      2   if denominador == 0:
----&gt; 3     raise Exception("El denominador no puede ser 0")
      4 
      5   return numerador/denominador
Exception: El denominador no puede ser 0</output_code>
  <markdown>You can define what type of error to generate and the text that will be displayed to the user.</markdown>
  <input_code>def division(numerador, denominador):
  if denominador == 0:
    raise TypeError("El denominador no puede ser 0")
  
  return numerador/denominador

print(division(10, 0))</input_code>
  <output_code>---------------------------------------------------------------------------TypeError                                 Traceback (most recent call last)&lt;ipython-input-17-26bfa63ae44c&gt; in &lt;module&gt;
      5   return numerador/denominador
      6 
----&gt; 7 print(division(10, 0))
&lt;ipython-input-17-26bfa63ae44c&gt; in division(numerador, denominador)
      1 def division(numerador, denominador):
      2   if denominador == 0:
----&gt; 3     raise TypeError("El denominador no puede ser 0")
      4 
      5   return numerador/denominador
TypeError: El denominador no puede ser 0</output_code>
  <markdown>## 13. Keywords or reserved words</markdown>
  <markdown>Throughout this post, several occasions have featured Python reserved words or `keywords`, these are a series of words reserved by Python

Below is a list of the `keywords`</markdown>
  <input_code>import keyword

keyword.kwlist</input_code>
  <output_code>['False',
 'None',
 'True',
 'and',
 'as',
 'assert',
 'async',
 'await',
 'break',
 'class',
 'continue',
 'def',
 'del',
 'elif',
 'else',
 'except',
 'finally',
 'for',
 'from',
 'global',
 'if',
 'import',
 'in',
 'is',
 'lambda',
 'nonlocal',
 'not',
 'or',
 'pass',
 'raise',
 'return',
 'try',
 'while',
 'with',
 'yield']</output_code>
  <markdown>## 14. The ZEN of Python</markdown>
  <markdown>By importing the `this` module we can read the `zen` of Python, that is, its philosophy or principles.</markdown>
  <input_code>import this</input_code>
  <output_code>The Zen of Python, by Tim Peters

Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!
</output_code>
</notebook>