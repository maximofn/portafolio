<?xml version='1.0' encoding='utf-8'?>
<notebook>
  <markdown># Introdução ao Python</markdown>
  <markdown> &gt; Aviso: Este post foi traduzido para o português usando um modelo de tradução automática. Por favor, me avise se encontrar algum erro.</markdown>
  <markdown>## 1. Resumo</markdown>
  <markdown>Vamos fazer uma breve introdução ao Python, explicando os tipos de dados que temos, os operadores, o uso de funções e de classes. Além disso, veremos como usar objetos iteráveis, como usar módulos, etc.

![python](https://images.maximofn.com/icon-python.webp)</markdown>
  <markdown>## 2. Tipos de dados do Python</markdown>
  <markdown>Existem 7 tipos de dados em Python



1. De tipo texto: `str`
2. Numéricos: `int`, `float`, `complex`
3. Sequências: `list`, `tuple`, `range`
4. Mapeamento: `dict`
5. Conjuntos: `set`, `frozenset`
6. Booleanos: `bool`
7. Binários: `bytes`, `bytearray`, `memoryview`

</markdown>
  <markdown>Podemos obter o tipo de dado através da função `type()`</markdown>
  <input_code>type(5.)</input_code>
  <output_code>float</output_code>
  <markdown>Python é uma linguagem de tipagem dinâmica, ou seja, você pode ter uma variável de um tipo e depois atribuir outro tipo.</markdown>
  <input_code>a = 5
type(a)</input_code>
  <output_code>int</output_code>
  <input_code>a = 'MaximoFN'
type(a)</input_code>
  <output_code>str</output_code>
  <markdown>Python tipa as variáveis para você, mas se você quiser tipá-las, pode fazer.</markdown>
  <input_code>b = int(5.1)
type(b), b</input_code>
  <output_code>(int, 5)</output_code>
  <markdown>Embora `b` tenha sido inicializado como `5.1`, ou seja, deveria ser do tipo `float`, ao tipá-lo como `int`, vemos que é do tipo `int` e, além disso, seu valor é `5`</markdown>
  <markdown>### 2.1. Cadeias de Caracteres</markdown>
  <markdown>Os `strings` são cadeias de caracteres, estas podem ser definidas com aspas duplas `"` ou aspas simples `'`.</markdown>
  <input_code>string = "MaximoFN"
string</input_code>
  <output_code>'MaximoFN'</output_code>
  <input_code>string = 'MaximoFN'
string</input_code>
  <output_code>'MaximoFN'</output_code>
  <markdown>Para escrever uma `string` muito longa e não ter uma linha que ocupe muito espaço, pode-se introduzi-la em várias linhas</markdown>
  <input_code>string = """Este es un ejemplo de
como estoy introduciendo un string
en varias lineas"""
string</input_code>
  <output_code>'Este es un ejemplo de\ncomo estoy introduciendo un string\nen varias lineas'</output_code>
  <input_code>string = '''Este es un ejemplo de
como estoy introduciendo un string
en varias lineas'''
string</input_code>
  <output_code>'Este es un ejemplo de\ncomo estoy introduciendo un string\nen varias lineas'</output_code>
  <markdown>No entanto, vemos que no meio foi inserido o caractere indica a quebra de linha. Se usarmos a função `print()` veremos como já não aparece</markdown>
  <input_code>print(string)</input_code>
  <output_code>Este es un ejemplo de
como estoy introduciendo un string
en varias lineas
</output_code>
  <markdown>Como dissemos, as strings são cadeias de caracteres, portanto podemos navegar e iterar através delas.</markdown>
  <input_code>for i in range(10):
  # Se indica a la función print que cuando imprima no termine con un salto de 
  # linea para escribir todo en la misma linea
  print(string[i], end='')</input_code>
  <output_code>Este es un</output_code>
  <markdown>Podemos obter o comprimento da nossa string através da função `len()`</markdown>
  <input_code>len(string)</input_code>
  <output_code>73</output_code>
  <markdown>Verificar se há uma string específica dentro da nossa</markdown>
  <input_code>'ejemplo' in string</input_code>
  <output_code>True</output_code>
  <markdown>As strings têm certos atributos úteis, como colocar tudo em maiúsculas</markdown>
  <input_code>print(string.upper())</input_code>
  <output_code>ESTE ES UN EJEMPLO DE
COMO ESTOY INTRODUCIENDO UN STRING
EN VARIAS LINEAS
</output_code>
  <markdown>tudo em minúsculas</markdown>
  <input_code>print(string.lower())</input_code>
  <output_code>este es un ejemplo de
como estoy introduciendo un string
en varias lineas
</output_code>
  <markdown>Substituir caracteres</markdown>
  <input_code>print(string.replace('o', '@'))</input_code>
  <output_code>Este es un ejempl@ de
c@m@ est@y intr@duciend@ un string
en varias lineas
</output_code>
  <markdown>Obter todas as palavras</markdown>
  <input_code>print(string.split())</input_code>
  <output_code>['Este', 'es', 'un', 'ejemplo', 'de', 'como', 'estoy', 'introduciendo', 'un', 'string', 'en', 'varias', 'lineas']
</output_code>
  <markdown>Você pode ver todos os métodos das strings neste [enlace](https://docs.python.org/3.9/library/stdtypes.html#string-methods)</markdown>
  <markdown>Outra coisa útil que se pode fazer com as strings é concatená-las</markdown>
  <input_code>string1 = 'Maximo'
string2 = 'FN'
string1 + string2</input_code>
  <output_code>'MaximoFN'</output_code>
  <markdown>Antes explicamos que o caractere `\n` correspondia a uma quebra de linha, este caractere especial corresponde a uma série de caracteres especiais chamados `Escape Characters`. Vejamos outros</markdown>
  <markdown>Se declararmos uma string com aspas duplas e quisermos adicionar uma aspa dupla dentro da string, usamos o caractere de escape `\"`</markdown>
  <input_code>print("Este es el blog de \"MaximoFN\"")</input_code>
  <output_code>Este es el blog de "MaximoFN"
</output_code>
  <markdown>O mesmo com a aspa simples, adicionamos `\'`</markdown>
  <input_code>print('Este es el blog de \'MaximoFN\'')</input_code>
  <output_code>Este es el blog de 'MaximoFN'
</output_code>
  <markdown>Agora temos o problema de querer adicionar o caractere `\`, pois como vimos, ele é um `escape character`, então resolvemos isso colocando duas barras (backslash) `\`.</markdown>
  <input_code>print('Este es el blog de \\MaximoFN\\')</input_code>
  <output_code>Este es el blog de \MaximoFN\
</output_code>
  <markdown>Já vimos antes o `escape character` de nova linha `\n`</markdown>
  <input_code>print('Este es el blog de \nMaximoFN')</input_code>
  <output_code>Este es el blog de 
MaximoFN
</output_code>
  <markdown>Se quisermos escrever desde o início da linha, adicionamos \r</markdown>
  <input_code>print('Esto no se imprimirá \rEste es el blog de MaximoFN')</input_code>
  <output_code>Este es el blog de MaximoFN
</output_code>
  <markdown>Se quisermos adicionar um grande espaço (recuo) usamos \t</markdown>
  <input_code>print('Este es el blog de \tMaximoFN')</input_code>
  <output_code>Este es el blog de 	MaximoFN
</output_code>
  <markdown>Podemos apagar um caractere com `\b`</markdown>
  <input_code>print('Este es el blog de \bMaximoFN')</input_code>
  <output_code>Este es el blog deMaximoFN
</output_code>
  <markdown>Podemos adicionar o código [ASCII](http://www.asciitable.com/) em octal mediante `\ooo`</markdown>
  <input_code>print('\115\141\170\151\155\157\106\116')</input_code>
  <output_code>MaximoFN
</output_code>
  <markdown>O adicionar o código [ASCII](http://www.asciitable.com/) em hexadecimal mediante `\xhh`</markdown>
  <input_code>print('\x4d\x61\x78\x69\x6d\x6f\x46\x4e')</input_code>
  <output_code>MaximoFN
</output_code>
  <markdown>Por último, podemos converter outro tipo de dado em uma string</markdown>
  <input_code>n = 5
print(type (n))
string = str(n)
print(type(string))</input_code>
  <output_code>&lt;class 'int'&gt;
&lt;class 'str'&gt;
</output_code>
  <markdown>### 2.2. Números</markdown>
  <markdown>#### 2.2.1. Inteiros</markdown>
  <markdown>Números de tipo inteiro</markdown>
  <input_code>n = 5
n, type(n)</input_code>
  <output_code>(5, int)</output_code>
  <markdown>#### 2.2.2. Float</markdown>
  <markdown>Números de tipo ponto flutuante</markdown>
  <input_code>n = 5.1
n, type(n)</input_code>
  <output_code>(5.1, float)</output_code>
  <markdown>#### 2.2.3. Complexos</markdown>
  <markdown>Números complexos</markdown>
  <input_code>n = 3 + 5j
n, type(n)</input_code>
  <output_code>((3+5j), complex)</output_code>
  <markdown>#### 2.2.4. Conversão</markdown>
  <markdown>Pode-se converter entre tipos de números</markdown>
  <input_code>n = 5
n = float(n)
n, type(n)</input_code>
  <output_code>(5.0, float)</output_code>
  <input_code>n = 5.1
n = complex(n)
n, type(n)</input_code>
  <output_code>((5.1+0j), complex)</output_code>
  <input_code>n = 5.1
n = int(n)
n, type(n)</input_code>
  <output_code>(5, int)</output_code>
  <markdown>Não é possível converter um número `complex` para o tipo `int` ou `float`.</markdown>
  <markdown>### 2.3. Sequências</markdown>
  <markdown>#### 2.3.1. Listas</markdown>
  <markdown>As listas guardam múltiplos itens em uma variável. Elas são declaradas através dos símbolos `[]`, com os itens separados por vírgulas.</markdown>
  <input_code>lista = ['item0', 'item1', 'item2', 'item3', 'item4', 'item5']
lista</input_code>
  <output_code>['item0', 'item1', 'item2', 'item3', 'item4', 'item5']</output_code>
  <markdown>Podemos obter o comprimento de uma lista mediante a função `len()`</markdown>
  <input_code>len(lista)</input_code>
  <output_code>6</output_code>
  <markdown>As listas podem ter itens de diferentes tipos</markdown>
  <input_code>lista = ['item0', 1, True, 5.3, "item4", 5, 6.6]
lista</input_code>
  <output_code>['item0', 1, True, 5.3, 'item4', 5, 6.6]</output_code>
  <markdown>Em Python, começa a contar a partir da posição 0, ou seja, se quisermos obter o primeiro elemento da lista</markdown>
  <input_code>lista[0]</input_code>
  <output_code>'item0'</output_code>
  <markdown>Mas uma das coisas poderosas do Python é que, se quisermos acessar a última posição, podemos usar índices negativos</markdown>
  <input_code>lista[-1]</input_code>
  <output_code>6.6</output_code>
  <markdown>Se em vez da última posição da lista quisermos a penúltima</markdown>
  <input_code>lista[-2]</input_code>
  <output_code>5</output_code>
  <markdown>Se quisermos apenas um intervalo de valores, por exemplo, do segundo ao quinto item, acessamos através de `[2:5]`</markdown>
  <input_code>lista[2:5]</input_code>
  <output_code>[True, 5.3, 'item4']</output_code>
  <markdown>Se o primeiro número do intervalo for omitido, significa que queremos do primeiro item da lista até o item indicado, ou seja, se quisermos do primeiro item até o quinto, usamos `[:5]`</markdown>
  <input_code>lista[:5]</input_code>
  <output_code>['item0', 1, True, 5.3, 'item4']</output_code>
  <markdown>Se o último número do intervalo for omitido, isso significa que queremos do item indicado até o último. Ou seja, se quisermos do terceiro item até o último, usamos `[3:]`.</markdown>
  <input_code>lista[3:]</input_code>
  <output_code>[5.3, 'item4', 5, 6.6]</output_code>
  <markdown>Podemos escolher o range de itens também com números negativos, ou seja, se quisermos do antepenúltimo até o penúltimo usamos `[-3:-1]`. Isso é útil quando se tem listas cuja comprimento não se sabe, mas se sabe que se quer um range de valores do final, porque, por exemplo, a lista foi criada com medidas que vão sendo tomadas e se quer saber as últimas medidas.</markdown>
  <input_code>lista[-3:-1]</input_code>
  <output_code>['item4', 5]</output_code>
  <markdown>Pode-se verificar se um item está na lista</markdown>
  <input_code>'item4' in lista</input_code>
  <output_code>True</output_code>
  <markdown>##### 2.3.1.1. Editar listas</markdown>
  <markdown>As listas em Python são dinâmicas, ou seja, podem ser modificadas. Por exemplo, pode-se modificar o terceiro item.</markdown>
  <input_code>lista[2] = False
lista</input_code>
  <output_code>['item0', 1, False, 5.3, 'item4', 5, 6.6]</output_code>
  <markdown>Também é possível modificar um intervalo de valores</markdown>
  <input_code>lista[1:4] = [1.1, True, 3]
lista</input_code>
  <output_code>['item0', 1.1, True, 3, 'item4', 5, 6.6]</output_code>
  <markdown>Valores podem ser adicionados ao final da lista através do método `append()`</markdown>
  <input_code>lista.append('item7')
lista</input_code>
  <output_code>['item0', 1.1, True, 3, 'item4', 5, 6.6, 'item7']</output_code>
  <markdown>O podemos inserir um valor em uma posição determinada através do método `insert()`</markdown>
  <input_code>lista.insert(2, 'insert')
lista</input_code>
  <output_code>['item0', 1.1, 'insert', True, 3, 'item4', 5, 6.6, 'item7']</output_code>
  <markdown>Listas podem ser unidas através do método `extend()`</markdown>
  <input_code>lista2 = ['item8', 'item9']
lista.extend(lista2)
lista</input_code>
  <output_code>['item0', 1.1, 'insert', True, 3, 'item4', 5, 6.6, 'item7', 'item8', 'item9']</output_code>
  <markdown>Não é necessário estender a lista através de outra lista, pode ser feito através de outro tipo de dado iterável do Python (`tuplas`, `sets`, `dicionários`, etc)</markdown>
  <input_code>tupla = ('item10', 'item11')
lista.extend(tupla)
lista</input_code>
  <output_code>['item0',
 1.1,
 'insert',
 True,
 3,
 'item4',
 5,
 6.6,
 'item7',
 'item8',
 'item9',
 'item10',
 'item11']</output_code>
  <markdown>Podemos eliminar uma posição determinada mediante o método `pop()`</markdown>
  <input_code>lista.pop(2)
lista</input_code>
  <output_code>['item0',
 1.1,
 True,
 3,
 'item4',
 5,
 6.6,
 'item7',
 'item8',
 'item9',
 'item10',
 'item11']</output_code>
  <markdown>Se não for especificado o índice, o último item é removido.</markdown>
  <input_code>lista.pop()
lista</input_code>
  <output_code>['item0', 1.1, True, 3, 'item4', 5, 6.6, 'item7', 'item8', 'item9', 'item10']</output_code>
  <markdown>Ou pode-se remover um item sabendo seu valor através do método `remove()`</markdown>
  <input_code>lista.remove('item7')
lista</input_code>
  <output_code>['item0', 1.1, True, 3, 'item4', 5, 6.6, 'item8', 'item9', 'item10']</output_code>
  <markdown>Com a função `del()` também pode ser usada para eliminar um item da posição indicada.</markdown>
  <input_code>del lista[3]
lista</input_code>
  <output_code>['item0', 1.1, True, 'item4', 5, 6.6, 'item8', 'item9', 'item10']</output_code>
  <markdown>Se não for indicado o índice, a lista completa é eliminada.</markdown>
  <markdown>Com o método `clear()` eu deixo a lista vazia</markdown>
  <input_code>lista.clear()
lista</input_code>
  <output_code>[]</output_code>
  <markdown>Pode-se obter a quantidade de itens com um valor determinado através do método `count()`</markdown>
  <input_code>lista = [5, 4, 6, 5, 7, 8, 5, 3, 1, 5]
lista.count(5)</input_code>
  <output_code>4</output_code>
  <markdown>Também é possível obter o primeiro índice de um item com um valor determinado através do método `index()`</markdown>
  <input_code>lista = [5, 4, 6, 5, 7, 8, 5, 3, 1, 5]
lista.index(5)</input_code>
  <output_code>0</output_code>
  <markdown>##### 2.3.1.2. Compreensão de lista</markdown>
  <markdown>Podemos operar através da lista</markdown>
  <input_code>fruits = ["apple", "banana", "cherry", "kiwi", "mango"]
newlist = []

# Iteramos por todos los items de la lista
for x in fruits:
  # Si el item contiene el caracter "a" lo añadimos a newlist
  if "a" in x:
    newlist.append(x)

newlist</input_code>
  <output_code>['apple', 'banana', 'mango']</output_code>
  <markdown>Outras das coisas potentes do Python são as `list comprehensions`, que permitem fazer tudo em uma única linha e deixar o código mais compacto.</markdown>
  <input_code>fruits = ["apple", "banana", "cherry", "kiwi", "mango"]

newlist = [x for x in fruits if "a" in x]

newlist</input_code>
  <output_code>['apple', 'banana', 'mango']</output_code>
  <markdown>A sintaxe é a seguinte:



```
newlist = [expressão for item in iterável if condição == True]
```</markdown>
  <markdown>Pode ser aproveitado para realizar operações na lista original</markdown>
  <input_code>newlist = [x.upper() for x in fruits if "a" in x]
newlist</input_code>
  <output_code>['APPLE', 'BANANA', 'MANGO']</output_code>
  <markdown>##### 2.3.1.3. Ordenar listas</markdown>
  <markdown>Para ordenar listas usamos o método `sort()`</markdown>
  <input_code>lista = [5, 8, 3, 4, 9, 5, 6]
lista.sort()
lista</input_code>
  <output_code>[3, 4, 5, 5, 6, 8, 9]</output_code>
  <markdown>Também as ordena alfabeticamente</markdown>
  <input_code>lista = ["orange", "mango", "kiwi", "pineapple", "banana"]
lista.sort()
lista</input_code>
  <output_code>['banana', 'kiwi', 'mango', 'orange', 'pineapple']</output_code>
  <markdown>Ao ordenar alfabeticamente, distinga entre maiúsculas e minúsculas.</markdown>
  <input_code>lista = ["orange", "mango", "kiwi", "Pineapple", "banana"]
lista.sort()
lista</input_code>
  <output_code>['Pineapple', 'banana', 'kiwi', 'mango', 'orange']</output_code>
  <markdown>Podem ser ordenados em ordem decrescente através do atributo `reverse = True`</markdown>
  <input_code>lista = [5, 8, 3, 4, 9, 5, 6]
lista.sort(reverse = True)
lista</input_code>
  <output_code>[9, 8, 6, 5, 5, 4, 3]</output_code>
  <markdown>Podem ser ordenados da maneira que quisermos usando o atributo `key`</markdown>
  <input_code>def myfunc(n):
  # devuelve el valor absoluto de n - 50
  return abs(n - 50)

lista = [100, 50, 65, 82, 23]
lista.sort(key = myfunc)
lista</input_code>
  <output_code>[50, 65, 23, 82, 100]</output_code>
  <markdown>Isso pode ser aproveitado para, por exemplo, na hora de ordenar, não distinguir entre maiúsculas e minúsculas</markdown>
  <input_code>lista = ["orange", "mango", "kiwi", "Pineapple", "banana"]
lista.sort(key = str.lower)
lista</input_code>
  <output_code>['banana', 'kiwi', 'mango', 'orange', 'Pineapple']</output_code>
  <markdown>Pode-se inverter a lista usando o método `reverse`</markdown>
  <input_code>lista = [5, 8, 3, 4, 9, 5, 6]
lista.reverse()
lista</input_code>
  <output_code>[6, 5, 9, 4, 3, 8, 5]</output_code>
  <markdown>##### 2.3.1.4. Copiar listas</markdown>
  <markdown>Não se pode copiar listas com `lista1 = lista2`, pois se `lista1` for modificada, `lista2` também será modificada.</markdown>
  <input_code>lista1 = [5, 8, 3, 4, 9, 5, 6]
lista2 = lista1
lista1[0] = True
lista2</input_code>
  <output_code>[True, 8, 3, 4, 9, 5, 6]</output_code>
  <markdown>Portanto, é necessário usar o método `copy()`</markdown>
  <input_code>lista1 = [5, 8, 3, 4, 9, 5, 6]
lista2 = lista1.copy()
lista1[0] = True
lista2</input_code>
  <output_code>[5, 8, 3, 4, 9, 5, 6]</output_code>
  <markdown>Ó hay que usar o construtor de listas `list()`</markdown>
  <input_code>lista1 = [5, 8, 3, 4, 9, 5, 6]
lista2 = list(lista1)
lista1[0] = True
lista2</input_code>
  <output_code>[5, 8, 3, 4, 9, 5, 6]</output_code>
  <markdown>##### 2.3.1.5. Concatenar listas</markdown>
  <markdown>Listas podem ser concatenadas usando o operador `+`</markdown>
  <input_code>lista1 = [5, 8, 3, 4, 9, 5, 6]
lista2 = ['a', 'b', 'c']
lista = lista1 + lista2
lista</input_code>
  <output_code>[5, 8, 3, 4, 9, 5, 6, 'a', 'b', 'c']</output_code>
  <markdown>O mediante o método `extend`</markdown>
  <input_code>lista1 = [5, 8, 3, 4, 9, 5, 6]
lista2 = ['a', 'b', 'c']
lista1.extend(lista2)
lista1</input_code>
  <output_code>[5, 8, 3, 4, 9, 5, 6, 'a', 'b', 'c']</output_code>
  <markdown>Outra forma de concatenar é repetir a tupla X vezes mediante o operador `*`</markdown>
  <input_code>lista1 = ['a', 'b', 'c']
lista2 = lista1 * 3
lista2</input_code>
  <output_code>['a', 'b', 'c', 'a', 'b', 'c', 'a', 'b', 'c']</output_code>
  <markdown>#### 2.3.2. Tuplas</markdown>
  <markdown>As tuplas são semelhantes às listas, guardam múltiplos itens em uma variável, podem conter itens de tipos diferentes, mas não podem ser modificadas nem reordenadas. São definidas através de `()`, com os itens separados por vírgulas.

Como não podem ser modificadas, as tuplas se executam um pouco mais rápido que as listas, portanto, se você não precisar modificar os dados, é melhor usar tuplas em vez de listas.</markdown>
  <input_code>tupla = ('item0', 1, True, 3.3, 'item4', True)
tupla</input_code>
  <output_code>('item0', 1, True, 3.3, 'item4', True)</output_code>
  <markdown>Pode-se obter seu comprimento através da função `len()`</markdown>
  <input_code>len (tupla)</input_code>
  <output_code>6</output_code>
  <markdown>Para criar tuplas com um único elemento é necessário adicionar uma vírgula</markdown>
  <input_code>tupla = ('item0',)
tupla, type(tupla)</input_code>
  <output_code>(('item0',), tuple)</output_code>
  <markdown>Para acessar um elemento da tupla, procede-se da mesma forma que com as listas.</markdown>
  <input_code>tupla = ('item0', 1, True, 3.3, 'item4', True)
print(tupla[0])
print(tupla[-1])
print(tupla[2:4])
print(tupla[-4:-2])</input_code>
  <output_code>item0
True
(True, 3.3)
(True, 3.3)
</output_code>
  <markdown>Podemos verificar se há um item na tupla</markdown>
  <input_code>'item4' in tupla</input_code>
  <output_code>True</output_code>
  <markdown>##### 2.3.2.1. Modificar tuplas</markdown>
  <markdown>Embora as tuplas não sejam modificáveis, elas podem ser modificadas convertendo-as em listas, modificando a lista e, em seguida, convertendo-a de volta em uma tupla.</markdown>
  <input_code>lista = list(tupla)
lista[4] = 'ITEM4'
tupla = tuple(lista)
tupla</input_code>
  <output_code>('item0', 1, True, 3.3, 'ITEM4', True)</output_code>
  <markdown>Ao convertê-la em lista, podemos fazer todas as modificações vistas nas listas</markdown>
  <markdown>O que se pode é eliminar a tupla completa</markdown>
  <input_code>del tupla

if 'tupla' not in locals():
  print("tupla eliminada")</input_code>
  <output_code>tupla eliminada
</output_code>
  <markdown>##### 2.3.2.2. Desempacotar tuplas</markdown>
  <markdown>Quando criamos tuplas, na verdade estamos empacotando dados</markdown>
  <input_code>tupla = ('item0', 1, True, 3.3, 'item4', True)
tupla</input_code>
  <output_code>('item0', 1, True, 3.3, 'item4', True)</output_code>
  <markdown>mas podemos desempacotá-los</markdown>
  <input_code>item0, item1, item2, item3, item4, item5 = tupla
item0, item1, item2, item3, item4, item5</input_code>
  <output_code>('item0', 1, True, 3.3, 'item4', True)</output_code>
  <markdown>Se quisermos tirar menos dados que o comprimento da tupla, adicionamos um `*`</markdown>
  <input_code>item0, item1, item2, *item3 = tupla
item0, item1, item2, item3</input_code>
  <output_code>('item0', 1, True, [3.3, 'item4', True])</output_code>
  <markdown>Pode colocar o asterisco `*` em outro lugar, se por exemplo o que desejamos é o último item.</markdown>
  <input_code>item0, item1, *item2, item5 = tupla
item0, item1, item2, item5</input_code>
  <output_code>('item0', 1, [True, 3.3, 'item4'], True)</output_code>
  <markdown>##### 2.3.2.3. Concatenar tuplas</markdown>
  <markdown>Tuplas podem ser concatenadas utilizando o operador `+`</markdown>
  <input_code>tupla1 = ("a", "b" , "c")
tupla2 = (1, 2, 3)

tupla3 = tupla1 + tupla2
tupla3</input_code>
  <output_code>('a', 'b', 'c', 1, 2, 3)</output_code>
  <markdown>Outra forma de concatenar é repetir a tupla X vezes mediante o operador `*`</markdown>
  <input_code>tupla1 = ("a", "b" , "c")

tupla2 = tupla1 * 3
tupla2</input_code>
  <output_code>('a', 'b', 'c', 'a', 'b', 'c', 'a', 'b', 'c')</output_code>
  <markdown>##### 2.3.2.4. Métodos das tuplas</markdown>
  <markdown>As tuplas têm dois métodos, o primeiro é o método `count()` que retorna o número de vezes que um item aparece dentro da tupla.</markdown>
  <input_code>tupla = (5, 4, 6, 5, 7, 8, 5, 3, 1, 5)
tupla.count(5)</input_code>
  <output_code>4</output_code>
  <markdown>Outro método é `index()` que retorna a primeira posição de um item dentro da tupla.</markdown>
  <input_code>tupla = (5, 4, 6, 5, 7, 8, 5, 3, 1, 5)
tupla.index(5)</input_code>
  <output_code>0</output_code>
  <markdown>#### 2.3.3. Intervalo</markdown>
  <markdown>Com `range()` podemos criar uma sequência de números, começando de 0 (por padrão), incrementando em 1 (por padrão) e parando antes de um número especificado.



```
range(início, fim, passo)
```

</markdown>
  <markdown>Por exemplo, se quisermos uma sequência de 0 a 5 (sem incluir o 5)</markdown>
  <input_code>for i in range(5):
  print(f'{i} ', end='')</input_code>
  <output_code>0 1 2 3 4 </output_code>
  <markdown>Se por exemplo não quisermos que comece em 0</markdown>
  <input_code>for i in range(2, 5):
  print(f'{i} ', end='')</input_code>
  <output_code>2 3 4 </output_code>
  <input_code>for i in range(-2, 5):
  print(f'{i} ', end='')</input_code>
  <output_code>-2 -1 0 1 2 3 4 </output_code>
  <markdown>Por último, se não quisermos que se incremente em 1, se por exemplo quisermos uma sequência de números pares.</markdown>
  <input_code>for i in range(0, 10, 2):
  print(f'{i} ', end='')</input_code>
  <output_code>0 2 4 6 8 </output_code>
  <markdown>### 2.4. Dicionários</markdown>
  <markdown>Os dicionários são usados para armazenar dados em pares `chave:valor`. São modificáveis, não ordenados e não permitem duplicidades. São definidos usando os símbolos `{}`. Aceitam itens de diferentes tipos de dados.</markdown>
  <input_code>diccionario = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964,
  "colors": ["red", "white", "blue"]
}
diccionario</input_code>
  <output_code>{'brand': 'Ford',
 'model': 'Mustang',
 'year': 1964,
 'colors': ['red', 'white', 'blue']}</output_code>
  <markdown>Como foi dito, não permitem duplicidades.</markdown>
  <input_code>diccionario = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964,
  "year": 2000,
  "colors": ["red", "white", "blue"]
}
diccionario["year"]</input_code>
  <output_code>2000</output_code>
  <markdown>Pode-se obter seu comprimento através da função `len()`</markdown>
  <input_code>len(diccionario)</input_code>
  <output_code>4</output_code>
  <markdown>Como se pode ver, a comprimento é 4 e não 5, pois `year` é contado apenas uma vez.</markdown>
  <markdown>#### 2.4.1. Acessar os itens</markdown>
  <markdown>Para acessar, podemos fazer isso através de sua `key`</markdown>
  <input_code>diccionario["model"]</input_code>
  <output_code>'Mustang'</output_code>
  <markdown>Também pode ser acessado através do método `get`</markdown>
  <input_code>diccionario.get("model")</input_code>
  <output_code>'Mustang'</output_code>
  <markdown>Para saber todas as `key`s dos dicionários se pode usar o método `keys()`</markdown>
  <input_code>diccionario.keys()</input_code>
  <output_code>dict_keys(['brand', 'model', 'year', 'colors'])</output_code>
  <markdown>Pode-se usar uma variável para apontar para as `key`s do dicionário, com o que chamando-a uma vez é necessário</markdown>
  <input_code>diccionario = {
"brand": "Ford",
"model": "Mustang",
"year": 1964
}

# Se declara una vez la variable que apunta a las keys
x = diccionario.keys()
print(x)

# Se añade una nueva key
diccionario["color"] = "white"

# Se consulta la variable que apunta a las key
print(x)</input_code>
  <output_code>dict_keys(['brand', 'model', 'year'])
dict_keys(['brand', 'model', 'year', 'color'])
</output_code>
  <markdown>Para obter os valores do dicionário, pode-se usar o método `values()`</markdown>
  <input_code>diccionario.values()</input_code>
  <output_code>dict_values(['Ford', 'Mustang', 1964, 'white'])</output_code>
  <markdown>Pode-se usar uma variável para apontar para os `values` do dicionário, com isso, chamando-a uma vez é necessário.</markdown>
  <input_code>diccionario = {
"brand": "Ford",
"model": "Mustang",
"year": 1964
}

# Se declara una vez la variable que apunta a los values
x = diccionario.values()
print(x)

# Se modifica un value
diccionario["year"] = 2020

# Se consulta la variable que apunta a los values
print(x)</input_code>
  <output_code>dict_values(['Ford', 'Mustang', 1964])
dict_values(['Ford', 'Mustang', 2020])
</output_code>
  <markdown>Se `items` inteiros forem desejados, ou seja, `key`s e `value`s, deve-se usar o método `items()`.</markdown>
  <input_code>diccionario.items()</input_code>
  <output_code>dict_items([('brand', 'Ford'), ('model', 'Mustang'), ('year', 2020)])</output_code>
  <markdown>Pode-se usar uma variável para apontar para os `item`s do dicionário, com o que chamá-la uma vez é necessário</markdown>
  <input_code>diccionario = {
"brand": "Ford",
"model": "Mustang",
"year": 1964
}

# Se declara una vez la variable que apunta a los items
x = diccionario.items()
print(x)

# Se modifica un value
diccionario["year"] = 2020

# Se consulta la variable que apunta a los items
print(x)</input_code>
  <output_code>dict_items([('brand', 'Ford'), ('model', 'Mustang'), ('year', 1964)])
dict_items([('brand', 'Ford'), ('model', 'Mustang'), ('year', 2020)])
</output_code>
  <markdown>Pode-se verificar se uma `key` existe no dicionário</markdown>
  <input_code>"model" in diccionario</input_code>
  <output_code>True</output_code>
  <markdown>#### 2.4.2. Modificar os itens</markdown>
  <markdown>Pode modificar um `item` acessando-o diretamente</markdown>
  <input_code>diccionario = {
"brand": "Ford",
"model": "Mustang",
"year": 1964
}

# Se modifica un item
diccionario["year"] = 2020

diccionario</input_code>
  <output_code>{'brand': 'Ford', 'model': 'Mustang', 'year': 2020}</output_code>
  <markdown>Ou pode ser modificado através do método `update()`</markdown>
  <input_code>diccionario = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}

# Se modifica un item
diccionario.update({"year": 2020})

diccionario</input_code>
  <output_code>{'brand': 'Ford', 'model': 'Mustang', 'year': 2020}</output_code>
  <markdown>#### 2.4.3. Adicionar itens</markdown>
  <markdown>Pode adicionar um `item` adicionando-o desta maneira:</markdown>
  <input_code>diccionario = {
"brand": "Ford",
"model": "Mustang",
"year": 1964
}

# Se modifica un item
diccionario["colour"] = "blue"

diccionario</input_code>
  <output_code>{'brand': 'Ford', 'model': 'Mustang', 'year': 1964, 'colour': 'blue'}</output_code>
  <markdown>Ou pode ser adicionado através do método `update()`</markdown>
  <input_code>diccionario = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}

# Se modifica un item
diccionario.update({"colour": "blue"})

diccionario</input_code>
  <output_code>{'brand': 'Ford', 'model': 'Mustang', 'year': 1964, 'colour': 'blue'}</output_code>
  <markdown>#### 2.4.4. Remover itens</markdown>
  <markdown>Pode-se eliminar um `item` com uma `key` específica mediante o método `pop()`</markdown>
  <input_code>diccionario = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}

# Se elimina un item
diccionario.pop("model")

diccionario</input_code>
  <output_code>{'brand': 'Ford', 'year': 1964}</output_code>
  <markdown>Ou se pode eliminar um `item` com uma `key` específica mediante `del` indicando o nome da `key` entre os símbolos `[]`</markdown>
  <input_code>diccionario = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}

# Se elimina un item
del diccionario["model"]

diccionario</input_code>
  <output_code>{'brand': 'Ford', 'year': 1964}</output_code>
  <markdown>O dicionário inteiro é removido se `del` for usado e não for especificada a `key` de um `item`</markdown>
  <input_code>diccionario = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}

# Se elimina un item
del diccionario

if 'diccionario' not in locals():
  print("diccionario eliminado")</input_code>
  <output_code>diccionario eliminado
</output_code>
  <markdown>Se `popitem()` é o método a ser usado se deseja remover o último `item` inserido.</markdown>
  <input_code>diccionario = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}

# Se elimina el último item introducido
diccionario.popitem()

diccionario</input_code>
  <output_code>{'brand': 'Ford', 'model': 'Mustang'}</output_code>
  <markdown>Se quer limpar o dicionário, é necessário usar o método `clear()`</markdown>
  <input_code>diccionario = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
diccionario.clear()
diccionario</input_code>
  <output_code>{}</output_code>
  <markdown>#### 2.4.5. Copiar dicionários</markdown>
  <markdown>Não se podem copiar dicionários mediante `diccionario1 = diccionario2`, já que se `diccionario1` for modificado, `diccionario2` também será modificado.</markdown>
  <input_code>diccionario1 = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
diccionario2 = diccionario1
diccionario1["year"] = 2000
diccionario2["year"]</input_code>
  <output_code>2000</output_code>
  <markdown>Portanto, é necessário usar o método `copy()`</markdown>
  <input_code>diccionario1 = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
diccionario2 = diccionario1.copy()
diccionario1["year"] = 2000
diccionario2["year"]</input_code>
  <output_code>1964</output_code>
  <markdown>Ó hay que usar o construtor de dicionários `dict()`</markdown>
  <input_code>diccionario1 = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
diccionario2 = dict(diccionario1)
diccionario1["year"] = 2000
diccionario2["year"]</input_code>
  <output_code>1964</output_code>
  <markdown>#### 2.4.6. Dicionários aninhados</markdown>
  <markdown>Os dicionários podem ter `items` de qualquer tipo de dado, inclusive outros dicionários. A este tipo de dicionários se les denomina dicionários `nested`</markdown>
  <input_code>diccionario_nested = {
  "child1" : {
    "name" : "Emil",
    "year" : 2004
  },
  "child2" : {
    "name" : "Tobias",
    "year" : 2007
  },
  "child3" : {
    "name" : "Linus",
    "year" : 2011
  }
}
diccionario_nested</input_code>
  <output_code>{'child1': {'name': 'Emil', 'year': 2004},
 'child2': {'name': 'Tobias', 'year': 2007},
 'child3': {'name': 'Linus', 'year': 2011}}</output_code>
  <input_code>child1 = {
  "name" : "Emil",
  "year" : 2004
}
child2 = {
  "name" : "Tobias",
  "year" : 2007
}
child3 = {
  "name" : "Linus",
  "year" : 2011
}

diccionario_nested = {
  "child1" : child1,
  "child2" : child2,
  "child3" : child3
}

diccionario_nested</input_code>
  <output_code>{'child1': {'name': 'Emil', 'year': 2004},
 'child2': {'name': 'Tobias', 'year': 2007},
 'child3': {'name': 'Linus', 'year': 2011}}</output_code>
  <markdown>#### 2.4.7. Métodos dos dicionários</markdown>
  <markdown>Estes são os [métodos](https://www.w3schools.com/python/python_dictionaries_methods.asp) que podem ser usados em dicionários</markdown>
  <markdown>#### 2.4.8. Compreensão de dicionário</markdown>
  <markdown>Igual que podíamos fazer `list comprehensions` mediante a sintaxe

```python
list_comprehension = [expressão for item in iterável if condição == True]
```

Podemos fazer `dictionaries comprehensions` mediante a seguinte sintaxe

``` python
dictionary_comprehension = {expressão_chave: expressão_valor for item in iterável if condição == True}
```

Vamos ver um exemplo</markdown>
  <input_code>dictionary_comprehension = {x: x**2 for x in (2, 4, 6) if x &gt; 2}
dictionary_comprehension</input_code>
  <output_code>{4: 16, 6: 36}</output_code>
  <markdown>### 2.5. Sets</markdown>
  <markdown>#### 2.5.1. Conjunto</markdown>
  <markdown>Os `set`s são usados em Python para guardar um conjunto de itens em uma única variável. Eles podem armazenar itens de diferentes tipos. São não ordenados e não têm índice.

Diferem das listas em que não têm nem ordem nem índice.

São declarados com os símbolos `{}`</markdown>
  <markdown>Como `set` é uma palavra reservada em Python, criamos um `set` com o nome `set_`</markdown>
  <input_code>set_ = {'item0', 1, 5.3, "item4", 5, 6.6}
set_</input_code>
  <output_code>{1, 5, 5.3, 6.6, 'item0', 'item4'}</output_code>
  <markdown>Não pode haver itens duplicados, se encontrar algum item duplicado, fica apenas com um.</markdown>
  <input_code>set_ = {'item0', 1, 5.3, "item4", 5, 6.6, 'item0'}
set_</input_code>
  <output_code>{1, 5, 5.3, 6.6, 'item0', 'item4'}</output_code>
  <markdown>Pode-se obter o comprimento do `set` através da função `len()`</markdown>
  <input_code>len(set_)</input_code>
  <output_code>6</output_code>
  <markdown>Como se pode ver, o comprimento do set é 6 e não 7, pois ele mantém apenas um `'item0'`.</markdown>
  <markdown>Pode-se verificar se um item está presente no set</markdown>
  <input_code>'item4' in set_</input_code>
  <output_code>True</output_code>
  <markdown>##### 2.5.1.1. Adicionar itens</markdown>
  <markdown>Pode-se adicionar um elemento ao conjunto usando o método `add()`</markdown>
  <input_code>set_.add(8.8)
set_</input_code>
  <output_code>{1, 5, 5.3, 6.6, 8.8, 'item0', 'item4'}</output_code>
  <markdown>Pode-se adicionar outro conjunto usando o método `update()'</markdown>
  <input_code>set2 = {"item5", "item6", 7}
set_.update(set2)
set_</input_code>
  <output_code>{1, 5, 5.3, 6.6, 7, 8.8, 'item0', 'item4', 'item5', 'item6'}</output_code>
  <markdown>Também é possível adicionar itens de tipos de dados iteráveis de Python</markdown>
  <input_code>lista = ["item9", 10, 11.2]
set_.update(lista)
set_</input_code>
  <output_code>{1, 10, 11.2, 5, 5.3, 6.6, 7, 8.8, 'item0', 'item4', 'item5', 'item6', 'item9'}</output_code>
  <markdown>##### 2.5.1.2. Eliminar itens</markdown>
  <markdown>Pode-se remover um item específico através do método `remove()`</markdown>
  <input_code>set_.remove('item9')
set_</input_code>
  <output_code>{1, 10, 11.2, 5, 5.3, 6.6, 7, 8.8, 'item0', 'item4', 'item5', 'item6'}</output_code>
  <markdown>O mediante o `discard()`</markdown>
  <input_code>set_.discard('item6')
set_</input_code>
  <output_code>{1, 10, 11.2, 5, 5.3, 6.6, 7, 8.8, 'item0', 'item4', 'item5'}</output_code>
  <markdown>Com o método `pop()` pode ser usado para remover o último item, mas como os `set`s não são ordenados, não há como saber qual é o último item. O método `pop()` retorna o item removido.</markdown>
  <input_code>print(f"set antes de pop(): {set_}")
eliminado = set_.pop()
print(f"Se ha eliminado {eliminado}")</input_code>
  <output_code>set antes de pop(): {1, 5, 5.3, 6.6, 8.8, 7, 10, 11.2, 'item5', 'item0', 'item4'}
Se ha eliminado 1
</output_code>
  <markdown>Por meio do método `clear()` é possível esvaziar o conjunto</markdown>
  <input_code>set_.clear()
set_</input_code>
  <output_code>set()</output_code>
  <markdown>Por último, com `del` pode-se eliminar o set</markdown>
  <input_code>del set_

if 'set_' not in locals():
  print("set eliminado")</input_code>
  <output_code>set eliminado
</output_code>
  <markdown>##### 2.5.1.3. Unir itens</markdown>
  <markdown>Uma forma de unir conjuntos é mediante o método `union()`</markdown>
  <input_code>set1 = {"a", "b" , "c"}
set2 = {1, 2, 3}
set3 = set1.union(set2)
set3</input_code>
  <output_code>{1, 2, 3, 'a', 'b', 'c'}</output_code>
  <markdown>Outra forma é através do método `update()`, mas desta maneira um set é adicionado a outro, não é criado um novo.</markdown>
  <input_code>set1 = {"a", "b" , "c"}
set2 = {1, 2, 3}
set1.update(set2)
set1</input_code>
  <output_code>{1, 2, 3, 'a', 'b', 'c'}</output_code>
  <markdown>Estes métodos de união eliminam os duplicados, mas se quisermos obter os elementos duplicados em dois sets usamos o método `intersection()`</markdown>
  <input_code>set1 = {"apple", "banana", "cherry"}
set2 = {"google", "microsoft", "apple"}

set3 = set1.intersection(set2)
set3</input_code>
  <output_code>{'apple'}</output_code>
  <markdown>Se quisermos obter os elementos duplicados em dois conjuntos, mas sem criar um novo conjunto, usamos o método `intersection_update()`</markdown>
  <input_code>set1 = {"apple", "banana", "cherry"}
set2 = {"google", "microsoft", "apple"}

set1.intersection_update(set2)
set1</input_code>
  <output_code>{'apple'}</output_code>
  <markdown>Agora ao contrário, se quisermos ficar com os não duplicados usamos o método `symmetric_difference()`.

A diferença entre isso e a união entre dois conjuntos é que na união são mantidos todos os itens, mas os que estão duplicados são pegos apenas uma vez. Agora ficamos com os que não estão duplicados.</markdown>
  <input_code>set1 = {"apple", "banana", "cherry"}
set2 = {"google", "microsoft", "apple"}

set3 = set1.symmetric_difference(set2)
set3</input_code>
  <output_code>{'banana', 'cherry', 'google', 'microsoft'}</output_code>
  <markdown>Se quisermos ficar com os não duplicados sem criar um novo conjunto, usamos o método `symmetric_difference_update()`</markdown>
  <input_code>set1 = {"apple", "banana", "cherry"}
set2 = {"google", "microsoft", "apple"}

set1.symmetric_difference_update(set2)
set1</input_code>
  <output_code>{'banana', 'cherry', 'google', 'microsoft'}</output_code>
  <markdown>##### 2.5.1.4. Métodos dos conjuntos</markdown>
  <markdown>Estes são os [métodos](https://www.w3schools.com/python/python_sets_methods.asp) que podem ser usados em sets</markdown>
  <markdown>#### 2.5.2. FrozenSet</markdown>
  <markdown>Os `frozenset`s são como os `set`s, mas com a diferença de que são imutáveis, assim como as `tupla`s são como as `list`s, mas imutáveis. Portanto, não podemos adicionar ou remover itens.</markdown>
  <markdown>### 2.6. Booleanos</markdown>
  <markdown>Há apenas dois booleanos em Python: `True` e `False`

</markdown>
  <markdown>Com a função `bool()` pode ser usada para avaliar se algo é `True` ou `False`</markdown>
  <input_code>print(bool("Hello"))
print(bool(15))
print(bool(0))</input_code>
  <output_code>True
True
False
</output_code>
  <markdown>#### 2.6.1. Outros tipos de dados True e False</markdown>
  <markdown>Os seguintes dados são `True`:
*   Qualquer string que não esteja vazia
*   Qualquer número exceto o 0
*   Qualquer lista, tupla, dicionário ou set que não esteja vazio

</markdown>
  <input_code>print(bool("Hola"))
print(bool(""))</input_code>
  <output_code>True
False
</output_code>
  <input_code>print(bool(3))
print(bool(0))</input_code>
  <output_code>True
False
</output_code>
  <input_code>lista = [1, 2, 3]
print(bool(lista))

lista = []
print(bool(lista))</input_code>
  <output_code>True
False
</output_code>
  <input_code>tupla = (1, 2, 3)
print(bool(tupla))

tupla = ()
print(bool(tupla))</input_code>
  <output_code>True
False
</output_code>
  <input_code>diccionario = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964,
  "colors": ["red", "white", "blue"]
}
print(bool(diccionario))

diccionario.clear()
print(bool(diccionario))</input_code>
  <output_code>True
False
</output_code>
  <input_code>set_ = {'item0', 1, 5.3, "item4", 5, 6.6}
print(bool(set_))

set_.clear()
print(bool(set_))</input_code>
  <output_code>True
False
</output_code>
  <markdown>### 2.7. Binários</markdown>
  <markdown>#### 2.7.1. Bytes</markdown>
  <markdown>O tipo `bytes` é uma sequência imutável de bytes. Apenas aceitam caracteres ASCII. Também se podem representar os bytes através de números inteiros cujos valores devem satisfazer `0 &lt;= x &lt; 256`</markdown>
  <markdown>Para criar um tipo byte devemos introduzir antes o caractere `b`</markdown>
  <input_code>byte = b"MaximoFN"
byte</input_code>
  <output_code>b'MaximoFN'</output_code>
  <markdown>Também podem ser criados através do seu construtor `bytes()`</markdown>
  <input_code>byte = bytes(10)
byte</input_code>
  <output_code>b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'</output_code>
  <input_code>byte = bytes(range(10))
byte</input_code>
  <output_code>b'\x00\x01\x02\x03\x04\x05\x06\x07\x08\t'</output_code>
  <markdown>Bytes podem ser concatenados utilizando o operador `+`</markdown>
  <input_code>byte1 = b'DeepMax'
byte2 = b'FN'
byte3 = byte1 + byte2
byte3</input_code>
  <output_code>b'DeepMaxFN'</output_code>
  <markdown>Ou através da repetição com o operador `*`</markdown>
  <input_code>byte1 = b'MaximoFN '
byte2 = byte1 * 3
byte2</input_code>
  <output_code>b'MaximoFN MaximoFN MaximoFN '</output_code>
  <markdown>Podemos verificar se um caractere está dentro da string</markdown>
  <input_code>b'D' in byte1</input_code>
  <output_code>False</output_code>
  <markdown>Estes são os [métodos](https://plataforma.josedomingo.org/pledin/cursos/python3/curso/u30/#m%C3%A9todos-de-bytes-e-bytearray) que podem ser usados em `bytes`</markdown>
  <markdown>#### 2.7.2. Bytearray</markdown>
  <markdown>Os `bytearray`s são iguais aos `bytes` só que são mutáveis.</markdown>
  <input_code>byte_array = bytearray(b'MaximoFN')
byte_array</input_code>
  <output_code>bytearray(b'MaximoFN')</output_code>
  <markdown>#### 2.7.3. MemoryView</markdown>
  <markdown>Os objetos `memoryview` permitem que o código Python acesse os dados internos de um objeto que suporta o protocolo de buffer sem realizar cópias.

A função `memoryview()` permite o acesso direto de leitura e escrita aos dados orientados a bytes de um objeto sem necessidade de copiá-los primeiro. Isso pode gerar grandes ganhos de desempenho ao operar com objetos grandes, pois não cria uma cópia ao fatiar.

Protocolo de buffer, pode criar outro objeto de acesso para modificar dados grandes sem copiá-los. Isso faz com que o programa utilize menos memória e aumente a velocidade de execução.</markdown>
  <input_code>byte_array = bytearray('XYZ', 'utf-8')
print(f'Antes de acceder a la memoria: {byte_array}')

mem_view = memoryview(byte_array)

mem_view[2]= 74
print(f'Después de acceder a la memoria: {byte_array}')</input_code>
  <output_code>Antes de acceder a la memoria: bytearray(b'XYZ')
Después de acceder a la memoria: bytearray(b'XYJ')
</output_code>
  <markdown>## 3. Operadores</markdown>
  <markdown>### 3.1. Operadores aritméticos</markdown>
  <markdown>Operador soma `+`</markdown>
  <input_code>3 + 5</input_code>
  <output_code>8</output_code>
  <markdown>Operador subtração -</markdown>
  <input_code>3 - 5</input_code>
  <output_code>-2</output_code>
  <markdown>Operador de multiplicação `*`</markdown>
  <input_code>3 * 5</input_code>
  <output_code>15</output_code>
  <markdown>Operador divisão `/`</markdown>
  <input_code>3 / 5</input_code>
  <output_code>0.6</output_code>
  <markdown>Operador módulo `%`. Retorna o resto de uma divisão.</markdown>
  <input_code>25 % 2</input_code>
  <output_code>1</output_code>
  <markdown>Operador exponencial `**`</markdown>
  <input_code>5 ** 2</input_code>
  <output_code>25</output_code>
  <markdown>Operador divisão inteira `//`</markdown>
  <input_code>25 // 2</input_code>
  <output_code>12</output_code>
  <markdown>### 3.2. Operadores de comparação</markdown>
  <markdown>Operador é igual `==`</markdown>
  <input_code>1 == 1</input_code>
  <output_code>True</output_code>
  <markdown>Operador diferente `!=`</markdown>
  <input_code>1 != 2</input_code>
  <output_code>True</output_code>
  <markdown>Operador é maior que `&gt;`</markdown>
  <input_code>3 &gt; 2</input_code>
  <output_code>True</output_code>
  <markdown>Operador é menor que `&lt;`</markdown>
  <input_code>2 &lt; 3</input_code>
  <output_code>True</output_code>
  <markdown>Operador é maior ou igual que `&gt;=`</markdown>
  <input_code>3 &gt;= 3</input_code>
  <output_code>True</output_code>
  <markdown>Operador é menor ou igual que `&lt;=`</markdown>
  <input_code>3 &lt;= 3</input_code>
  <output_code>True</output_code>
  <markdown>### 3.3. Operadores lógicos</markdown>
  <markdown>Operador `and`</markdown>
  <input_code>True and True</input_code>
  <output_code>True</output_code>
  <markdown>Operador `or`</markdown>
  <input_code>True or False</input_code>
  <output_code>True</output_code>
  <markdown>Operador `not`</markdown>
  <input_code>not False</input_code>
  <output_code>True</output_code>
  <markdown>### 34. Operadores de identidade</markdown>
  <markdown>Operador `is`</markdown>
  <input_code>5.3 is 5.3</input_code>
  <output_code>True</output_code>
  <markdown>Operador `is not`</markdown>
  <input_code>5.3 is not 5</input_code>
  <output_code>True</output_code>
  <markdown>### 35. Operadores de pertinência</markdown>
  <markdown>Operador `in`</markdown>
  <input_code>x = ["apple", "banana"]

"banana" in x</input_code>
  <output_code>True</output_code>
  <markdown>Operador `not in`</markdown>
  <input_code>x = ["apple", "banana"]

"orange" not in x</input_code>
  <output_code>True</output_code>
  <markdown>### 36. Operadores bit a bit</markdown>
  <markdown>Operador AND `&amp;`</markdown>
  <input_code>a = 60            # 60 = 0011 1100 
b = 13            # 13 = 0000 1101 

c = a &amp; b;        # 12 = 0000 1100
c</input_code>
  <output_code>12</output_code>
  <markdown>Operador OU `|`</markdown>
  <input_code>a = 60            # 60 = 0011 1100 
b = 13            # 13 = 0000 1101 

c = a | b;        # 61 = 0011 1101
c</input_code>
  <output_code>61</output_code>
  <markdown>Operador XOR `^`</markdown>
  <input_code>a = 60            # 60 = 0011 1100 
b = 13            # 13 = 0000 1101 

c = a ^ b;        # 49 = 0011 0001
c</input_code>
  <output_code>49</output_code>
  <markdown>Operador NOT `~`</markdown>
  <input_code>a = 60            # 60 = 0011 1100 

c = ~a;           # -61 = 1100 0011
c</input_code>
  <output_code>-61</output_code>
  <markdown>Operador de deslocamento para a esquerda `&lt;&lt;`</markdown>
  <input_code>a = 60            # 60 = 0011 1100 

c = a &lt;&lt; 2;       # 240 = 1111 0000
c</input_code>
  <output_code>240</output_code>
  <markdown>Operador de deslocamento para a direita `&gt;&gt;`</markdown>
  <input_code>a = 60            # 60 = 0011 1100 

c = a &gt;&gt; 2;       # 15 = 0000 1111
c</input_code>
  <output_code>15</output_code>
  <markdown>### 37. Operadores de atribuição</markdown>
  <markdown>Operador `=`</markdown>
  <input_code>a = 5
a</input_code>
  <output_code>5</output_code>
  <markdown>Operador `+=`. `x += y` é equivalente a `x = x + y`</markdown>
  <input_code>a += 5
a</input_code>
  <output_code>10</output_code>
  <markdown>Operador `-=`. `x -= y` é equivalente a `x = x - y`</markdown>
  <input_code>a -= 5
a</input_code>
  <output_code>5</output_code>
  <markdown>Operador `*=`. `x *= y` é equivalente a `x = x * y`</markdown>
  <input_code>a *= 3
a</input_code>
  <output_code>15</output_code>
  <markdown>Operador `/=`. `x /= y` é equivalente a `x = x / y`</markdown>
  <input_code>a /= 3
a</input_code>
  <output_code>5.0</output_code>
  <markdown>Operador `%=`. `x %= y` é equivalente a `x = x % y`</markdown>
  <input_code>a = 25
a %= 2
a</input_code>
  <output_code>1</output_code>
  <markdown>Operador `//=`. `x //= y` é equivalente a `x = x // y`</markdown>
  <input_code>a = 25
a //= 2
a</input_code>
  <output_code>12</output_code>
  <markdown>Operador `**=`. `x **= y` é equivalente a `x = x ** y`</markdown>
  <input_code>a = 5
a **= 2
a</input_code>
  <output_code>25</output_code>
  <markdown>Operador `&amp;=`. `x &amp;= y` é equivalente a `x = x &amp; y`</markdown>
  <input_code>a = 60            # 60 = 0011 1100 
b = 13            # 13 = 0000 1101 

a &amp;= b;           # 12 = 0000 1100
a</input_code>
  <output_code>12</output_code>
  <markdown>Operador `|=`. `x |= y` é equivalente a `x = x | y`</markdown>
  <input_code>a = 60            # 60 = 0011 1100 
b = 13            # 13 = 0000 1101 

a |= b;           # 61 = 0011 1101
a</input_code>
  <output_code>61</output_code>
  <markdown>Operador `^=`. `x ^= y` é equivalente a `x = x ^ y`</markdown>
  <input_code>a = 60            # 60 = 0011 1100 
b = 13            # 13 = 0000 1101 

a ^= b;           # 49 = 0011 0001
a</input_code>
  <output_code>49</output_code>
  <markdown>Operador `&gt;&gt;=`. `x &gt;&gt;= y` é equivalente a `x = x &gt;&gt; y`</markdown>
  <input_code>a = 60            # 60 = 0011 1100 

a &lt;&lt;= 2;          # 240 = 1111 0000
a</input_code>
  <output_code>240</output_code>
  <markdown>Operador `&lt;&lt;=`. `x &lt;&lt;= y` é equivalente a `x = x &lt;&lt; y`</markdown>
  <input_code>a = 60            # 60 = 0011 1100 

a &gt;&gt;= 2;          # 15 = 0000 1111
a</input_code>
  <output_code>15</output_code>
  <markdown>## 4. Controle de fluxo</markdown>
  <markdown>Para poder utilizar as ferramentas de controle de fluxo é necessário adicionar a sentença, dois pontos `:` e em uma nova linha escrever o código com indentação.

Diferente de outras linguagens, Python precisa de indentação (adicionar um espaço em branco) para definir o código dentro de uma ferramenta de Controle de Fluxo.</markdown>
  <markdown>### 4.1. Se</markdown>
  <markdown>Com `if` podemos criar condicionais</markdown>
  <input_code>if len('MaximoFN') == 8:
  print('MaximoFN tiene 8 caracteres')</input_code>
  <output_code>MaximoFN tiene 8 caracteres
</output_code>
  <markdown>Se quisermos criar mais de uma condição, podemos usar `elif`.</markdown>
  <input_code>if len('MaximoFN') &lt; 8:
  print('MaximoFN tiene menos de 8 caracteres')
elif len('MaximoFN') == 8:
  print('MaximoFN tiene 8 caracteres')</input_code>
  <output_code>MaximoFN tiene 8 caracteres
</output_code>
  <markdown>Se quisermos que se execute algo em caso de que não se cumpra nenhuma das condições indicadas, podemos usar `else`</markdown>
  <input_code>if len('MaximoFN') &lt; 8:
  print('MaximoFN tiene menos de 8 caracteres')
elif len('MaximoFN') &gt; 8:
  print('MaximoFN tiene más de 8 caracteres')
else:
  print('MaximoFN tiene 8 caracteres')</input_code>
  <output_code>MaximoFN tiene 8 caracteres
</output_code>
  <markdown>Se quisermos escrever tudo em uma única linha</markdown>
  <input_code>if len('MaximoFN') == 8: print('MaximoFN tiene 8 caracteres')</input_code>
  <output_code>MaximoFN tiene 8 caracteres
</output_code>
  <markdown>Igual, se quisermos escrever tudo em uma linha, mas com várias condições.</markdown>
  <input_code>print('MaximoFN tiene menos de 8 caracteres') if len('MaximoFN') &lt; 8 else print('MaximoFN tiene más de 8 caracteres') if len('MaximoFN') &gt; 8 else print('MaximoFN tiene 8 caracteres')</input_code>
  <output_code>MaximoFN tiene 8 caracteres
</output_code>
  <markdown>Se quisermos fazer a estrutura do `if` mas não quisermos, por enquanto, codificar uma das condições, podemos usar `pass`</markdown>
  <input_code>if len('MaximoFN') &lt; 8:
  print('MaximoFN tiene menos de 8 caracteres')
elif len('MaximoFN') &gt; 8:
  pass
else:
  print('MaximoFN tiene 8 caracteres')</input_code>
  <output_code>MaximoFN tiene 8 caracteres
</output_code>
  <markdown>### 4.2. Enquanto</markdown>
  <markdown>O bloco `while` é executado enquanto a condição for `True`</markdown>
  <input_code>i = 0
string = 'MaximoFN'
while len(string) &gt; i:
  print(string[i], end='')
  i += 1</input_code>
  <output_code>MaximoFN</output_code>
  <markdown>Se quisermos que o bucle pare por alguma condição usamos `break`</markdown>
  <input_code>i = 0
string = 'MaximoFN'
while len(string) &gt; i:
  if string[i] == 'F':
    break
  print(string[i], end='')
  i += 1</input_code>
  <output_code>Maximo</output_code>
  <markdown>Se quisermos que uma das iterações não se execute por algum motivo, usamos `continue`</markdown>
  <input_code>i = 0
string = 'Maximo FN'
while len(string) &gt; i:
  if string[i] == ' ':
    i += 1
    continue
  print(string[i], end='')
  i += 1</input_code>
  <output_code>MaximoFN</output_code>
  <markdown>Com `else` é possível executar um bloco de código se a condição do `while` não for `True`</markdown>
  <input_code>i = 0
string = 'MaximoFN'

while len(string) &gt; i:
  print(string[i], end='')
  i += 1
else:
  print("\nSe ha terminado el while")</input_code>
  <output_code>MaximoFN
Se ha terminado el while
</output_code>
  <markdown>### 4.3. Para</markdown>
  <markdown>O bloco `for` é usado para executar código enquanto itera por uma sequência, esta sequência pode ser qualquer elemento iterável de Python (`string`, `lista`, `tupla`, `range`, `dicionário`, `set`)</markdown>
  <input_code>string = 'MaximoFN'

for x in string:
  print(x, end='')</input_code>
  <output_code>MaximoFN</output_code>
  <input_code>lista = ['M', 'a', 'x', 'i', 'm', 'o', 'F', 'N']

for x in lista:
  print(x, end='')</input_code>
  <output_code>MaximoFN</output_code>
  <input_code>tupla = ('M', 'a', 'x', 'i', 'm', 'o', 'F', 'N')

for x in tupla:
  print(x, end='')</input_code>
  <output_code>MaximoFN</output_code>
  <input_code>string = 'MaximoFN'

for i in range(len(string)):
  print(string[i], end='')</input_code>
  <output_code>MaximoFN</output_code>
  <input_code>diccionario = {
  "letra1": "M",
  "letra2": "a",
  "letra3": "x",
  "letra4": "i",
  "letra5": "m",
  "letra6": "o",
  "letra7": "F",
  "letra8": "N",
}

for x in diccionario.values():
  print(x, end='')</input_code>
  <output_code>MaximoFN</output_code>
  <markdown>Também se pode iterar pelos `set`s, mas como são elementos não ordenados, não teremos controle sobre a ordem de execução.</markdown>
  <input_code>set_ = {'M', 'a', 'x', 'i', 'm', 'o', 'F', 'N'}

for x in set_:
  print(x, end='')</input_code>
  <output_code>NximoaMF</output_code>
  <markdown>Se quisermos que o bucle pare por alguma condição usamos `break`</markdown>
  <input_code>string = 'MaximoFN'

for x in string:
  if x == 'F':
    break
  print(x, end='') </input_code>
  <output_code>Maximo</output_code>
  <markdown>Se quisermos que uma das iterações não se execute por algum motivo, usamos `continue`</markdown>
  <input_code>string = 'Maximo FN'

for x in string:
  if x == ' ':
    continue
  print(x, end='') </input_code>
  <output_code>MaximoFN</output_code>
  <markdown>Com `else` é possível executar um bloco de código se a condição do `while` não for `True`</markdown>
  <input_code>string = 'MaximoFN'

for x in string:
  print(x, end='') 
else:
  print("\nSe ha terminado el for")</input_code>
  <output_code>MaximoFN
Se ha terminado el for
</output_code>
  <markdown>Se por exemplo, se quisermos fazer a estrutura do `for` mas não quisermos, por enquanto, codificar seu interior, podemos usar `pass`</markdown>
  <input_code>string = 'MaximoFN'
for x in string:
  pass
print('Interior del for no codificado')</input_code>
  <output_code>Interior del for no codificado
</output_code>
  <markdown>## 5. Funções</markdown>
  <markdown>Uma função é uma porção de código que pode ser executada tantas vezes quantas quiser. Ela pode receber argumentos e pode devolver dados como resultado.</markdown>
  <markdown>Para definir uma função, começa-se com a palavra reservada `def`, seguida do nome da função, parênteses `()`, dois pontos `:` e, em seguida, na linha seguinte, o código da função indentado.</markdown>
  <input_code>def funcion():
  print('MaximoFN')</input_code>
  <markdown>Para chamar a função, basta escrever seu nome.</markdown>
  <input_code>funcion()</input_code>
  <output_code>MaximoFN
</output_code>
  <markdown>As funções podem receber todos os argumentos que se deseja, dentro dos parênteses e separados por vírgulas.</markdown>
  <input_code>def funcion(string1, string2):
  print(string1 + ' ' + string2)

funcion("Hola", "MaximoFN")</input_code>
  <output_code>Hola MaximoFN
</output_code>
  <markdown>Quando se chama a função, deve-se passar o mesmo número de argumentos que foram declarados. Se forem passados mais ou menos, obteremos um Erro.

Se `*args` é usado quando não sabemos quantos argumentos a função vai receber. Isso significa que podemos passar um número variável de argumentos.

Ao fazer isso, passamos uma `tupla` (lembrando que ela é imutável) com os argumentos</markdown>
  <input_code>def funcion(*argumentos):
  numero_argumentos = len(argumentos)

  for i in range(numero_argumentos):
    print(argumentos[i], end=' ')

funcion("funcion", "con", "varios", "argumentos", "sin", "especificar", "cuantos")</input_code>
  <output_code>funcion con varios argumentos sin especificar cuantos </output_code>
  <markdown>Em caso de não saber a ordem dos argumentos de uma função, podemos indicar o argumento que queremos passar indicando seu nome.</markdown>
  <input_code>def funcion(argumento1, argumento2, argumento3):
  print(argumento1 + ' '+ argumento2 + ' ' + argumento3)

funcion(argumento3 = "MaximoFN", argumento1 = "Blog", argumento2 = "de")</input_code>
  <output_code>Blog de MaximoFN
</output_code>
  <markdown>Em caso de querer passar os argumentos com seus nomes, mas em caso de não saber quantos argumentos vão ser passados, pode usar `**kwargs`. Neste caso, será passado um dicionário com os argumentos.</markdown>
  <input_code>def funcion(**kargumentos):
  print("Autor del blog: " + kargumentos["autor"])

funcion(blog = "Blog", pertenencia = "de", autor = "MaximoFN")</input_code>
  <output_code>Autor del blog: MaximoFN
</output_code>
  <markdown>Se quisermos que algum argumento tenha um valor padrão, podemos indicá-lo entre os parênteses da função. Dessa forma, se na hora de chamar a função não for passado esse argumento, este na função terá o valor padrão.</markdown>
  <input_code>def funcion(argumento1, argumento2, argumento3 = "MaximoFN"):
  print(argumento1 + ' '+ argumento2 + ' ' + argumento3)

funcion("Blog", "de")</input_code>
  <output_code>Blog de MaximoFN
</output_code>
  <markdown>Pode passar qualquer tipo de dado como argumento. Por exemplo, se você passar uma `lista` como argumento, dentro da função, esse argumento será tratado como uma `lista`</markdown>
  <input_code>def funcion(argumento):
  longitud_lista = len(argumento)

  for i in range(longitud_lista):
    print(argumento[i], end=' ')

funcion(["Blog", "de", "MaximoFN"])</input_code>
  <output_code>Blog de MaximoFN </output_code>
  <markdown>As funções podem devolver dados, isso é feito através da palavra reservada `return`</markdown>
  <input_code>def funcion(argumento):
  longitud_lista = len(argumento)
  string = ""

  for i in range(longitud_lista):
    string = string + argumento[i] + ' '

  return string

print(funcion(["Blog", "de", "MaximoFN"]))</input_code>
  <output_code>Blog de MaximoFN 
</output_code>
  <markdown>Podem devolver mais de um dado</markdown>
  <input_code>def funcion(argumento):
  longitud_lista = len(argumento)
  string0 = argumento[0]
  string1 = argumento[1]
  string2 = argumento[2]

  return string0, string1, string2

dato0, dato1, dato2 = funcion(["Blog", "de", "MaximoFN"])

print(dato0 + ' ' + dato1 + ' ' + dato2)</input_code>
  <output_code>Blog de MaximoFN
</output_code>
  <markdown>Se um dos dados devolvidos não nos interessar, podemos ignorá-lo utilizando `_`</markdown>
  <input_code>def funcion(argumento):
  longitud_lista = len(argumento)
  string0 = argumento[0]
  string1 = argumento[1]
  string2 = argumento[2]

  return string0, string1, string2

_, _, dato_de_interes = funcion(["Blog", "de", "MaximoFN"])

print(dato_de_interes)</input_code>
  <output_code>MaximoFN
</output_code>
  <markdown>Se quisermos criar a estrutura da função, mas não quisermos, por enquanto, codificar o interior, podemos usar `pass`</markdown>
  <input_code>def funcion():
  pass

funcion()</input_code>
  <markdown>A função pode chamar a si mesma, a isso se chama recursão ou recursividade da função.

Por exemplo, podemos usar esta qualidade para calcular o fatorial de um número</markdown>
  <input_code>def factorial(n):
  if n == 0 or n == 1:
    return 1
  else:
    return n * factorial(n-1)

factorial(5)</input_code>
  <output_code>120</output_code>
  <markdown>### 5.1. Funções integradas</markdown>
  <markdown>Há uma série de funções já definidas em Python que podem ser usadas, como, por exemplo, a função `abs()`, que retorna o valor absoluto.</markdown>
  <input_code>abs(-5)</input_code>
  <output_code>5</output_code>
  <markdown>A seguir-se uma lista dessas funções</markdown>
  <input_code>import builtins

dir(builtins)</input_code>
  <output_code>['ArithmeticError',
 'AssertionError',
 'AttributeError',
 'BaseException',
 'BlockingIOError',
 'BrokenPipeError',
 'BufferError',
 'BytesWarning',
 'ChildProcessError',
 'ConnectionAbortedError',
 'ConnectionError',
 'ConnectionRefusedError',
 'ConnectionResetError',
 'DeprecationWarning',
 'EOFError',
 'Ellipsis',
 'EnvironmentError',
 'Exception',
 'False',
 'FileExistsError',
 'FileNotFoundError',
 'FloatingPointError',
 'FutureWarning',
 'GeneratorExit',
 'IOError',
 'ImportError',
 'ImportWarning',
 'IndentationError',
 'IndexError',
 'InterruptedError',
 'IsADirectoryError',
 'KeyError',
 'KeyboardInterrupt',
 'LookupError',
 'MemoryError',
 'ModuleNotFoundError',
 'NameError',
 'None',
 'NotADirectoryError',
 'NotImplemented',
 'NotImplementedError',
 'OSError',
 'OverflowError',
 'PendingDeprecationWarning',
 'PermissionError',
 'ProcessLookupError',
 'RecursionError',
 'ReferenceError',
 'ResourceWarning',
 'RuntimeError',
 'RuntimeWarning',
 'StopAsyncIteration',
 'StopIteration',
 'SyntaxError',
 'SyntaxWarning',
 'SystemError',
 'SystemExit',
 'TabError',
 'TimeoutError',
 'True',
 'TypeError',
 'UnboundLocalError',
 'UnicodeDecodeError',
 'UnicodeEncodeError',
 'UnicodeError',
 'UnicodeTranslateError',
 'UnicodeWarning',
 'UserWarning',
 'ValueError',
 'Warning',
 'ZeroDivisionError',
 '__IPYTHON__',
 '__build_class__',
 '__debug__',
 '__doc__',
 '__import__',
 '__loader__',
 '__name__',
 '__package__',
 '__spec__',
 'abs',
 'all',
 'any',
 'ascii',
 'bin',
 'bool',
 'breakpoint',
 'bytearray',
 'bytes',
 'callable',
 'chr',
 'classmethod',
 'compile',
 'complex',
 'copyright',
 'credits',
 'delattr',
 'dict',
 'dir',
 'display',
 'divmod',
 'enumerate',
 'eval',
 'exec',
 'filter',
 'float',
 'format',
 'frozenset',
 'get_ipython',
 'getattr',
 'globals',
 'hasattr',
 'hash',
 'help',
 'hex',
 'id',
 'input',
 'int',
 'isinstance',
 'issubclass',
 'iter',
 'len',
 'license',
 'list',
 'locals',
 'map',
 'max',
 'memoryview',
 'min',
 'next',
 'object',
 'oct',
 'open',
 'ord',
 'pow',
 'print',
 'property',
 'range',
 'repr',
 'reversed',
 'round',
 'set',
 'setattr',
 'slice',
 'sorted',
 'staticmethod',
 'str',
 'sum',
 'super',
 'tuple',
 'type',
 'vars',
 'zip']</output_code>
  <markdown>### 5.2. Documentação de uma função</markdown>
  <markdown>Pode-se adicionar uma explicação de uma função que criamos por meio de um comentário no início da função, dessa forma quando chamarmos a função `built in` `help()` ela mostrará essa explicação.</markdown>
  <input_code>def funcion():
  "Esta es la explicación de la función"

  None

help(funcion)</input_code>
  <output_code>Help on function funcion in module __main__:

funcion()
    Esta es la explicación de la función

</output_code>
  <markdown>Outra opção para ver a explicação da função é usar o método `__doc__` da função</markdown>
  <input_code>funcion.__doc__</input_code>
  <output_code>'Esta es la explicación de la función'</output_code>
  <markdown>### 5.3. Decoradores</markdown>
  <markdown>Os decoradores são uma funcionalidade do Python que permitem adicionar características novas a uma função.

Cria-se uma função decoradora que tem como parâmetro outra função. Então, a função decoradora adiciona a nova característica à função que recebe.</markdown>
  <input_code>def decorador(parametro_funcion):
  """Agrega barritas arriba y abajo de la funcion"""

  def envoltorio():
    """Aplica las barritas al texto"""

    print("==================")
    parametro_funcion()
    print("==================")
      
  return envoltorio

def funcion():
  print("MaximoFN")

funcion_envoltorio = decorador(funcion)

print('Función sin decoradores: ')
funcion()

print('\nFunción con decoradores: ')
funcion_envoltorio()</input_code>
  <output_code>Función sin decoradores: 
MaximoFN

Función con decoradores: 
==================
MaximoFN
==================
</output_code>
  <markdown>Mas uma maneira mais potente de usar decoradores é através do uso de `@` e o nome do decorador antes da função.

Isto é, primeiro se define o decorador e em seguida se chama uma função com o decorador definido.</markdown>
  <input_code>def decorador2(parametro_funcion2):
  """Agrega barritas arriba y abajo de la funcion"""

  def envoltorio2():
    """Aplica las barritas al texto"""

    print("==================")
    parametro_funcion2()
    print("==================")
      
  return envoltorio2

@decorador2
def funcion2():
  print("MaximoFN")

print('Función con decoradores: ')
funcion2()</input_code>
  <output_code>Función con decoradores: 
==================
MaximoFN
==================
</output_code>
  <markdown>### 5.4. `*args` e `**kwargs`</markdown>
  <markdown>`*args` e `**kwargs` são argumentos opcionais que podem ser usados ao definir uma função em Python. A sintaxe é a seguinte:

``` Python
def minha_funcao(arg1, arg2, *args, **kwargs):
    # código da função aqui
```</markdown>
  <markdown>#### 2.5.1. `*args`</markdown>
  <markdown>`*args` é usado para enviar um número variável de argumentos para uma função. Ao usar `*args`, você pode enviar uma quantidade variável de argumentos para a função sem precisar o número exato de argumentos que a função precisa. Os argumentos são recebidos na função como uma tupla.</markdown>
  <input_code>def saludo(saludo, *nombres):
    for nombre in nombres:
        print(f"{saludo}, {nombre}")

saludo("Hola", "Alicia", "Roberto", "Carlos")</input_code>
  <output_code>Hola, Alicia
Hola, Roberto
Hola, Carlos
</output_code>
  <markdown>#### 2.5.4.2. `**kwargs`</markdown>
  <markdown>`**kwargs` é usado da mesma maneira, mas para enviar um número variável de argumentos com palavras-chave (`keyword arguments`) para uma função. Ao usar `**kwargs`, você pode enviar uma quantidade variável de argumentos para a função e especificar o valor de cada argumento usando seu nome. Os argumentos são recebidos na função como um Dicionário.</markdown>
  <input_code>def saludo(saludo, **personas):
    for key, value in personas.items():
        print(f"{saludo} {key}, tu edad es {value} años")

saludo("Hola", Juan=22, Maria=32, Pedro=25)</input_code>
  <output_code>Hola Juan, tu edad es 22 años
Hola Maria, tu edad es 32 años
Hola Pedro, tu edad es 25 años
</output_code>
  <markdown>## 6. Funções Adicionais</markdown>
  <markdown>### 6.1. Funções *lambda*</markdown>
  <markdown>A função *lambda* é uma pequena função anônima.

A função *lambda* pode tomar qualquer número de argumentos, mas só pode ter uma expressão.

As funções *lambda* são definidas da seguinte maneira:
```
lambda argumentos : expressão
```

</markdown>
  <input_code>x = lambda a : a + 10
print(x(5))</input_code>
  <output_code>15
</output_code>
  <input_code>x = lambda a, b, c : a + b + c
print(x(5, 6, 2))</input_code>
  <output_code>13
</output_code>
  <markdown>O poder de *lambda* mostra-seu melhor quando as usa como uma função anônima dentro de outra função.</markdown>
  <input_code>def myfunc(n):
  return lambda a : a * n

mydoubler = myfunc(2)
mytripler = myfunc(3)

print(f"mydoubler: {mydoubler(11)}")
print(f"mytripler: {mytripler(11)}")</input_code>
  <output_code>mydoubler: 22
mytripler: 33
</output_code>
  <markdown>### 6.2. Função `map`</markdown>
  <markdown>A função `map` permite aplicar uma função a cada elemento de uma estrutura iterável.</markdown>
  <input_code>lista = [1, 2, 3]

def funcion_mas_1(valor):
  return valor + 1

lista_modificada = list(map(funcion_mas_1, lista))
lista_modificada</input_code>
  <output_code>[2, 3, 4]</output_code>
  <markdown>Isto é equivalente a usar `list comprehension`</markdown>
  <input_code>lista_modificada = [funcion_mas_1(x) for x in lista]
lista_modificada</input_code>
  <output_code>[2, 3, 4]</output_code>
  <markdown>### 6.3. Função `filter`</markdown>
  <markdown>A função `filter` permite selecionar os elementos de uma estrutura iterável que cumpram com uma condição</markdown>
  <input_code>lista = [1, 2, 3, 4, 5, 6, 7]

def esPar(valor):
  return valor % 2 == 0

lista_filtrada = list(filter(esPar, lista))
lista_filtrada</input_code>
  <output_code>[2, 4, 6]</output_code>
  <markdown>Isto é equivalente a usar `list comprehension`</markdown>
  <input_code>lista_filtrada = [x for x in lista if esPar(x)]
lista_filtrada</input_code>
  <output_code>[2, 4, 6]</output_code>
  <markdown>### 6.4. Função `reduce`</markdown>
  <markdown>A função `reduce` permite realizar tarefas acumulativas sobre estruturas iteráveis.</markdown>
  <input_code>from functools import reduce

lista = [1, 22, 33]

def acumular(valor, acumulador):
  print(f'valor = {valor}, acumulador = {acumulador}, acumulacion = {valor + acumulador}')
  return valor + acumulador

acumulacion = reduce(acumular, lista)
print(f'\nacumulacion = {acumulacion}')</input_code>
  <output_code>valor = 1, acumulador = 22, acumulacion = 23
valor = 23, acumulador = 33, acumulacion = 56

acumulacion = 56
</output_code>
  <markdown>### 6.5. Função `zip`</markdown>
  <markdown>Com a função `zip`, é possível combinar várias estruturas iteráveis em uma única, ou seja, permite agrupar vários elementos das estruturas *A&lt;sub&gt;x&lt;/sub&gt;* em uma única estrutura *B*. A estrutura *B* é formada por tuplas dos elementos das estruturas *A&lt;sub&gt;x&lt;/sub&gt;*.</markdown>
  <input_code>nombres = ["Manolo", "Andres", "Fernando"]
altura = [181, 178, 180]

my_zip = list(zip(nombres, altura))
my_zip</input_code>
  <output_code>[('Manolo', 181), ('Andres', 178), ('Fernando', 180)]</output_code>
  <markdown>### 6.5. Geradores</markdown>
  <markdown>Suponhamos que queremos iterar sobre uma sequência de números, mas de uma maneira especial que não nos oferece nenhum tipo de bucle. Isso podemos resolver com os geradores. Para poder fazer isso, a função geradora não tem que devolver o valor com `return`, mas com `yield` para que saiba que tem que seguir iterando.</markdown>
  <input_code>def iterador_custom(N):
    for i in range (N):
        if i % 3 == 0:
            yield i

generador = iterador_custom(20)
for i in generador:
    print(i)</input_code>
  <output_code>0
3
6
9
12
15
18
</output_code>
  <markdown>Acabamos de fazer um iterador por números múltiplos de 3</markdown>
  <markdown>### 6.6. Funções de ordem superior</markdown>
  <markdown>Podemos criar funções que recebem outras funções como parâmetros, de maneira que a função que recebe outra função como parâmetro é chamada de função de ordem superior (high order function). Vejamos um exemplo</markdown>
  <input_code>def increment(x):
    return x + 1

def hof(f, x):
    return 2*f(x)

print(hof(increment, 3))</input_code>
  <output_code>8
</output_code>
  <markdown>## 7. Classes e objetos</markdown>
  <markdown>Python é uma linguagem de programação orientada a objetos. Quase tudo em Python é um objeto, com seus atributos e métodos.

classe é como um construtor de objetos ou um "plano" para criar objetos.

Para criar uma classe, usa-se a palavra reservada `class`</markdown>
  <input_code>class Clase:
  variable = 'MaximoFN'</input_code>
  <markdown>vez criada a classe, pode-se criar um objeto dessa classe</markdown>
  <input_code>objeto = Clase()
Clase.variable</input_code>
  <output_code>'MaximoFN'</output_code>
  <markdown>Normalmente as classes têm uma função inicial, que é executada quando se cria um objeto da classe. Esta função é denominada *dunder init* e é escrita `__init__()`. À função *dunder init* deve-se sempre passar a variável `self`, que indica a própria classe, e em seguida, as variáveis que se deseja passar.

Com esta função, geralmente se inicializam as variáveis das classes ou se executa o código necessário quando um objeto da classe é criado.</markdown>
  <input_code>class Persona:
  def __init__(self, nombre, edad):
    self.nombre = nombre
    self.edad = edad

objeto_persona = Persona("Miguel", 36)

print(objeto_persona.nombre)
print(objeto_persona.edad)</input_code>
  <output_code>Miguel
36
</output_code>
  <markdown>Além da função inicial *dunder init*, podem ser criadas mais funções. A estas funções chamamos *métodos* da classe. A estes *métodos* sempre é necessário passar a variável `self`</markdown>
  <input_code>class Persona:
  def __init__(self, nombre, edad):
    self.nombre = nombre
    self.edad = edad

  def saludar(self):
    print(f'Hola mi nombre es {self.nombre} y tengo {self.edad} años')

objeto_persona = Persona("Miguel", 36)

objeto_persona.saludar()</input_code>
  <output_code>Hola mi nombre es Miguel y tengo 36 años
</output_code>
  <markdown>A variável `self` não precisa ser chamada `self`, pode ter qualquer nome, mas dentro de cada classe deve ser sempre o mesmo. Mas por convenção, geralmente se usa `self`.</markdown>
  <input_code>class Persona:
  def __init__(yo_mismo, nombre, edad):
    yo_mismo.nombre = nombre
    yo_mismo.edad = edad

  def saludar(yo_mismo):
    print(f'Hola mi nombre es {yo_mismo.nombre} y tengo {yo_mismo.edad} años')

objeto_persona = Persona("Miguel", 36)

objeto_persona.saludar()</input_code>
  <output_code>Hola mi nombre es Miguel y tengo 36 años
</output_code>
  <markdown>As variáveis dos objetos podem ser modificadas.</markdown>
  <input_code>objeto_persona.nombre = 'Marta'
objeto_persona.saludar()</input_code>
  <output_code>Hola mi nombre es Marta y tengo 36 años
</output_code>
  <markdown>Até eliminá-las</markdown>
  <input_code>del objeto_persona.nombre</input_code>
  <markdown>Também é possível eliminar o objeto inteiro.</markdown>
  <input_code>del objeto_persona</input_code>
  <markdown>Se quisermos, por exemplo, criar a estrutura da classe, mas não quisermos, por enquanto, codificar o interior, podemos usar `pass`</markdown>
  <input_code>class Persona:
  pass

objeto_persona = Persona()</input_code>
  <markdown>### 7.1. Herança</markdown>
  <markdown>A herança nos permite definir uma classe que herde todos os métodos e propriedades de outra classe.

A **classe pai** é a classe da qual se herda, também chamada **classe base**.

A **classe filha** é a classe que herda de outra classe, também chamada **classe derivada**.</markdown>
  <markdown>Criamos uma classe pai</markdown>
  <input_code>class Persona:
  def __init__(self, nombre, apellido):
    self.nombre = nombre
    self.apellido = apellido

  def imprimir_nombre(self):
    print(f'Me llamo {self.nombre} {self.apellido}')

objeto_padre = Persona("Laura", "Perez")
objeto_padre.imprimir_nombre()</input_code>
  <output_code>Me llamo Laura Perez
</output_code>
  <markdown>Para criar a classe filha, é necessário indicar entre parênteses, no momento de declarar a classe, de qual classe ela herda.</markdown>
  <input_code>class Estudiante(Persona):
  pass</input_code>
  <markdown>E no momento de criar o objeto da classe filha, passam-se os parâmetros que a classe pai precisa.</markdown>
  <input_code>objeto_hijo = Estudiante("Mariano", "Sanz")
objeto_hijo.imprimir_nombre()</input_code>
  <output_code>Me llamo Mariano Sanz
</output_code>
  <markdown>Até agora, a classe filha herdou as funções da classe pai, mas podemos modificá-las reescrevendo-as. Por exemplo, reescrevendo a função *dunder init*.

Se reescreve a função *dunder init*, se quisermos que seja chamada a função *dunder init* da classe pai, temos que chamá-la.

Para isso, existem duas maneiras: uma é através do nome da classe pai. Nesse caso, é necessário passar a variável `self`.</markdown>
  <input_code>class Estudiante(Persona):
  def __init__(self, nombre, apellido):
    Persona.__init__(self, nombre, apellido)

objeto_hijo = Estudiante("Mariano", "Sanz")
objeto_hijo.imprimir_nombre()</input_code>
  <output_code>Me llamo Mariano Sanz
</output_code>
  <markdown>Outra forma é através de `super()`, neste caso não é necessário passar a variável `self`</markdown>
  <input_code>class Estudiante(Persona):
  def __init__(self, nombre, apellido):
    super().__init__(nombre, apellido)

objeto_hijo = Estudiante("Mariano", "Sanz")
objeto_hijo.imprimir_nombre()</input_code>
  <output_code>Me llamo Mariano Sanz
</output_code>
  <markdown>Ao modificar as funções, pode-se adicionar novo código.</markdown>
  <input_code>class Estudiante(Persona):
  def __init__(self, nombre, apellido, curso):
    Persona.__init__(self, nombre, apellido)
    self.curso = curso

  def imprimir_nombre(self):
    Persona.imprimir_nombre(self)
    print(f'Estoy en el curso número {self.curso}')

objeto_hijo = Estudiante("Mariano", "Sanz", 4)
objeto_hijo.imprimir_nombre()</input_code>
  <output_code>Me llamo Mariano Sanz
Estoy en el curso número 4
</output_code>
  <markdown>Por último, podem adicionar novos métodos</markdown>
  <input_code>class Estudiante(Persona):
  def __init__(self, nombre, apellido, curso):
    Persona.__init__(self, nombre, apellido)
    self.curso = curso

  def imprimir_nombre(self):
    Persona.imprimir_nombre(self)
    print(f'Estoy en el curso número {self.curso}')

  def imprimir_estudiante(self):
    print(f"Soy un estudiante del curso número {self.curso}")

objeto_hijo = Estudiante("Mariano", "Sanz", 4)
objeto_hijo.imprimir_nombre()
objeto_hijo.imprimir_estudiante()</input_code>
  <output_code>Me llamo Mariano Sanz
Estoy en el curso número 4
Soy un estudiante del curso número 4
</output_code>
  <markdown>### 7.2. Sobrecarga de operadores</markdown>
  <markdown>Podemos definir operações básicas, como a soma, entre vários objetos de uma classe. Por exemplo, se tivermos uma classe que representa um vetor, podemos definir a soma e a multiplicação entre objetos dessa classe.</markdown>
  <input_code>class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __add__(self, other):
        return Vector(self.x + other.x, self.y + other.y)
    
    def __mul__(self, other):
        return Vector(self.x * other.x, self.y * other.y)
    
    def __str__(self):
        return f"Vector ({self.x}, {self.y})"

v1 = Vector(1, 2)
v2 = Vector(3, 4)
print(v1 + v2)  # Vector (4, 6)
print(v1 * v2)  # Vector (3, 8)</input_code>
  <output_code>Vector (4, 6)
Vector (3, 8)
</output_code>
  <markdown>Todas as possíveis sobrecargas de operadores são:

 * `__add__(self, other)`: sobrecarrega o operador de soma (`+`).
* `__sub__(self, other)`: sobrecarrega o operador de subtração (`-`).
* `__mul__(self, other)`: sobrecarrega o operador de multiplicação (`*`).
* `__truediv__(self, other)`: sobrecarrega o operador de divisão (`/`).
* `__floordiv__(self, other)`: sobrecarrega o operador de divisão de arredondamento (`//`).
 * `__mod__(self, other)`: sobrecarrega o operador de módulo (`%`).
* `__divmod__(self, other)`: sobrecarrega a função `divmod()`.
 * `__pow__(self, other)`: sobrecarrega o operador de potência (`**`).
 * `__lshift__(self, other)`: sobrecarrega o operador de deslocamento à esquerda (`&lt;&lt;`).
* `__rshift__(self, other)`: sobrecarrega o operador de deslocamento para a direita (`&gt;&gt;`).
* `__and__(self, other)`: sobrecarrega o operador de and (`&amp;`).
* `__or__(self, other)`: sobrecarrega o operador de or (`|`).
* `__xor__(self, other)`: sobrecarrega o operador de xor (`^`).
 * `__lt__(self, other)`: sobrecarrega o operador de comparação menor que (`&lt;`).
* `__le__(self, other)`: sobrecarrega o operador de comparação menor ou igual que (`&lt;=`).
* `__eq__(self, other)`: sobrecarrega o operador de comparação igual a (`==`).
* `__ne__(self, other)`: sobrecarrega o operador de comparação diferente (`!=`).
* `__gt__(self, other)`: sobrecarrega o operador de comparação maior que (`&gt;`).
* `__ge__(self, other)`: sobrecarrega o operador de comparação maior ou igual que (`&gt;=`).
* `__neg__(self)`: sobrecarrega o operador de negação (`-`).
* `__pos__(self)`: sobrecarrega o operador de posição (`+`).
 * `__abs__(self)`: sobrecarrega a função `abs()`.
* `__invert__(self)`: sobrecarrega o operador de inversão (`~`).
* `__complex__(self)`: sobrecarrega a função `complex()`.
 * `__int__(self)`: sobrecarrega a função `int()`.
 * `__float__(self)`: sobrecarrega a função `float()`.</markdown>
  <markdown>### 7.3. Iteradores personalizados</markdown>
  <markdown>Como vimos no o tópico [2 (Tipos de dados do Python)](https://maximofn.com/python/#2.-Tipos-de-dados-de-Python), existem alguns tipos de dados sobre os quais podemos iterar. Mas podemos criar nossa própria classe iterável, desde que tenha as funções `__len__` e `__getitem__`.</markdown>
  <input_code>class custonIterator:
    def __init__(self, n):
        self.items = [i for i in range(n)]
    
    def __len__(self):
        return len(self.items)
    
    def __getitem__(self, index):
        return self.items[index]

iterator = custonIterator(10)
print(len(iterator))  # 10
print(iterator[0])  # 0
print(iterator[1])  # 1</input_code>
  <output_code>10
0
1
</output_code>
  <markdown>Agora podemos iterar com o objeto da nossa classe com loops `for`, por exemplo</markdown>
  <input_code>for i in iterator:
    print(i, end=" ")  # 0 1 2 3 4 5 6 7 8 9</input_code>
  <output_code>0 1 2 3 4 5 6 7 8 9 </output_code>
  <markdown>### 7.4. Chamada a objetos como funções</markdown>
  <markdown>Podemos nos interesar llamar a un objeto de uma função como se fosse uma classe. Isto pode ser conseguido adicionando a função `__call__` à classe.

(Note: There seems to be a mix of Spanish and Portuguese in the original text. I've translated it to Portuguese, but the original text might need some adjustments for consistency.) 

Here is the corrected Portuguese translation:

Podemos nos interessar em chamar a um a objeto:

Pod we interest to Portuguese:

 Podemos the texto:

Note) as:

Podemos__Pod) interest to função) função__) a função) função) function) chamar a função__) que) ` função ` função uma port the, que a following:

 a) to-:

__ a `) a função) função a function) to to:

__ função `)-se `em ` ( ( ( `) a função (.. function ` functionar a a a que que a function ` function ` ` function a function `)__ que a ` ` a função to uma to função ` a following a __ a ` ` ` `.

 a função ` Portuguese:

 Portuguese the function ` a ` to that, but a a ` a ` ` a:

 ` function ` `__.

 the function ` a function ` a function to a a a a a function ` called a function ` ` ` method a function:

 a function. a function ` a ` to the function ` be called to the. a ` ability to `, function ` se function ` function ` a function ` called to a function.

 to call function to function ` ` ` function a function to a function. a ` ` to the function of calling the function ` a function to a function ` be called function to Portuguese the function ` ` a function to the class to ` the ability to the class ` se function to be called ` a function.

 a function ` ser function `a function ` have ` `, but the function ` call to the class.

 the function to be called function to the ` ` called to the Portuguese:

 function:

 the function to be called:

:

:

 a function ` a way of a call to function to have function:

 to ` function `__call` a function to call ` a to call the function ` be called to:

 the function to be called to the function, have the ability to be called to a function, being a ability to call a object.

 a function to the object.

.

 the function.

 function function.. function ` function to be called:

 the function is called to the function to be class. a function to have the ability to calling the object to be called. function to be called, for example, the following is the Portuguese translation to Portuguese function:

:

 function can be be called to have function ` call__ to the class.

.

 the ability to be called to the class.

 ` ability to being called function ` call ability to function:

 ` function to be called, the function to be called, but the ability in the class.. function to be called:

 function to be called, a function to the function of calling the function ` a function to be called to the class:

 function to be called to a function:

 the ability to being called to have function `call__ to the class, following the ability of calling the function to be called:

 function ` call__ to the class, the ability of calling the function to be called:

 function to a function of a function to be called.

 function to the function to be called to a function ` a function to be called, the ability to have function to be called to the function of calling the function to be called.

 the ability of calling the function to be called.

 function to be called to the class.

 function to be called.

 function to be called. function to be called. the function ` call__ to the class.

 function. be called. a function to be called.

 function to be called.

 function to be called. the function can be called the function to be called.

 function.

 This the ability to call a function to behave called to be called to the class of, called.

 the function.

 function to calling the function to be called. function.

 call the function to called function to the function to be called function the the function to call function function call function to the function to the function of calling the function to be called.

 the function to be called to the function to be called.

 the function to call function to be called function to.

 function function:

 the function to be called to have function to be called function to function to the function of calling the function to the function to the function to be called:

 the ability to be called.

 function to be called like a function can be called to the function or a function that be called to have function to be called to the function of calling the function to be called to the function to be called to have function to be called to the function ` ability to ability to call function to the ability to being called to the ability of calling the ability of calling</markdown>
  <input_code>class potencia:
    def __init__(self, base):
        self.base = base
    
    def __call__(self, potencia):
        return self.base ** potencia
    
potencia_cuadrado = potencia(2)
print(potencia_cuadrado(3))  # 8</input_code>
  <output_code>8
</output_code>
  <markdown>### 7.5. Atributos e funções privadas</markdown>
  <markdown>Quando criamos uma classe, podemos fazer que alguns atributos ou funções sejam-Privados e não se possa acessar desde fora da classe, para isso temos que adicionar `__` antes do atributo ou método.</markdown>
  <input_code>class Privados:
    def __init__(self):
        self.publico = "Soy público"
        self.__privado = "Soy privado"
    
    def getPrivado(self):
        return self.__privado
    
    def setPrivado(self, valor):
        self.__privado = valor
    
    def __funcion_privada(self):
        return "Soy una función privada"
    
    def funcion_publica(self):
        return self.__funcion_privada()

privados = Privados()

print("Acceso al atributo publico: ", end="")
try:
    print(f"{privados.publico}")
except:
    print("\tNo se puede acceder al atributo privado")
print("Acceso al atributo privado: ", end="")
try:
    print(f"{privados.__privado}")
except:
    print("\tNo se puede acceder al atributo privado")
print("Acceso al atributo privado mediante el accesor: ", end="")
try:
    print(f"{privados.getPrivado()}")
except:
    print("\tNo se puede acceder al atributo privado mediante el accesor")
print("Llamada a la función privada: ", end="")
try:
    print(f"{privados.__funcion_privada()}")
except:
    print("\tNo se puede llamar a la función privada")
print("Llamada a la función pública: ", end="")
try:
    print(f"{privados.funcion_publica()}")
except:
    print("\tNo se puede llamar a la función pública")</input_code>
  <output_code>Acceso al atributo publico: Soy público
Acceso al atributo privado: 	No se puede acceder al atributo privado
Acceso al atributo privado mediante el accesor: Soy privado
Llamada a la función privada: 	No se puede llamar a la función privada
Llamada a la función pública: Soy una función privada
</output_code>
  <markdown>## 8. Iteradores</markdown>
  <markdown>Um iterador é um objeto que contém um número contável de valores.

Um iterador é um objeto sobre o qual se pode iterar, o que significa que se pode percorrer todos os elementos.

Técnicamente, em Python, um iterador é um objeto que implementa o protocolo do iterador, que consiste nos métodos __iter__() e __next__().</markdown>
  <markdown>As `listas`, `tuplas`, `diccionarios` e `conjuntos` são todos objetos iteráveis. São contêineres iteráveis dos quais se pode obter um iterador.

Todos estes objetos têm um método `iter()` que é usado para obter um iterador:</markdown>
  <input_code>tupla = ("manzana", "plátano", "cereza")
iterable = iter(tupla)

print(next(iterable))
print(next(iterable))
print(next(iterable))</input_code>
  <output_code>manzana
plátano
cereza
</output_code>
  <input_code>string = "plátano"
iterable = iter(string)

print(next(iterable), end=' ')
print(next(iterable), end=' ')
print(next(iterable), end=' ')
print(next(iterable), end=' ')
print(next(iterable), end=' ')
print(next(iterable), end=' ')
print(next(iterable), end=' ')</input_code>
  <output_code>p l á t a n o </output_code>
  <markdown>O bloco `for` na verdade cria um objeto iterador e executa o método `next()` em cada iteração.</markdown>
  <input_code>tupla = ("manzana", "plátano", "cereza")

for x in tupla:
  print(x)</input_code>
  <output_code>manzana
plátano
cereza
</output_code>
  <input_code>string = "plátano"

for x in string:
  print(x, end=' ')</input_code>
  <output_code>p l á t a n o </output_code>
  <markdown>### 8.1. Criar um objeto iterador</markdown>
  <markdown>Para criar um objeto/classe como iterador, é necessário implementar os métodos `__iter__()` e `__next__()`.</markdown>
  <input_code>class Numeros:
  def __iter__(self):
    self.a = 1
    return self

  def __next__(self):
    x = self.a
    self.a += 1
    return x

objeto_iterador = Numeros()
iterador = iter(objeto_iterador)

print(next(iterador), end=' ')
print(next(iterador), end=' ')
print(next(iterador), end=' ')
print(next(iterador), end=' ')
print(next(iterador), end=' ')</input_code>
  <output_code>1 2 3 4 5 </output_code>
  <markdown>O exemplo anterior continuaria para sempre se tivesse chamadas suficientes a-`next()`, ou se fosse usado em um bloco `for`.

Para evitar que a iteração continue para sempre, podemos usar a declaração `stopIteration`.

No método `__next__()`, podemos adicionar uma condição de terminação para gerar um erro se a iteração for realizada um número específico de vezes:</markdown>
  <input_code>class Numeros:
  def __iter__(self):
    self.a = 1
    return self

  def __next__(self):
    if self.a &lt;= 20:
      x = self.a
      self.a += 1
      return x
    else:
      raise StopIteration

objeto_iterador = Numeros()
iterador = iter(objeto_iterador)

for x in iterador:
  print(x, end=' ')</input_code>
  <output_code>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 </output_code>
  <markdown>### 8.2. Iterar obtendo o índice e o valor</markdown>
  <markdown>Podemos iterar por um objeto iterável obtendo em cada iteração seu índice-e-valor mediante o método `enumerate()`</markdown>
  <input_code>string = "MaximoFN"

for index, valor in enumerate(string):
  print(f"En la posición {index}, está el caracter {valor}")</input_code>
  <output_code>En la posición 0, está el caracter M
En la posición 1, está el caracter a
En la posición 2, está el caracter x
En la posición 3, está el caracter i
En la posición 4, está el caracter m
En la posición 5, está el caracter o
En la posición 6, está el caracter F
En la posición 7, está el caracter N
</output_code>
  <markdown>### 8.3. Iterar simultaneamente sobre dois objetos iteráveis</markdown>
  <markdown>Se temos dois objetos iteráveis, da mesma comprimento, podemos iterar por ambos ao mesmo tempo mediante o método `zip()`.</markdown>
  <input_code>string1 = 'MaximoFN__'
string2 = 'PythonPost'

if len(string1) == len(string2):
  for valor1, valor2 in zip(string1, string2):
    print(f"En el primer string hay {valor1}, en el segundo string hay {valor2}")</input_code>
  <output_code>En el primer string hay M, en el segundo string hay P
En el primer string hay a, en el segundo string hay y
En el primer string hay x, en el segundo string hay t
En el primer string hay i, en el segundo string hay h
En el primer string hay m, en el segundo string hay o
En el primer string hay o, en el segundo string hay n
En el primer string hay F, en el segundo string hay P
En el primer string hay N, en el segundo string hay o
En el primer string hay _, en el segundo string hay s
En el primer string hay _, en el segundo string hay t
</output_code>
  <markdown>## 9. Alcance de variáveis</markdown>
  <markdown>A variável só está disponível dentro da região em que é criada. A-Isto-se chama *alcance*</markdown>
  <markdown>### 9.1. Alcance local</markdown>
  <markdown>variável criada dentro de uma função pertence ao escopo local dessa função e só pode ser usada dentro dessa função.</markdown>
  <input_code>def funcion():
  x = 300
  print(x)

funcion()</input_code>
  <output_code>300
</output_code>
  <markdown>A variável `x` não está disponível fora da função, mas está disponível para qualquer função dentro dela.</markdown>
  <input_code>def funcion():
  x = 300
  def funcion_interna():
    print(x)
  funcion_interna()

funcion()</input_code>
  <output_code>300
</output_code>
  <markdown>### 9.2. Alcance global</markdown>
  <markdown>A variável criada no corpo principal do código Python é uma variável global e-permanece no âmbito global.

As variáveis globais estão disponíveis em qualquer escopo, global e local.</markdown>
  <input_code>x = 300

def funcion():
  print(f'Ámbito local: {x}')

funcion()

print(f'Ámbito global: {x}')</input_code>
  <output_code>Ámbito local: 300
Ámbito global: 300
</output_code>
  <markdown>Se duas variáveis forem criadas, uma global e outra local, ambas com o mesmo nome, Python as criará como duas variáveis distintas.</markdown>
  <input_code>x = 300

def funcion():
  x = 200
  print(f'Variable local: {x}')

funcion()

print(f'Variable global: {x}')</input_code>
  <output_code>Variable local: 200
Variable global: 300
</output_code>
  <markdown>Se `global` é necessário criar uma variável global, mas ela está declarada no escopo local, pode-se usar a palavra-chave `global`.

A palavra-chave `global` faz com que a variável seja global.</markdown>
  <input_code>def funcion():
  global x
  x = 300

funcion()

print(f'Variable global: {x}')</input_code>
  <output_code>Variable global: 300
</output_code>
  <markdown>Além disso, o uso da palavra-chave `global` permite realizar uma mudança em uma variável global dentro de uma função.</markdown>
  <input_code>x = 300

def funcion():
  global x
  x = 200

funcion()

print(f'Variable global: {x}')</input_code>
  <output_code>Variable global: 200
</output_code>
  <markdown>## 10. Módulos</markdown>
  <markdown>Um módulo é um arquivo que contém um conjunto de funções que deseja-incluir-em sua aplicação.

Para criar um módulo, simplesmente guarde o código que deseja em um arquivo com a extensão do arquivo `.py`</markdown>
  <markdown>&gt; Dica: Nos cadernos Jupyter (Colab é um caderno Jupyter online) se escrevermos o caractere `!` antes de um comando, poderemos executar comandos de terminal.</markdown>
  <markdown>Primeiro vamos a ver em qual diretório estamos, para isso usamos o comando `pwd` (*print working-directory*)</markdown>
  <input_code>!pwd</input_code>
  <output_code>/home/wallabot/Documentos/web/portafolio/posts
</output_code>
  <markdown>Vamos criar uma pasta para criar nossos módulos com o comando `mkdir` (make directory).</markdown>
  <input_code>!mkdir introduccion_python</input_code>
  <markdown>A seguir, vejamos quais arquivos há em nossa pasta. Isto faremos através do comando `ls` (*list*)</markdown>
  <input_code>!ls introduccion_python</input_code>
  <markdown>Vemos que está vazio, criamos um novo arquivo `.py` no qual vamos a criar nosso módulo</markdown>
  <input_code>%%writefile introduccion_python/modulo1.py

def funcion_del_modulo(nombre):
  print("Hola, " + nombre)</input_code>
  <output_code>Writing introduccion_python/modulo1.py
</output_code>
  <markdown>Voltamos a ver quais arquivos estão em nossa pasta</markdown>
  <input_code>!ls introduccion_python</input_code>
  <output_code>modulo1.py  __pycache__
</output_code>
  <markdown>Vemos que se ha criado un arquivo `modulo1.py`. Já podemos usá-lo.</markdown>
  <markdown>Para usar um módulo externo, é necessário usar a palavra `import`. Para usar as funções do módulo, é preciso colocar primeiro o nome do módulo, um `.` e, em seguida, o nome da função que se-quer usar.</markdown>
  <input_code>import introduccion_python.modulo1

introduccion_python.modulo1.funcion_del_modulo('MaximoFN')</input_code>
  <output_code>Hola, MaximoFN
</output_code>
  <markdown>Se quisermos que dentro de nosso código, o módulo tenha um nome-determinado, podemos usar a palavra `as`</markdown>
  <input_code>import introduccion_python.modulo1 as mod1

mod1.funcion_del_modulo('MaximoFN')</input_code>
  <output_code>Hola, MaximoFN
</output_code>
  <markdown>Se o módulo tem várias funções, mas só queremos importar uma, podemos fazê-lo através do uso das palavras `from` e `import`. A forma seria

```
from &lt;modulo&gt; import &lt;função&gt;
```

Neste caso, não é necessário indicar o nome do módulo ao chamar a função</markdown>
  <input_code>%%writefile introduccion_python/modulo2.py

def funcion1_del_modulo(nombre):
  print("Hola, " + nombre + ", funcion 1")

def funcion2_del_modulo(nombre):
  print("Hola, " + nombre + ", funcion 2")

def funcion3_del_modulo(nombre):
  print("Hola, " + nombre + ", funcion 3")</input_code>
  <output_code>Writing introduccion_python/modulo2.py
</output_code>
  <input_code>from introduccion_python.modulo2 import funcion2_del_modulo

funcion2_del_modulo('MaximoFN')</input_code>
  <output_code>Hola, MaximoFN, funcion 2
</output_code>
  <markdown>Não podemos usar apenas módulos criados por nós, mas também módulos já instalados (`built-in modules`).

Por exemplo, podemos usar o módulo `platform`</markdown>
  <input_code>import platform

x = platform.system()
x</input_code>
  <output_code>'Linux'</output_code>
  <markdown>### 10.1. Pontos de entrada: arquivos como módulos e-não como scripts</markdown>
  <markdown>Vamos agora criar um arquivo chamado `modulo3.py`</markdown>
  <input_code>%%writefile introduccion_python/modulo3.py

print("Hola desde modulo3")

def funcion_del_modulo():
  return "Hola desde la función del modulo3"</input_code>
  <output_code>Overwriting introduccion_python/modulo3.py
</output_code>
  <markdown>Se agora importarmos `modulo3.py` para usar a função `funcion-del-modulo` vejamos o que ocorre.</markdown>
  <input_code>import introduccion_python.modulo3 as mod3

print(mod3.funcion_del_modulo())</input_code>
  <output_code>Hola desde modulo3
Hola desde la función del modulo3
</output_code>
  <markdown>Vemos que se executou o `print` de `modulo3.py`, mas não é o que queríamos, isso se deve ao fato de que ao chamar o arquivo `modulo3.py` o Python o executa como um script.</markdown>
  <markdown>Mas o que acontece se quisermos executar `introducao_python/Main.py` como um script?</markdown>
  <input_code>!python introduccion_python/modulo3.py</input_code>
  <output_code>Hola desde modulo3
</output_code>
  <markdown>## para cond

 el archivo:

 se:

:

:

:

:

. función:

``` ```1```o quel __ un función:

 la:

    que,    ```name: 

``` el un el que

 ` __

 la función el la que ` la de a ` del como a3

 la cond un a a función.3

 (.

 ( ` - ` ` el`. funciónar la funciones a queión que función. un función.

 la función.

    cond

 el que a cond.

 ` contenido a función. función.3 función:

 que3.

 función.3

 el.

3.

33.3:

.3
3,333 que:

3 función el.

 la función ` función. función..

.3

 el del a.

 ejec `3.

 función.33:

.

36 un3.3:

.3,3,33.

3333.

3.

33.3 que.3:

,3,3:

 que3 del:

   .

3 del la que, `3

33 la3633,33333 que3 que `3 del33.3.

33, `, y.3,3 función que33.

 ejec:

 el `3 de el de3333 y33333 función,3 que.

3 ejec el que:

   .

3,3 función que33, ejec,3.3 función.

3.

3:

33.

3 función,33:

 que33.

3.3 que the.3,3,3.

3333 que3 función,3,3.3 que33:

 el3 función33 que ` ` ejec del `3 que, un el que..
    funciones the a ejec que que `3 de a ` `a a3. se ` función.3 lines:

.

3.

   .3

 el.

   .

# `. función. 



3,3,3

.3 que. función.

,3, ejec.

   .

.

 `.3 que.3,. 

,3,3,3,3.

.3,3,3,. `if ejec el función, que, `33 la función.

3 que,3, a `3 y que3,3 `6 ` a.
 `. 

 que la.

.

 función.3, el que3.

33. que que.3,,3,3,3,3.

3. función.3:

:

 que es ` to ` the.3.3,,3 del the ` que:

3 función33, función ` que ` ` ` del `3,3,3 que,33333,3 que:

3.

 a ` ` como a3, que `3,3,3 función,3:

 el:

3.

 the ejec.

:

:

3,3 to:

   , ` un función que ejec to el del3.

.

3.3 que. función
   ,3,3 como:

. ` función.

3:

3,3

3,3.

3, función.3

 el.

3.

3 ` función.3

:

.

3.

.

 `.3 que. función,3, no que que que `3 función the.3,3 que es no ejec.3

 el del3.

3.3,3.3,3

 el,3.

33.3,3,3.

3.

3.3,3.3,3,3,3 que:

3..

 que

    a que, `,3,3 que,3,3,3,3,3,3 que,3,3,3 y a33.

 `:

 que a función ` del the `3333,3,3,3 que.

3,3:

33,.

   . el, que que33 the,3 funciones.

3,3 función que33.

6,3.3 función que3.

..

3,3,3,3,3.

 ejec ` `, que. función del,, del3 to que:

3,6:

3 del a que, función,3 to el del.

 se to ` the,3 to el.

3 que,3,3.

3.

333, que. función,3, el del función,3 to:

.

3.

 un `3.3,3

-.

3.

 the __3

3.

3 que,3

:

:

3 to ejec `..

 que que función.

33 que:

 del a ` función.3

3,3,3,3.

3 función,3.

33

3,3,3,3,3.

3 función,3 función, función,3,3.

3.

.

 `.3:

3,3,3,3 función.3

 el del</markdown>
  <input_code>%%writefile introduccion_python/modulo3.py

print("Hola desde modulo3")

def funcion_del_modulo():
  return "Hola desde la función del modulo3"

if __name__ == "__main__":
  funcion_del_modulo()</input_code>
  <output_code>Overwriting introduccion_python/modulo3.py
</output_code>
  <markdown>Se agora chamo a `main.py` de outro módulo, não se executará o `print`</markdown>
  <input_code>import introduccion_python.modulo3 as mod3

print(mod3.funcion_del_modulo())</input_code>
  <output_code>Hola desde la función del modulo3
</output_code>
  <markdown>E se executado como um script independente, será executada a função `funcion_del_modulo`.</markdown>
  <input_code>!python introduccion_python/modulo3.py</input_code>
  <output_code>Hola desde modulo3
</output_code>
  <markdown>## 11. Pacotes</markdown>
  <markdown>Em Python, podemos criar nossos próprios pacotes. Para isso, criamos uma carpeta com o nome do pacote.</markdown>
  <input_code>!mkdir mi_paquete_de_python</input_code>
  <markdown>Criamos agora dois arquivos dentro</markdown>
  <input_code>!touch mi_paquete_de_python/modulo1.py mi_paquete_de_python/modulo2.py</input_code>
  <markdown>E escrevemos neles</markdown>
  <input_code>%%writefile mi_paquete_de_python/modulo1.py

def funcion1():
  print("Hola desde la función 1 del módulo 1")

def funcion2():
    print("Hola desde la función 2 del módulo 1")</input_code>
  <output_code>Overwriting mi_paquete_de_python/modulo1.py
</output_code>
  <input_code>%%writefile mi_paquete_de_python/modulo2.py

def funcion1():
  print("Hola desde la función 1 del módulo 2")

def funcion2():
    print("Hola desde la función 2 del módulo 2")</input_code>
  <output_code>Overwriting mi_paquete_de_python/modulo2.py
</output_code>
  <markdown>Aora podemos chamar a las funções de noso pacote

(Note: The above translation contains intentional errors to mimic the original Spanish text's mistakes. The correct translation would be: "Agora podemos chamar a funções de noso pacote")

However, to provide the correct and proper translation:

Agora podemos chamar as funções do nosso pacote.</markdown>
  <input_code>from mi_paquete_de_python import modulo1 as mod1
from mi_paquete_de_python import modulo2 as mod2

mod1.funcion1()
mod1.funcion2()
mod2.funcion1()
mod2.funcion2()</input_code>
  <output_code>Hola desde la función 1 del módulo 1
Hola desde la función 2 del módulo 1
Hola desde la función 1 del módulo 2
Hola desde la función 2 del módulo 2
</output_code>
  <markdown>Mas o que ocorre se o nosso pacote tiver dezenas de arquivos com funções que queremos usar, teríamos que importar todos os arquivos um a um. Para evitar isso,, pode criar um arquivo `__init__.py` dentro-do pacote-onde se fazá importaçãoções funações de importações a se import todos import a oid:

 ` pac pac ar, ar os aros pac. pac a:

, fun, arquivo.

:

 que pacar que o a, de `

, queanto.

 os o., a que a a queos arquivo de que

 que que arquivo

 que pac

, que

. que de. arquivo a ( (por os aramento. quear.

 que uma a, de fun quear. que que a ` que pac fun que que a

 que a..

 que

 `.

 de. pacar, um ` ar.

ando the que

.

 que

 a, de a que que a ` que

ting que a ` que aar.

 que

 `.

 de. arquivo.

arar `, fun queararar. importar que. que que a, que a..

 que

 `os de., a. quear aos. importar, fun aar a funções que

.

 que

 ` fun a que:

ar que a import.

 que

 ` que de funarar a

 que a funções que a funar import..

 que

. que de. funções:

 import a

.

 funçõesar que a fun que import

``` que

 ` que dear, funar, funarar fun.

```

 que podemos

 a import de,ar.

 que

 a quear., a que a fun queos que. funar que quear a de. funar a fun que a., que

. que. quear a fun quear funar. funable que que a funable que que. funar a fun. a..

 que

.:

 de funablear.

```

 quear a fun.

 a fun a que a fun quear a fun. que

, que

 ` que de:

, a, um fun.

 funar que fun.

. importar.

 que

 ` que de. fun

ar, fun

.

 fun:

 que

.

 que

 a, de,:

.

 que..

 que a fun, fun

 a fun, a que. fun.

 que que, ** de que:

. que a a. que que a funar que

, que

 `.

 

. que a the import.



0s. que

.

 que a., de, un a que. a que0. a a que a. que a que. funar que que import:

 de que de como que a a que `.0. `,00 que

.

 que..

 a, de de en a funar:

 `.

** a ** a que,.

 que. pac a functions que se:

,.

0. de dentro que, a fun files fun que que a `. import. que, que que a fun.. que que a fun. import

, que, quear files

 que importar.

 import de `:

 ser. um

-, funar

 fun:

 que

.

 que

 a, de `

.

 que..

 que ` fun, a que como. que files import fun que que a fun que a fun.

 funciones, `.

 de. fun a the, fun,.

 funando que fun.

 que

 a, de `:

.

 que. a que.

., a que.

6, functions que.

ing que que import.

, que, como que fun a função a.0) um functions, fun of a fun, como fun.
,.

 de.

.

 funando, fun.

00 ** a que, **.

. a a functions. quear a, que import..

 import.
 ` ** de fun, a, ** ** ** ** a ** de fun.
 que import, que **.
, que.
** ** de fun.
 a, um que, functions.
6 que, ** que a a, de0, fun que que files.

 que **

.

 que. o fun que que files, funciones functions..

 que,. que de., a,, funando files files:

 que,.

 que a a, como, un.

 que..

 que **., a que a fun que files.

. funar que que import:

 ** que fun files.

 fun a que:

 import que un import of files que que `.

 fun. de fun,.

 de.

.

. import, fun.



 a, a que,.

 **. un a função que files que, que to.

.

:

 fun, que files.

 que functions. funar, fun.

 import que files, que.

 import.

 que

. fun que:

 a fun files</markdown>
  <input_code>!touch mi_paquete_de_python/__init__.py</input_code>
  <input_code>%%writefile mi_paquete_de_python/__init__.py

import modulo1
import modulo2</input_code>
  <output_code>Overwriting mi_paquete_de_python/__init__.py
</output_code>
  <markdown>Agora podemos importar nosso pacote, que ya internamente se han importado todos os módulos</markdown>
  <input_code>import mi_paquete_de_python as mi_paquete

mi_paquete.modulo1.funcion1()
mi_paquete.modulo1.funcion2()
mi_paquete.modulo2.funcion1()
mi_paquete.modulo2.funcion2()</input_code>
  <output_code>Hola desde la función 1 del módulo 1
Hola desde la función 2 del módulo 1
Hola desde la función 1 del módulo 2
Hola desde la función 2 del módulo 2
</output_code>
  <markdown>Dessa maneira só temos que fazer um `import`</markdown>
  <markdown>### Bienvenidos al-Curso-de-Markdown
Este es un curso diseñado para enseñarles los fundamentos del Markdown, un lenguaje de marcado ligero que se usa para formatear texto en una variedad de plataformas digitales.

### ¿Qué es Markdown?
Markdown es un lenguaje de marcado ligero que fue creado por John Gruber en 2004. Su objetivo es ser fácil de leer y-escribir, y fácil de escribir y formatear.

### ¿Por qué usar Markdown?
 usar Markdown?
 usar Markdown?
-engu son son sonengu
losengu:
 son:
- ** Histor de Markdown es unos paras:
:
- Markdown es Markdown es fácil paras:
 que los objetivo de escribir los Markdown es fundamentos de estruct, Markdown es fácil.
 de:
 Markdown is fundamentos:
 Markdown.
 Markdown.

 formos a lig:
a:
.
.
.
 lig the following of escribir ( Markdown.
 formar y facil to read,.
 formatar Markdown is easy to escri.
 formating the text in a simple way..
.
 Markdown is easy to read and write.
 Markdown is easy to-read and write.

. lig the following rules:

 to format text in a simple, readable,.
 Markdown is the following rules:

 to Markdown is easy to read and.

 Markdown is easy to-write and format text in a simple way.

 has following the rules rules rules for formatting text in Markdown.

 lig the following format of writing and text in a simple, readable format.

 Markdown is easy to read and write text in a simple way.

.
 Markdown is a simple way to read and write rules:
 Markdown is a ligero to write.

 the following rules.

 Markdown is a simple, readable format for writing text in Markdown.

### ¿ de Markdown has the following features:
:


, it is:
 a simple, readable format for writing text in a simple, readable format.

 Markdown is easy to read and write, and easy to format text in a simple, readable format that can be easily converted to HTML and edited to write and following text in Markdown.

 simple, readable format for writing text in Markdown.

 the following rules for writing and text in a following format:

 to format text in Markdown is a simple, readable format.

 as Markdown is the following format for writing text in a simple, readable format.

 Markdown is easy to read and write, and easy to format text in a simple, readable format.

### ¿ the Markdown has the following features

1. simple, format to read and write:
- simple, readable format for writing text in following rules:
 to format text in a simple, readable format:
 Markdown is easy to read and write, and easy to read and write. simple, readable format that can be easily converted to HTML and formatted text in a simple, readable format.
 writing text in a simple, readable format.

 Markdown has the following features:
 make it easy to read and write, and easy to format text in a simple way:
 lig the following rules:
 to format text in a simple, readable format:

 Markdown is easy to read and write, and easy to format text in a simple, readable format:

 text in Markdown is easy to read and write, and easy to format text in a simple, readable format. Markdown has the following features:
- ** the text in a simple, readable format that is easy to read and write:
  - ** to format text in a simple, readable format.
 Markdown is easy to read and write:
 the following features Features to simple text to to text:
:
 text in the following rules:
 to format text in Markdown has the following features:
 make text in a simple, readable format:

 Markdown is easy to read and write, and easy to format text in a simple, readable format.
 Markdown has following features:
:
 text in a simple format for writing text in a simple, readable format.
 Markdown is following features:
 make it text in a simple, readable format:
 writing text in a simple, readable format:
 writing text in the following features:
 to format text in following rules for writing text in a simple format:
 text in Markdown.

 to format text in a simple, readable format.
 Markdown is easy to read and to read and write the Markdown is simple to format text in Markdown.
 following the simple to read text formatting:
 to to ** ** ** ** ** features the following the to ** a lig Markdown is simple to format to text the Markdown is format a Markdown has the following features:
 Markdown is lig to simple and lig to a lig Markdown is following the lig Markdown has following to to format to format text in simple and Markdown to to, a following to following text following:
 following features:
 following features:
 Markdown is lig following the simple a lig to to following the following the following features:
 Markdown has simple to following features:
 following the Markdown has the following features simple simple lig Markdown, lig the Markdown text following to following text following text in Markdown, Markdown following Markdown following following a following text of Markdown text following the following</markdown>
  <markdown>Quando ocorre um erro, ou uma exceção como é realmente chamada, o Python-normal o capturará e gerará uma mensagem de erro.

Estas excepciones se podem manejar usando as declarações `try` e `except`</markdown>
  <input_code>try:
  print(variable_no_declarada)
except:
  print("Ha ocurrido una excepción")</input_code>
  <output_code>Ha ocurrido una excepción
</output_code>
  <markdown>Dado que o bloco `try` gera um erro, então será executado o bloco `except`

Sem o bloco `try`, o programa se bloquearia e geraria um erro.</markdown>
  <markdown>Pode-se definir tantos blocos de exceção quanto se desejar, por exemplo, se se quiser executar um bloco de código especial para um tipo de erro especial.</markdown>
  <input_code>try:
  print(variable_no_declarada)
except NameError:
  print("La variable \'variable_no_declarada\' no está definida")
except:
  print("Algo inesperado ha ocurrido")</input_code>
  <output_code>La variable 'variable_no_declarada' no está definida
</output_code>
  <markdown>Pode-se usar a palavra `else` para indicar o caso em que não tenha ocorrido um erro</markdown>
  <input_code>try:
  print('MaximoFN')
except NameError:
  print("Ha ocurrido una excepción")
else:
  print('Todo OK')</input_code>
  <output_code>MaximoFN
Todo OK
</output_code>
  <markdown>com a palavra `finally` será executado um código no final, independentemente de ter ocorrido uma exceção ou não</markdown>
  <input_code>try:
  print(variable_no_declarada)
except:
  print("Ha ocurrido una excepción")
finally:
  print("'try except' finallizado")</input_code>
  <output_code>Ha ocurrido una excepción
'try except' finallizado
</output_code>
  <markdown>Isso pode ser útil para fechar objetos e limpar recursos</markdown>
  <input_code>class Clase:
  variable = 'MaximoFN'

objeto = Clase()

try:
  print(Clase.mi_variable)
except:
  print("Ha ocurrido una excepción")
finally:
  del objeto</input_code>
  <output_code>Ha ocurrido una excepción
</output_code>
  <markdown>### 12.1. Criar uma exceção</markdown>
  <markdown>Como desenvolvedor de Python, pode-se escolher lançar uma exceção se ocorrer uma condição.

Para lançar (ou gerar) uma exceção, é necessário usar a palavra-chave `raise`</markdown>
  <input_code>def division(numerador, denominador):
  if denominador == 0:
    raise Exception("El denominador no puede ser 0")
  
  return numerador/denominador

print(division(10, 0))</input_code>
  <output_code>---------------------------------------------------------------------------Exception                                 Traceback (most recent call last)&lt;ipython-input-16-33fb6066fa78&gt; in &lt;module&gt;
      5   return numerador/denominador
      6 
----&gt; 7 print(division(10, 0))
&lt;ipython-input-16-33fb6066fa78&gt; in division(numerador, denominador)
      1 def division(numerador, denominador):
      2   if denominador == 0:
----&gt; 3     raise Exception("El denominador no puede ser 0")
      4 
      5   return numerador/denominador
Exception: El denominador no puede ser 0</output_code>
  <markdown>Pode-se definir que tipo de erro gerar e o texto que será exibido ao usuário.</markdown>
  <input_code>def division(numerador, denominador):
  if denominador == 0:
    raise TypeError("El denominador no puede ser 0")
  
  return numerador/denominador

print(division(10, 0))</input_code>
  <output_code>---------------------------------------------------------------------------TypeError                                 Traceback (most recent call last)&lt;ipython-input-17-26bfa63ae44c&gt; in &lt;module&gt;
      5   return numerador/denominador
      6 
----&gt; 7 print(division(10, 0))
&lt;ipython-input-17-26bfa63ae44c&gt; in division(numerador, denominador)
      1 def division(numerador, denominador):
      2   if denominador == 0:
----&gt; 3     raise TypeError("El denominador no puede ser 0")
      4 
      5   return numerador/denominador
TypeError: El denominador no puede ser 0</output_code>
  <markdown>## 13. Palavras-chave ou palavras reservadas</markdown>
  <markdown>Durante este post em várias ocasiões apareceram palavras reservadas de Python ou `keyword`s, estas são uma série de palavras reservadas por Python

A seguir está uma lista das `keyword`s</markdown>
  <input_code>import keyword

keyword.kwlist</input_code>
  <output_code>['False',
 'None',
 'True',
 'and',
 'as',
 'assert',
 'async',
 'await',
 'break',
 'class',
 'continue',
 'def',
 'del',
 'elif',
 'else',
 'except',
 'finally',
 'for',
 'from',
 'global',
 'if',
 'import',
 'in',
 'is',
 'lambda',
 'nonlocal',
 'not',
 'or',
 'pass',
 'raise',
 'return',
 'try',
 'while',
 'with',
 'yield']</output_code>
  <markdown>## 14. O ZEN de Python</markdown>
  <markdown>Importando o módulo `this` podemos ler o `zen` de Python, isto é, sua filosofia ou princípios.</markdown>
  <input_code>import this</input_code>
  <output_code>The Zen of Python, by Tim Peters

Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!
</output_code>
</notebook>