<?xml version='1.0' encoding='utf-8'?>
<notebook>
  <markdown># Docker</markdown>
  <markdown>## Contenedores</markdown>
  <markdown>### Hello world</markdown>
  <markdown>Ejecutar el primer contenedor tipo Hello world con el comando `docker run hello-world`</markdown>
  <input_code>!docker run hello-world</input_code>
  <output_code>Unable to find image 'hello-world:latest' locally
</output_code>
  <output_code>latest: Pulling from library/hello-world

[1B85e32844: Pull complete 457kB/2.457kBB[1A[2KDigest: sha256:dcba6daec718f547568c562956fa47e1b03673dd010fe6ee58ca806767031d1c
Status: Downloaded newer image for hello-world:latest

Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.
    (amd64)
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
 https://hub.docker.com/

For more examples and ideas, visit:
 https://docs.docker.com/get-started/

</output_code>
  <markdown>Como no tenemos el contenedor guardado en local, Docker lo descarga de Docker Hub. Si ahora volvemos a ejecutar el contenedor, ya no aparecer√° el primer mensaje, en el que indica que se est√° descargando</markdown>
  <input_code>!docker run hello-world</input_code>
  <output_code>
Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.
    (amd64)
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
 https://hub.docker.com/

For more examples and ideas, visit:
 https://docs.docker.com/get-started/

</output_code>
  <markdown>Para ver los contenedores que est√°n corriendo ejecutar `docker ps`</markdown>
  <input_code>!docker ps</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
</output_code>
  <markdown>Como vemos no hay ning√∫n contenedor abierto. Pero sin embargo, si ejecutamos `docker ps -a` (`all`) vemos que s√≠ aparecen</markdown>
  <input_code>!docker ps -a</input_code>
  <output_code>CONTAINER ID   IMAGE         COMMAND    CREATED          STATUS                      PORTS     NAMES
1efb51bbbf38   hello-world   "/hello"   10 seconds ago   Exited (0) 9 seconds ago              strange_thompson
5f5705e7603e   hello-world   "/hello"   15 seconds ago   Exited (0) 14 seconds ago             laughing_jang
</output_code>
  <markdown>Vemos que aparecen dos contenedores llamados `hello-world` que son los dos que hemos ejecutado antes. Por tanto cada vez que ejecutamos el comando `run`, docker crea un nuevo contenedor, no ejecuta uno que ya exista</markdown>
  <markdown>Si queremos tener m√°s informaci√≥n de uno de los dos contenedores podemos ejecutar `docker inspect &lt;id&gt;`, donde `&lt;id&gt;` corresponde a la ID del contenedor que se ha mostrado en la lista anterior</markdown>
  <input_code>!docker inspect 1efb51bbbf38</input_code>
  <output_code>[
    {
        "Id": "1efb51bbbf38917affd1b5871db8e658ebfe0b2efa5ead17545680b7866f682e",
        "Created": "2023-09-04T03:59:17.795499354Z",
        "Path": "/hello",
        "Args": [],
        "State": {
            "Status": "exited",
            "Running": false,
            "Paused": false,
            "Restarting": false,
            "OOMKilled": false,
            "Dead": false,
            "Pid": 0,
            "ExitCode": 0,
            "Error": "",
            "StartedAt": "2023-09-04T03:59:18.406663026Z",
            "FinishedAt": "2023-09-04T03:59:18.406181184Z"
        },
        "Image": "sha256:9c7a54a9a43cca047013b82af109fe963fde787f63f9e016fdc3384500c2823d",
        "ResolvConfPath": "/var/lib/docker/containers/1efb51bbbf38917affd1b5871db8e658ebfe0b2efa5ead17545680b7866f682e/resolv.conf",
        "HostnamePath": "/var/lib/docker/containers/1efb51bbbf38917affd1b5871db8e658ebfe0b2efa5ead17545680b7866f682e/hostname",
        "HostsPath": "/var/lib/docker/containers/1efb51bbbf38917affd1b5871db8e658ebfe0b2efa5ead17545680b7866f682e/hosts",
        "LogPath": "/var/lib/docker/containers/1efb51bbbf38917affd1b5871db8e658ebfe0b2efa5ead17545680b7866f682e/1efb51bbbf38917affd1b5871db8e658ebfe0b2efa5ead17545680b7866f682e-json.log",
        "Name": "/strange_thompson",
        ...
            }
        }
    }
]
</output_code>
  <markdown>Como acordarnos de IDs es complicado para nosotros, Docker asigna nombres a los contenedores para facilitarnos la vida. As√≠ en la lista anterior, la √∫ltima columna corresponde al nombre que ha asignado Docker a cada contenedor, de modo que si ahora ejecutamos `docker inspect &lt;name&gt;` obtendremos la misma informaci√≥n que con la ID</markdown>
  <markdown>Vuelvo a ejecutar `docker ps -a` para volver a ver la lista</markdown>
  <input_code>!docker ps -a</input_code>
  <output_code>CONTAINER ID   IMAGE         COMMAND    CREATED         STATUS                     PORTS     NAMES
1efb51bbbf38   hello-world   "/hello"   2 minutes ago   Exited (0) 2 minutes ago             strange_thompson
5f5705e7603e   hello-world   "/hello"   2 minutes ago   Exited (0) 2 minutes ago             laughing_jang
</output_code>
  <markdown>Y ahora ejecuto `docker inspect &lt;name&gt;` para ver la informaci√≥n del contenedor</markdown>
  <input_code>!docker inspect strange_thompson</input_code>
  <output_code>[
    {
        "Id": "1efb51bbbf38917affd1b5871db8e658ebfe0b2efa5ead17545680b7866f682e",
        "Created": "2023-09-04T03:59:17.795499354Z",
        "Path": "/hello",
        "Args": [],
        "State": {
            "Status": "exited",
            "Running": false,
            "Paused": false,
            "Restarting": false,
            "OOMKilled": false,
            "Dead": false,
            "Pid": 0,
            "ExitCode": 0,
            "Error": "",
            "StartedAt": "2023-09-04T03:59:18.406663026Z",
            "FinishedAt": "2023-09-04T03:59:18.406181184Z"
        },
        "Image": "sha256:9c7a54a9a43cca047013b82af109fe963fde787f63f9e016fdc3384500c2823d",
        "ResolvConfPath": "/var/lib/docker/containers/1efb51bbbf38917affd1b5871db8e658ebfe0b2efa5ead17545680b7866f682e/resolv.conf",
        "HostnamePath": "/var/lib/docker/containers/1efb51bbbf38917affd1b5871db8e658ebfe0b2efa5ead17545680b7866f682e/hostname",
        "HostsPath": "/var/lib/docker/containers/1efb51bbbf38917affd1b5871db8e658ebfe0b2efa5ead17545680b7866f682e/hosts",
        "LogPath": "/var/lib/docker/containers/1efb51bbbf38917affd1b5871db8e658ebfe0b2efa5ead17545680b7866f682e/1efb51bbbf38917affd1b5871db8e658ebfe0b2efa5ead17545680b7866f682e-json.log",
        "Name": "/strange_thompson",
        ...
            }
        }
    }
]
</output_code>
  <markdown>Pero por qu√© con `docker ps` no vemos ning√∫n contenedor y con `docker ps -a` s√≠. Esto es porque `docker ps` solo muestra los contenedores que est√°n corriendo, mientras que `docker ps -a` muestra todos los contenedores, los que est√°n corriendo y los que est√°n apagados</markdown>
  <markdown>Podemos crear un contenedor asign√°ndole un nombre nosotros mediante el comando `docker run --name &lt;name&gt; hello-world`</markdown>
  <input_code>!docker run --name hello_world hello-world</input_code>
  <output_code>
Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.
    (amd64)
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
 https://hub.docker.com/

For more examples and ideas, visit:
 https://docs.docker.com/get-started/

</output_code>
  <markdown>Esto ser√° m√°s c√≥modo para nosotros, ya que podremos controlar nosotros los nombres de los contenedores</markdown>
  <markdown>Si ahora queremos crear otro contenedor con el mismo nombre no podremos, porque docker no permite que se dupliquen los nombres de los contenedores. De modo que si queremos renombrar el contenedor podemos usar el comando `docker rename &lt;old name&gt; &lt;new name&gt;`</markdown>
  <input_code>!docker rename hello_world hello_world2</input_code>
  <markdown>Tenemos ahora un mont√≥n de contenedores iguales. As√≠ que si queremos borrar alguno tenemos que usar el comando `docker rm &lt;id&gt;` o `docker rm &lt;name&gt;`</markdown>
  <input_code>!docker ps -a</input_code>
  <output_code>CONTAINER ID   IMAGE         COMMAND    CREATED         STATUS                     PORTS     NAMES
f432c9c2ca21   hello-world   "/hello"   9 seconds ago   Exited (0) 8 seconds ago             hello_world2
1efb51bbbf38   hello-world   "/hello"   4 minutes ago   Exited (0) 4 minutes ago             strange_thompson
5f5705e7603e   hello-world   "/hello"   4 minutes ago   Exited (0) 4 minutes ago             laughing_jang
</output_code>
  <input_code>!docker rm hello_world2</input_code>
  <output_code>hello_world2
</output_code>
  <markdown>Si volvemos a ver la lista de contenedores, el contenedor `hello_world2` ya no estar√°</markdown>
  <input_code>!docker ps -a</input_code>
  <output_code>CONTAINER ID   IMAGE         COMMAND    CREATED         STATUS                     PORTS     NAMES
1efb51bbbf38   hello-world   "/hello"   5 minutes ago   Exited (0) 5 minutes ago             strange_thompson
5f5705e7603e   hello-world   "/hello"   5 minutes ago   Exited (0) 5 minutes ago             laughing_jang
</output_code>
  <markdown>Si queremos borrar todos los contenedores, podemos hacerlo uno a uno, pero como es muy pesado, podemos borrar todos mediante el comando `docker container prune`. Este comando elimina solo los contenedores que est√©n parados</markdown>
  <input_code>!docker container prune</input_code>
  <output_code>WARNING! This will remove all stopped containers.
Are you sure you want to continue? [y/N] y</output_code>
  <markdown>Docker pregunta si est√°s seguro, y si le dices que s√≠, borra todos. Si ahora listo todos los contenedores, no aparece ninguno</markdown>
  <input_code>!docker ps -a</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
</output_code>
  <markdown>### El modo iteractivo</markdown>
  <markdown>Vamos a ejecutar un ubuntu mediante el comando `docker run ubuntu`</markdown>
  <input_code>!docker run ubuntu</input_code>
  <output_code>Unable to find image 'ubuntu:latest' locally
latest: Pulling from library/ubuntu

[1BDigest: sha256:20fa2d7bb4de7723f542be5923b06c4d704370f0390e4ae9e1c833c8785644c1[1A[2K[1A[2K[1A[2K[1A[2K[1A[2K[1A[2K[1A[2K[1A[2K
Status: Downloaded newer image for ubuntu:latest
</output_code>
  <markdown>Como vemos, ahora ha tardado m√°s en descargar. Si listamos los contenedores mediante el comando `docker ps`, vemos que no aparece el contenedor que acabamos de crear, es decir, no est√° corriendo.</markdown>
  <input_code>!docker ps</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
</output_code>
  <markdown>Listamos ahora todos los contenedores</markdown>
  <input_code>!docker ps -a</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND   CREATED         STATUS                     PORTS     NAMES
da16b3a85178   ubuntu    "bash"    4 seconds ago   Exited (0) 3 seconds ago             hardcore_kare
</output_code>
  <markdown>Vemos que el estado del contenedor es `Exited (0)`</markdown>
  <markdown>Si nos fijamos en el comando del contenedor aparece `bash` y junto al estado `Exited (0)` nos indica que ha arrancado Ubuntu, ha ejecutado su *bash*, ha terminado la ejecuci√≥n y ha devuelto un 0. Esto pasa porque al bash de Ubuntu no se le ha dicho nada que hacer. Para solucionar esto, ahora vamos a ejecutar el contenedor mediante el comando `docker run -it ubuntu`, con `it` lo que le estamos indicando es que lo queremos ejecutar en modo interactivo</markdown>
  <input_code>!docker run -it ubuntu</input_code>
  <output_code>root@5b633e9d838f:/#</output_code>
  <markdown>Ahora vemos que estamos dentro del bash de Ubuntu. Si ejecutamos el comando `cat /etc/lsb-release` podemos ver la distribuci√≥n de Ubuntu</markdown>
  <input_code>!root@5b633e9d838f:/# cat /etc/lsb-release</input_code>
  <output_code>DISTRIB_ID=Ubuntu
DISTRIB_RELEASE=22.04
DISTRIB_CODENAME=jammy
DISTRIB_DESCRIPTION="Ubuntu 22.04.1 LTS"</output_code>
  <markdown>Si abrimos otra terminal y vemos la lista de contenedores, ahora s√≠ aparecer√° el contenedor corriendo Ubuntu</markdown>
  <input_code>!docker ps</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND   CREATED         STATUS         PORTS     NAMES
5b633e9d838f   ubuntu    "bash"    3 minutes ago   Up 3 minutes             funny_mirzakhani
</output_code>
  <markdown>Vemos el contenedor con Ubuntu y en su estado podemos ver `UP`</markdown>
  <markdown>Si vemos ahora la lista de todos los contenedores, veremos que aparecen los dos contenedores con Ubuntu, el primero apagado y el segundo el que est√° corriendo</markdown>
  <input_code>!docker ps -a</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND   CREATED         STATUS                     PORTS     NAMES
5b633e9d838f   ubuntu    "bash"    3 minutes ago   Up 3 minutes                         funny_mirzakhani
da16b3a85178   ubuntu    "bash"    3 minutes ago   Exited (0) 3 minutes ago             hardcore_kare
</output_code>
  <markdown>Si volvemos a la terminal donde ten√≠amos Ubuntu corriendo dentro de un docker, si escribimos ``exit`` saldremos de Ubuntu.</markdown>
  <input_code>!root@5b633e9d838f:/# exit</input_code>
  <output_code>exit</output_code>
  <markdown>Si ejecutamos `docker ps` el contenedor ya no aparece</markdown>
  <input_code>!docker ps</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
</output_code>
  <markdown>Pero si ejecuto ``docker ps -a`` s√≠ que aparece. Esto quiere decir que el contenedor se apag√≥</markdown>
  <input_code>!docker ps -a</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND   CREATED         STATUS                      PORTS     NAMES
5b633e9d838f   ubuntu    "bash"    4 minutes ago   Exited (0) 27 seconds ago             funny_mirzakhani
da16b3a85178   ubuntu    "bash"    4 minutes ago   Exited (0) 4 minutes ago              hardcore_kare
</output_code>
  <markdown>Esto ocurre porque al escribir ``exit``, en realidad lo estamos escribiendo en la consola del bash de Ubuntu, lo que significa que estamos terminando el proceso bash de Ubuntu.</markdown>
  <markdown>### Ciclo de vida de un contenedor</markdown>
  <markdown>En Docker, cuando el proceso principal de un contenedor se termina, se apaga el contenedor. Dentro de un contenedor pueden ejecutarse varios procesos, pero solo cuando se termina el proceso principal se apaga el contenedor

Por tanto, si queremos correr un contenedor que no se apague cuando finalice un proceso, debemos hacer que su proceso principal no termine. En este caso, que no finalice bash

Si queremos ejecutar un contenedor con Ubuntu, pero que no finalice cuando termine el proceso de Bash lo podemos hacer de la siguiente manera</markdown>
  <input_code>!docker run --name alwaysup -d ubuntu tail -f /dev/null</input_code>
  <output_code>ce4d60427dcd4b326d15aa832b816c209761d6b4e067a016bb75bf9366c37054
</output_code>
  <markdown>Lo que hacemos es primero darle el nombre ``alwaysup``, en segundo lugar pasarle la opci√≥n ``-d`` (``detach``) para que el contenedor se ejecute en segundo plano y por √∫ltimo le decimos el proceso principal que queremos que se ejecute en el contenedor, que en este caso es ``tail -f /dev/null`` que equivale a un comando ``nop``

Esto nos devolver√° la ID del contenedor, pero no estaremos dentro de Ubuntu como pasaba antes</markdown>
  <markdown>Si ahora vemos la lista de contenedores que se est√°n ejecutando, aparece el contenedor que acabamos de crear</markdown>
  <input_code>!docker ps</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND               CREATED          STATUS          PORTS     NAMES
ce4d60427dcd   ubuntu    "tail -f /dev/null"   18 seconds ago   Up 17 seconds             alwaysup
</output_code>
  <markdown>Como ya tenemos un contenedor corriendo siempre, podemos conectarnos al el mediante el comando ``exec``. Le decimos el nombre o la ID del contenedor y le pasamos el proceso que queremos que se ejecuta. Adem√°s pasamos la opci√≥n ``-it`` para decirle que sea iteractivo</markdown>
  <input_code>!docker exec -it alwaysup bash</input_code>
  <output_code>root@ce4d60427dcd:/#</output_code>
  <markdown>Ahora volvemos a estar dentro de Ubuntu. Si ejecutamos el comando ``ps -aux`` podemos ver una lista de los procesos que se est√°n ejecutando dentro de Ubuntu.</markdown>
  <input_code>!ps -aux</input_code>
  <output_code>USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root           1  0.0  0.0   2820  1048 ?        Ss   13:04   0:00 tail -f /dev/null
root           7  0.0  0.0   4628  3796 pts/0    Ss   13:04   0:00 bash
root          15  0.0  0.0   7060  1556 pts/0    R+   13:05   0:00 ps -aux</output_code>
  <markdown>Vemos solo tres procesos, el ``ps -aux``, el ``bash`` y el ``tail -f /dev/null``

Este contenedor va a estar siempre encendido mientras el proceso ``tail -f /dev/null`` siga corriendo</markdown>
  <markdown>Si salimos del contenedor con el comando ``exit`` y ejecutamos el comando ``docker ps`` vemos que el contenedor sigue encendido</markdown>
  <input_code>!exit</input_code>
  <output_code>exit</output_code>
  <input_code>!docker ps</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND               CREATED         STATUS         PORTS     NAMES
ce4d60427dcd   ubuntu    "tail -f /dev/null"   2 minutes ago   Up 2 minutes             alwaysup
</output_code>
  <markdown>Para poder finalizar el proceso y poder apagar el contenedor debemos usar el comando ``docker stop &lt;name&gt;``</markdown>
  <input_code>!docker stop alwaysup</input_code>
  <output_code>alwaysup
</output_code>
  <markdown>Si ahora volvemos a listar los contenedores encendidos ya no aparece el contenedor con Ubuntu</markdown>
  <input_code>!docker ps</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
</output_code>
  <markdown>Y si listamos todos los contenedores, aparece el contenedor con Ubuntu, y su estado ``Exited``</markdown>
  <input_code>!docker ps -a</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND               CREATED          STATUS                            PORTS     NAMES
ce4d60427dcd   ubuntu    "tail -f /dev/null"   14 minutes ago   Exited (137) About a minute ago             alwaysup
5b633e9d838f   ubuntu    "bash"                19 minutes ago   Exited (0) 15 minutes ago                   funny_mirzakhani
da16b3a85178   ubuntu    "bash"                20 minutes ago   Exited (0) 20 minutes ago                   hardcore_kare
</output_code>
  <markdown>Tambi√©n podemos pausar un contenedor mediante el comando `docker pause &lt;name&gt;`</markdown>
  <input_code>!docker run --name alwaysup -d ubuntu tail -f /dev/null</input_code>
  <output_code>8282eaf9dc3604fa94df206b2062287409cc92cbcd203f1a018742b5c171c9e4
</output_code>
  <markdown>Ahora lo pausamos</markdown>
  <input_code>!docker pause alwaysup</input_code>
  <output_code>alwaysup
</output_code>
  <markdown>Si volvemos a ver todos los contenedores, vemos que el contenedor con Ubuntu est√° pausado</markdown>
  <input_code>!docker ps -a</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND               CREATED          STATUS                       PORTS     NAMES
8282eaf9dc36   ubuntu    "tail -f /dev/null"   41 seconds ago   Up 41 seconds (Paused)                 alwaysup
5b633e9d838f   ubuntu    "bash"                19 minutes ago   Exited (0) 15 minutes ago              funny_mirzakhani
da16b3a85178   ubuntu    "bash"                20 minutes ago   Exited (0) 20 minutes ago              hardcore_kare
</output_code>
  <markdown>### Contenedores de un solo uso</markdown>
  <markdown>Si a la hora de ejecutar un contenedor, ponemos la opci√≥n `--rm`, ese contenedor se va a borrar cuando termine de ejecutarse.</markdown>
  <input_code>!docker run --rm --name autoremove ubuntu:latest</input_code>
  <markdown>Si ahora vemos cu√°les contenedores tenemos</markdown>
  <input_code>!docker ps -a</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
</output_code>
  <markdown>Vemos que no est√° el contenedor que acabamos de crear</markdown>
  <markdown>### Exponer contenedores al mundo exterior</markdown>
  <markdown>Vamos a crear un nuevo contenedor con un servidor</markdown>
  <input_code>!docker run -d --name proxy nginx</input_code>
  <output_code>Unable to find image 'nginx:latest' locally
latest: Pulling from library/nginx

[1Bf1ad4ce1: Pulling fs layer 
[1Bb079d0f8: Pulling fs layer 
[1B5fbbebc6: Pulling fs layer 
[1Bffdd25f4: Pulling fs layer 
[1B32c8fba2: Pulling fs layer 
[1B24b8ba39: Pull complete 393kB/1.393kBB[5A[2K[6A[2K[5A[2K[6A[2K[5A[2K[6A[2K[5A[2K[6A[2K[5A[2K[3A[2K[5A[2K[5A[2K[6A[2K[6A[2K[6A[2K[2A[2K[6A[2K[6A[2K[6A[2K[6A[2K[6A[2K[6A[2K[5A[2K[5A[2K[5A[2K[5A[2K[5A[2K[4A[2K[3A[2K[2A[2K[1A[2K[1A[2KDigest: sha256:2888a97f7c7d498bbcc47ede1ad0f6ced07d72dfd181071dde051863f1f79d7b
Status: Downloaded newer image for nginx:latest
1a530e04f14be082811b72ea8b6ea5a95dad3037301ee8a1351a0108ff8d3b30
</output_code>
  <markdown>Esto crea un servidor, vamos a volver a listar los contenedores que est√°n corriendo</markdown>
  <input_code>!docker ps</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND                  CREATED        STATUS                  PORTS     NAMES
1a530e04f14b   nginx     "/docker-entrypoint.‚Ä¶"   1 second ago   Up Less than a second   80/tcp    proxy
</output_code>
  <markdown>Ahora aparece una nueva columna con el puerto, y nos dice que el servidor que acabamos de crear est√° en el puerto ``80`` bajo el protocolo ``tcp``.

Si abrimos un navegador e intentamos conectarnos al servidor mediante ``http://localhost:80`` no conseguimos conectar. Esto es porque cada contenedor tiene su propia interfaz de red. Es decir, el servidor est√° escuchando en el puerto ``80`` del contenedor, pero nosotros estamos intentando conectar al puerto ``80`` del host</markdown>
  <markdown>Paramos el contenedor para relanzarlo de otra forma</markdown>
  <input_code>!docker stop proxy</input_code>
  <output_code>proxy
</output_code>
  <markdown>Si listamos los contenedores, no aparece corriendo</markdown>
  <input_code>!docker ps</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
</output_code>
  <markdown>Lo borramos para volver a crearlo</markdown>
  <input_code>!docker rm proxy</input_code>
  <output_code>proxy
</output_code>
  <markdown>Si listamos todos los contenedores ya no est√°</markdown>
  <input_code>!docker ps -a</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND               CREATED          STATUS                       PORTS     NAMES
ce4d60427dcd   ubuntu    "tail -f /dev/null"   19 minutes ago   Exited (137) 5 minutes ago             alwaysup
5b633e9d838f   ubuntu    "bash"                24 minutes ago   Exited (0) 20 minutes ago              funny_mirzakhani
da16b3a85178   ubuntu    "bash"                24 minutes ago   Exited (0) 24 minutes ago              hardcore_kare
</output_code>
  <markdown>Para volver a crear el contenedor con el servidor y poderlo ver desde el host, tenemos que usar la opci√≥n ``-p`` (``publish``), indicando en primer lugar el puerto en el que queremos verlo en el host y a continuaci√≥n el puerto del contenedor, es decir, ``-p &lt;ip host&gt;:&lt;ip contenedor&gt;``</markdown>
  <input_code>!docker run -d --name proxy -p 8080:80 nginx</input_code>
  <output_code>c199235e42f76a30266f6e1af972e0a59811806eb3d3a9afdd873f6fa1785eae
</output_code>
  <markdown>Listamos los contenedores</markdown>
  <input_code>!docker ps</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS          PORTS                                   NAMES
c199235e42f7   nginx     "/docker-entrypoint.‚Ä¶"   22 seconds ago   Up 21 seconds   0.0.0.0:8080-&gt;80/tcp, :::8080-&gt;80/tcp   proxy
</output_code>
  <markdown>Vemos que el puerto del contenedor es `0.0.0.0:8080-&gt;80/tcp`. Si ahora vamos a un navegador e introducimos `0.0.0.0:8080` podremos acceder al servidor del contenedor</markdown>
  <markdown>Al listar los contenedores, en la columna ``PORTS`` indica ``0.0.0.0:8080-&gt;80/tcp``, lo que nos ayuda a ver la relaci√≥n de puertos</markdown>
  <markdown>Para ver los logs del contenedor, mediante el comando ``docker logs &lt;name&gt;`` puedo ver los registros del contenedor</markdown>
  <input_code>!docker logs proxy</input_code>
  <output_code>/docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration
/docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d/
/docker-entrypoint.sh: Launching /docker-entrypoint.d/10-listen-on-ipv6-by-default.sh
10-listen-on-ipv6-by-default.sh: info: Getting the checksum of /etc/nginx/conf.d/default.conf
10-listen-on-ipv6-by-default.sh: info: Enabled listen on IPv6 in /etc/nginx/conf.d/default.conf
/docker-entrypoint.sh: Launching /docker-entrypoint.d/20-envsubst-on-templates.sh
/docker-entrypoint.sh: Launching /docker-entrypoint.d/30-tune-worker-processes.sh
/docker-entrypoint.sh: Configuration complete; ready for start up
2022/09/13 13:24:06 [notice] 1#1: using the "epoll" event method
2022/09/13 13:24:06 [notice] 1#1: nginx/1.23.1
2022/09/13 13:24:06 [notice] 1#1: built by gcc 10.2.1 20210110 (Debian 10.2.1-6) 
2022/09/13 13:24:06 [notice] 1#1: OS: Linux 5.15.0-46-generic
2022/09/13 13:24:06 [notice] 1#1: getrlimit(RLIMIT_NOFILE): 1048576:1048576
2022/09/13 13:24:06 [notice] 1#1: start worker processes
2022/09/13 13:24:06 [notice] 1#1: start worker process 31
2022/09/13 13:24:06 [notice] 1#1: start worker process 32
2022/09/13 13:24:06 [notice] 1#1: start worker process 33
2022/09/13 13:24:06 [notice] 1#1: start worker process 34
2022/09/13 13:24:06 [notice] 1#1: start worker process 35
2022/09/13 13:24:06 [notice] 1#1: start worker process 36
2022/09/13 13:24:06 [notice] 1#1: start worker process 37
2022/09/13 13:24:06 [notice] 1#1: start worker process 38
2022/09/13 13:24:06 [notice] 1#1: start worker process 39
2022/09/13 13:24:06 [notice] 1#1: start worker process 40
2022/09/13 13:24:06 [notice] 1#1: start worker process 41
...
172.17.0.1 - - [13/Sep/2022:13:24:40 +0000] "GET /favicon.ico HTTP/1.1" 404 555 "http://0.0.0.0:8080/" "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36" "-"
172.17.0.1 - - [13/Sep/2022:13:25:00 +0000] "\x16\x03\x01\x02\x00\x01\x00\x01\xFC\x03\x03\xE2\x19V$Zqi'\xD7\xFC[\x80\xEF\xBA\xE5\xC7\xE8\xF7&amp;3nS\xEB\xC9\xEC\x91\xC2\xD8\xD1\x89\x9E\xBE \xC7?\xE1\xFA\x04a\x1C\xCE\x90\x0F\x8F\x98u\xE3/\xD8RfOH\xEC\x92+\x93\x5C\xBB\xB1\xBF\xD2m\xB09\x00 \xFA\xFA\x13\x01\x13\x02\x13\x03\xC0+\xC0/\xC0,\xC00\xCC\xA9\xCC\xA8\xC0\x13\xC0\x14\x00\x9C\x00\x9D\x00/\x005\x01\x00\x01\x93\x9A\x9A\x00\x00\x00\x00\x00\x0E\x00\x0C\x00\x00\x09localhost\x00\x17\x00\x00\xFF\x01\x00\x01\x00\x00" 400 157 "-" "-" "-"
172.17.0.1 - - [13/Sep/2022:13:25:00 +0000] "\x16\x03\x01\x02\x00\x01\x00\x01\xFC\x03\x03)\x9A\x8FbC\xD9m\xF1\x86\xEBd\x22\xCF\xC4E\x87#~L\xC1\x84\x7F\xB5\x91k\x98\xABl\xEE\x1E[0 \xD0\xD2`\x85\xC6\x8B\x85R\x8B\x87\xEAq{P\xF2\xFB\xE2\xA8\x9DI\xF4tH\x99\x13\x10~\xCA1-|\x8E\x00 \xEA\xEA\x13\x01\x13\x02\x13\x03\xC0+\xC0/\xC0,\xC00\xCC\xA9\xCC\xA8\xC0\x13\xC0\x14\x00\x9C\x00\x9D\x00/\x005\x01\x00\x01\x93" 400 157 "-" "-" "-"
172.17.0.1 - - [13/Sep/2022:13:26:28 +0000] "GET / HTTP/1.1" 304 0 "-" "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36" "-"
</output_code>
  <markdown>Ahora puedo ver todas las peticiones que se le han hecho al servidor. Pero si quiero ver los logs en tiempo real, mediante ``docker logs -f &lt;name&gt;`` lo puedo hacer</markdown>
  <input_code>!docker logs -f proxy</input_code>
  <output_code />
  <markdown>Ahora puedo ver los logs en tiempo real. Para salir introducir ``CTRL+C``</markdown>
  <markdown>Como puede llegar un momento en el que haya muchos logs, si solo quieres los √∫ltimos logs, mediante la opci√≥n ``--tail &lt;num&gt;`` puedes ver los √∫ltimos ``&lt;num&gt;`` logs. Si a√±ado la opci√≥n ``-f`` estaremos viendo siempre los √∫ltimos ``&lt;num&gt;`` logs</markdown>
  <input_code>!docker logs --tail 10 proxy</input_code>
  <output_code>2022/09/13 13:24:06 [notice] 1#1: start worker process 41
2022/09/13 13:24:06 [notice] 1#1: start worker process 42
172.17.0.1 - - [13/Sep/2022:13:24:16 +0000] "\x16\x03\x01\x02\x00\x01\x00\x01\xFC\x03\x03\x01E\x14\x8E\xB6\x0BEg\xF3\xC9\x9A\x19\x9C\xCA\xEC\xA7y#3\x92\x05\x95\xDCQ\x07\x19\x1D\xEF\xEA$\xBF# \x0B\x83\xF7-,s\x1B!r\xEA|\xAE\xDF\xA1\x9DLZ\xAA4y\xB3t\xAB\xC0\xCE_\xB8\xE7\xFF'\xCF\x86\x00 \xEA\xEA\x13\x01\x13\x02\x13\x03\xC0+\xC0/\xC0,\xC00\xCC\xA9\xCC\xA8\xC0\x13\xC0\x14\x00\x9C\x00\x9D\x00/\x005\x01\x00\x01\x93\x8A\x8A\x00\x00\x00\x00\x00\x0E\x00\x0C\x00\x00\x09localhost\x00\x17\x00\x00\xFF\x01\x00\x01\x00\x00" 400 157 "-" "-" "-"
172.17.0.1 - - [13/Sep/2022:13:24:16 +0000] "\x16\x03\x01\x02\x00\x01\x00\x01\xFC\x03\x03}\xA9Dr{\x8C;\x90z\x82\xAD\xBC\x8Az\xC2x\xDF\x1E\x9A\xE6l?\xA7\xE0DoK\x91'g\xBB\xB5 %\xBB\xFD\xD9\x82?\xDB\x80\xB3T\xF6cJ\xF7\xE5\xC2\xD2\x11\xBC\xA2\x1F\x90\x14\xA3\xEB\xBD=R\xBC\x83\x89\x85\x00 \xCA\xCA\x13\x01\x13\x02\x13\x03\xC0+\xC0/\xC0,\xC00\xCC\xA9\xCC\xA8\xC0\x13\xC0\x14\x00\x9C\x00\x9D\x00/\x005\x01\x00\x01\x93\x9A\x9A\x00\x00\x00\x00\x00\x0E\x00\x0C\x00\x00\x09localhost\x00\x17\x00\x00\xFF\x01\x00\x01\x00\x00" 400 157 "-" "-" "-"
172.17.0.1 - - [13/Sep/2022:13:24:39 +0000] "GET / HTTP/1.1" 200 615 "-" "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36" "-"
2022/09/13 13:24:40 [error] 34#34: *3 open() "/usr/share/nginx/html/favicon.ico" failed (2: No such file or directory), client: 172.17.0.1, server: localhost, request: "GET /favicon.ico HTTP/1.1", host: "0.0.0.0:8080", referrer: "http://0.0.0.0:8080/"
172.17.0.1 - - [13/Sep/2022:13:24:40 +0000] "GET /favicon.ico HTTP/1.1" 404 555 "http://0.0.0.0:8080/" "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36" "-"
172.17.0.1 - - [13/Sep/2022:13:25:00 +0000] "\x16\x03\x01\x02\x00\x01\x00\x01\xFC\x03\x03\xE2\x19V$Zqi'\xD7\xFC[\x80\xEF\xBA\xE5\xC7\xE8\xF7&amp;3nS\xEB\xC9\xEC\x91\xC2\xD8\xD1\x89\x9E\xBE \xC7?\xE1\xFA\x04a\x1C\xCE\x90\x0F\x8F\x98u\xE3/\xD8RfOH\xEC\x92+\x93\x5C\xBB\xB1\xBF\xD2m\xB09\x00 \xFA\xFA\x13\x01\x13\x02\x13\x03\xC0+\xC0/\xC0,\xC00\xCC\xA9\xCC\xA8\xC0\x13\xC0\x14\x00\x9C\x00\x9D\x00/\x005\x01\x00\x01\x93\x9A\x9A\x00\x00\x00\x00\x00\x0E\x00\x0C\x00\x00\x09localhost\x00\x17\x00\x00\xFF\x01\x00\x01\x00\x00" 400 157 "-" "-" "-"
172.17.0.1 - - [13/Sep/2022:13:25:00 +0000] "\x16\x03\x01\x02\x00\x01\x00\x01\xFC\x03\x03)\x9A\x8FbC\xD9m\xF1\x86\xEBd\x22\xCF\xC4E\x87#~L\xC1\x84\x7F\xB5\x91k\x98\xABl\xEE\x1E[0 \xD0\xD2`\x85\xC6\x8B\x85R\x8B\x87\xEAq{P\xF2\xFB\xE2\xA8\x9DI\xF4tH\x99\x13\x10~\xCA1-|\x8E\x00 \xEA\xEA\x13\x01\x13\x02\x13\x03\xC0+\xC0/\xC0,\xC00\xCC\xA9\xCC\xA8\xC0\x13\xC0\x14\x00\x9C\x00\x9D\x00/\x005\x01\x00\x01\x93" 400 157 "-" "-" "-"
172.17.0.1 - - [13/Sep/2022:13:26:28 +0000] "GET / HTTP/1.1" 304 0 "-" "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36" "-"
</output_code>
  <markdown>Si adem√°s a√±adimos la opci√≥n `-t` podemos ver la fecha y hora de cada log, de esta manera si hemos tenido un problema, podemos saber en qu√© momento ha ocurrido</markdown>
  <input_code>!docker logs --tail -t 10 proxy</input_code>
  <output_code>2022-09-13T13:24:06.573362728Z 2022/09/13 13:24:06 [notice] 1#1: start worker process 41
2022-09-13T13:24:06.651127107Z 2022/09/13 13:24:06 [notice] 1#1: start worker process 42
2022-09-13T13:24:16.651160189Z 172.17.0.1 - - [13/Sep/2022:13:24:16 +0000] "\x16\x03\x01\x02\x00\x01\x00\x01\xFC\x03\x03\x01E\x14\x8E\xB6\x0BEg\xF3\xC9\x9A\x19\x9C\xCA\xEC\xA7y#3\x92\x05\x95\xDCQ\x07\x19\x1D\xEF\xEA$\xBF# \x0B\x83\xF7-,s\x1B!r\xEA|\xAE\xDF\xA1\x9DLZ\xAA4y\xB3t\xAB\xC0\xCE_\xB8\xE7\xFF'\xCF\x86\x00 \xEA\xEA\x13\x01\x13\x02\x13\x03\xC0+\xC0/\xC0,\xC00\xCC\xA9\xCC\xA8\xC0\x13\xC0\x14\x00\x9C\x00\x9D\x00/\x005\x01\x00\x01\x93\x8A\x8A\x00\x00\x00\x00\x00\x0E\x00\x0C\x00\x00\x09localhost\x00\x17\x00\x00\xFF\x01\x00\x01\x00\x00" 400 157 "-" "-" "-"
2022-09-13T13:24:16.116817914Z 172.17.0.1 - - [13/Sep/2022:13:24:16 +0000] "\x16\x03\x01\x02\x00\x01\x00\x01\xFC\x03\x03}\xA9Dr{\x8C;\x90z\x82\xAD\xBC\x8Az\xC2x\xDF\x1E\x9A\xE6l?\xA7\xE0DoK\x91'g\xBB\xB5 %\xBB\xFD\xD9\x82?\xDB\x80\xB3T\xF6cJ\xF7\xE5\xC2\xD2\x11\xBC\xA2\x1F\x90\x14\xA3\xEB\xBD=R\xBC\x83\x89\x85\x00 \xCA\xCA\x13\x01\x13\x02\x13\x03\xC0+\xC0/\xC0,\xC00\xCC\xA9\xCC\xA8\xC0\x13\xC0\x14\x00\x9C\x00\x9D\x00/\x005\x01\x00\x01\x93\x9A\x9A\x00\x00\x00\x00\x00\x0E\x00\x0C\x00\x00\x09localhost\x00\x17\x00\x00\xFF\x01\x00\x01\x00\x00" 400 157 "-" "-" "-"
2022-09-13T13:24:39.117398081Z 172.17.0.1 - - [13/Sep/2022:13:24:39 +0000] "GET / HTTP/1.1" 200 615 "-" "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36" "-"
2022-09-13T13:24:39.117412408Z 2022/09/13 13:24:40 [error] 34#34: *3 open() "/usr/share/nginx/html/favicon.ico" failed (2: No such file or directory), client: 172.17.0.1, server: localhost, request: "GET /favicon.ico HTTP/1.1", host: "0.0.0.0:8080", referrer: "http://0.0.0.0:8080/"
2022-09-13T13:24:40.117419389Z 172.17.0.1 - - [13/Sep/2022:13:24:40 +0000] "GET /favicon.ico HTTP/1.1" 404 555 "http://0.0.0.0:8080/" "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36" "-"
2022-09-13T13:25:00.117434249Z 172.17.0.1 - - [13/Sep/2022:13:25:00 +0000] "\x16\x03\x01\x02\x00\x01\x00\x01\xFC\x03\x03\xE2\x19V$Zqi'\xD7\xFC[\x80\xEF\xBA\xE5\xC7\xE8\xF7&amp;3nS\xEB\xC9\xEC\x91\xC2\xD8\xD1\x89\x9E\xBE \xC7?\xE1\xFA\x04a\x1C\xCE\x90\x0F\x8F\x98u\xE3/\xD8RfOH\xEC\x92+\x93\x5C\xBB\xB1\xBF\xD2m\xB09\x00 \xFA\xFA\x13\x01\x13\x02\x13\x03\xC0+\xC0/\xC0,\xC00\xCC\xA9\xCC\xA8\xC0\x13\xC0\x14\x00\x9C\x00\x9D\x00/\x005\x01\x00\x01\x93\x9A\x9A\x00\x00\x00\x00\x00\x0E\x00\x0C\x00\x00\x09localhost\x00\x17\x00\x00\xFF\x01\x00\x01\x00\x00" 400 157 "-" "-" "-"
2022-09-13T13:25:00.223560881Z 172.17.0.1 - - [13/Sep/2022:13:25:00 +0000] "\x16\x03\x01\x02\x00\x01\x00\x01\xFC\x03\x03)\x9A\x8FbC\xD9m\xF1\x86\xEBd\x22\xCF\xC4E\x87#~L\xC1\x84\x7F\xB5\x91k\x98\xABl\xEE\x1E[0 \xD0\xD2`\x85\xC6\x8B\x85R\x8B\x87\xEAq{P\xF2\xFB\xE2\xA8\x9DI\xF4tH\x99\x13\x10~\xCA1-|\x8E\x00 \xEA\xEA\x13\x01\x13\x02\x13\x03\xC0+\xC0/\xC0,\xC00\xCC\xA9\xCC\xA8\xC0\x13\xC0\x14\x00\x9C\x00\x9D\x00/\x005\x01\x00\x01\x93" 400 157 "-" "-" "-"
2022-09-13T13:26:25.223596738Z 172.17.0.1 - - [13/Sep/2022:13:26:28 +0000] "GET / HTTP/1.1" 304 0 "-" "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36" "-"
</output_code>
  <markdown>Paramos y borramos el contenedor</markdown>
  <input_code>!docker rm -f proxy</input_code>
  <output_code>proxy
</output_code>
  <input_code>!docker ps -a</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND               CREATED          STATUS                        PORTS     NAMES
ce4d60427dcd   ubuntu    "tail -f /dev/null"   26 minutes ago   Exited (137) 13 minutes ago             alwaysup
5b633e9d838f   ubuntu    "bash"                31 minutes ago   Exited (0) 27 minutes ago               funny_mirzakhani
da16b3a85178   ubuntu    "bash"                32 minutes ago   Exited (0) 32 minutes ago               hardcore_kare
</output_code>
  <markdown>## Datos en Docker</markdown>
  <markdown>### Bind mounts</markdown>
  <markdown>Vamos a ver los contenedores que tenemos parados</markdown>
  <input_code>!docker ps -a</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND               CREATED          STATUS                        PORTS     NAMES
ce4d60427dcd   ubuntu    "tail -f /dev/null"   26 minutes ago   Exited (137) 13 minutes ago             alwaysup
5b633e9d838f   ubuntu    "bash"                31 minutes ago   Exited (0) 28 minutes ago               funny_mirzakhani
da16b3a85178   ubuntu    "bash"                32 minutes ago   Exited (0) 32 minutes ago               hardcore_kare
</output_code>
  <markdown>Vamos a borrar los dos de Ubuntu en los que su comando principal es la Bash y vamos a dejar el que dejamos como no operaci√≥n</markdown>
  <input_code>!docker rm funny_mirzakhani</input_code>
  <output_code>funny_mirzakhani
</output_code>
  <input_code>!docker rm hardcore_kare</input_code>
  <output_code>hardcore_kare
</output_code>
  <input_code>!docker ps -a</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND               CREATED          STATUS                        PORTS     NAMES
ce4d60427dcd   ubuntu    "tail -f /dev/null"   27 minutes ago   Exited (137) 14 minutes ago             alwaysup
</output_code>
  <markdown>Vamos a volver a ejecutar el contenedor de Ubuntu que hemos dejado, esto se hace mediante el comando `start`</markdown>
  <input_code>!docker start alwaysup</input_code>
  <output_code>alwaysup
</output_code>
  <markdown>Nos metemos otra vez dentro de el</markdown>
  <input_code>!docker exec -it alwaysup bash</input_code>
  <output_code>root@ce4d60427dcd:/#
</output_code>
  <markdown>En el contenedor, puedo crear una nueva carpeta que se llame `dockerfolder`</markdown>
  <input_code>!mkdir dockerfolder</input_code>
  <output_code />
  <markdown>Si listamos los archivos aparecer√° la nueva carpeta</markdown>
  <input_code>!ls</input_code>
  <output_code>bin  boot  dev  dockerfolder  etc  home  lib  lib32  lib64  libx32  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</output_code>
  <markdown>Si salimos del contenedor</markdown>
  <input_code>!exit</input_code>
  <output_code>exit</output_code>
  <markdown>Y lo borramos</markdown>
  <input_code>!docker rm -f alwaysup</input_code>
  <output_code>alwaysup
</output_code>
  <markdown>Si listamos todos los contenedores, ya no aparece el √∫ltimo que hemos creado</markdown>
  <input_code>!docker ps -a</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
</output_code>
  <markdown>Vamos a volver a hacer todo, pero primero vamos a crear una carpeta en el host en la que compartiremos los datos con el contenedor</markdown>
  <input_code>!mkdir dockerHostFolder</input_code>
  <markdown>Vemos que dentro de la carpeta no hay nada</markdown>
  <input_code>!ls dockerHostFolder</input_code>
  <markdown>Ahora obtenemos nuestra ruta absoluta</markdown>
  <input_code>!pwd</input_code>
  <output_code>/home/wallabot/Documentos/web/portafolio/posts
</output_code>
  <markdown>Volvemos a crear el contenedor pero a√±adiendo la opci√≥n ``-v`` (``bind mount``). A continuaci√≥n se a√±ade la ruta absoluta de la carpeta del host y la ruta absoluta de la carpeta en el contenedor, ``-v &lt;host path&gt;:&lt;container path&gt;``</markdown>
  <input_code>!docker run -d --name alwaysup -v ~/Documentos/web/portafolio/posts/dockerHostFolder:/dockerContainerFolder ubuntu tail -f /dev/null</input_code>
  <output_code>4ede4512c293bdcc155e9c8e874dfb4a28e5163f4d5c7ddda24ad2863f28921b
</output_code>
  <markdown>Entramos al contenedor, listamos los archivos y ya aparece la carpeta que hab√≠amos creado</markdown>
  <input_code>!docker exec -it alwaysup bash</input_code>
  <output_code>root@4ede4512c293:/#</output_code>
  <input_code>root@4ede4512c293:/# ls</input_code>
  <output_code>bin   dev                    etc   lib    lib64   media  opt   root  sbin  sys  usr
boot  dockerContainerFolder  home  lib32  libx32  mnt    proc  run   srv   tmp  var
</output_code>
  <markdown>Vamos al directorio del contenedor que hemos compartido, creamos un archivo y salimos del contenedor</markdown>
  <input_code>root@4ede4512c293:/# cd dockerContainerFolder</input_code>
  <output_code />
  <input_code>root@4ede4512c293:/dockerContainerFolder# touch bindFile.txt</input_code>
  <output_code />
  <input_code>root@4ede4512c293:/dockerContainerFolder# exit</input_code>
  <output_code>exit</output_code>
  <markdown>Vemos qu√© hay dentro de la carpeta compartida</markdown>
  <input_code>!ls dockerHostFolder</input_code>
  <output_code>bindFile.txt
</output_code>
  <markdown>Pero es m√°s, si borramos el contenedor, el archivo sigue all√≠</markdown>
  <input_code>!docker rm -f alwaysup</input_code>
  <output_code>alwaysup
</output_code>
  <input_code>!ls dockerHostFolder</input_code>
  <output_code>bindFile.txt
</output_code>
  <markdown>Si vuelvo a crear un contenedor compartiendo las carpetas, todos los archivos estar√°n en el contenedor</markdown>
  <input_code>!docker run -d --name alwaysup -v ~/Documentos/web/portafolio/posts/dockerHostFolder:/dockerContainerFolder ubuntu tail -f /dev/null</input_code>
  <output_code>6c021d37ea29d8b23fe5cd4968baa446085ae1756682f65340288b4c851c362d
</output_code>
  <input_code>!docker exec -it alwaysup bash</input_code>
  <output_code>root@6c021d37ea29:/#</output_code>
  <input_code>!root@6c021d37ea29:/# ls dockerContainerFolder/</input_code>
  <output_code>bindFile.txt:/#</output_code>
  <markdown>Eliminamos el contenedor</markdown>
  <input_code>!docker rm -f alwaysup</input_code>
  <output_code>alwaysup
</output_code>
  <input_code>!docker ps -a</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
</output_code>
  <markdown>### Vol√∫menes</markdown>
  <markdown>Los vol√∫menes se crearon como una evoluci√≥n de los ``bind mounts`` para dar m√°s seguridad. Podemos listar todos los vol√∫menes de docker mediante ``docker volume ls``</markdown>
  <input_code>!docker volume ls</input_code>
  <output_code>DRIVER    VOLUME NAME
</output_code>
  <markdown>Vamos a crear un nuevo volumen para el contenedor de ubuntu, para ello usamos el comando ``docker volume create &lt;volume name&gt;``</markdown>
  <input_code>!docker volume create ubuntuVolume</input_code>
  <output_code>ubuntuVolume
</output_code>
  <markdown>Si volvemos a listar los vol√∫menes aparecer√° el que acabamos de crear</markdown>
  <input_code>!docker volume ls</input_code>
  <output_code>DRIVER    VOLUME NAME
local     ubuntuVolume
</output_code>
  <markdown>Sin embargo, no aparece como una carpeta en el sistema de archivos del host. Con `ls -d */` listamos todas las carpetas</markdown>
  <input_code>!ls -d */</input_code>
  <output_code>dockerHostFolder/  __pycache__/
</output_code>
  <markdown>Vamos a volver a crear un contenedor, pero ahora lo creamos con el volumen que acabamos de crear con la opci√≥n ``--mount``, indicando el volumen fuente mediante ``src=&lt;volume name&gt;`` (si el volumen no existiese, docker lo crear√≠a), a continuaci√≥n el destino separado por una ``,``, ``dst=&lt;container path&gt;``, es decir ``--mount src=&lt;volume name&gt;,dst=&lt;container path&gt;``</markdown>
  <input_code>!docker run -d --name alwaysup --mount src=ubuntuVolume,dst=/dockerVolumeFolder ubuntu tail -f /dev/null</input_code>
  <output_code>42cdcddf4e46dc298a87b0570115e0b2fc900cb4c6db5eea22a61409b8cb271d
</output_code>
  <markdown>Una vez creado podemos ver los vol√∫menes del contenedor mediante el comando ``inspect`` y filtrando por `'{{.Mounts}}'`

```bash
$ docker inspect --format '{{.Mounts}}' alwaysup 
[
    {
        volume ubuntuVolume /var/lib/docker/volumes/ubuntuVolume/_data /dockerVolumeFolder local z true 
    }
]
```</markdown>
  <markdown>Vemos que el volumen se llama `ubuntuVolume` y adem√°s podemos ver la ruta donde est√° guardado, en este caso en `/var/lib/docker/volumes/ubuntuVolume/_data`. Hacemos lo mismo que antes, nos metemos en el contenedor, creamos un archivo en la ruta del volumen, salimos y vemos en el host si se ha creado

```bash
$ docker exec -it alwaysup bash
root@42cdcddf4e46:/# touch dockerVolumeFolder/volumeFile.txt
root@42cdcddf4e46:/# exit
```


```bash
$ sudo ls /var/lib/docker/volumes/ubuntuVolume/_data
volumeFile.txt
```</markdown>
  <markdown>Est√° el archivo creado</markdown>
  <markdown>### Insertar y extraer archivos de un contenedor</markdown>
  <markdown>Primero vamos a crear un archivo que queremos copiar dentro de un contenedor</markdown>
  <input_code>!touch dockerHostFolder/text.txt</input_code>
  <markdown>Entramos en el contenedor

```bash
$ docker exec -it alwaysup bash
root@42cdcddf4e46:/#
```</markdown>
  <markdown>Creamos una nueva carpeta donde vamos a copiar el archivo y salimos

```bash
root@42cdcddf4e46:/# mkdir folderToCopy
root@42cdcddf4e46:/# ls
bin  boot  dev  dockerVolumeFolder  etc  folderToCopy  home  lib  lib32  lib64  libx32  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
root@42cdcddf4e46:/# exit
exit
```</markdown>
  <markdown>Copiamos dentro del contenedor el archivo mediante el comando ``cp``, indicando el archivo que **quiero** copiar, el contenedor donde lo queremos copiar y la ruta dentro del contenedor, ``docker cp &lt;file&gt; &lt;container&gt;:&lt;container path&gt;``</markdown>
  <input_code>!docker cp dockerHostFolder/text.txt alwaysup:/folderToCopy</input_code>
  <markdown>Volvemos a entrar al contenedor y comprobamos que est√© el archivo

```bash
$ docker exec -it alwaysup bash
root@42cdcddf4e46:/# ls folderToCopy/
text.txt
```</markdown>
  <markdown>Salimos del contenedor

```bash
/# exit
exit
```</markdown>
  <markdown>Ahora vamos a extraer el archivo del contenedor y lo vamos a guardar en el host con otro nombre, para ello usamos otra vez el comando ``cp``, pero indicando ahora el contenedor, la ruta del archivo en el contenedor y la ruta y nombre que queremos que tenga el archivo en el host, ``docker cp &lt;container&gt;:&lt;docker file path&gt; &lt;host file path&gt;``</markdown>
  <input_code>!docker cp alwaysup:/folderToCopy/text.txt dockerHostFolder/fileExtract.txt</input_code>
  <markdown>Vemos que est√° en el host</markdown>
  <input_code>!ls dockerHostFolder</input_code>
  <output_code>bindFile.txt  fileExtract.txt  text.txt
</output_code>
  <markdown>Aunque el contenedor est√© parado tambi√©n se pueden copiar archivos</markdown>
  <markdown>Por √∫ltimo, borramos el contenedor</markdown>
  <input_code>!docker rm -f alwaysup</input_code>
  <output_code>alwaysup
</output_code>
  <markdown>## Im√°genes</markdown>
  <markdown>### Conceptos fundamentales</markdown>
  <markdown>Las im√°genes son los archivos ("plantillas") con toda la configuraci√≥n para crear un contenedor. Cada vez que creamos un contenedor se crea a partir de una imagen. Cuando cre√°bamos contenedores nuevos, la primera vez sal√≠a un mensaje diciendo que no ten√≠amos la imagen y que iba a descargarla. En Docker Hub existen multitud de im√°genes con todo tipo de m√°quinas, pero para un entorno de desarrollo muy espec√≠fico podemos crear nuestra propia plantilla para pas√°rsela a alguien y trabaje en un contenedor con la misma configuraci√≥n que el nuestro</markdown>
  <markdown>Podemos ver todas las im√°genes que tenemos guardadas en nuestro ordenador mediante el comando ``docker image ls``</markdown>
  <input_code>!docker image ls</input_code>
  <output_code>REPOSITORY    TAG       IMAGE ID       CREATED         SIZE
nginx         latest    2d389e545974   8 hours ago     142MB
ubuntu        latest    2dc39ba059dc   11 days ago     77.8MB
hello-world   latest    feb5d9fea6a5   11 months ago   13.3kB
</output_code>
  <markdown>Podemos ver los tama√±os, y podemos ver c√≥mo la de `nginx` ocupa mucho y por eso tard√≥ m√°s en descargarse que el resto</markdown>
  <markdown>Otra columna que podemos ver es la de ``TAG``, esto indica la versi√≥n de la imagen. En todas pone ``latest``, esto quiere decir que es la √∫ltima. Es decir, en el momento de descarg√°rnosla nos hemos descargado la √∫ltima versi√≥n que hay en Docker Hub. Esto en un entorno de desarrollo no es √≥ptimo, porque nosotros podemos descargarnos una imagen de Ubuntu, y si no especificamos versi√≥n se baja la √∫ltima, por ejemplo la 20.04. Pero despu√©s de un tiempo alguien puede querer desarrollar contigo y descargarse esa imagen, pero al no especificar la versi√≥n se descargar√° otra vez la √∫ltima, que en su caso puede ser la 22.04. Esto puede dar lugar a problemas y a que cosas que a una de las personas le funcione y a la otra no</markdown>
  <markdown>Podemos ver todas las im√°genes que hay en docker hub yendo a ``https://hub.docker.com/``. Ah√≠ podr√°s buscar la imagen que mejor se adapte al proyecto que quieras hacer. Si navegamos a la image de Ubuntu, por ejemplo, podemos ver las versiones (`tags`) de las im√°genes.</markdown>
  <markdown>Vamos a descargar, **pero no ejecutar** una imagen. Para ello usamos el comando ``docker pull &lt;hub&gt; &lt;image name&gt;:&lt;tag&gt;``. Si no indicamos el hub, lo descargar√° de docker hub por defecto, pero podemos indicar otro, por ejemplo uno privado de nuestra organizaci√≥n. Tambi√©n, si no indicamos el tag, por defecto bajar√° la √∫ltima versi√≥n</markdown>
  <input_code>!docker pull ubuntu:20.04</input_code>
  <output_code>20.04: Pulling from library/ubuntu

[1BDigest: sha256:35ab2bf57814e9ff49e365efd5a5935b6915eede5c7f8581e9e1b85e0eecbe16[1A[2K[1A[2K[1A[2K[1A[2K[1A[2K[1A[2K[1A[2K[1A[2K[1A[2K
Status: Downloaded newer image for ubuntu:20.04
docker.io/library/ubuntu:20.04
</output_code>
  <markdown>Si volvemos a listar las im√°genes, vemos que ahora tenemos dos im√°genes de Ubuntu, una con el tag ``20.04`` y otra con el tag ``latest``</markdown>
  <input_code>!docker image ls</input_code>
  <output_code>REPOSITORY    TAG       IMAGE ID       CREATED         SIZE
nginx         latest    2d389e545974   8 hours ago     142MB
ubuntu        latest    2dc39ba059dc   11 days ago     77.8MB
ubuntu        20.04     a0ce5a295b63   11 days ago     72.8MB
hello-world   latest    feb5d9fea6a5   11 months ago   13.3kB
</output_code>
  <markdown>### Crear im√°genes mediante `Dockerfile`</markdown>
  <markdown>Creamos un directorio en el host llamado `dockerImages` para trabajar en √©l</markdown>
  <input_code>!mkdir dockerImages</input_code>
  <markdown>Creamos un archivo `Dockerfile` con el que crearemos una imagen</markdown>
  <input_code>!touch dockerImages/Dockerfile</input_code>
  <markdown>Abrimos el archivo creado con nuestro editor preferido y escribimos lo siguiente:

```Dockerfile
FROM ubuntu:latest
```

Esto le dice a docker que cree la imagen a ra√≠z de la imagen `latest` de ubuntu</markdown>
  <markdown>A continuaci√≥n, escribimos un comando que se va a ejecutar en tiempo de compilaci√≥n

```Dockerfile
RUN touch /test.txt
```

Esto quiere decir que cuando se compile el `Dockerfile` se ejecutar√° ese comando, pero no cuando se corra el contenedor de la imagen</markdown>
  <markdown>Al final el `Dockerfile` queda as√≠:
```dockerfile
    FROM ubuntu:latest
    RUN touch /test.txt
```</markdown>
  <markdown>Compilamos el `Dockerfile` mediante el comando `build`, con la opci√≥n `-t` podemos darle un `tag`. Por √∫ltimo, hay que indicarle la ruta del contexto de `build`, m√°s adelante explicaremos esto</markdown>
  <input_code>!docker build -t ubuntu:test ./dockerImages</input_code>
  <output_code>Sending build context to Docker daemon  2.048kB
Step 1/2 : FROM ubuntu:latest
 ---&gt; 2dc39ba059dc
Step 2/2 : RUN touch /test.txt
 ---&gt; Using cache
 ---&gt; a78cf3ea16d8
Successfully built a78cf3ea16d8
Successfully tagged ubuntu:test

Use 'docker scan' to run Snyk tests against images to find vulnerabilities and learn how to fix them
</output_code>
  <markdown>Como vemos se compila en 2 pasos, cada uno tiene una `id`, cada una de esas `id`s son capas de la imagen, esto tambi√©n lo veremos m√°s adelante

Volvemos a ver las im√°genes que tenemos guardadas en nuestro ordenador y aparece la que acabamos de crear</markdown>
  <input_code>!docker image ls</input_code>
  <output_code>REPOSITORY    TAG       IMAGE ID       CREATED         SIZE
ubuntu        test      a78cf3ea16d8   8 minutes ago   77.8MB
nginx         latest    2d389e545974   8 hours ago     142MB
ubuntu        latest    2dc39ba059dc   11 days ago     77.8MB
ubuntu        20.04     a0ce5a295b63   11 days ago     72.8MB
hello-world   latest    feb5d9fea6a5   11 months ago   13.3kB
</output_code>
  <markdown>Corremos el contenedor a partir de la imagen que acabamos de crear

```bash
$ docker run -it ubuntu:test
root@b57b9d4eedeb:/#
```

Entramos en el bash del contenedor. Como dijimos, el comando RUN se ejecuta en tiempo de compilaci√≥n de la imagen, por lo que el archivo que hemos pedido que se cree deber√≠a estar en nuestro contenedor

```bash
root@b57b9d4eedeb:/# ls
bin  boot  dev  etc  home  lib  lib32  lib64  libx32  media  mnt  opt  proc  root  run  sbin  srv  sys  test.txt  tmp  usr  var
```

Es importante entender que ese archivo se cre√≥ cuando se construy√≥ la imagen, es decir, la imagen del contenedor ya tiene ese archivo. No se crea cuando se lanza el contenedor

Salimos del contenedor

```bash
root@b57b9d4eedeb:/# exit
exit
```</markdown>
  <markdown>Como ya tenemos una imagen, la podr√≠amos subir al hub de Docker, pero vamos a volver a listar las im√°genes antes de eso.</markdown>
  <input_code>!docker image ls</input_code>
  <output_code>REPOSITORY    TAG       IMAGE ID       CREATED          SIZE
ubuntu        test      a78cf3ea16d8   20 minutes ago   77.8MB
nginx         latest    2d389e545974   8 hours ago      142MB
ubuntu        latest    2dc39ba059dc   11 days ago      77.8MB
ubuntu        20.04     a0ce5a295b63   11 days ago      72.8MB
hello-world   latest    feb5d9fea6a5   11 months ago    13.3kB
</output_code>
  <markdown>Si vemos, nos est√° diciendo que la imagen que acabamos de crear pertenece al repositorio de ubuntu, pero nosotros no tenemos acceso al repositorio de ubuntu, por lo que en docker hub nos tenemos que hacer una cuenta para poder subir la imagen a nuestro repositorio. En mi caso, mi repositorio se llama `maximofn`, por lo que cambio el repositorio de la imagen mediante el comando `tag`, indic√°ndole la imagen a la que queremos cambiar de repositorio y el nuevo repositorio. En el nuevo repositorio se suele indicar el nombre del repositorio seguido del tipo de imagen y el tag, en mi caso `maximofn/ubuntu:test`</markdown>
  <input_code>!docker tag ubuntu:test maximofn/ubuntu:test</input_code>
  <markdown>Si ahora volvemos a listar las im√°genes</markdown>
  <input_code>!docker image ls</input_code>
  <output_code>REPOSITORY        TAG       IMAGE ID       CREATED          SIZE
ubuntu            test      a78cf3ea16d8   24 minutes ago   77.8MB
maximofn/ubuntu   test      a78cf3ea16d8   24 minutes ago   77.8MB
nginx             latest    2d389e545974   8 hours ago      142MB
ubuntu            latest    2dc39ba059dc   11 days ago      77.8MB
ubuntu            20.04     a0ce5a295b63   11 days ago      72.8MB
hello-world       latest    feb5d9fea6a5   11 months ago    13.3kB
</output_code>
  <markdown>Ahora debemos loguearnos dentro de docker hub para poder subir la imagen, para ello usamos el comando `login`

```bash
$ docker login
Login with your Docker ID to push and pull images from Docker Hub. If you do not have a Docker ID, head over to https://hub.docker.com to create one.
Username: maximofn
Password:

Login Succeeded
```</markdown>
  <markdown>Ahora podemos subir la imagen mediante el comando `push`</markdown>
  <input_code>!docker push maximofn/ubuntu:test</input_code>
  <output_code>The push refers to repository [docker.io/maximofn/ubuntu]

[1B06994357: Preparing 
[2B06994357: Pushed  from library/ubuntu [2A[2Ktest: digest: sha256:318d83fc3c35ff930d695b0dc1c5ad1b0ea54e1ec6e3478b8ca85c05fd793c4e size: 735
</output_code>
  <markdown>Ha subido solo la primera capa, la segunda, como la us√© a ra√≠z de la imagen de Ubuntu, lo que hace es colocar un puntero a esa imagen para no tener capas subidas m√°s de una vez</markdown>
  <markdown>Hay que tener en cuenta que este repositorio es p√∫blico, por lo que no debes subir im√°genes con datos sensibles. Adem√°s, si una imagen no tiene uso en 6 meses ser√° borrada</markdown>
  <markdown>### El sistema de capas</markdown>
  <markdown>Mediante el comando `history` podemos ver las capas de una imagen. Si vemos las capas de la imagen que acabamos de crear, usamos `docker history ubuntu:test`</markdown>
  <input_code>!docker history ubuntu:test</input_code>
  <output_code>IMAGE          CREATED        CREATED BY                                      SIZE      COMMENT
a78cf3ea16d8   3 minutes ago  /bin/sh -c touch /test.txt                      0B        
2dc39ba059dc   12 days ago    /bin/sh -c #(nop)  CMD ["bash"]                 0B        
&lt;missing&gt;      12 days ago    /bin/sh -c #(nop) ADD file:a7268f82a86219801‚Ä¶   77.8MB    
</output_code>
  <markdown>Vemos que la primera capa tiene el comando que hemos introducido en el `Dockerfile`, adem√°s dice que ha sido creada hace 3 minutos. Sin embargo, el resto de capas fueron creadas hace 12 d√≠as, y son las capas de la imagen de Ubuntu de la que nos hemos basado</markdown>
  <markdown>Al `Dockerfile` que hemos creado anteriormente le a√±adimos la l√≠nea

```docker
RUN rm /test.txt
```</markdown>
  <markdown>Al final el `Dockerfile` queda as√≠:
```dockerfile
    FROM ubuntu:latest
    RUN touch /test.txt
    RUN rm /test.txt
```</markdown>
  <markdown>Si volvemos a compilar, vemos qu√© pasa</markdown>
  <input_code>!docker build -t ubuntu:test ./dockerImages</input_code>
  <output_code>Sending build context to Docker daemon  2.048kB
Step 1/3 : FROM ubuntu:latest
 ---&gt; 2dc39ba059dc
Step 2/3 : RUN touch /test.txt
 ---&gt; Using cache
 ---&gt; a78cf3ea16d8
Step 3/3 : RUN rm /test.txt
 ---&gt; Running in c2e6887f2025
Removing intermediate container c2e6887f2025
 ---&gt; 313243a9b573
Successfully built 313243a9b573
Successfully tagged ubuntu:test

Use 'docker scan' to run Snyk tests against images to find vulnerabilities and learn how to fix them
</output_code>
  <markdown>Como vemos, hay una capa m√°s con la nueva l√≠nea que hemos agregado. Si volvemos a ver las capas de la imagen con `history`</markdown>
  <input_code>!docker history ubuntu:test</input_code>
  <output_code>IMAGE          CREATED              CREATED BY                                      SIZE      COMMENT
313243a9b573   About a minute ago   /bin/sh -c rm /test.txt                         0B        
a78cf3ea16d8   3 minutes ago        /bin/sh -c touch /test.txt                      0B        
2dc39ba059dc   12 days ago          /bin/sh -c #(nop)  CMD ["bash"]                 0B        
&lt;missing&gt;      12 days ago          /bin/sh -c #(nop) ADD file:a7268f82a86219801‚Ä¶   77.8MB    
</output_code>
  <markdown>Vemos que las primeras capas son iguales a las de antes y ha a√±adido una nueva capa con el nuevo comando</markdown>
  <markdown>### B√∫squeda en docker hub</markdown>
  <markdown>No hace falta meterse en la p√°gina de docker hub para buscar im√°genes, se puede hacer desde la terminal. Para ello usamos el comando `docker search &lt;image name&gt;`</markdown>
  <input_code>!docker search ubuntu</input_code>
  <output_code>NAME                             DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
ubuntu                           Ubuntu is a Debian-based Linux operating sys‚Ä¶   16425     [OK]       
websphere-liberty                WebSphere Liberty multi-architecture images ‚Ä¶   297       [OK]       
open-liberty                     Open Liberty multi-architecture images based‚Ä¶   62        [OK]       
neurodebian                      NeuroDebian provides neuroscience research s‚Ä¶   104       [OK]       
ubuntu-debootstrap               DEPRECATED; use "ubuntu" instead                52        [OK]       
ubuntu-upstart                   DEPRECATED, as is Upstart (find other proces‚Ä¶   115       [OK]       
ubuntu/nginx                     Nginx, a high-performance reverse proxy &amp; we‚Ä¶   98                   
ubuntu/squid                     Squid is a caching proxy for the Web. Long-t‚Ä¶   66                   
ubuntu/cortex                    Cortex provides storage for Prometheus. Long‚Ä¶   4                    
ubuntu/apache2                   Apache, a secure &amp; extensible open-source HT‚Ä¶   60                   
ubuntu/kafka                     Apache Kafka, a distributed event streaming ‚Ä¶   35                   
ubuntu/mysql                     MySQL open source fast, stable, multi-thread‚Ä¶   53                   
ubuntu/bind9                     BIND 9 is a very flexible, full-featured DNS‚Ä¶   62                   
ubuntu/prometheus                Prometheus is a systems and service monitori‚Ä¶   51                   
ubuntu/zookeeper                 ZooKeeper maintains configuration informatio‚Ä¶   12                   
ubuntu/postgres                  PostgreSQL is an open source object-relation‚Ä¶   31                   
ubuntu/redis                     Redis, an open source key-value store. Long-‚Ä¶   19                   
ubuntu/grafana                   Grafana, a feature rich metrics dashboard &amp; ‚Ä¶   9                    
ubuntu/memcached                 Memcached, in-memory keyvalue store for smal‚Ä¶   5                    
ubuntu/dotnet-aspnet             Chiselled Ubuntu runtime image for ASP.NET a‚Ä¶   11                   
ubuntu/dotnet-deps               Chiselled Ubuntu for self-contained .NET &amp; A‚Ä¶   11                   
ubuntu/prometheus-alertmanager   Alertmanager handles client alerts from Prom‚Ä¶   9                    
ubuntu/dotnet-runtime            Chiselled Ubuntu runtime image for .NET apps‚Ä¶   10                   
ubuntu/cassandra                 Cassandra, an open source NoSQL distributed ‚Ä¶   2                    
ubuntu/telegraf                  Telegraf collects, processes, aggregates &amp; w‚Ä¶   4                    
</output_code>
  <markdown>## Uso de docker para crear aplicaciones</markdown>
  <markdown>### Exposici√≥n de puertos</markdown>
  <markdown>Antes vimos c√≥mo pod√≠amos vincular un puerto de un contenedor a un puerto del ordenador (`-p 8080:80`). Pero para que eso sea posible, a la hora de crear la imagen hay que exponer el puerto, esto se hace a√±adiendo al Dockerfile la l√≠nea `EXPOSE &lt;port&gt;`, en el caso de antes

```docker
EXPOSE 80
```

O usar im√°genes como base que ya tengan puertos expuestos</markdown>
  <markdown>### Reuso del cach√© de capas al compilar</markdown>
  <markdown>Cuando compilamos una imagen, si alguna de las capas que hemos definido ya han sido compiladas antes, Docker lo detecta y las usa, no las vuelve a compilar. Si volvemos a compilar la imagen que hemos definido en el `Dockerfile` ahora tardar√° muy poco, porque todas las capas ya est√°n compiladas y Docker no las vuelve a compilar</markdown>
  <input_code>!docker build -t ubuntu:test ./dockerImages</input_code>
  <output_code>Sending build context to Docker daemon  2.048kB
Step 1/3 : FROM ubuntu:latest
 ---&gt; 2dc39ba059dc
Step 2/3 : RUN touch /test.txt
 ---&gt; Using cache
 ---&gt; a78cf3ea16d8
Step 3/3 : RUN rm /test.txt
 ---&gt; Using cache
 ---&gt; 313243a9b573
Successfully built 313243a9b573
Successfully tagged ubuntu:test

Use 'docker scan' to run Snyk tests against images to find vulnerabilities and learn how to fix them
</output_code>
  <markdown>En la segunda y tercera capa aparece el texto `Using cache`

Como esto es un cuaderno Jupyter a la hora de ejecutar las celdas te da la informaci√≥n del tiempo que tardan en ejecutarse, la vez anterior que compil√© la imagen tard√≥ 1,4 segundos, mientras que ahora ha tardado 0,5 segundos</markdown>
  <markdown>Pero si ahora cambio el Dockerfile, y en la primera l√≠nea, donde dec√≠a que nos bas√°bamos en la √∫ltima versi√≥n de Ubuntu y cambiamos a la versi√≥n 20.04

```docker
FROM ubuntu:20.04
```</markdown>
  <markdown>Al final el `Dockerfile` queda as√≠:
```dockerfile
    FROM ubuntu:20.04
    RUN touch /test.txt
    RUN rm /test.txt
```</markdown>
  <markdown>Si volvemos a compilar, tardar√° mucho m√°s</markdown>
  <input_code>!docker build -t ubuntu:test ./dockerImages</input_code>
  <output_code>Sending build context to Docker daemon  2.048kB
Step 1/3 : FROM ubuntu:20.04
 ---&gt; a0ce5a295b63
Step 2/3 : RUN touch /test.txt
 ---&gt; Running in a40fe8df2c0d
Removing intermediate container a40fe8df2c0d
 ---&gt; 0bb9b452c11f
Step 3/3 : RUN rm /test.txt
 ---&gt; Running in 2e14919f3685
Removing intermediate container 2e14919f3685
 ---&gt; fdc248fa833b
Successfully built fdc248fa833b
Successfully tagged ubuntu:test

Use 'docker scan' to run Snyk tests against images to find vulnerabilities and learn how to fix them
</output_code>
  <markdown>Ha tardado 1,9 segundos y ya no aparece el texto `Using cache`</markdown>
  <markdown>Al cambiar la primera capa, Docker vuelve a compilar todas las capas. Esto puede ser un problema porque a la hora de desarrollar c√≥digo se puede dar el siguiente caso
 * Desarrollamos el c√≥digo en nuestro ordenador
 * Al construir la imagen, copiamos todo el c√≥digo de nuestro ordenador al contenedor
 * Luego le pedimos a la imagen que instale las bibliotecas necesarias

Esto puede hacer que al cambiar cualquier parte del c√≥digo, al tener que volver a compilar la imagen, la capa en la que se instalan las librer√≠as se tenga que volver a compilar, ya que ha cambiado una capa anterior</markdown>
  <markdown>Para solucionar esto, la idea ser√≠a que a la hora de crear la imagen, primero pidamos que se instalen las librer√≠as y luego que se copie el c√≥digo de nuestro ordenador al contenedor. As√≠, cada vez que cambiemos el c√≥digo y volvamos a compilar la imagen, solo se recompilar√° la capa en la que se copia el c√≥digo, por lo que la compilaci√≥n ser√° m√°s r√°pida</markdown>
  <markdown>Podr√°s pensar que es mejor compartir una carpeta entre el host y el contenedor (`bind mount`) donde tendremos el c√≥digo y as√≠ no hace falta volver a compilar la imagen cada vez que cambiemos el c√≥digo. Y la respuesta es que es verdad, solo he puesto este ejemplo porque es muy f√°cil de entender, pero es para escenificar que a la hora de crear im√°genes hay que pensar bien de manera que si hace falta volver a compilarla, recompile el m√≠nimo n√∫mero de capas</markdown>
  <markdown>### Escribir correctamente un Dockerfile</markdown>
  <markdown>Como hemos visto Docker no vuelve a compilar capas de un Dockerfile si ya las ha compilado antes, por lo que las carga de cach√©. Vamos a ver c√≥mo tiene que ser la forma correcta de escribir un Dockerfile para aprovecharnos de esto</markdown>
  <markdown>Vamos a partir de este Dockerfile para ir comentando posibles correcciones

``` Dockerfile
FROM ubuntu
COPY ./sourceCode /sourceCode
RUN apt-get update
RUN apt-get install -y python3 ssh
CMD ["python3", "/sourceCode/sourceApp/app.py"]
```

Como se puede ver se parte de una imagen de ubuntu, se copia la carpeta con el c√≥digo, se actualizan los repositorios, se instala python, se instala tambi√©n ssh y se corre la aplicaci√≥n</markdown>
  <markdown>#### Copiar el c√≥digo antes de la ejecuci√≥n</markdown>
  <markdown>Como hemos dicho antes, si primero copiamos el c√≥digo y luego instalamos Python, cada vez que hagamos un cambio en el c√≥digo y compilemos la imagen la compilar√° entera, pero si copiamos el c√≥digo despu√©s de instalar Python, cada vez que cambiemos el c√≥digo y compilemos la imagen, solo compilar√° desde la copia del c√≥digo y no volver√° a instalar Python, por lo que el Dockerfile deber√≠a pasar a ser as√≠

``` Dockerfile
FROM ubuntu
RUN apt-get update
RUN apt-get install -y python3 ssh
COPY ./sourceCode /sourceCode
CMD ["python3", "/sourceCode/sourceApp/app.py"]
```</markdown>
  <markdown>#### Copiar solo el c√≥digo nesario</markdown>
  <markdown>Estamos copiando la carpeta con todo el c√≥digo, pero a lo mejor dentro tenemos c√≥digo que no necesitamos, por lo que hay que copiar solo el c√≥digo que de verdad necesitemos para la aplicaci√≥n, de esta manera la imagen ocupar√° menos memoria. De modo que el Dockerfile quedar√≠a as√≠

``` Dockerfile
FROM ubuntu
RUN apt-get update
RUN apt-get install -y python3 ssh
COPY ./sourceCode/sourceApp /sourceCode/sourceApp
CMD ["python3", "/sourceCode/sourceApp/app.py"]
```</markdown>
  <markdown>#### Actualizar repositorios e instalar python en la misma l√≠nea</markdown>
  <markdown>Estamos actualizando los repositorios en una l√≠nea y en otra instalando python3.

``` Dockerfile
FROM ubuntu
RUN apt-get update &amp;&amp; apt-get install -y python3 ssh
COPY ./sourceCode/sourceApp /sourceCode/sourceApp
CMD ["python3", "/sourceCode/sourceApp/app.py"]
```</markdown>
  <markdown>#### No instalar ssh</markdown>
  <markdown>Hab√≠amos instalado ssh en la imagen para poder debuggear en caso de necesitarlo, pero eso hace que la imagen ocupe m√°s memoria. En caso de necesitar debuggear, deber√≠amos entrar en el contenedor, instalar ssh y a continuaci√≥n debuggear. Por lo que quitamos la instalaci√≥n de ssh

``` Dockerfile
FROM ubuntu
RUN apt-get update &amp;&amp; apt-get install -y python3
COPY ./sourceCode/sourceApp /sourceCode/sourceApp
CMD ["python3", "/sourceCode/sourceApp/app.py"]
```</markdown>
  <markdown>#### Usar `--no-install-recommends`</markdown>
  <markdown>Cuando instalamos algo en Ubuntu instala paquetes recomendados, pero que no necesitamos, por lo que la imagen ocupa m√°s espacio. As√≠ que para evitarlo a√±adimos a la instalaci√≥n `--no-install-recommends`

``` Dockerfile
FROM ubuntu
RUN apt-get update &amp;&amp; apt-get install -y python3 --no-install-recommends
COPY ./sourceCode/sourceApp /sourceCode/sourceApp
CMD ["python3", "/sourceCode/sourceApp/app.py"]
```</markdown>
  <markdown>#### Borrar lista de repositorios actualizados</markdown>
  <markdown>Hemos actualizado la lista de repositorios y hemos instalado python, pero una vez hecho ya no necesitamos la lista de repositorios actualizados, porque lo √∫nico que har√°n ser√° que la imagen ocupe m√°s, de modo que los eliminamos despu√©s de instalar python y en su misma l√≠nea

``` Dockerfile
FROM ubuntu
RUN apt-get update &amp;&amp; apt-get install -y python3 --no-install-recommends &amp;&amp; rm -rf /var/lib/apt/lists/*
COPY ./sourceCode/sourceApp /sourceCode/sourceApp
CMD ["python3", "/sourceCode/sourceApp/app.py"]
```</markdown>
  <markdown>#### Usar una imagen de Python</markdown>
  <markdown>Todo lo que hemos hecho de actualizar la lista de paquetes e instalar python no es necesario, ya que ya existen im√°genes de python sobre Ubuntu, que seguramente tambi√©n han seguido buenas pr√°cticas, que incluso lo hayan hecho mejor que nosotros y que ha sido escaneada en busca de vulnerabilidades por Docker Hub. Por lo que quitamos todo eso y partimos de una imagen de Python

``` Dockerfile
FROM python
COPY ./sourceCode/sourceApp /sourceCode/sourceApp
CMD ["python3", "/sourceCode/sourceApp/app.py"]
```</markdown>
  <markdown>#### Especificar la imagen de Python</markdown>
  <markdown>Al no especificar la imagen de Python se est√° bajando la √∫ltima, pero en funci√≥n de cu√°ndo construyas el contenedor se puede bajar una u otra, por lo que hay que a√±adir el tag con la versi√≥n de Python que se quiere

``` Dockerfile
FROM python:3.9.18
COPY ./sourceCode/sourceApp /sourceCode/sourceApp
CMD ["python3", "/sourceCode/sourceApp/app.py"]
```</markdown>
  <markdown>#### Elegir un tag peque√±o</markdown>
  <markdown>Hemos elegido el tag `3.9.18`, pero esa versi√≥n de python tiene un mont√≥n de librer√≠as que posiblemente no las necesitemos, por lo que podemos usar las versiones `3.9.18-slim` que tiene muchas menos librer√≠as instaladas, o la versi√≥n `3.9.18-alpine` que es una versi√≥n de python sobre Alpine y no sobre Ubuntu. Alpine es una distribuci√≥n de Linux muy ligera que tiene muy pocos paquetes instalados y que se suele usar mucho en contenedores Docker para que ocupen muy poco espacio

La imagen de python `3.9.18` ocupa 997 MB, la `3.9.18-slim` ocupa 126 MB y la `3.9.18-alpine` ocupa 47.8 MB

``` Dockerfile
FROM python:3.9.18-alpine
COPY ./sourceCode/sourceApp /sourceCode/sourceApp
CMD ["python3", "/sourceCode/sourceApp/app.py"]
```</markdown>
  <markdown>#### Indicar el workspace</markdown>
  <markdown>En lugar de indicar la ruta de la imagen `/sourceCode/sourceApp` establecemos que dicha ruta sea el workspace de la imagen. As√≠ cuando copiemos el c√≥digo o ejecutemos la aplicaci√≥n no hace falta indicar la ruta

``` Dockerfile
FROM python:3.9.18-alpine
WORKDIR /sourceCode/sourceApp
COPY ./sourceCode/sourceApp .
CMD ["python3", "app.py"]
```</markdown>
  <markdown>#### Indicar el workspace</markdown>
  <markdown>En lugar de indicar la ruta de la imagen `/sourceCode/sourceApp` establecemos que dicha ruta sea el workspace de la imagen. As√≠ cuando copiemos el c√≥digo o ejecutemos la aplicaci√≥n no hace falta indicar la ruta

``` Dockerfile
FROM python:3.9.18-alpine
WORKDIR /sourceCode/sourceApp
COPY ./sourceCode/sourceApp .
CMD ["python3", "app.py"]
```</markdown>
  <markdown>### C√≥digo compartido en una carpeta `bind mount`</markdown>
  <markdown>Hab√≠amos creado una carpeta llamada `dockerHostFolder` en la que hab√≠amos compartido archivos entre el host y un contenedor. Dentro, adem√°s, deber√≠an haber tres archivos</markdown>
  <input_code>!ls dockerHostFolder</input_code>
  <output_code>bindFile.txt  fileExtract.txt  text.txt
</output_code>
  <markdown>Vamos a aprovechar el archivo `text.txt` para ver eso. Vamos a ver qu√© hay dentro de `text.txt`</markdown>
  <input_code>!cat dockerHostFolder/text.txt</input_code>
  <markdown>No hay salida, el archivo est√° vac√≠o. Vamos a crear de nuevo un contenedor de ubuntu compartiendo la carpeta `dockerHostFolder`</markdown>
  <input_code>!docker run --name alwaysup -d -v ~/Documentos/web/portafolio/posts/dockerHostFolder:/dockerContainerFolder ubuntu tail -f /dev/null</input_code>
  <output_code>24adbded61f507cdf7f192eb5e246e43ee3ffafc9944b7c57918eb2d547dff19
</output_code>
  <markdown>Vemos que el contenedor est√° corriendo</markdown>
  <input_code>!docker ps</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND               CREATED          STATUS          PORTS     NAMES
24adbded61f5   ubuntu    "tail -f /dev/null"   16 seconds ago   Up 15 seconds             alwaysup
</output_code>
  <markdown>Entramos en el contenedor, vemos que est√° `text.txt` y que est√° vac√≠o

```bash
$ docker exec -it alwaysup bash
root@24adbded61f5:/# ls dockerContainerFolder/
bindFile.txt  fileExtract.txt  text.txt
root@24adbded61f5:/# cat dockerContainerFolder/text.txt 
root@24adbded61f5:/# 
```

Ahora abrimos en el host el archivo `text.txt` con el editor de textos que queramos, escribimos `Hola mundo` y guardamos. Si ahora vemos qu√© hay dentro del archivo en el contenedor veremos el mismo texto

```bash
root@24adbded61f5:/# cat dockerContainerFolder/text.txt 
Hola mundo
```

Ahora editamos el archivo en el contenedor y salimos del contenedor

```bash
root@24adbded61f5:/# echo hola contenedor &gt; dockerContainerFolder/text.txt 
root@24adbded61f5:/# cat dockerContainerFolder/text.txt 
hola contenedor
root@24adbded61f5:/# exit
exit
```

Si miramos el archivo en el host, veremos el texto que escribimos en el contenedor</markdown>
  <input_code>!cat dockerHostFolder/text.txt</input_code>
  <output_code>hola contenedor
</output_code>
  <markdown>Borramos el contenedor</markdown>
  <input_code>!docker rm -f alwaysup</input_code>
  <output_code>alwaysup
</output_code>
  <markdown>### Conectar contenedores por red</markdown>
  <markdown>En caso de que queramos tener varios contenedores corriendo y queramos que se comuniquen, podemos hacer que se comuniquen por red. Docker nos da la posibilidad de hacer eso mediante sus redes virtuales</markdown>
  <markdown>Vamos a ver qu√© redes tiene docker mediante el comando `docker network ls`</markdown>
  <input_code>!docker network ls</input_code>
  <output_code>NETWORK ID     NAME      DRIVER    SCOPE
de6e8b7b737e   bridge    bridge    local
da1f5f6fccc0   host      host      local
d3b0d93993c0   none      null      local
</output_code>
  <markdown>Vemos que por defecto Docker tiene tres redes
* bridge: Est√° por retrocompatibilidad con versiones anteriores, pero no deber√≠amos usarla ya
 * host: Es la red del host
* none: Esta es la opci√≥n que debemos usar si queremos que un contenedor no tenga acceso a internet</markdown>
  <markdown>Podemos crear redes nuevas a las que otros contenedores se puedan conectar, para ello usamos el comando `docker network create &lt;name&gt;`, para que otros contenedores se puedan conectar adem√°s debemos a√±adir la opci√≥n `--attachable`</markdown>
  <input_code>!docker network create --attachable myNetwork</input_code>
  <output_code>2f6f3ddbfa8642e9f6819aa0965c16339e9e910be7bcf56ebb718fcac324cc27
</output_code>
  <markdown>Podemos inspeccionarla mediante el comando `docker network inspect &lt;name&gt;`</markdown>
  <input_code>!docker network inspect myNetwork</input_code>
  <output_code>[
    {
        "Name": "myNetwork",
        "Id": "2f6f3ddbfa8642e9f6819aa0965c16339e9e910be7bcf56ebb718fcac324cc27",
        "Created": "2022-09-14T15:20:08.539830161+02:00",
        "Scope": "local",
        "Driver": "bridge",
        "EnableIPv6": false,
        "IPAM": {
            "Driver": "default",
            "Options": {},
            "Config": [
                {
                    "Subnet": "172.18.0.0/16",
                    "Gateway": "172.18.0.1"
                }
            ]
        },
        "Internal": false,
        "Attachable": true,
        "Ingress": false,
        "ConfigFrom": {
            "Network": ""
        },
        "ConfigOnly": false,
        "Containers": {},
        "Options": {},
        "Labels": {}
    }
]
</output_code>
  <markdown>Ahora tenemos que crear dos contenedores para que se puedan comunicar.</markdown>
  <markdown>Vamos a crear un nuevo contenedor, que llamaremos `container1`, con una carpeta compartida y que en su interior se llamar√° `folder1`</markdown>
  <input_code>!docker run --name container1 -d -v ~/Documentos/web/portafolio/posts/dockerHostFolder:/folder1 ubuntu tail -f /dev/null</input_code>
  <output_code>a5fca8ba1e4ff0a67002f8f1b8cc3cd43185373c2a7e295546f774059ad8dd1a
</output_code>
  <markdown>Ahora creamos otro contenedor, llamado `container2`, con otra carpeta compartida, pero que se llame `folder2`</markdown>
  <input_code>!docker run --name container2 -d -v ~/Documentos/web/portafolio/posts/dockerHostFolder:/folder2 ubuntu tail -f /dev/null</input_code>
  <output_code>6c8dc18315488ef686f7548516c19b3d716728dd8a173cdb889ec0dd082232f9
</output_code>
  <markdown>Vemos los contenedores corriendo y vemos que est√°n los dos</markdown>
  <input_code>!docker ps</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND               CREATED         STATUS         PORTS     NAMES
6c8dc1831548   ubuntu    "tail -f /dev/null"   3 seconds ago   Up 2 seconds             container2
a5fca8ba1e4f   ubuntu    "tail -f /dev/null"   4 seconds ago   Up 3 seconds             container1
</output_code>
  <markdown>Ahora tenemos que conectar los contenedores a la red, para ello usamos el comando `docker network connect &lt;network name&gt; &lt;container name&gt;`</markdown>
  <input_code>!docker network connect myNetwork container1</input_code>
  <input_code>!docker network connect myNetwork container2</input_code>
  <markdown>Para comprobar que se han conectado correctamente podemos inspeccionar la red, pero filtrando por los contenedores conectados

```bash
$ docker network inspect --format '{{.Containers}}' myNetwork 
map
[
    6c8dc18315488ef686f7548516c19b3d716728dd8a173cdb889ec0dd082232f9:
    {
        container2 
        f828d211e894f7a5a992ce41a2a0def8e2424e9737fb4e1485fc09cc2d607b69 
        02:42:ac:12:00:03 
        172.18.0.3/16 
    }
    a5fca8ba1e4ff0a67002f8f1b8cc3cd43185373c2a7e295546f774059ad8dd1a:
    {
        container1 
        cff762e6286ebc169804b2a675bbff904102de796751d367c18d4b490c994c45 
        02:42:ac:12:00:02 
        172.18.0.2/16 
    }
]
```

Como podemos ver el contenedor `container1` tiene la IP `172.18.0.2` y el contenedor `container2` tiene la IP `172.18.0.3`</markdown>
  <markdown>Nos metemos dentro del contenedor `container1` e instalamos `ping`

``` bash
$ docker exec -it container1 bash
root@a5fca8ba1e4f:/# apt update
    ...
root@a5fca8ba1e4f:/# apt install iputils-ping
    ...
root@a5fca8ba1e4f:/#
```</markdown>
  <markdown>Nos metemos dentro del contenedor `container2` e instalamos `ping`

```bash
$ docker exec -it container2 bash
root@a5fca8ba1e4f:/# apt update
    ...
root@a5fca8ba1e4f:/# apt install iputils-ping
    ...
root@a5fca8ba1e4f:/#
```</markdown>
  <markdown>Ahora desde el contenedor `container1` hacemos un ping a la IP `172.18.0.3`, que pertenece al contenedor `container2`

```bash
root@a5fca8ba1e4f:/# ping 172.18.0.3
PING 172.18.0.3 (172.18.0.3) 56(84) bytes of data.
64 bytes from 172.18.0.3: icmp_seq=1 ttl=64 time=0.115 ms
64 bytes from 172.18.0.3: icmp_seq=2 ttl=64 time=0.049 ms
64 bytes from 172.18.0.3: icmp_seq=3 ttl=64 time=0.056 ms
64 bytes from 172.18.0.3: icmp_seq=4 ttl=64 time=0.060 ms
^C
--- 172.18.0.3 ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 3068ms
rtt min/avg/max/mdev = 0.049/0.070/0.115/0.026 ms
```</markdown>
  <markdown>Y desde el contenedor `container2` hacemos un ping a la IP `172.18.0.2`, que pertenece al contenedor `container1`

```bash
root@6c8dc1831548:/# ping 172.18.0.2
PING 172.18.0.2 (172.18.0.2) 56(84) bytes of data.
64 bytes from 172.18.0.2: icmp_seq=1 ttl=64 time=0.076 ms
64 bytes from 172.18.0.2: icmp_seq=2 ttl=64 time=0.045 ms
64 bytes from 172.18.0.2: icmp_seq=3 ttl=64 time=0.049 ms
64 bytes from 172.18.0.2: icmp_seq=4 ttl=64 time=0.051 ms
^C
--- 172.18.0.2 ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 3074ms
rtt min/avg/max/mdev = 0.045/0.055/0.076/0.012 ms
```</markdown>
  <markdown>Pero hay una cosa mejor que nos permite hacer Docker, si no me s√© la IP del contenedor al que me quiero conectar, en vez de escribir su IP puedo escribir su nombre</markdown>
  <markdown>Ahora desde el contenedor `container1` hacemos un ping a la IP de `container2`

```bash
root@a5fca8ba1e4f:/# ping container2
PING container2 (172.18.0.3) 56(84) bytes of data.
64 bytes from container2.myNetwork (172.18.0.3): icmp_seq=1 ttl=64 time=0.048 ms
64 bytes from container2.myNetwork (172.18.0.3): icmp_seq=2 ttl=64 time=0.050 ms
64 bytes from container2.myNetwork (172.18.0.3): icmp_seq=3 ttl=64 time=0.052 ms
64 bytes from container2.myNetwork (172.18.0.3): icmp_seq=4 ttl=64 time=0.053 ms
^C
--- container2 ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 3071ms
rtt min/avg/max/mdev = 0.048/0.050/0.053/0.002 ms
```

Como vemos docker sabe que la IP del contenedor `container2` es la `172.18.0.3`</markdown>
  <markdown>Y desde el contenedor `container2` hacemos un ping a la IP de `container1`

```bash
root@6c8dc1831548:/# ping container1
PING container1 (172.18.0.2) 56(84) bytes of data.
64 bytes from container1.myNetwork (172.18.0.2): icmp_seq=1 ttl=64 time=0.051 ms
64 bytes from container1.myNetwork (172.18.0.2): icmp_seq=2 ttl=64 time=0.058 ms
64 bytes from container1.myNetwork (172.18.0.2): icmp_seq=3 ttl=64 time=0.052 ms
64 bytes from container1.myNetwork (172.18.0.2): icmp_seq=4 ttl=64 time=0.056 ms
^C
--- container1 ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 3057ms
rtt min/avg/max/mdev = 0.051/0.054/0.058/0.003 ms
```

Como vemos docker sabe que la IP del contenedor `container1` es la `172.18.0.2`</markdown>
  <markdown>Salimos de los contenedores y los borramos</markdown>
  <input_code>!docker rm -f container1 container2</input_code>
  <output_code>container1
container2
</output_code>
  <markdown>Borramos tambi√©n la red que hemos creado</markdown>
  <input_code>!docker network rm myNetwork</input_code>
  <output_code>myNetwork
</output_code>
  <markdown>## Uso de GPUs</markdown>
  <markdown>Para poder usar las GPUs del host dentro de los contenedores Docker es necesario realizar los pasos descritos en la p√°gina de instalaci√≥n de [Nvidia container toolkit](https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/install-guide.html)</markdown>
  <markdown>### Configurar el repositorio y la llave GPG</markdown>
  <markdown>Tenemos que configurar el repositorio de `nvidia container toolkit` y la llave GPG, para ello ejecutamos el siguiente comando en la consola

``` bash
distribution=$(. /etc/os-release;echo $ID$VERSION_ID) \
      &amp;&amp; curl -fsSL https://nvidia.github.io/libnvidia-container/gpgkey | sudo gpg --dearmor -o /usr/share/keyrings/nvidia-container-toolkit-keyring.gpg \
      &amp;&amp; curl -s -L https://nvidia.github.io/libnvidia-container/$distribution/libnvidia-container.list | \
            sed 's#deb https://#deb [signed-by=/usr/share/keyrings/nvidia-container-toolkit-keyring.gpg] https://#g' | \
            sudo tee /etc/apt/sources.list.d/nvidia-container-toolkit.list
```</markdown>
  <markdown>### Instalaci√≥n de `nvidia container toolkit`</markdown>
  <markdown>Una vez hemos actualizado el repositorio y la llave actualizamos los repositorios mediante el comando
``` bash
sudo apt update
```

E instalamos `nvidia container toolkit`
``` bash
sudo apt install -y nvidia-docker2
```</markdown>
  <markdown>### Reinicio de docker</markdown>
  <markdown>Una vez hayamos terminado, tenemos que reiniciar el demonio de Docker mediante
``` bash
sudo systemctl restart docker
```</markdown>
  <markdown>### Uso de GPUs</markdown>
  <markdown>Ahora que hemos configurado Docker para poder usar las GPUs del host dentro de los contenedores lo podemos probar mediante la opci√≥n `--gpus all`. Si se tiene m√°s de una GPU y solo se quiere usar 1 habr√≠a que especificarlo, pero de momento aqu√≠ solo explicamos c√≥mo usar todas</markdown>
  <markdown>Creamos un contenedor que no se va a ejecutar en segundo plano, sino que lo que va a hacer es ejecutar el comando `nvidia-smi` para que podamos ver si tiene acceso a las GPUs</markdown>
  <input_code>!docker run --name container_gpus --gpus all ubuntu nvidia-smi</input_code>
  <output_code>Unable to find image 'ubuntu:latest' locally
latest: Pulling from library/ubuntu

[1B6a12be2b: Pull complete .54MB/29.54MBB[1A[2K[1A[2K[1A[2K[1A[2K[1A[2K[1A[2K[1A[2K[1A[2K[1A[2K[1A[2K[1A[2K[1A[2K[1A[2K[1A[2K[1A[2K[1A[2K[1A[2K[1A[2K[1A[2K[1A[2K[1A[2KDigest: sha256:aabed3296a3d45cede1dc866a24476c4d7e093aa806263c27ddaadbdce3c1054
Status: Downloaded newer image for ubuntu:latest
Mon Sep  4 07:10:36 2023       
+-----------------------------------------------------------------------------+
| NVIDIA-SMI 510.39.01    Driver Version: 510.39.01    CUDA Version: 11.6     |
|-------------------------------+----------------------+----------------------+
| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |
| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |
|                               |                      |               MIG M. |
|===============================+======================+======================|
|   0  Quadro T1000        On   | 00000000:01:00.0 Off |                  N/A |
| N/A   44C    P0    15W /  N/A |      9MiB /  4096MiB |      0%      Default |
|                               |                      |                  N/A |
+-------------------------------+----------------------+----------------------+
                                                                               
+-----------------------------------------------------------------------------+
| Processes:                                                                  |
|  GPU   GI   CI        PID   Type   Process name                  GPU Memory |
|        ID   ID                                                   Usage      |
|=============================================================================|
|    0   N/A  N/A      2545      G                                       4MiB |
|    0   N/A  N/A      3421      G                                       4MiB |
+-----------------------------------------------------------------------------+
</output_code>
  <markdown>Borramos el contenedor</markdown>
  <input_code>!doker rm container_gpus</input_code>
  <markdown>## Docker compose</markdown>
  <markdown>### Docker compose vs docker-compose</markdown>
  <markdown>`docker-compose` fue una herramienta que se cre√≥ para ayudar al mantenimiento de im√°genes y contenedores y hab√≠a que instalarla a parte de docker. Sin embargo docker lo incorpor√≥ en sus √∫ltimas versiones y ya no es necesario instalarla, sin embargo, para usarla, en vez de usar el comando `docker-compose` hay que usar el comando `docker compose`. En muchos sitios encontrar√°s informaci√≥n con `docker-compose`, pero al instalar docker ya te vendr√° instalado `docker compose` por lo que todo lo que se pod√≠a hacer con `docker-compose` es compatible con `docker compose`</markdown>
  <markdown>### Docker compose</markdown>
  <markdown>Docker Compose es una herramienta de Docker que hace todo lo que hemos visto hasta ahora, pero ahorr√°ndonos tiempo y esfuerzo. Editando un archivo `.yml` podemos decirle a Docker Compose que cree todos los contenedores que queramos.

Para usarlo una vez no habr√° mucha diferencia de escribir todos los comandos que vimos antes o escribir el archivo `.yml` pero cuando quieras volver a tener la misma configuraci√≥n de contenedores trabajando, solo con llamar al archivo `.yml` volver√° a crear toda la configuraci√≥n</markdown>
  <markdown>Vamos a crear una carpeta donde guardaremos los archivos de Docker Compose</markdown>
  <input_code>!mkdir dockerComposeFiles</input_code>
  <markdown>Creamos el archivo .yml dentro</markdown>
  <input_code>!touch dockerComposeFiles/docker-compose.yml</input_code>
  <markdown>Un archivo Docker Compose tiene que empezar por la versi√≥n

```json
version: "&lt;v.v&gt;"
```

En el momento de escribir esto, la √∫ltima versi√≥n es la `3.8` as√≠ que escribimos esa</markdown>
  <markdown>*docker-compose.yml*:

```json
    version: "3.8"
```</markdown>
  <markdown>A continuaci√≥n se indican los servicios, que son los contenedores. En cada servicio hay que especificar la imagen y, adem√°s, se pueden a√±adir otros par√°metros como puertos, variables de entorno, etc.

```json
services:
    container1:
        image: ubuntu
    
    container2:
        image: ubuntu
```</markdown>
  <markdown>El `docker-compose.yml` quedar√≠a as√≠:

```json
    version: "3.8"

    services:
    container1:
        image: ubuntu
    
    container2:
        image: ubuntu
```</markdown>
  <markdown>Una vez que hemos creado el archivo, en su path, podemos ejecutar todo mediante el comando `docker compose up`, pero adem√°s a√±adiendo la opci√≥n `-d` haremos que corra en segundo plano</markdown>
  <input_code>!cd dockerComposeFiles &amp;&amp; docker compose up -d</input_code>
  <output_code>[1A[1B[0G[?25l[+] Running 1/0
[34m ‚†ø Network dockercomposefiles_default         Created                      0.1s
[0m[37m ‚†ã Container dockercomposefiles-container2-1  Creating                     0.0s
[0m[37m ‚†ã Container dockercomposefiles-container1-1  Creating                     0.0s
[0m[?25h[1A[1A[1A[1A[0G[?25l[+] Running 1/3
[34m ‚†ø Network dockercomposefiles_default         Created                      0.1s
[0m[37m ‚†ô Container dockercomposefiles-container2-1  Creating                     0.1s
[0m[37m ‚†ô Container dockercomposefiles-container1-1  Creating                     0.1s
[0m[?25h[1A[1A[1A[1A[0G[?25l[+] Running 1/3
[34m ‚†ø Network dockercomposefiles_default         Created                      0.1s
[0m[37m ‚†ø Container dockercomposefiles-container2-1  Starting                     0.2s
[0m[37m ‚†ø Container dockercomposefiles-container1-1  Starting                     0.2s
[0m[?25h[1A[1A[1A[1A[0G[?25l[+] Running 1/3
[34m ‚†ø Network dockercomposefiles_default         Created                      0.1s
[0m[37m ‚†ø Container dockercomposefiles-container2-1  Starting                     0.3s
[0m[37m ‚†ø Container dockercomposefiles-container1-1  Starting                     0.3s
[0m[?25h[1A[1A[1A[1A[0G[?25l[+] Running 1/3
[34m ‚†ø Network dockercomposefiles_default         Created                      0.1s
[0m[37m ‚†ø Container dockercomposefiles-container2-1  Starting                     0.4s
[0m[37m ‚†ø Container dockercomposefiles-container1-1  Starting                     0.4s
[0m[?25h[1A[1A[1A[1A[0G[?25l[+] Running 1/3
[34m ‚†ø Network dockercomposefiles_default         Created                      0.1s
[0m[37m ‚†ø Container dockercomposefiles-container2-1  Starting                     0.5s
[0m[37m ‚†ø Container dockercomposefiles-container1-1  Starting                     0.5s
[0m[?25h[1A[1A[1A[1A[0G[?25l[+] Running 2/3
[34m ‚†ø Network dockercomposefiles_default         Created                      0.1s
[0m[34m ‚†ø Container dockercomposefiles-container2-1  Started                      0.5s
[0m[37m ‚†ø Container dockercomposefiles-container1-1  Starting                     0.6s
[0m[?25h[1A[1A[1A[1A[0G[?25l[34m[+] Running 3/3[0m
[34m ‚†ø Network dockercomposefiles_default         Created                      0.1s
[0m[34m ‚†ø Container dockercomposefiles-container2-1  Started                      0.5s
[0m[34m ‚†ø Container dockercomposefiles-container1-1  Started                      0.7s
[0m[?25h</output_code>
  <markdown>Si nos fijamos, ha creado dos contenedores `dockercomposefiles-container1-1` y `dockercomposefiles-container2-1` y la red que los une `dockercomposefiles_default`</markdown>
  <markdown>Vamos a borrar los dos contenedores</markdown>
  <input_code>!docker rm -f dockercomposefiles-container1-1 dockercomposefiles-container2-1</input_code>
  <output_code>dockercomposefiles-container1-1
dockercomposefiles-container2-1
</output_code>
  <markdown>Y borramos la red que ha creado</markdown>
  <input_code>!docker network rm dockercomposefiles_default</input_code>
  <output_code>dockercomposefiles_default
</output_code>
  <markdown>Vamos a intentar hacer lo que hicimos antes con lo que sabemos hasta ahora. Creamos una nueva imagen que venga con `ping` instalada

*Dockerfile*:
```docker
    FROM ubuntu:20.04
    RUN apt update
    RUN apt install iputils-ping -y
```

Y la compilamos</markdown>
  <input_code>!docker build -t ubuntu:ping ./dockerImages</input_code>
  <output_code>Sending build context to Docker daemon  2.048kB
Step 1/3 : FROM ubuntu:20.04
 ---&gt; a0ce5a295b63
Step 2/3 : RUN apt update
 ---&gt; Running in 3bd5278d39b4
[91m
WARNING: apt does not have a stable CLI interface. Use with caution in scripts.

[0mGet:1 http://security.ubuntu.com/ubuntu focal-security InRelease [114 kB]
Get:2 http://archive.ubuntu.com/ubuntu focal InRelease [265 kB]
Get:3 http://security.ubuntu.com/ubuntu focal-security/universe amd64 Packages [898 kB]
Get:4 http://archive.ubuntu.com/ubuntu focal-updates InRelease [114 kB]
Get:5 http://archive.ubuntu.com/ubuntu focal-backports InRelease [108 kB]
Get:6 http://archive.ubuntu.com/ubuntu focal/universe amd64 Packages [11.3 MB]
Get:7 http://security.ubuntu.com/ubuntu focal-security/main amd64 Packages [2133 kB]
Get:8 http://security.ubuntu.com/ubuntu focal-security/multiverse amd64 Packages [27.5 kB]
Get:9 http://security.ubuntu.com/ubuntu focal-security/restricted amd64 Packages [1501 kB]
Get:10 http://archive.ubuntu.com/ubuntu focal/main amd64 Packages [1275 kB]
Get:11 http://archive.ubuntu.com/ubuntu focal/restricted amd64 Packages [33.4 kB]
Get:12 http://archive.ubuntu.com/ubuntu focal/multiverse amd64 Packages [177 kB]
Get:13 http://archive.ubuntu.com/ubuntu focal-updates/main amd64 Packages [2594 kB]
Get:14 http://archive.ubuntu.com/ubuntu focal-updates/restricted amd64 Packages [1613 kB]
Get:15 http://archive.ubuntu.com/ubuntu focal-updates/multiverse amd64 Packages [30.2 kB]
Get:16 http://archive.ubuntu.com/ubuntu focal-updates/universe amd64 Packages [1200 kB]
Get:17 http://archive.ubuntu.com/ubuntu focal-backports/universe amd64 Packages [27.4 kB]
...
Successfully built c3d32aa9de02
Successfully tagged ubuntu:ping

Use 'docker scan' to run Snyk tests against images to find vulnerabilities and learn how to fix them
</output_code>
  <markdown>Comprobamos que se ha creado</markdown>
  <input_code>!docker image ls</input_code>
  <output_code>REPOSITORY        TAG       IMAGE ID       CREATED              SIZE
ubuntu            ping      c3d32aa9de02   About a minute ago   112MB
maximofn/ubuntu   test      a78cf3ea16d8   25 hours ago         77.8MB
nginx             latest    2d389e545974   33 hours ago         142MB
ubuntu            latest    2dc39ba059dc   12 days ago          77.8MB
ubuntu            20.04     a0ce5a295b63   12 days ago          72.8MB
hello-world       latest    feb5d9fea6a5   11 months ago        13.3kB
</output_code>
  <markdown>Le cambiamos el tag</markdown>
  <input_code>!docker tag ubuntu:ping maximofn/ubuntu:ping</input_code>
  <input_code>!docker image ls</input_code>
  <output_code>REPOSITORY        TAG       IMAGE ID       CREATED              SIZE
ubuntu            ping      c3d32aa9de02   About a minute ago   112MB
maximofn/ubuntu   ping      c3d32aa9de02   About a minute ago   112MB
maximofn/ubuntu   test      c3d32aa9de02   About a minute ago   112MB
nginx             latest    2d389e545974   33 hours ago         142MB
ubuntu            latest    2dc39ba059dc   12 days ago          77.8MB
ubuntu            20.04     a0ce5a295b63   12 days ago          72.8MB
hello-world       latest    feb5d9fea6a5   11 months ago        13.3kB
</output_code>
  <markdown>Editamos el archivo Docker Compose para que coja las im√°genes que acabamos de crear

*docker-compose.yml*:
```json
    version: "3.8"

    services:
      container1:
        image: maximofn/ubuntu:ping

    container2:
        image: maximofn/ubuntu:ping
```

Y adem√°s le decimos que ejecute una no operaci√≥n

El `docker-compose.yml` quedar√≠a as√≠:
```json
    version: "3.8"

    services:
      container1:
        image: ubuntu
        command: tail -f /dev/null

    container2:
        image: ubuntu
        command: tail -f /dev/null
```

Lo levantamos</markdown>
  <input_code>!cd dockerComposeFiles &amp;&amp; docker compose up -d</input_code>
  <output_code>[1A[1B[0G[?25l[+] Running 0/0
[37m ‚†ã Container dockercomposefiles-container1-1  Recreate                     0.1s
[0m[37m ‚†ã Container dockercomposefiles-container2-1  Recreate                     0.1s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 1/2
[34m ‚†ø Container dockercomposefiles-container1-1  Recreated                    0.1s
[0m[37m ‚†ô Container dockercomposefiles-container2-1  Recreate                     0.2s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 1/2
[34m ‚†ø Container dockercomposefiles-container1-1  Recreated                    0.1s
[0m[37m ‚†π Container dockercomposefiles-container2-1  Recreate                     0.3s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 1/2
[34m ‚†ø Container dockercomposefiles-container1-1  Recreated                    0.1s
[0m[37m ‚†∏ Container dockercomposefiles-container2-1  Recreate                     0.4s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 1/2
[34m ‚†ø Container dockercomposefiles-container1-1  Recreated                    0.1s
[0m[37m ‚†º Container dockercomposefiles-container2-1  Recreate                     0.5s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 1/2
[34m ‚†ø Container dockercomposefiles-container1-1  Recreated                    0.1s
[0m[37m ‚†¥ Container dockercomposefiles-container2-1  Recreate                     0.6s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 1/2
[34m ‚†ø Container dockercomposefiles-container1-1  Recreated                    0.1s
[0m[37m ‚†¶ Container dockercomposefiles-container2-1  Recreate                     0.7s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 1/2
[34m ‚†ø Container dockercomposefiles-container1-1  Recreated                    0.1s
[0m[37m ‚†ß Container dockercomposefiles-container2-1  Recreate                     0.8s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 1/2
[34m ‚†ø Container dockercomposefiles-container1-1  Recreated                    0.1s
[0m[37m ‚†á Container dockercomposefiles-container2-1  Recreate                     0.9s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 1/2
[34m ‚†ø Container dockercomposefiles-container1-1  Recreated                    0.1s
[0m[37m ‚†è Container dockercomposefiles-container2-1  Recreate                     1.0s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 1/2
[34m ‚†ø Container dockercomposefiles-container1-1  Recreated                    0.1s
[0m[37m ‚†ã Container dockercomposefiles-container2-1  Recreate                     1.1s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 1/2
[34m ‚†ø Container dockercomposefiles-container1-1  Recreated                    0.1s
[0m[37m ‚†ô Container dockercomposefiles-container2-1  Recreate                     1.2s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 1/2
[34m ‚†ø Container dockercomposefiles-container1-1  Recreated                    0.1s
[0m[37m ‚†π Container dockercomposefiles-container2-1  Recreate                     1.3s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 1/2
[34m ‚†ø Container dockercomposefiles-container1-1  Recreated                    0.1s
[0m[37m ‚†∏ Container dockercomposefiles-container2-1  Recreate                     1.4s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 1/2
[34m ‚†ø Container dockercomposefiles-container1-1  Recreated                    0.1s
...
[0m[?25h[1A[1A[1A[0G[?25l[34m[+] Running 2/2[0m
[34m ‚†ø Container dockercomposefiles-container1-1  Started                     10.8s
[0m[34m ‚†ø Container dockercomposefiles-container2-1  Started                     10.9s
[0m[?25h[1A[1A[1A[0G[?25l[34m[+] Running 2/2[0m
[34m ‚†ø Container dockercomposefiles-container1-1  Started                     10.8s
[0m[34m ‚†ø Container dockercomposefiles-container2-1  Started                     10.9s
[0m[?25h</output_code>
  <markdown>Vemos los contenedores que est√°n corriendo</markdown>
  <input_code>!docker ps</input_code>
  <output_code>CONTAINER ID   IMAGE                  COMMAND               CREATED          STATUS          PORTS     NAMES
935939e5a75d   maximofn/ubuntu:ping   "tail -f /dev/null"   15 seconds ago   Up 13 seconds             dockercomposefiles-container2-1
f9138d7064dd   maximofn/ubuntu:ping   "tail -f /dev/null"   25 seconds ago   Up 13 seconds             dockercomposefiles-container1-1
</output_code>
  <markdown>Est√°n los dos contenedores corriendo, ahora nos metemos en uno e intentamos hacer `ping` al otro

```bash
$ docker exec -it dockercomposefiles-container1-1 bash
root@f9138d7064dd:/# ping dockercomposefiles-container2-1
PING dockercomposefiles-container2-1 (172.21.0.3) 56(84) bytes of data.
64 bytes from dockercomposefiles-container2-1.dockercomposefiles_default (172.21.0.3): icmp_seq=1 ttl=64 time=0.110 ms
64 bytes from dockercomposefiles-container2-1.dockercomposefiles_default (172.21.0.3): icmp_seq=2 ttl=64 time=0.049 ms
64 bytes from dockercomposefiles-container2-1.dockercomposefiles_default (172.21.0.3): icmp_seq=3 ttl=64 time=0.049 ms
64 bytes from dockercomposefiles-container2-1.dockercomposefiles_default (172.21.0.3): icmp_seq=4 ttl=64 time=0.075 ms
^C
--- dockercomposefiles-container2-1 ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 3068ms
rtt min/avg/max/mdev = 0.049/0.070/0.110/0.025 ms
```

Como vemos, podemos hacer `ping`, hemos creado bien la imagen con `ping` instalado. Adem√°s, en el docker-compose hemos hecho que se ejecute una no operaci√≥n para que los contenedores est√©n corriendo</markdown>
  <markdown>Borramos los dos contenedores y la red que hemos creado</markdown>
  <input_code>!docker rm -f dockercomposefiles-container1-1 dockercomposefiles-container2-1</input_code>
  <output_code>dockercomposefiles-container1-1
dockercomposefiles-container2-1
</output_code>
  <input_code>!docker network rm dockercomposefiles_default</input_code>
  <output_code>dockercomposefiles_default
</output_code>
  <markdown>### C√≥mo nombra docker compose los contenedores</markdown>
  <markdown>Si nos fijamos, los contenedores que crea Docker se llaman `dockercomposefiles-container1-1` y `dockercomposefiles-container2-1`. Esto es porque la carpeta en la que est√° el archivo de Docker Compose est√° en una carpeta llamada `dockerComposeFiles`, por eso la primera parte del nombre de los contenedores es `dockercomposefiles`, a continuaci√≥n aparece el nombre del servicio que le hemos dado en el archivo Docker Compose (`container1` y `container2`) y por √∫ltimo un n√∫mero para poder crear m√°s si es necesario

Similar ocurre con el nombre de la red que ha creado `dockercomposefiles_default`</markdown>
  <markdown>### Logs en docker compose</markdown>
  <markdown>Vamos ahora a cambiar el archivo Docker Compose, en las l√≠neas en las que ten√≠amos `command: tail -f /dev/null`, vamos a poner `command: ping 0.0.0.0`

Y adem√°s le decimos que ejecute una no operaci√≥n

El `docker-compose.yml` quedar√≠a as√≠:
```json
    version: "3.8"

    services:
      container1:
        image: ubuntu
        command: ping 0.0.0.0

    container2:
        image: ubuntu
        command: ping 0.0.0.0
```

Esto lo hacemos para que cada contenedor est√© escupiendo el ping constantemente, as√≠ simulamos algunos logs

Si ejecutamos de nuevo el docker compose</markdown>
  <input_code>!cd dockerComposeFiles &amp;&amp; docker compose up -d</input_code>
  <output_code>[1A[1B[0G[?25l[+] Running 0/0
[37m ‚†ã Container dockercomposefiles-container1-1  Recreate                     0.1s
[0m[37m ‚†ã Container dockercomposefiles-container2-1  Recreate                     0.1s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 0/2
[37m ‚†ô Container dockercomposefiles-container1-1  Recreate                     0.2s
[0m[37m ‚†ô Container dockercomposefiles-container2-1  Recreate                     0.2s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 0/2
[37m ‚†π Container dockercomposefiles-container1-1  Recreate                     0.3s
[0m[37m ‚†π Container dockercomposefiles-container2-1  Recreate                     0.3s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 0/2
[37m ‚†∏ Container dockercomposefiles-container1-1  Recreate                     0.4s
[0m[37m ‚†∏ Container dockercomposefiles-container2-1  Recreate                     0.4s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 0/2
[37m ‚†º Container dockercomposefiles-container1-1  Recreate                     0.5s
[0m[37m ‚†º Container dockercomposefiles-container2-1  Recreate                     0.5s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 0/2
[37m ‚†¥ Container dockercomposefiles-container1-1  Recreate                     0.6s
[0m[37m ‚†¥ Container dockercomposefiles-container2-1  Recreate                     0.6s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 0/2
[37m ‚†¶ Container dockercomposefiles-container1-1  Recreate                     0.7s
[0m[37m ‚†¶ Container dockercomposefiles-container2-1  Recreate                     0.7s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 0/2
[37m ‚†ß Container dockercomposefiles-container1-1  Recreate                     0.8s
[0m[37m ‚†ß Container dockercomposefiles-container2-1  Recreate                     0.8s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 0/2
...
[37m ‚†ø Container dockercomposefiles-container1-1  Starting                    11.0s
[0m[34m ‚†ø Container dockercomposefiles-container2-1  Started                     11.0s
[0m[?25h[1A[1A[1A[0G[?25l[34m[+] Running 2/2[0m
[34m ‚†ø Container dockercomposefiles-container1-1  Started                     11.1s
[0m[34m ‚†ø Container dockercomposefiles-container2-1  Started                     11.0s
[0m[?25h</output_code>
  <markdown>Ahora podemos ver los logs de los dos contenedores mediante el comando `docker compose logs`</markdown>
  <input_code>!cd dockerComposeFiles &amp;&amp; docker compose logs</input_code>
  <output_code>[36mdockercomposefiles-container2-1  | [0mPING 0.0.0.0 (127.0.0.1) 56(84) bytes of data.
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.042 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.025 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=3 ttl=64 time=0.022 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=4 ttl=64 time=0.030 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=5 ttl=64 time=0.021 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=6 ttl=64 time=0.021 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=7 ttl=64 time=0.030 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=8 ttl=64 time=0.028 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=9 ttl=64 time=0.028 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=10 ttl=64 time=0.026 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=11 ttl=64 time=0.028 ms
[33mdockercomposefiles-container1-1  | [0mPING 0.0.0.0 (127.0.0.1) 56(84) bytes of data.
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=12 ttl=64 time=0.027 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=13 ttl=64 time=0.039 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=14 ttl=64 time=0.035 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=15 ttl=64 time=0.034 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=16 ttl=64 time=0.036 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=17 ttl=64 time=0.034 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=18 ttl=64 time=0.036 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=19 ttl=64 time=0.032 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=20 ttl=64 time=0.032 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=21 ttl=64 time=0.033 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=22 ttl=64 time=0.034 ms
[33mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.037 ms
...
[33mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=214 ttl=64 time=0.015 ms
[33mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=215 ttl=64 time=0.021 ms
[33mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=216 ttl=64 time=0.020 ms
[33mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=217 ttl=64 time=0.049 ms
</output_code>
  <markdown>Como vemos, podemos ver los logs de los dos contenedores, pero en el caso de querer ver solo los de uno, podemos especificar el **nombre del servicio**</markdown>
  <input_code>!cd dockerComposeFiles &amp;&amp; docker compose logs container1</input_code>
  <output_code>[36mdockercomposefiles-container1-1  | [0mPING 0.0.0.0 (127.0.0.1) 56(84) bytes of data.
[36mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.037 ms
[36mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.025 ms
[36mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=3 ttl=64 time=0.023 ms
[36mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=4 ttl=64 time=0.031 ms
[36mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=5 ttl=64 time=0.034 ms
[36mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=6 ttl=64 time=0.033 ms
[36mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=7 ttl=64 time=0.034 ms
[36mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=8 ttl=64 time=0.022 ms
[36mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=9 ttl=64 time=0.032 ms
[36mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=10 ttl=64 time=0.029 ms
[36mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=11 ttl=64 time=0.031 ms
[36mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=12 ttl=64 time=0.024 ms
[36mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=13 ttl=64 time=0.029 ms
[36mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=14 ttl=64 time=0.032 ms
[36mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=15 ttl=64 time=0.033 ms
[36mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=16 ttl=64 time=0.034 ms
[36mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=17 ttl=64 time=0.028 ms
[36mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=18 ttl=64 time=0.034 ms
...
[36mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=332 ttl=64 time=0.027 ms
[36mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=333 ttl=64 time=0.030 ms
[36mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=334 ttl=64 time=0.033 ms
[36mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=335 ttl=64 time=0.036 ms
</output_code>
  <input_code>!cd dockerComposeFiles &amp;&amp; docker compose logs container2</input_code>
  <output_code>[36mdockercomposefiles-container2-1  | [0mPING 0.0.0.0 (127.0.0.1) 56(84) bytes of data.
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.042 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.025 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=3 ttl=64 time=0.022 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=4 ttl=64 time=0.030 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=5 ttl=64 time=0.021 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=6 ttl=64 time=0.021 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=7 ttl=64 time=0.030 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=8 ttl=64 time=0.028 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=9 ttl=64 time=0.028 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=10 ttl=64 time=0.026 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=11 ttl=64 time=0.028 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=12 ttl=64 time=0.027 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=13 ttl=64 time=0.039 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=14 ttl=64 time=0.035 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=15 ttl=64 time=0.034 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=16 ttl=64 time=0.036 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=17 ttl=64 time=0.034 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=18 ttl=64 time=0.036 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=19 ttl=64 time=0.032 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=20 ttl=64 time=0.032 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=21 ttl=64 time=0.033 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=22 ttl=64 time=0.034 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=23 ttl=64 time=0.035 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=24 ttl=64 time=0.037 ms
...
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=340 ttl=64 time=0.034 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=341 ttl=64 time=0.033 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=342 ttl=64 time=0.034 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=343 ttl=64 time=0.036 ms
</output_code>
  <markdown>Si queremos ver los logs continuamente, podemos a√±adir la opci√≥n `-f`: `docker compose logs -f &lt;service name&gt;`</markdown>
  <markdown>Si he hecho un docker compose con m√°s de dos servicios, cuando se quiera ver los logs de varios servicios solo hay que a√±adir m√°s nombres al comando, `docker compose logs &lt;name service 1&gt; &lt;name service 2&gt; ...`</markdown>
  <markdown>### Exec servicios</markdown>
  <markdown>Como hemos visto, mediante el comando `exec` podemos entrar a un contenedor indicando el nombre del contenedor, el comando que se quiere ejecutar y la opci√≥n `-it`. Con Docker Compose esto es m√°s sencillo, ya que solamente es necesario el nombre del servicio y el comando, pero no es necesaria la opci√≥n `-it` ya que Docker Compose lo da por supuesto

```bash
$ docker compose exec container1 bash
root@a7cf282fe66c:/#
```</markdown>
  <markdown>### Deteniendo docker compose</markdown>
  <markdown>Cuando hemos terminado de trabajar, con un solo comando (`stop`), Docker Compose para todo, no hace falta ir parando uno a uno cada contenedor</markdown>
  <input_code>!cd dockerComposeFiles &amp;&amp; docker compose stop</input_code>
  <output_code>[1A[1B[0G[?25l[+] Running 0/0
[37m ‚†ã Container dockercomposefiles-container2-1  Stopping                     0.1s
[0m[37m ‚†ã Container dockercomposefiles-container1-1  Stopping                     0.1s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 0/2
[37m ‚†ô Container dockercomposefiles-container2-1  Stopping                     0.2s
[0m[37m ‚†ô Container dockercomposefiles-container1-1  Stopping                     0.2s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 0/2
[37m ‚†π Container dockercomposefiles-container2-1  Stopping                     0.3s
[0m[37m ‚†π Container dockercomposefiles-container1-1  Stopping                     0.3s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 0/2
[37m ‚†∏ Container dockercomposefiles-container2-1  Stopping                     0.4s
[0m[37m ‚†∏ Container dockercomposefiles-container1-1  Stopping                     0.4s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 0/2
[37m ‚†º Container dockercomposefiles-container2-1  Stopping                     0.5s
[0m[37m ‚†º Container dockercomposefiles-container1-1  Stopping                     0.5s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 0/2
[37m ‚†¥ Container dockercomposefiles-container2-1  Stopping                     0.6s
[0m[37m ‚†¥ Container dockercomposefiles-container1-1  Stopping                     0.6s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 0/2
[37m ‚†¶ Container dockercomposefiles-container2-1  Stopping                     0.7s
[0m[37m ‚†¶ Container dockercomposefiles-container1-1  Stopping                     0.7s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 0/2
[37m ‚†ß Container dockercomposefiles-container2-1  Stopping                     0.8s
[0m[37m ‚†ß Container dockercomposefiles-container1-1  Stopping                     0.8s
...
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 1/2
[34m ‚†ø Container dockercomposefiles-container2-1  Stopped                     10.4s
[0m[37m ‚†∏ Container dockercomposefiles-container1-1  Stopping                    10.4s
[0m[?25h[1A[1A[1A[0G[?25l[34m[+] Running 2/2[0m
[34m ‚†ø Container dockercomposefiles-container2-1  Stopped                     10.4s
[0m[34m ‚†ø Container dockercomposefiles-container1-1  Stopped                     10.4s
[0m[?25h</output_code>
  <markdown>Como se puede ver, docker compose ha parado los dos contenedores, pero no los ha borrado, ni ha borrado la red</markdown>
  <input_code>!docker ps</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
</output_code>
  <input_code>!docker ps -a</input_code>
  <output_code>CONTAINER ID   IMAGE                  COMMAND          CREATED          STATUS                        PORTS     NAMES
1e6c1dd9adb2   maximofn/ubuntu:ping   "ping 0.0.0.0"   16 minutes ago   Exited (137) 25 seconds ago             dockercomposefiles-container2-1
a7cf282fe66c   maximofn/ubuntu:ping   "ping 0.0.0.0"   16 minutes ago   Exited (137) 25 seconds ago             dockercomposefiles-container1-1
</output_code>
  <input_code>!docker network ls</input_code>
  <output_code>NETWORK ID     NAME                         DRIVER    SCOPE
13cc632147f3   bridge                       bridge    local
d4a2f718cd83   dockercomposefiles_default   bridge    local
da1f5f6fccc0   host                         host      local
d3b0d93993c0   none                         null      local
</output_code>
  <markdown>### Docker compose como herramienta de desarrollo</markdown>
  <markdown>Al igual que vimos antes, para poder desarrollar, lo ideal ser√≠a compartir la carpeta que tiene el c√≥digo con el servicio. Esto con docker compose se hace a√±adiendo la etiqueta `volumes` al archivo docker compose. Primero tenemos que a√±adirle la ruta de la carpeta donde est√° el c√≥digo en el host y luego la ruta en el contenedor.

*docker-compose.yml*:
```json
    version: "3.8"

    services:
      container1:
        image: ubuntu
        command: ping 0.0.0.0
        volumes:
            - ../dockerHostFolder/:/dockerContainerFolder

    container2:
        image: ubuntu
        command: ping 0.0.0.0
```

Como se puede ver, la ruta de la carpeta del host la he puesto relativa

Si levantamos el Docker Compose</markdown>
  <input_code>!cd dockerComposeFiles &amp;&amp; docker compose up -d</input_code>
  <output_code>[1A[1B[0G[?25l[+] Running 1/0
[37m ‚†ã Container dockercomposefiles-container1-1  Recreate                     0.1s
[0m[34m ‚†ø Container dockercomposefiles-container2-1  Created                      0.0s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 0/2
[37m ‚†ø Container dockercomposefiles-container1-1  Starting                     0.2s
[0m[37m ‚†ø Container dockercomposefiles-container2-1  Starting                     0.2s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 0/2
[37m ‚†ø Container dockercomposefiles-container1-1  Starting                     0.3s
[0m[37m ‚†ø Container dockercomposefiles-container2-1  Starting                     0.3s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 0/2
[37m ‚†ø Container dockercomposefiles-container1-1  Starting                     0.4s
[0m[37m ‚†ø Container dockercomposefiles-container2-1  Starting                     0.4s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 1/2
[34m ‚†ø Container dockercomposefiles-container1-1  Started                      0.5s
[0m[37m ‚†ø Container dockercomposefiles-container2-1  Starting                     0.5s
[0m[?25h[1A[1A[1A[0G[?25l[34m[+] Running 2/2[0m
[34m ‚†ø Container dockercomposefiles-container1-1  Started                      0.5s
[0m[34m ‚†ø Container dockercomposefiles-container2-1  Started                      0.6s
[0m[?25h</output_code>
  <markdown>Si entramos en el contenedor, podemos ver qu√© hay dentro del archivo text.txt

```bash
$ docker compose exec container1 bash
root@c8aae9d619d3:/# ls dockerContainerFolder/
bindFile.txt  fileExtract.txt  text.txt
root@c8aae9d619d3:/# cat dockerContainerFolder/text.txt 
hola contenedor
```

Si ahora lo abrimos en el host, escribimos `hola host` y volvemos a ver en el contenedor

```bash
root@c8aae9d619d3:/# cat dockerContainerFolder/text.txt 
hola host
```

Y ahora al rev√©s, si lo modificamos en el contenedor

```bash
root@c8aae9d619d3:/# echo hola compose &gt; dockerContainerFolder/text.txt
root@c8aae9d619d3:/# exit
exit
```

Si lo vemos desde el host, debemos obtener `hola compose`</markdown>
  <input_code>!cat dockerHostFolder/text.txt</input_code>
  <output_code>hola compose
</output_code>
  <markdown>### Exposici√≥n de puertos en docker compose</markdown>
  <markdown>Tambi√©n podemos configurar los puertos en el archivo de Docker Compose, mediante la etiqueta `ports`, indicando el puerto del host y a continuaci√≥n la IP del servicio

```json
ports:
    - &lt;host port&gt;:&lt;service port&gt;
```</markdown>
  <markdown>### Docker compose en equipo - docker override</markdown>
  <markdown>Si somos un grupo de personas desarrollando sobre Docker con Docker Compose, es probable que muchas personas anden cambiando el archivo Docker Compose, lo cual puede hacer que no se sincronicen bien y haya conflictos.

Para solucionar esto Docker ofrece una herramienta llamada Docker Override. De esta manera puede haber un archivo Docker Compose base y que cada uno lo modifique mediante Docker Override.

Para hacer esto, ahora tenemos que crear un archivo llamado `docker-compose.override.yml` que ser√° el que podremos editar</markdown>
  <input_code>!touch dockerComposeFiles/docker-compose.override.yml</input_code>
  <markdown>Si ahora intentamos levantar el Docker Compose vamos a recibir un error</markdown>
  <input_code>!cd dockerComposeFiles &amp;&amp; docker compose up -d</input_code>
  <output_code>Top-level object must be a mapping
</output_code>
  <markdown>Y esto es porque Docker Compose ha detectado que hay un archivo llamado `docker-compose.override.yml` y que est√° vac√≠o, por lo que vamos a editarlo. El archivo `docker-compose.override.yml` lo que hace es editar el archivo `docker-compose.yml`, por lo que si por ejemplo queremos hacer un cambio en el servicio `container2` para a√±adirle un volumen escribir√≠amos as√≠ el archivo `docker-compose.override.yml`

*docker-compose.override.yml*:
```json
    version: "3.8"

    services:
    container2:
        volumes:
        - ../dockerHostFolder/:/dockerOverrideFolder
```

Date cuenta de que la carpeta compartida en el servicio la he llamado `dockerOverrideFolder`, por lo que vamos a levantar el docker compose y ver si vemos esa carpeta en el contenedor `container2`</markdown>
  <input_code>!cd dockerComposeFiles &amp;&amp; docker compose up -d</input_code>
  <output_code>[1A[1B[0G[?25l[+] Running 1/0
[37m ‚†ã Container dockercomposefiles-container2-1  Recreate                     0.1s
[0m[34m ‚†ø Container dockercomposefiles-container1-1  Running                      0.0s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 1/2
[37m ‚†ô Container dockercomposefiles-container2-1  Recreate                     0.2s
[0m[34m ‚†ø Container dockercomposefiles-container1-1  Running                      0.0s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 1/2
[37m ‚†π Container dockercomposefiles-container2-1  Recreate                     0.3s
[0m[34m ‚†ø Container dockercomposefiles-container1-1  Running                      0.0s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 1/2
[37m ‚†∏ Container dockercomposefiles-container2-1  Recreate                     0.4s
[0m[34m ‚†ø Container dockercomposefiles-container1-1  Running                      0.0s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 1/2
[37m ‚†º Container dockercomposefiles-container2-1  Recreate                     0.5s
[0m[34m ‚†ø Container dockercomposefiles-container1-1  Running                      0.0s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 1/2
[37m ‚†¥ Container dockercomposefiles-container2-1  Recreate                     0.6s
[0m[34m ‚†ø Container dockercomposefiles-container1-1  Running                      0.0s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 1/2
[37m ‚†¶ Container dockercomposefiles-container2-1  Recreate                     0.7s
[0m[34m ‚†ø Container dockercomposefiles-container1-1  Running                      0.0s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 1/2
[37m ‚†ß Container dockercomposefiles-container2-1  Recreate                     0.8s
[0m[34m ‚†ø Container dockercomposefiles-container1-1  Running                      0.0s
...
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 1/2
[37m ‚†ø Container dockercomposefiles-container2-1  Starting                    10.8s
[0m[34m ‚†ø Container dockercomposefiles-container1-1  Running                      0.0s
[0m[?25h[1A[1A[1A[0G[?25l[34m[+] Running 2/2[0m
[34m ‚†ø Container dockercomposefiles-container2-1  Started                     10.8s
[0m[34m ‚†ø Container dockercomposefiles-container1-1  Running                      0.0s
[0m[?25h</output_code>
  <markdown>Vemos que ha tardado 10 segundos en montar el servicio `container2`, eso es porque ha estado aplicando los cambios

```bash
$ docker compose exec container2 bash
root@d8777a4e611a:/# ls dockerOverrideFolder/
bindFile.txt  fileExtract.txt  text.txt
root@d8777a4e611a:/# cat dockerOverrideFolder/text.txt 
hola compose
root@d8777a4e611a:/# exit
exit
```</markdown>
  <markdown>Bajamos el Compose y borramos los contenedores y la red creada</markdown>
  <input_code>!cd dockerComposeFiles &amp;&amp; docker compose down</input_code>
  <output_code>[1A[1B[0G[?25l[+] Running 0/0
[37m ‚†ã Container dockercomposefiles-container2-1  Stopping                     0.1s
[0m[37m ‚†ã Container dockercomposefiles-container1-1  Stopping                     0.1s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 0/2
[37m ‚†ô Container dockercomposefiles-container2-1  Stopping                     0.2s
[0m[37m ‚†ô Container dockercomposefiles-container1-1  Stopping                     0.2s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 0/2
[37m ‚†π Container dockercomposefiles-container2-1  Stopping                     0.3s
[0m[37m ‚†π Container dockercomposefiles-container1-1  Stopping                     0.3s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 0/2
[37m ‚†∏ Container dockercomposefiles-container2-1  Stopping                     0.4s
[0m[37m ‚†∏ Container dockercomposefiles-container1-1  Stopping                     0.4s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 0/2
[37m ‚†º Container dockercomposefiles-container2-1  Stopping                     0.5s
[0m[37m ‚†º Container dockercomposefiles-container1-1  Stopping                     0.5s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 0/2
[37m ‚†¥ Container dockercomposefiles-container2-1  Stopping                     0.6s
[0m[37m ‚†¥ Container dockercomposefiles-container1-1  Stopping                     0.6s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 0/2
[37m ‚†¶ Container dockercomposefiles-container2-1  Stopping                     0.7s
[0m[37m ‚†¶ Container dockercomposefiles-container1-1  Stopping                     0.7s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 0/2
[37m ‚†ß Container dockercomposefiles-container2-1  Stopping                     0.8s
[0m[37m ‚†ß Container dockercomposefiles-container1-1  Stopping                     0.8s
...
[37m ‚†∏ Container dockercomposefiles-container2-1  Stopping                    10.4s
[0m[37m ‚†∏ Container dockercomposefiles-container1-1  Stopping                    10.4s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 1/2
[34m ‚†ø Container dockercomposefiles-container2-1  Removed                     10.4s
[0m[37m ‚†ø Container dockercomposefiles-container1-1  Removing                    10.5s
[0m[?25h[1A[1A[1A[0G[?25l[34m[+] Running 2/2[0m
[34m ‚†ø Container dockercomposefiles-container2-1  Removed                     10.4s
[0m[34m ‚†ø Container dockercomposefiles-container1-1  Removed                     10.5s
[0m[37m ‚†ã Network dockercomposefiles_default         Removing                     0.1s
[0m[?25h[1A[1A[1A[1A[0G[?25l[34m[+] Running 3/3[0m
[34m ‚†ø Container dockercomposefiles-container2-1  Removed                     10.4s
[0m[34m ‚†ø Container dockercomposefiles-container1-1  Removed                     10.5s
[0m[34m ‚†ø Network dockercomposefiles_default         Removed                      0.2s
[0m[?25h</output_code>
  <markdown>En este caso, solo con `down` Docker Compose ha parado y borrado todo, ya que, como vemos en los contenedores y en la red pone `Removed`</markdown>
  <markdown>### Docker compose restart</markdown>
  <markdown>A la hora de escribir un docker compose, podemos a√±adir la etiqueta `restart` para que si el contenedor se cae, se reinicie autom√°ticamente

```json
restart: always
```

De esta manera, si el contenedor se cae, se reiniciar√° autom√°ticamente. Si queremos que se reinicie solo un n√∫mero de veces, podemos a√±adirle la opci√≥n `on-failure`

```json
restart: on-failure:&lt;number&gt;
```

Ahora el contenedor se reiniciar√° un n√∫mero de veces, pero si se cae m√°s veces, no se reiniciar√°. Si queremos que se reinicie siempre, podemos a√±adirle la opci√≥n `unless-stopped`

```json
restart: unless-stopped
```

Ahora el contenedor se reiniciar√° siempre, a menos que se pare manualmente</markdown>
  <markdown>## Docker avanzado</markdown>
  <markdown>### Administrar ambiente de trabajo</markdown>
  <markdown>#### Borrado de contenedores apagados</markdown>
  <markdown>Despu√©s de estar un tiempo desarrollando, podemos tener varios contenedores apagados, pero guardados en el ordenador. Esto al final ocupa memoria, as√≠ que con `docker container prune` podemos eliminar todos los que est√°n parados</markdown>
  <input_code>!docker run ubuntu</input_code>
  <input_code>!docker ps</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
</output_code>
  <input_code>!docker ps -a</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND   CREATED          STATUS                      PORTS     NAMES
effcee24f54a   ubuntu    "bash"    37 seconds ago   Exited (0) 36 seconds ago             musing_rosalind
</output_code>
  <markdown>``` bash
$ docker container prune 
WARNING! This will remove all stopped containers.
Are you sure you want to continue? [y/N] y
Deleted Containers:
effcee24f54aab22e34fdea2465b3b7af132d8c627e5432ba3e915a370876977

Total reclaimed space: 0B
```

En este caso hemos ahorrado 0 bytes, pero en el caso de dejar contenedores apagados despu√©s de mucho desarrollo, seguro que el ahorro de memoria ser√° mayor</markdown>
  <markdown>#### Borrado de todos los contenedores</markdown>
  <markdown>En caso de tener contenedores corriendo, podemos eliminar todos los contenedores mediante otro comando

El comando `docker ps -q` nos devuelve la ID de todos los contenedores, por lo que con el comando `docker rm -f $(docker ps -aq)` pararemos y borraremos todos</markdown>
  <input_code>!docker run -d ubuntu tail -f /dev/null</input_code>
  <output_code>c22516186ef7e3561fb1ad0d508a914857dbc61274a218f297c4d80b1fc33863
</output_code>
  <input_code>!docker ps</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND               CREATED              STATUS              PORTS     NAMES
c22516186ef7   ubuntu    "tail -f /dev/null"   About a minute ago   Up About a minute             agitated_knuth
</output_code>
  <input_code>!docker rm -f $(docker ps -aq)</input_code>
  <output_code>c22516186ef7
</output_code>
  <input_code>!docker ps -a</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
</output_code>
  <markdown>#### Borrado de todo</markdown>
  <markdown>Como hemos visto Docker tambi√©n crea redes, im√°genes, vol√∫menes, etc, as√≠ que con el comando `docker system prune` podemos borrar todos los contenedores parados, todas las redes que no est√©n usadas por al menos un contenedor, las im√°genes repetidas, y lo que haya repetido en la cach√© de compilaci√≥n

``` bash
$ docker system prune 
WARNING! This will remove:
  - all stopped containers
  - all networks not used by at least one container
  - all dangling images
  - all dangling build cache

Are you sure you want to continue? [y/N] y
Total reclaimed space: 0B
```

Al igual que antes, no se ha ahorrado mucho espacio, pero despu√©s de mucho tiempo desarrollando, el ahorro ser√° considerable</markdown>
  <markdown>### Uso de recursos del host por parte de contenedores</markdown>
  <markdown>Por ejemplo a la hora de crear un contenedor, podemos limitar la RAM que el host puede usar mediante la opci√≥n `--memory`</markdown>
  <input_code>!docker run -d --memory 1g ubuntu tail -f /dev/null</input_code>
  <output_code>d84888eafe531831ef8915d2270422365adec02678122bf59580e2da782e6972
</output_code>
  <markdown>Pero con `docker ps` no tenemos acceso a los recursos que est√° consumiendo el contenedor</markdown>
  <input_code>!docker ps</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND               CREATED          STATUS          PORTS     NAMES
d84888eafe53   ubuntu    "tail -f /dev/null"   35 seconds ago   Up 34 seconds             musing_ritchie
</output_code>
  <markdown>Para ello tenemos el comando `docker stats`

```bash
$ docker stats
CONTAINER ID   NAME             CPU %     MEM USAGE / LIMIT   MEM %     NET I/O       BLOCK I/O   PIDS
d84888eafe53   musing_ritchie   0.00%     540KiB / 1GiB       0.05%     5.62kB / 0B   0B / 0B     1
```

Esto es muy √∫til si queremos simular un entorno con un l√≠mite de RAM</markdown>
  <markdown>### Deteniendo contenedores correctamente: SHELL vs EXEC</markdown>
  <markdown>Como hemos explicado, cuando asignamos un proceso a un contenedor, cuando ese proceso termina, el contenedor se para, pero a veces podemos encontrarnos con problemas con esto. Vamos a crear una nueva carpeta llamada Dockerfile_loop</markdown>
  <input_code>!mkdir Dockerfile_loop</input_code>
  <markdown>Ahora vamos a crear un archivo llamado `loop.sh` dentro de `Dockerfile_loop`</markdown>
  <input_code>!touch Dockerfile_loop/loop.sh</input_code>
  <markdown>Y vamos a escribir lo siguiente dentro de `loop.sh`

``` shell
#!/usr/bin/env bash
trap "exit 0" SIGTERM
while true; do :; done
```

Si yo ejecuto este script en el host se ejecuta hasta que introduzca `CTRL+C`


``` bash
 ./loop
 ^C
 ```</markdown>
  <markdown>Ahora vamos a crear un archivo `Dockerfile` dentro de `Dockerfile_loop`</markdown>
  <input_code>!touch Dockerfile_loop/Dockerfile</input_code>
  <markdown>*Dockerfile*:
``` docker
FROM ubuntu:trusty
COPY ["loop.sh", "/"]
CMD /loop.sh
```</markdown>
  <markdown>Vamos a crear una imagen basada en Ubuntu que copia el script dentro y lo ejecuta, y el script se ejecuta hasta que recibe la se√±al `SIGTERM` del sistema operativo. Compilamos la imagen</markdown>
  <input_code>!docker build -t ubuntu:loop ./Dockerfile_loop</input_code>
  <output_code>Sending build context to Docker daemon  3.072kB
Step 1/3 : FROM ubuntu:trusty
 ---&gt; 13b66b487594
Step 2/3 : COPY ["loop.sh", "/"]
 ---&gt; 89f2bbd25a88
Step 3/3 : CMD /loop.sh
 ---&gt; Running in ff52569c35fd
Removing intermediate container ff52569c35fd
 ---&gt; feb091e4efa3
Successfully built feb091e4efa3
Successfully tagged ubuntu:loop

Use 'docker scan' to run Snyk tests against images to find vulnerabilities and learn how to fix them
</output_code>
  <markdown>Ejecutamos el contenedor

``` bash
docker run -d --name looper ubuntu:loop bash
```</markdown>
  <input_code>!docker run -d --name looper ubuntu:loop</input_code>
  <output_code>8a28f8cc9892213c4e0603dfdde320edf52c091b82c60510083549a391cd6645
</output_code>
  <markdown>Comprobamos y vemos que el contenedor est√° corriendo</markdown>
  <input_code>!docker ps</input_code>
  <output_code>CONTAINER ID   IMAGE         COMMAND                 CREATED         STATUS         PORTS     NAMES
8a28f8cc9892   ubuntu:loop   "/bin/sh -c /loop.sh"   4 seconds ago   Up 3 seconds             looper
</output_code>
  <markdown>Intentamos parar el contenedor con `docker stop looper`. Docker stop trata de parar el contenedor envi√°ndole la se√±al `SIGTERM`.</markdown>
  <input_code>%%time
!docker stop looper</input_code>
  <output_code>looper
CPU times: user 89.2 ms, sys: 21.7 ms, total: 111 ms
Wall time: 10.6 s
</output_code>
  <markdown>Esto ha tardado unos 10 segundos en detenerse, cuando tendr√≠a que ser inmediato. Esto es porque `stop` ha mandado la orden `SIGTERM` para que se parara el contenedor, pero como no paraba, al rato le ha mandado un `SIGKILL` para forzar que se detenga. Vemos a ver qu√© pasa, si listamos los contenedores</markdown>
  <input_code>!docker ps -a</input_code>
  <output_code>CONTAINER ID   IMAGE         COMMAND                 CREATED          STATUS                       PORTS     NAMES
8a28f8cc9892   ubuntu:loop   "/bin/sh -c /loop.sh"   23 seconds ago   Exited (137) 2 seconds ago             looper
</output_code>
  <markdown>Podemos ver que la se√±al de `Exited` es `137`, eso equivale a SIGKILL, es decir, docker tuvo que forzar el apagado.</markdown>
  <markdown>Vamos a borrar el contenedor y a volverlo a ejecutar</markdown>
  <input_code>!docker rm looper</input_code>
  <output_code>looper
</output_code>
  <input_code>!docker run -d --name looper ubuntu:loop</input_code>
  <output_code>84bc37f944d270be5f84a952968db2b8cf5372c61146d29383468198ceed18fd
</output_code>
  <markdown>Si ahora intentamos detener el contenedor con `docker kill looper`</markdown>
  <input_code>%%time
!docker kill looper</input_code>
  <output_code>looper
CPU times: user 9.1 ms, sys: 857 ¬µs, total: 9.96 ms
Wall time: 545 ms
</output_code>
  <markdown>Vemos que el tiempo son unos 500 ms, es decir, docker lo ha parado en un momento envi√°ndole la orden `SIGKILL`. Porque `kill` no manda `SIGTERM` y si en un tiempo no se ha parado el contenedor manda `SIGKILL`, lo que hace es mandar `SIGKILL` desde el inicio.

Si vemos los contenedores, vemos que la se√±al de salida es la misma, `137`</markdown>
  <input_code>!docker ps -a</input_code>
  <output_code>CONTAINER ID   IMAGE         COMMAND                 CREATED         STATUS                       PORTS     NAMES
84bc37f944d2   ubuntu:loop   "/bin/sh -c /loop.sh"   6 seconds ago   Exited (137) 2 seconds ago             looper
</output_code>
  <markdown>Esta no es la manera correcta de apagar un contenedor, porque cuando queramos apagar el contenedor habr√≠a que hacerlo mediante la se√±al `SIGTERM`, para que este termine de procesar lo que estuviera haciendo y luego se apague</markdown>
  <markdown>Si borramos el contenedor y lo volvemos a ejecutar</markdown>
  <input_code>!docker rm looper</input_code>
  <output_code>looper
</output_code>
  <input_code>!docker run -d --name looper ubuntu:loop</input_code>
  <output_code>b9d9f370cc0de7569eb09d0a85cd67e8ea6babc0754a517ccba5c5057f5cc50e
</output_code>
  <markdown>Si ahora vemos los procesos que se est√°n ejecutando dentro del contenedor</markdown>
  <input_code>!docker exec looper ps -ef</input_code>
  <output_code>UID          PID    PPID  C STIME TTY          TIME CMD
root           1       0  0 14:05 ?        00:00:00 /bin/sh -c /loop.sh
root           7       1 93 14:05 ?        00:00:02 bash /loop.sh
root           8       0  0 14:05 ?        00:00:00 ps -ef
</output_code>
  <markdown>En realidad el proceso principal, el 1, no es `/loop.sh` sino que es `/bin/sh -c /loop.sh`, es decir, es un proceso hijo del `shell`. Por lo que cuando llegaba la se√±al `SIGTERM` le llegaba al `shell`, pero este no se lo manda a sus procesos hijos, por eso no le llegaba a `loop.sh`</markdown>
  <markdown>Para que no pase esto hay que cambiar el `Dockerfile` a lo siguiente

*Dockerfile*:
``` docker
FROM ubuntu:trusty
COPY ["loop.sh", "/"]
CMD ["/loop.sh"]    # antes era CMD /loop.sh
```

Esta forma se llama `exec form`, mientras que la anterior se llama `shell form`, de manera que de la anterior forma corre el proceso como un hijo del `shell`, mientras que de la forma `exec form` ejecuta el proceso que le digamos. As√≠ que borramos el contenedor, volvemos a compilar y volvemos a hacer correr el contenedor con la imagen</markdown>
  <input_code>!docker rm -f looper</input_code>
  <output_code>looper
</output_code>
  <input_code>!docker build -t ubuntu:loop ./Dockerfile_loop</input_code>
  <output_code>Sending build context to Docker daemon  3.072kB
Step 1/3 : FROM ubuntu:trusty
 ---&gt; 13b66b487594
Step 2/3 : COPY ["loop.sh", "/"]
 ---&gt; Using cache
 ---&gt; 89f2bbd25a88
Step 3/3 : CMD ["/loop.sh"]
 ---&gt; Running in 6b8d92fcd57c
Removing intermediate container 6b8d92fcd57c
 ---&gt; 35a7bb2b1892
Successfully built 35a7bb2b1892
Successfully tagged ubuntu:loop

Use 'docker scan' to run Snyk tests against images to find vulnerabilities and learn how to fix them
</output_code>
  <input_code>!docker run -d --name looper ubuntu:loop</input_code>
  <output_code>850ae70c071426850b28428ac60dcbf875c6d35d9b7cc66c17cf391a23392965
</output_code>
  <markdown>S√≠ ahora veo los procesos dentro del contenedor</markdown>
  <input_code>!docker exec looper ps -ef</input_code>
  <output_code>UID          PID    PPID  C STIME TTY          TIME CMD
root           1       0 88 14:14 ?        00:00:02 bash /loop.sh
root           7       0  0 14:14 ?        00:00:00 ps -ef
</output_code>
  <markdown>Ahora s√≠ veo que el proceso principal, el 1, es `/loop.sh`

Si ahora pruebo a parar el contenedor</markdown>
  <input_code>%%time
!docker stop looper</input_code>
  <output_code>looper
CPU times: user 989 ¬µs, sys: 7.55 ms, total: 8.54 ms
Wall time: 529 ms
</output_code>
  <markdown>Vemos que tarda m√°s. Veamos el c√≥digo con el que par√≥</markdown>
  <input_code>!docker ps -a</input_code>
  <output_code>CONTAINER ID   IMAGE         COMMAND      CREATED              STATUS                      PORTS     NAMES
850ae70c0714   ubuntu:loop   "/loop.sh"   About a minute ago   Exited (0) 33 seconds ago             looper
</output_code>
  <markdown>### Contenedores ejecutables</markdown>
  <markdown>Si queremos un binario que corra como un ejecutable, en el `dockerfile` hay que especificar el comando en `ENTRYPOINT` y los par√°metros del comando en `CMD`, vamos a verlo</markdown>
  <markdown>Vamos a crear una nueva carpeta donde guardaremos el `Dockerfile`</markdown>
  <input_code>!mkdir dockerfile_ping</input_code>
  <markdown>Ahora creamos un Dockerfile dentro</markdown>
  <input_code>!touch dockerfile_ping/Dockerfile</input_code>
  <markdown>Escribimos dentro del Dockerfile lo siguiente

``` docker
FROM ubuntu:trusty
ENTRYPOINT [ "/bin/ping", "-c", "3" ]
CMD [ "localhost" ]
```

Compilamos la imagen</markdown>
  <input_code>!docker build -t ubuntu:ping ./dockerfile_ping</input_code>
  <output_code>Sending build context to Docker daemon  3.072kB
Step 1/3 : FROM ubuntu:trusty
 ---&gt; 13b66b487594
Step 2/3 : ENTRYPOINT [ "/bin/ping", "-c", "3" ]
 ---&gt; Using cache
 ---&gt; 1cebcfb542b1
Step 3/3 : CMD [ "localhost" ]
 ---&gt; Using cache
 ---&gt; 04ddc3de52a2
Successfully built 04ddc3de52a2
Successfully tagged ubuntu:ping

Use 'docker scan' to run Snyk tests against images to find vulnerabilities and learn how to fix them
</output_code>
  <markdown>Si ahora corremos la imagen sin pasarle un par√°metro, el contenedor se har√° un ping a s√≠ mismo</markdown>
  <input_code>!docker run --name ping_localhost ubuntu:ping</input_code>
  <output_code>PING localhost (127.0.0.1) 56(84) bytes of data.
64 bytes from localhost (127.0.0.1): icmp_seq=1 ttl=64 time=0.041 ms
64 bytes from localhost (127.0.0.1): icmp_seq=2 ttl=64 time=0.058 ms
64 bytes from localhost (127.0.0.1): icmp_seq=3 ttl=64 time=0.054 ms

--- localhost ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2027ms
rtt min/avg/max/mdev = 0.041/0.051/0.058/0.007 ms
</output_code>
  <markdown>Pero si ahora le pasamos un par√°metro, har√° ping a la direcci√≥n que le digamos</markdown>
  <input_code>!docker run --name ping_google ubuntu:ping google.com</input_code>
  <output_code>PING google.com (216.58.209.78) 56(84) bytes of data.
64 bytes from waw02s06-in-f14.1e100.net (216.58.209.78): icmp_seq=1 ttl=111 time=3.93 ms
64 bytes from waw02s06-in-f14.1e100.net (216.58.209.78): icmp_seq=2 ttl=111 time=6.80 ms
64 bytes from waw02s06-in-f14.1e100.net (216.58.209.78): icmp_seq=3 ttl=111 time=6.92 ms

--- google.com ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2002ms
rtt min/avg/max/mdev = 3.930/5.886/6.920/1.383 ms
</output_code>
  <markdown>Borramos los contenedores</markdown>
  <input_code>!docker rm ping_localhost ping_google</input_code>
  <output_code>ping_localhost
ping_google
</output_code>
  <markdown>### El contexto de `build`</markdown>
  <markdown>Vamos a crear una carpeta llamada `dockerfile_contexto`</markdown>
  <input_code>!mkdir dokerfile_contexto</input_code>
  <markdown>Ahora creamos en ella dos archivos: un `test.txt` y el `Dockerfile`</markdown>
  <input_code>!touch dokerfile_contexto/Dockerfile dokerfile_contexto/text.txt</input_code>
  <markdown>Modificamos el Dockerfile y ponemos lo siguiente

``` docker
FROM ubuntu:trusty
COPY [".", "/"]
```

Esto lo que va a hacer es que va a copiar dentro de la imagen, todo lo que tenga en la carpeta en la que se encuentra el `Dockerfile`. Compilamos la imagen</markdown>
  <input_code>!docker build -t ubuntu:contexto ./dokerfile_contexto</input_code>
  <output_code>Sending build context to Docker daemon   2.56kB
Step 1/2 : FROM ubuntu:trusty
 ---&gt; 13b66b487594
Step 2/2 : COPY [".", "/"]
 ---&gt; 3ab79fdce389
Successfully built 3ab79fdce389
Successfully tagged ubuntu:contexto

Use 'docker scan' to run Snyk tests against images to find vulnerabilities and learn how to fix them
</output_code>
  <markdown>Vamos a ver qu√© hay dentro del contenedor</markdown>
  <input_code>!docker run --name ls ubuntu:contexto ls</input_code>
  <output_code>Dockerfile
bin
boot
dev
etc
home
lib
lib64
media
mnt
opt
proc
root
run
sbin
srv
sys
text.txt
tmp
usr
var
</output_code>
  <markdown>Como vemos est√° el archivo `text.txt`. Pero es posible que dentro de la carpeta que est√° en el mismo directorio que el `Dockerfile` haya archivos o carpetas que no queremos que se copien en la imagen, por la raz√≥n que sea, as√≠ que al igual que en git tenemos el `.gitignore`, en docker tenemos el `.dockerignore`, donde metemos los archivos o carpetas que no queremos que a la hora de compilar se tengan en cuenta

As√≠ que creamos un archivo `.dockerignore`</markdown>
  <input_code>!touch dokerfile_contexto/.dockerignore</input_code>
  <markdown>Y dentro a√±adimos el `text.txt`, y de paso el `Dockerfile` que no lo necesitamos dentro de la imagen

*.dockerignore*:
```
Dockerfile
text.txt
```</markdown>
  <markdown>Borramos el contenedor que hab√≠amos creado, volvemos a compilar y vemos qu√© hay dentro del contenedor</markdown>
  <input_code>!docker rm ls</input_code>
  <output_code>ls
</output_code>
  <input_code>!docker build -t ubuntu:contexto ./dokerfile_contexto</input_code>
  <output_code>Sending build context to Docker daemon  3.072kB
Step 1/2 : FROM ubuntu:trusty
 ---&gt; 13b66b487594
Step 2/2 : COPY [".", "/"]
 ---&gt; 7a6689546da4
Successfully built 7a6689546da4
Successfully tagged ubuntu:contexto

Use 'docker scan' to run Snyk tests against images to find vulnerabilities and learn how to fix them
</output_code>
  <input_code>!docker run --name ls ubuntu:contexto ls</input_code>
  <output_code>bin
boot
dev
etc
home
lib
lib64
media
mnt
opt
proc
root
run
sbin
srv
sys
tmp
usr
var
</output_code>
  <markdown>Vemos que ahora no est√°n ni `Dockerfile` ni `text.txt`. Borramos el contenedor</markdown>
  <input_code>!docker rm ls</input_code>
  <output_code>ls
</output_code>
  <markdown>### Multi-stage build</markdown>
  <markdown>Al final de un desarrollo no queremos que todo el c√≥digo est√© en la imagen que se va a mandar a producci√≥n.

Podemos dividir el `dockerfile` en dos, por ejemplo, el `developer.Dockerfile` y el `production.Dockerfile`, donde en desarrollo habr√° m√°s cosas que en el de producci√≥n. A la hora de compilarlos, mediante la opci√≥n `-f` elegimos el `dockerfile` que queremos usar

``` bash
docker build -t &lt;tag&gt; -f developer.Dockerfile
docker build -t &lt;tag&gt; -f production.Dockerfile
```</markdown>
  <markdown>Pero para no tener que crear dos archivos `Dockerfile`, Docker cre√≥ el `multi stage builds`. Con un solo `Dockerfile` vamos a solucionar el problema</markdown>
  <markdown>Creamos la carpeta donde vamos a guardar el `Dockerfile`</markdown>
  <input_code>!mkdir docker_multi_stage</input_code>
  <markdown>Y dentro creamos el archivo `Dockerfile`</markdown>
  <input_code>!cd docker_multi_stage &amp;&amp; touch Dockerfile</input_code>
  <markdown>Editamos el archivo, metiendo lo siguiente

``` dockerfile
# Etapa 1: Generar el ejecutable con Python basado en Alpine
FROM python:3.9-alpine as build-stage
WORKDIR /app
# Instalar dependencias para PyInstaller
RUN apk add --no-cache gcc musl-dev libc-dev
# Generar hello.py
RUN echo 'print("Hello from Alpine!")' &gt; hello.py
# Instalar PyInstaller
RUN pip install pyinstaller
# Usar PyInstaller para crear un ejecutable independiente
RUN pyinstaller --onefile hello.py

# Etapa 2: Ejecutar el ejecutable en una imagen de Alpine
FROM alpine:latest
WORKDIR /app
# Copiar el ejecutable desde la etapa de build
COPY --from=build-stage /app/dist/hello .
# Comando por defecto para ejecutar el ejecutable
CMD ["./hello"]
```

Como se puede ver, el `Dockerfile` est√° dividido en dos. Por un lado, se trabaja sobre la imagen `python:3.9-alpine`, que se llama como `build-stage`. Y por otro lado, trabajamos sobre la imagen `alpine:latest`, que es una imagen de Linux muy ligera y se utiliza mucho en producci√≥n

Lo compilamos</markdown>
  <input_code>!docker build -t maximofn/multistagebuild:latest ./docker_multi_stage</input_code>
  <output_code>[1A[1B[0G[?25l[+] Building 0.0s (0/2)                                          docker:default
[?25h</output_code>
  <output_code>[1A[0G[?25l[+] Building 0.2s (4/6)                                          docker:default
[34m =&gt; [internal] load build definition from Dockerfile                       0.0s
[0m[34m =&gt; =&gt; transferring dockerfile: 722B                                       0.0s
[0m[34m =&gt; [internal] load .dockerignore                                          0.0s
[0m[34m =&gt; =&gt; transferring context: 2B                                            0.0s
[0m =&gt; [internal] load metadata for docker.io/library/alpine:latest           0.1s
 =&gt; [internal] load metadata for docker.io/library/python:3.9-alpine       0.1s
...
[0m[34m =&gt; CACHED [stage-1 3/3] COPY --from=build-stage /app/dist/hello .         0.0s
[0m[34m =&gt; exporting to image                                                     0.0s
[0m[34m =&gt; =&gt; exporting layers                                                    0.0s
[0m[34m =&gt; =&gt; writing image sha256:7fb090d1495d00e892118b6bc3c03400b63a435fd4703  0.0s
[0m[34m =&gt; =&gt; naming to docker.io/maximofn/multistagebuild:latest                 0.0s
[0m[?25h</output_code>
  <markdown>Si ahora vemos las im√°genes que tenemos</markdown>
  <input_code>!docker image ls</input_code>
  <output_code>REPOSITORY                 TAG       IMAGE ID       CREATED         SIZE
maximofn/multistagebuild   latest    7fb090d1495d   8 minutes ago   13.6MB
</output_code>
  <markdown>Vamos a bajarnos la imagen de Python para ver cu√°nto pesa</markdown>
  <input_code>!docker pull python:3.9-alpine</input_code>
  <output_code>3.9-alpine: Pulling from library/python

[1Ba8db6415: Already exists 
[1Bd5e70e42: Already exists 
[1B3fe96417: Already exists 
[1Baa4dddbb: Already exists 
[1B518be9f7: Already exists Digest: sha256:6e508b43604ff9a81907ec17405c9ad5c13664e45a5affa2206af128818c7486
Status: Downloaded newer image for python:3.9-alpine
docker.io/library/python:3.9-alpine
</output_code>
  <input_code>!docker image ls</input_code>
  <output_code>REPOSITORY                 TAG          IMAGE ID       CREATED         SIZE
maximofn/multistagebuild   latest       7fb090d1495d   9 minutes ago   13.6MB
python                     3.9-alpine   6946662f018b   9 days ago      47.8MB
</output_code>
  <markdown>Podemos ver que mientras nuestra imagen pesa solo 13.6 MB, la de Python con la que ha construido la aplicaci√≥n pesa 47.8 MB. Por lo que podemos sacar dos conclusiones: con la primera imagen, la de Python, ha construido la aplicaci√≥n, ha generado el ejecutable y ese ejecutable es el que usamos en la segunda imagen, la de Alpine. Adem√°s podemos ver que aunque la primera imagen que usa es la de Python no se descarga en nuestro sistema, ya que la hemos tenido que descargar nosotros</markdown>
  <markdown>Pues ya s√≥lo queda probarlo</markdown>
  <input_code>!docker run --rm --name multi_stage_build maximofn/multistagebuild</input_code>
  <output_code>Hello from Alpine!
</output_code>
  <markdown>Funciona!</markdown>
  <markdown>### Multi arch builds</markdown>
  <markdown>Supongamos que queremos hacer una imagen que se pueda ejecutar en un ordenador y en una Raspberry. El ordenador probablemente tenga un micro con arquitectura AMD64, mientras que la Raspberry tiene un micro con arquitectura ARM. Por lo tanto, no podemos crear la misma imagen para los dos. Es decir, cuando creamos una imagen, la creamos con un `Dockerfile` que suele empezar as√≠

``` Dockerfile
FROM ...
```

Por lo tanto, el `Dockerfile` de la imagen del ordenador podr√≠a empezar as√≠

``` Dockerfile
FROM ubuntu:latest
```

Mientras que el de la Raspberry podr√≠a empezar as√≠

``` Dockerfile
FROM arm64v8/ubuntu:latest
```</markdown>
  <markdown>Tendr√≠amos que crear dos archivos `Dockerfile`, compilarlos y en el ordenador usar una imagen y en la raspberry usar otra</markdown>
  <markdown>Para evitar tener que ver la arquitectura del ordenador y ver qu√© imagen tenemos que usar, Docker crea los `manifest`, que como su nombre indica es un manifiesto que indica en funci√≥n de qu√© arquitectura de micro tengamos, usa una imagen u otra</markdown>
  <markdown>As√≠ que vamos a ver c√≥mo hacer esto</markdown>
  <markdown>En primer lugar, creamos una carpeta donde vamos a crear nuestros archivos `Dockerfile`</markdown>
  <input_code>!mkdir docker_multi_arch</input_code>
  <markdown>Ahora creamos los dos Dockerfiles</markdown>
  <input_code>!cd docker_multi_arch &amp;&amp; touch Dockerfile_arm64 Dockerfile_amd64</input_code>
  <markdown>Escribimos el `Dockerfile` para AMD64</markdown>
  <input_code>!cd docker_multi_arch &amp;&amp; echo "FROM ubuntu:20.04" &gt;&gt; Dockerfile_amd64 &amp;&amp; echo "CMD echo 'Hello from amd64'" &gt;&gt; Dockerfile_amd64</input_code>
  <input_code>!cd docker_multi_arch &amp;&amp; echo "FROM arm64v8/ubuntu:latest" &gt;&gt; Dockerfile_arm &amp;&amp; echo "CMD echo 'Hello from ARM'" &gt;&gt; Dockerfile_arm</input_code>
  <markdown>Ahora combinamos las dos im√°genes</markdown>
  <input_code>!cd docker_multi_arch &amp;&amp; docker build -t maximofn/multiarch:arm -f Dockerfile_arm .</input_code>
  <output_code>[1A[1B[0G[?25l[+] Building 0.0s (0/1)                                          docker:default
[?25h[1A[0G[?25l[+] Building 0.2s (2/3)                                          docker:default
[34m =&gt; [internal] load build definition from Dockerfile_amd64                 0.1s
[0m[34m =&gt; =&gt; transferring dockerfile: 89B                                        0.0s
[0m[34m =&gt; [internal] load .dockerignore                                          0.1s
[0m[34m =&gt; =&gt; transferring context: 2B                                            0.0s
[0m =&gt; [internal] load metadata for docker.io/library/ubuntu:20.04            0.1s
[?25h[1A[1A[1A[1A[1A[1A[0G[?25l[+] Building 0.3s (2/3)                                          docker:default
[34m =&gt; [internal] load build definition from Dockerfile_amd64                 0.1s
[0m[34m =&gt; =&gt; transferring dockerfile: 89B                                        0.0s
[0m[34m =&gt; [internal] load .dockerignore                                          0.1s
[0m[34m =&gt; =&gt; transferring context: 2B                                            0.0s
[0m =&gt; [internal] load metadata for docker.io/library/ubuntu:20.04            0.2s
[?25h[1A[1A[1A[1A[1A[1A[0G[?25l[+] Building 0.5s (2/3)                                          docker:default
[34m =&gt; [internal] load build definition from Dockerfile_amd64                 0.1s
[0m[34m =&gt; =&gt; transferring dockerfile: 89B                                        0.0s
[0m[34m =&gt; [internal] load .dockerignore                                          0.1s
[0m[34m =&gt; =&gt; transferring context: 2B                                            0.0s
[0m =&gt; [internal] load metadata for docker.io/library/ubuntu:20.04            0.4s
[?25h[1A[1A[1A[1A[1A[1A[0G[?25l[+] Building 0.6s (2/3)                                          docker:default
[34m =&gt; [internal] load build definition from Dockerfile_amd64                 0.1s
[0m[34m =&gt; =&gt; transferring dockerfile: 89B                                        0.0s
[0m[34m =&gt; [internal] load .dockerignore                                          0.1s
[0m[34m =&gt; =&gt; transferring context: 2B                                            0.0s
[0m =&gt; [internal] load metadata for docker.io/library/ubuntu:20.04            0.5s
...
[0m[34m =&gt; =&gt; transferring context: 2B                                            0.0s
[0m[34m =&gt; [internal] load build definition from Dockerfile_arm                   0.0s
[0m[34m =&gt; =&gt; transferring dockerfile: 94B                                        0.0s
[0m[34m =&gt; [internal] load metadata for docker.io/arm64v8/ubuntu:latest           1.8s
[0m[34m =&gt; [auth] arm64v8/ubuntu:pull token for registry-1.docker.io              0.0s
[0m[34m =&gt; CACHED [1/1] FROM docker.io/arm64v8/ubuntu:latest@sha256:94d12db896d0  0.0s
[0m[34m =&gt; exporting to image                                                     0.0s
[0m[34m =&gt; =&gt; exporting layers                                                    0.0s
[0m[34m =&gt; =&gt; writing image sha256:a9732c1988756dc8e836fd96e5c9512e349c97ea5af46  0.0s
[0m[34m =&gt; =&gt; naming to docker.io/maximofn/multiarch:arm                          0.0s
[0m[?25h</output_code>
  <markdown>Vamos a ver que tenemos las dos im√°genes compiladas</markdown>
  <input_code>!docker image ls</input_code>
  <output_code>REPOSITORY           TAG       IMAGE ID       CREATED       SIZE
maximofn/multiarch   arm       a9732c198875   4 weeks ago   69.2MB
maximofn/multiarch   amd64     5b612c83025f   6 weeks ago   72.8MB
</output_code>
  <markdown>Vemos que hemos compilado las dos im√°genes. Para poder crear un manifest, primero tenemos que subir las im√°genes a Docker Hub, as√≠ que las subimos</markdown>
  <input_code>!docker push maximofn/multiarch:amd64</input_code>
  <output_code>The push refers to repository [docker.io/maximofn/multiarch]

[1B82bdeb5f: Mounted from library/ubuntu amd64: digest: sha256:30e820f2a11a24ad4d8fb624ae485f7c1bcc299e8cfc72c88adce1acd0447e1d size: 529
</output_code>
  <input_code>!docker push maximofn/multiarch:arm</input_code>
  <output_code>The push refers to repository [docker.io/maximofn/multiarch]
</output_code>
  <output_code>
[1Beda53374: Layer already exists arm: digest: sha256:6ec5a0752d49d3805061314147761bf25b5ff7430ce143adf34b70d4eda15fb8 size: 529
</output_code>
  <markdown>Si me voy a mi Docker Hub puedo ver que mi imagen `maximofn/multiarch` tiene los tags `amd64` y `arm`

![docker_multi_arch_tags](https://images.maximofn.com/docker_multi_arch_tags.webp)</markdown>
  <markdown>Ahora vamos a crear el `manifest` basado en estas dos im√°genes</markdown>
  <input_code>!docker manifest create maximofn/multiarch:latest maximofn/multiarch:amd64 maximofn/multiarch:arm</input_code>
  <output_code>Created manifest list docker.io/maximofn/multiarch:latest
</output_code>
  <markdown>Una vez creado, tenemos que indicar las arquitecturas de las CPU a las que corresponde cada una</markdown>
  <input_code>!docker manifest annotate maximofn/multiarch:latest maximofn/multiarch:amd64 --os linux --arch amd64</input_code>
  <input_code>!docker manifest annotate maximofn/multiarch:latest maximofn/multiarch:arm64 --os linux --arch arm64</input_code>
  <output_code>manifest for image maximofn/multiarch:arm64 does not exist in maximofn/multiarch:latest
</output_code>
  <markdown>Una vez creado y anotado podemos subir el `manifest` a Docker Hub</markdown>
  <input_code>!docker manifest push maximofn/multiarch:latest</input_code>
  <output_code>sha256:1ea28e9a04867fe0e0d8b0efa455ce8e4e29e7d9fd4531412b75dbd0325e9304
</output_code>
  <markdown>Si ahora vuelvo a mirar los tags que tiene mi imagen `maximofn/multiarch`, veo tambi√©n la de `latest`

![docker_multi_arch_tags_manifest](https://images.maximofn.com/docker_multi_arch_tags_manifest.webp)</markdown>
  <markdown>Ahora, tanto si quiero usar mi imagen desde una m√°quina con CPU AMD64 o CPU ARM al hacer `FROM maximofn/multiarch:latest`, docker comprobar√° la arquitectura de la CPU y bajar√° el tag `amd64` o el tag `arm`. Vamos a verlo, si desde mi ordenador ejecuto la imagen obtengo</markdown>
  <input_code>!docker run maximofn/multiarch:latest</input_code>
  <output_code>Unable to find image 'maximofn/multiarch:latest' locally
</output_code>
  <output_code>latest: Pulling from maximofn/multiarch
Digest: sha256:7cef0de10f7fa2b3b0dca0fbf398d1f48af17a0bbc5b9beca701d7c427c9fd84
Status: Downloaded newer image for maximofn/multiarch:latest
Hello from amd64
</output_code>
  <markdown>Como no la tiene, se la baja</markdown>
  <markdown>Si ahora me conecto por ssh a una Raspberry Pi y pruebo lo mismo obtengo

```bash
raspberrry@raspberrypi:~ $ docker run maximofn/multiarch:latest
    Unable to find image 'maximofn/multiarch:latest' locally
    latest: Pulling from maximofn/multiarch
    Digest: sha256:1ea28e9a04867fe0e0d8b0efa455ce8e4e29e7d9fd4531412b75dbd0325e9304
    Status: Downloaded newer image for maximofn/multiarch:latest
    Hello from ARM
```

Aparece `Hello from ARM` ya que la raspberry tiene un micro con arquitectura ARM</markdown>
  <markdown>Como se puede ver, cada m√°quina se ha bajado la imagen que necesitaba</markdown>
  <markdown>### Escritura correcta de Dockerfiles avanzado</markdown>
  <markdown>Ya vimos la manera de escribir correctamente Dockerfiles, pero hay una cosa m√°s que podemos hacer ahora que conocemos el multi-stage build y es crear un contenedor para crear el ejecutable y otro m√°s peque√±o para ejecutarlo

Llegamos a la conclusi√≥n de que un buen Dockerfile podr√≠a ser este

``` Dockerfile
FROM python:3.9.18-alpine
WORKDIR /sourceCode/sourceApp
COPY ./sourceCode/sourceApp .
CMD ["python3", "app.py"]
```

Vamos a crear ahora un ejecutable en un contenedor builder y en otro m√°s peque√±o lo ejecutamos

``` dockerfile
FROM python:3.9.18-alpine as builder
WORKDIR /sourceCode/sourceApp
RUN apk add --no-cache gcc musl-dev libc-dev &amp;&amp; pip install pyinstaller
COPY ./sourceCode/sourceApp .
RUN pyinstaller --onefile app.py

FROM alpine:3.18.3
WORKDIR /sourceCode/sourceApp
COPY --from=builder /sourceCode/sourceApp/dist/app .
CMD ["./app"]
```</markdown>
  <markdown>Creamos el c√≥digo de Python en la ruta necesaria</markdown>
  <input_code>!mkdir multistagebuild/sourceCode
!mkdir multistagebuild/sourceCode/sourceApp
!touch multistagebuild/sourceCode/sourceApp/app.py
!echo 'print("Hello from Alpine!")' &gt; multistagebuild/sourceCode/sourceApp/app.py</input_code>
  <markdown>Ahora compilandos la imagen</markdown>
  <input_code>!docker build -t maximofn/multistagebuild:alpine-3.18.3 ./multistagebuild</input_code>
  <output_code>[1A[1B[0G[?25l[+] Building 0.0s (0/0)                                          docker:default
[?25h[1A[0G[?25l[+] Building 0.0s (0/1)                                          docker:default
[?25h[1A[0G[?25l[+] Building 0.2s (3/5)                                          docker:default
[34m =&gt; [internal] load build definition from Dockerfile                       0.1s
[0m[34m =&gt; =&gt; transferring dockerfile: 357B                                       0.0s
[0m[34m =&gt; [internal] load .dockerignore                                          0.1s
[0m[34m =&gt; =&gt; transferring context: 2B                                            0.0s
[0m =&gt; [internal] load metadata for docker.io/library/alpine:3.18.3           0.1s
 =&gt; [internal] load metadata for docker.io/library/python:3.9.18-alpine    0.1s
[34m =&gt; [auth] library/alpine:pull token for registry-1.docker.io              0.0s
[0m[?25h[1A[1A[1A[1A[1A[1A[1A[1A[0G[?25l[+] Building 0.3s (3/5)                                          docker:default
[34m =&gt; [internal] load build definition from Dockerfile                       0.1s
[0m[34m =&gt; =&gt; transferring dockerfile: 357B                                       0.0s
[0m[34m =&gt; [internal] load .dockerignore                                          0.1s
[0m[34m =&gt; =&gt; transferring context: 2B                                            0.0s
[0m =&gt; [internal] load metadata for docker.io/library/alpine:3.18.3           0.2s
 =&gt; [internal] load metadata for docker.io/library/python:3.9.18-alpine    0.2s
[34m =&gt; [auth] library/alpine:pull token for registry-1.docker.io              0.0s
[0m[?25h[1A[1A[1A[1A[1A[1A[1A[1A[0G[?25l[+] Building 0.5s (4/6)                                          docker:default
[34m =&gt; [internal] load build definition from Dockerfile                       0.1s
[0m[34m =&gt; =&gt; transferring dockerfile: 357B                                       0.0s
[0m[34m =&gt; [internal] load .dockerignore                                          0.1s
[0m[34m =&gt; =&gt; transferring context: 2B                                            0.0s
[0m =&gt; [internal] load metadata for docker.io/library/alpine:3.18.3           0.4s
...
[0m[34m =&gt; exporting to image                                                     0.1s
[0m[34m =&gt; =&gt; exporting layers                                                    0.1s
[0m[34m =&gt; =&gt; writing image sha256:8a22819145c6fee17e138e818610ccf46d7e13c786825  0.0s
[0m[34m =&gt; =&gt; naming to docker.io/maximofn/multistagebuild:alpine-3.18.3          0.0s
[0m[?25h</output_code>
  <markdown>La ejecutamos</markdown>
  <input_code>!docker run --rm --name multi_stage_build maximofn/multistagebuild:alpine-3.18.3</input_code>
  <output_code>Hello from Alpine!
</output_code>
  <markdown>La imagen `maximofn/multistagebuild:alpine-3.18.3` s√≥lo pesa 13.6 MB</markdown>
  <markdown>### Diferencia entre RUN, CMD y ENTRYPOINT</markdown>
  <markdown>#### RUN</markdown>
  <markdown>El comando `RUN` es el m√°s sencillo, simplemente ejecuta un comando en el momento de la compilaci√≥n de la imagen. Por ejemplo, si queremos instalar un paquete en la imagen, lo hacemos mediante `RUN`.

Por tanto, es importante, `RUN` se ejecuta en el momento de la compilaci√≥n de la imagen, no cuando se ejecuta el contenedor</markdown>
  <markdown>#### CMD</markdown>
  <markdown>El comando `CMD` es el comando que se ejecuta cuando se ejecuta el contenedor. Por ejemplo, si queremos que el contenedor ejecute un comando cuando se ejecute, lo hacemos mediante `CMD`. Por ejemplo, si tenemos una aplicaci√≥n de python en un contenedor, con `CMD` podemos indicarle que cuando se ejecute el contenedor ejecute la aplicaci√≥n de python.

De esta manera, cuando se levante el contenedor, se ejecutar√° la aplicaci√≥n de Python. Es decir, si hacemos `docker run &lt;image&gt;` se ejecutar√° la aplicaci√≥n de Python. Pero `CMD` nos permite sobreescribir el comando que se ejecuta cuando se levanta el contenedor, por ejemplo, si hacemos `docker run &lt;image&gt; bash` se ejecutar√° `bash` en vez de la aplicaci√≥n de Python.</markdown>
  <markdown>#### ENTRYPOINT</markdown>
  <markdown>El comando `ENTRYPOINT` es similar al comando `CMD`, pero con una diferencia: y es que `ENTRYPOINT` no est√° pensado para sobreescribirse. Es decir, si tenemos una aplicaci√≥n de Python en un contenedor, con `ENTRYPOINT` podemos indicarle que cuando se ejecute el contenedor ejecute la aplicaci√≥n de Python. Pero si hacemos `docker run &lt;image&gt; bash` se ejecutar√° la aplicaci√≥n de Python, no `bash`.

Un uso muy com√∫n de `ENTRYPOINT` es cuando queremos que el contenedor sea un ejecutable, por ejemplo, si queremos que el contenedor sea un ejecutable de una versi√≥n de Python que no tenemos en nuestro host, porque por ejemplo queremos probar la nueva versi√≥n de Python que ha salido podemos hacer

``` Dockerfile
FROM python:3.9.18-alpine
ENTRYPOINT ["python3"]
```

De esta manera, cuando se levante el contenedor, se ejecutar√° Python. Es decir, si hacemos `docker run &lt;image&gt;` se ejecutar√° Python. Pero `ENTRYPOINT` nos permite sobreescribir el comando que se ejecuta cuando se levanta el contenedor, por ejemplo, si hacemos `docker run &lt;image&gt; myapp.py` se ejecutar√° `python3 myapp.py` dentro del contenedor. As√≠ podemos probar nuestra aplicaci√≥n de Python en la nueva versi√≥n de Python</markdown>
  <markdown>### Cambios en un contenedor</markdown>
  <markdown>Con `docker diff` podemos ver las diferencias que hay entre el contenedor y la imagen, lo que es lo mismo, la diferencia en el contenedor desde que se cre√≥ hasta ahora

Vamos a correr un contenedor y dentro creamos un archivo</markdown>
  <input_code>!docker run --rm -it --name ubuntu-20.04 ubuntu:20.04 bash</input_code>
  <output_code>root@895a19aef124:/# touch file.txt
</output_code>
  <markdown>Ahora podemos ver la diferencia</markdown>
  <input_code>!docker diff ubuntu-20.04</input_code>
  <output_code>C /root
A /root/.bash_history
A /file.txt
</output_code>
  <markdown>`A` significa que se ha a√±adido, `C` significa que se ha cambiado y `D` significa que se ha borrado</markdown>
  <markdown>### Docker en Docker</markdown>
  <markdown>Supongamos que tenemos contenedores que necesitan levantar o apagar otros contenedores. Esto se logra de la siguiente manera

Dado que en Linux todo es un archivo y el host se comunica con Docker mediante un socket. Por lo que para Linux, ese socket es un archivo. As√≠ que si le montamos ese socket como un archivo al contenedor, podr√° hablar con Docker</markdown>
  <markdown>Primero vamos a montar un contenedor con Ubuntu</markdown>
  <input_code>!docker run -d --name ubuntu ubuntu:latest tail -f /dev/null</input_code>
  <output_code>144091e4a3325c9068064ff438f8865b40f944af5ce649c7156ca55a3453e423
</output_code>
  <markdown>Vamos a montar el contenedor que va a poder hablar con Docker montando la carpeta `/var/run/docker.sock`

``` bash
$ docker run -it --rm --name main -v /var/run/docker.sock:/var/run/docker.sock docker:19.03.12
/ # 
```

Nos hemos metido dentro de un contenedor, y si dentro ejecutamos `docker ps`

``` bash
# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
9afb778d6c20        docker:19.03.12     "docker-entrypoint.s‚Ä¶"   3 seconds ago       Up 2 seconds                            main
144091e4a332        ubuntu:latest       "tail -f /dev/null"      19 seconds ago      Up 18 seconds                           ubuntu
```

Como podemos ver, dentro de Docker podemos ver los contenedores del host</markdown>
  <markdown>Podemos correr un nuevo contenedor

``` bash
# docker run -d --name ubuntu_from_main ubuntu:latest tail -f /dev/null
362654a72bb0fb047c13968707a6f16b87fed7ce051eb5c1a146b15828589a1a
/ #
```

Y si volvemos a ver los contenedores

``` bash
# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS               NAMES
362654a72bb0        ubuntu:latest       "tail -f /dev/null"      3 seconds ago        Up 3 seconds                            ubuntu_from_main
9afb778d6c20        docker:19.03.12     "docker-entrypoint.s‚Ä¶"   About a minute ago   Up About a minute                       main
144091e4a332        ubuntu:latest       "tail -f /dev/null"      2 minutes ago        Up About a minute                       ubuntu
```

Pero si ahora ejecutamos una nueva terminal del host, veremos el contenedor creado desde dentro del contenedor</markdown>
  <input_code>!docker ps</input_code>
  <output_code>CONTAINER ID   IMAGE             COMMAND                  CREATED              STATUS              PORTS     NAMES
362654a72bb0   ubuntu:latest     "tail -f /dev/null"      About a minute ago   Up About a minute             ubuntu_from_main
9afb778d6c20   docker:19.03.12   "docker-entrypoint.s‚Ä¶"   3 minutes ago        Up 3 minutes                  main
144091e4a332   ubuntu:latest     "tail -f /dev/null"      3 minutes ago        Up 3 minutes                  ubuntu
</output_code>
  <markdown>Todo lo que hagamos desde el contenedor `main` se ver√° reflejado en el host</markdown>
  <markdown>Esto tiene la ventaja de que podemos instalar programas en un contenedor que tiene acceso al host para no tener que instalarlos en el host. Por ejemplo [dive](https://github.com/wagoodman/dive) es una herramienta para explorar contenedores, pero si no la quieres instalar en el host la puedes instalar en un contenedor con acceso al host, as√≠ desde ese contenedor `main` puedes explorar el resto de contenedores sin tener que instalarla en el host</markdown>
</notebook>