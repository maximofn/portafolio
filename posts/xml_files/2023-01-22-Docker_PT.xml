<?xml version='1.0' encoding='utf-8'?>
<notebook>
  <markdown># Docker</markdown>
  <markdown> &gt; Aviso: Este post foi traduzido para o portugu√™s usando um modelo de tradu√ß√£o autom√°tica. Por favor, me avise se encontrar algum erro.</markdown>
  <markdown>## Contentores</markdown>
  <markdown>### Ol√° mundo</markdown>
  <markdown>Executar o primeiro cont√™iner do tipo Hello World com o comando `docker run hello-world`</markdown>
  <input_code>!docker run hello-world</input_code>
  <output_code>Unable to find image 'hello-world:latest' locally
</output_code>
  <output_code>latest: Pulling from library/hello-world

[1B85e32844: Pull complete 457kB/2.457kBB[1A[2KDigest: sha256:dcba6daec718f547568c562956fa47e1b03673dd010fe6ee58ca806767031d1c
Status: Downloaded newer image for hello-world:latest

Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.
    (amd64)
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
 https://hub.docker.com/

For more examples and ideas, visit:
 https://docs.docker.com/get-started/

</output_code>
  <markdown>Como n√£o temos o cont√™iner salvo localmente, o Docker o baixa do Docker Hub. Se agora voltarmos a executar o cont√™iner, j√° n√£o aparecer√° a primeira mensagem, na qual indica que est√° sendo baixado.</markdown>
  <input_code>!docker run hello-world</input_code>
  <output_code>
Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.
    (amd64)
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
 https://hub.docker.com/

For more examples and ideas, visit:
 https://docs.docker.com/get-started/

</output_code>
  <markdown>Para ver os cont√™ineres que est√£o em execu√ß√£o, execute `docker ps`</markdown>
  <input_code>!docker ps</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
</output_code>
  <markdown>Como vemos n√£o h√° nenhum cont√™iner aberto. Mas, se executarmos `docker ps -a` (`all`), veremos que sim aparecem.</markdown>
  <input_code>!docker ps -a</input_code>
  <output_code>CONTAINER ID   IMAGE         COMMAND    CREATED          STATUS                      PORTS     NAMES
1efb51bbbf38   hello-world   "/hello"   10 seconds ago   Exited (0) 9 seconds ago              strange_thompson
5f5705e7603e   hello-world   "/hello"   15 seconds ago   Exited (0) 14 seconds ago             laughing_jang
</output_code>
  <markdown>Vemos que aparecem dois contentores chamados `hello-world` que s√£o os dois que executamos anteriormente. Portanto, cada vez que executamos o comando `run`, o Docker cria um novo contentor, n√£o executa um que j√° exista.</markdown>
  <markdown>Se quisermos ter mais informa√ß√µes sobre um dos dois cont√™ineres, podemos executar `docker inspect &lt;id&gt;`, onde `&lt;id&gt;` corresponde √† ID do cont√™iner que foi exibida na lista anterior.</markdown>
  <input_code>!docker inspect 1efb51bbbf38</input_code>
  <output_code>[
    {
        "Id": "1efb51bbbf38917affd1b5871db8e658ebfe0b2efa5ead17545680b7866f682e",
        "Created": "2023-09-04T03:59:17.795499354Z",
        "Path": "/hello",
        "Args": [],
        "State": {
            "Status": "exited",
            "Running": false,
            "Paused": false,
            "Restarting": false,
            "OOMKilled": false,
            "Dead": false,
            "Pid": 0,
            "ExitCode": 0,
            "Error": "",
            "StartedAt": "2023-09-04T03:59:18.406663026Z",
            "FinishedAt": "2023-09-04T03:59:18.406181184Z"
        },
        "Image": "sha256:9c7a54a9a43cca047013b82af109fe963fde787f63f9e016fdc3384500c2823d",
        "ResolvConfPath": "/var/lib/docker/containers/1efb51bbbf38917affd1b5871db8e658ebfe0b2efa5ead17545680b7866f682e/resolv.conf",
        "HostnamePath": "/var/lib/docker/containers/1efb51bbbf38917affd1b5871db8e658ebfe0b2efa5ead17545680b7866f682e/hostname",
        "HostsPath": "/var/lib/docker/containers/1efb51bbbf38917affd1b5871db8e658ebfe0b2efa5ead17545680b7866f682e/hosts",
        "LogPath": "/var/lib/docker/containers/1efb51bbbf38917affd1b5871db8e658ebfe0b2efa5ead17545680b7866f682e/1efb51bbbf38917affd1b5871db8e658ebfe0b2efa5ead17545680b7866f682e-json.log",
        "Name": "/strange_thompson",
        ...
            }
        }
    }
]
</output_code>
  <markdown>Como lembrar IDs √© complicado para n√≥s, o Docker atribui nomes aos cont√™ineres para facilitar nossa vida. Assim, na lista anterior, a √∫ltima coluna corresponde ao nome que o Docker atribuiu a cada cont√™iner, de modo que se agora executarmos `docker inspect &lt;name&gt;` obteremos as mesmas informa√ß√µes que com a ID.</markdown>
  <markdown>Volto a executar `docker ps -a` para voltar a ver a lista</markdown>
  <input_code>!docker ps -a</input_code>
  <output_code>CONTAINER ID   IMAGE         COMMAND    CREATED         STATUS                     PORTS     NAMES
1efb51bbbf38   hello-world   "/hello"   2 minutes ago   Exited (0) 2 minutes ago             strange_thompson
5f5705e7603e   hello-world   "/hello"   2 minutes ago   Exited (0) 2 minutes ago             laughing_jang
</output_code>
  <markdown>E agora eu executo `docker inspect &lt;name&gt;` para ver a informa√ß√£o do cont√™iner.</markdown>
  <input_code>!docker inspect strange_thompson</input_code>
  <output_code>[
    {
        "Id": "1efb51bbbf38917affd1b5871db8e658ebfe0b2efa5ead17545680b7866f682e",
        "Created": "2023-09-04T03:59:17.795499354Z",
        "Path": "/hello",
        "Args": [],
        "State": {
            "Status": "exited",
            "Running": false,
            "Paused": false,
            "Restarting": false,
            "OOMKilled": false,
            "Dead": false,
            "Pid": 0,
            "ExitCode": 0,
            "Error": "",
            "StartedAt": "2023-09-04T03:59:18.406663026Z",
            "FinishedAt": "2023-09-04T03:59:18.406181184Z"
        },
        "Image": "sha256:9c7a54a9a43cca047013b82af109fe963fde787f63f9e016fdc3384500c2823d",
        "ResolvConfPath": "/var/lib/docker/containers/1efb51bbbf38917affd1b5871db8e658ebfe0b2efa5ead17545680b7866f682e/resolv.conf",
        "HostnamePath": "/var/lib/docker/containers/1efb51bbbf38917affd1b5871db8e658ebfe0b2efa5ead17545680b7866f682e/hostname",
        "HostsPath": "/var/lib/docker/containers/1efb51bbbf38917affd1b5871db8e658ebfe0b2efa5ead17545680b7866f682e/hosts",
        "LogPath": "/var/lib/docker/containers/1efb51bbbf38917affd1b5871db8e658ebfe0b2efa5ead17545680b7866f682e/1efb51bbbf38917affd1b5871db8e658ebfe0b2efa5ead17545680b7866f682e-json.log",
        "Name": "/strange_thompson",
        ...
            }
        }
    }
]
</output_code>
  <markdown>Mas por que com `docker ps` n√£o vemos nenhum cont√™iner e com `docker ps -a` sim. Isso acontece porque `docker ps` s√≥ mostra os cont√™ineres que est√£o em execu√ß√£o, enquanto `docker ps -a` mostra todos os cont√™ineres, tanto os que est√£o em execu√ß√£o quanto os que est√£o desligados.</markdown>
  <markdown>Podemos criar um cont√™iner atribuindo a ele um nome atrav√©s do comando `docker run --name &lt;name&gt; hello-world`</markdown>
  <input_code>!docker run --name hello_world hello-world</input_code>
  <output_code>
Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.
    (amd64)
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
 https://hub.docker.com/

For more examples and ideas, visit:
 https://docs.docker.com/get-started/

</output_code>
  <markdown>Isso ser√° mais confort√°vel para n√≥s, pois poderemos controlar n√≥s mesmos os nomes dos cont√™ineres.</markdown>
  <markdown>Se agora quisermos criar outro cont√™iner com o mesmo nome, n√£o poderemos, porque o Docker n√£o permite que se dupliquem os nomes dos cont√™ineres. Desse modo, se quisermos renomear o cont√™iner, podemos usar o comando `docker rename &lt;old name&gt; &lt;new name&gt;`</markdown>
  <input_code>!docker rename hello_world hello_world2</input_code>
  <markdown>Agora temos um monte de cont√™ineres id√™nticos. Ent√£o, se quisermos remover algum, temos que usar o comando `docker rm &lt;id&gt;` ou `docker rm &lt;name&gt;`</markdown>
  <input_code>!docker ps -a</input_code>
  <output_code>CONTAINER ID   IMAGE         COMMAND    CREATED         STATUS                     PORTS     NAMES
f432c9c2ca21   hello-world   "/hello"   9 seconds ago   Exited (0) 8 seconds ago             hello_world2
1efb51bbbf38   hello-world   "/hello"   4 minutes ago   Exited (0) 4 minutes ago             strange_thompson
5f5705e7603e   hello-world   "/hello"   4 minutes ago   Exited (0) 4 minutes ago             laughing_jang
</output_code>
  <input_code>!docker rm hello_world2</input_code>
  <output_code>hello_world2
</output_code>
  <markdown>Se voltarmos a ver a lista de cont√™ineres, o cont√™iner `hello_world2` j√° n√£o estar√° mais l√°.</markdown>
  <input_code>!docker ps -a</input_code>
  <output_code>CONTAINER ID   IMAGE         COMMAND    CREATED         STATUS                     PORTS     NAMES
1efb51bbbf38   hello-world   "/hello"   5 minutes ago   Exited (0) 5 minutes ago             strange_thompson
5f5705e7603e   hello-world   "/hello"   5 minutes ago   Exited (0) 5 minutes ago             laughing_jang
</output_code>
  <markdown>Se quisermos apagar todos os cont√™ineres, podemos fazer isso um a um, mas como √© muito trabalhoso, podemos apagar todos usando o comando `docker container prune`. Este comando remove apenas os cont√™ineres que estejam parados.</markdown>
  <input_code>!docker container prune</input_code>
  <output_code>WARNING! This will remove all stopped containers.
Are you sure you want to continue? [y/N] y</output_code>
  <markdown>Docker pergunta se voc√™ tem certeza, e se voc√™ disser que sim, ele apaga todos. Se agora listar todos os cont√™ineres, nenhum aparecer√°.</markdown>
  <input_code>!docker ps -a</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
</output_code>
  <markdown>### O modo interativo</markdown>
  <markdown>Vamos a executar um Ubuntu por meio do comando `docker run ubuntu`</markdown>
  <input_code>!docker run ubuntu</input_code>
  <output_code>Unable to find image 'ubuntu:latest' locally
latest: Pulling from library/ubuntu

[1BDigest: sha256:20fa2d7bb4de7723f542be5923b06c4d704370f0390e4ae9e1c833c8785644c1[1A[2K[1A[2K[1A[2K[1A[2K[1A[2K[1A[2K[1A[2K[1A[2K
Status: Downloaded newer image for ubuntu:latest
</output_code>
  <markdown>Como vemos, agora demorou mais para baixar. Se listarmos os cont√™ineres atrav√©s do comando `docker ps`, veremos que n√£o aparece o cont√™iner que acabamos de criar, ou seja, ele n√£o est√° em execu√ß√£o.</markdown>
  <input_code>!docker ps</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
</output_code>
  <markdown>Listamos agora todos os cont√™ineres</markdown>
  <input_code>!docker ps -a</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND   CREATED         STATUS                     PORTS     NAMES
da16b3a85178   ubuntu    "bash"    4 seconds ago   Exited (0) 3 seconds ago             hardcore_kare
</output_code>
  <markdown>Vemos que o estado do cont√™iner √© `Exited (0)`</markdown>
  <markdown>Se observa que o comando do cont√™iner √© `bash` e junto ao estado `Exited (0)` indica que foi iniciado o Ubuntu, executou seu *bash*, terminou a execu√ß√£o e retornou 0. Isso acontece porque n√£o foi especificada nenhuma tarefa para o bash do Ubuntu. Para resolver isso, agora vamos executar o cont√™iner com o comando `docker run -it ubuntu`, onde `it` indica que queremos execut√°-lo em modo interativo.</markdown>
  <input_code>!docker run -it ubuntu</input_code>
  <output_code>root@5b633e9d838f:/#</output_code>
  <markdown>Agora vemos que estamos dentro do bash do Ubuntu. Se executarmos o comando `cat /etc/lsb-release` podemos ver a distribui√ß√£o do Ubuntu.</markdown>
  <input_code>!root@5b633e9d838f:/# cat /etc/lsb-release</input_code>
  <output_code>DISTRIB_ID=Ubuntu
DISTRIB_RELEASE=22.04
DISTRIB_CODENAME=jammy
DISTRIB_DESCRIPTION="Ubuntu 22.04.1 LTS"</output_code>
  <markdown>Se abrirmos outra terminal e vermos a lista de cont√™ineres, agora sim aparecer√° o cont√™iner rodando Ubuntu</markdown>
  <input_code>!docker ps</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND   CREATED         STATUS         PORTS     NAMES
5b633e9d838f   ubuntu    "bash"    3 minutes ago   Up 3 minutes             funny_mirzakhani
</output_code>
  <markdown>Vemos o cont√™iner com Ubuntu e em seu estado podemos ver `UP`</markdown>
  <markdown>Se vemos agora a lista de todos os contentores, veremos que aparecem os dois contentores com Ubuntu, o primeiro desligado e o segundo que est√° em execu√ß√£o.</markdown>
  <input_code>!docker ps -a</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND   CREATED         STATUS                     PORTS     NAMES
5b633e9d838f   ubuntu    "bash"    3 minutes ago   Up 3 minutes                         funny_mirzakhani
da16b3a85178   ubuntu    "bash"    3 minutes ago   Exited (0) 3 minutes ago             hardcore_kare
</output_code>
  <markdown>Se voltarmos √† terminal onde t√≠nhamos o Ubuntu rodando dentro de um docker, se escrevermos ``exit`` sairemos do Ubuntu.</markdown>
  <input_code>!root@5b633e9d838f:/# exit</input_code>
  <output_code>exit</output_code>
  <markdown>Se executarmos `docker ps` o cont√™iner j√° n√£o aparece</markdown>
  <input_code>!docker ps</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
</output_code>
  <markdown>Mas se eu executar ``docker ps -a`` ele aparece. Isso significa que o cont√™iner foi desligado.</markdown>
  <input_code>!docker ps -a</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND   CREATED         STATUS                      PORTS     NAMES
5b633e9d838f   ubuntu    "bash"    4 minutes ago   Exited (0) 27 seconds ago             funny_mirzakhani
da16b3a85178   ubuntu    "bash"    4 minutes ago   Exited (0) 4 minutes ago              hardcore_kare
</output_code>
  <markdown>Isso ocorre porque ao escrever ``exit``, na verdade estamos escrevendo no console do bash do Ubuntu, o que significa que estamos encerrando o processo bash do Ubuntu.</markdown>
  <markdown>### Ciclo de vida de um cont√™iner</markdown>
  <markdown>Em Docker, quando o processo principal de um cont√™iner termina, o cont√™iner √© desligado. Dentro de um cont√™iner podem ser executados v√°rios processos, mas apenas quando o processo principal termina, o cont√™iner √© desligado.

Portanto, se quisermos executar um cont√™iner que n√£o pare quando um processo terminar, devemos fazer com que seu processo principal n√£o termine. Neste caso, que o bash n√£o termine.

Se quisermos executar um cont√™iner com Ubuntu, mas que n√£o finalize quando o processo do Bash terminar, podemos fazer da seguinte maneira</markdown>
  <input_code>!docker run --name alwaysup -d ubuntu tail -f /dev/null</input_code>
  <output_code>ce4d60427dcd4b326d15aa832b816c209761d6b4e067a016bb75bf9366c37054
</output_code>
  <markdown>O que fazemos √© primeiro dar o nome ``alwaysup``, em segundo lugar passar a op√ß√£o ``-d`` (``detach``) para que o cont√™iner seja executado em segundo plano e por fim dizer o processo principal que queremos que seja executado no cont√™iner, que neste caso √© ``tail -f /dev/null`` que equivale a um comando ``nop``

Isso nos retornar√° o ID do cont√™iner, mas n√£o estaremos dentro do Ubuntu como acontecia antes.</markdown>
  <markdown>Se agora vermos a lista de cont√™ineres que est√£o em execu√ß√£o, aparecer√° o cont√™iner que acabamos de criar.</markdown>
  <input_code>!docker ps</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND               CREATED          STATUS          PORTS     NAMES
ce4d60427dcd   ubuntu    "tail -f /dev/null"   18 seconds ago   Up 17 seconds             alwaysup
</output_code>
  <markdown>Como j√° temos um cont√™iner rodando sempre, podemos nos conectar a ele atrav√©s do comando ``exec``. Dizemos o nome ou a ID do cont√™iner e passamos o processo que queremos que seja executado. Al√©m disso, passamos a op√ß√£o ``-it`` para dizer que deve ser interativo.</markdown>
  <input_code>!docker exec -it alwaysup bash</input_code>
  <output_code>root@ce4d60427dcd:/#</output_code>
  <markdown>Agora estamos de volta no Ubuntu. Se executarmos o comando ``ps -aux``, podemos ver uma lista dos processos que est√£o sendo executados dentro do Ubuntu.</markdown>
  <input_code>!ps -aux</input_code>
  <output_code>USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root           1  0.0  0.0   2820  1048 ?        Ss   13:04   0:00 tail -f /dev/null
root           7  0.0  0.0   4628  3796 pts/0    Ss   13:04   0:00 bash
root          15  0.0  0.0   7060  1556 pts/0    R+   13:05   0:00 ps -aux</output_code>
  <markdown>Vemos apenas tr√™s processos, o ``ps -aux``, o ``bash`` e o ``tail -f /dev/null``

Este cont√™iner vai ficar sempre ligado enquanto o processo ``tail -f /dev/null`` estiver em execu√ß√£o.</markdown>
  <markdown>Se sairmos do cont√™iner com o comando ``exit`` e executarmos o comando ``docker ps`` veremos que o cont√™iner continua ligado.</markdown>
  <input_code>!exit</input_code>
  <output_code>exit</output_code>
  <input_code>!docker ps</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND               CREATED         STATUS         PORTS     NAMES
ce4d60427dcd   ubuntu    "tail -f /dev/null"   2 minutes ago   Up 2 minutes             alwaysup
</output_code>
  <markdown>Para poder finalizar o processo e poder desligar o cont√™iner, devemos usar o comando ``docker stop &lt;name&gt;``</markdown>
  <input_code>!docker stop alwaysup</input_code>
  <output_code>alwaysup
</output_code>
  <markdown>Se agora listarmos os cont√™ineres em execu√ß√£o, o cont√™iner com Ubuntu j√° n√£o aparecer√°.</markdown>
  <input_code>!docker ps</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
</output_code>
  <markdown>E se listarmos todos os cont√™ineres, aparece o cont√™iner com Ubuntu, e seu estado ``Exited``</markdown>
  <input_code>!docker ps -a</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND               CREATED          STATUS                            PORTS     NAMES
ce4d60427dcd   ubuntu    "tail -f /dev/null"   14 minutes ago   Exited (137) About a minute ago             alwaysup
5b633e9d838f   ubuntu    "bash"                19 minutes ago   Exited (0) 15 minutes ago                   funny_mirzakhani
da16b3a85178   ubuntu    "bash"                20 minutes ago   Exited (0) 20 minutes ago                   hardcore_kare
</output_code>
  <markdown>Tamb√©m podemos pausar um cont√™iner por meio do comando `docker pause &lt;name&gt;`</markdown>
  <input_code>!docker run --name alwaysup -d ubuntu tail -f /dev/null</input_code>
  <output_code>8282eaf9dc3604fa94df206b2062287409cc92cbcd203f1a018742b5c171c9e4
</output_code>
  <markdown>Agora n√≥s pausamos</markdown>
  <input_code>!docker pause alwaysup</input_code>
  <output_code>alwaysup
</output_code>
  <markdown>Se voltarmos a ver todos os cont√™ineres, vemos que o cont√™iner com Ubuntu est√° pausado.</markdown>
  <input_code>!docker ps -a</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND               CREATED          STATUS                       PORTS     NAMES
8282eaf9dc36   ubuntu    "tail -f /dev/null"   41 seconds ago   Up 41 seconds (Paused)                 alwaysup
5b633e9d838f   ubuntu    "bash"                19 minutes ago   Exited (0) 15 minutes ago              funny_mirzakhani
da16b3a85178   ubuntu    "bash"                20 minutes ago   Exited (0) 20 minutes ago              hardcore_kare
</output_code>
  <markdown>### Contentores de uso √∫nico</markdown>
  <markdown>Se a hora de executar um cont√™iner, colocarmos a op√ß√£o `--rm`, esse cont√™iner vai ser apagado quando terminar de ser executado.</markdown>
  <input_code>!docker run --rm --name autoremove ubuntu:latest</input_code>
  <markdown>Se agora vemos quais cont√™ineres temos</markdown>
  <input_code>!docker ps -a</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
</output_code>
  <markdown>Vemos que n√£o est√° o cont√™iner que acabamos de criar</markdown>
  <markdown>### Expor containers ao mundo externo</markdown>
  <markdown>Vamos a criar um novo cont√™iner com um servidor</markdown>
  <input_code>!docker run -d --name proxy nginx</input_code>
  <output_code>Unable to find image 'nginx:latest' locally
latest: Pulling from library/nginx

[1Bf1ad4ce1: Pulling fs layer 
[1Bb079d0f8: Pulling fs layer 
[1B5fbbebc6: Pulling fs layer 
[1Bffdd25f4: Pulling fs layer 
[1B32c8fba2: Pulling fs layer 
[1B24b8ba39: Pull complete 393kB/1.393kBB[5A[2K[6A[2K[5A[2K[6A[2K[5A[2K[6A[2K[5A[2K[6A[2K[5A[2K[3A[2K[5A[2K[5A[2K[6A[2K[6A[2K[6A[2K[2A[2K[6A[2K[6A[2K[6A[2K[6A[2K[6A[2K[6A[2K[5A[2K[5A[2K[5A[2K[5A[2K[5A[2K[4A[2K[3A[2K[2A[2K[1A[2K[1A[2KDigest: sha256:2888a97f7c7d498bbcc47ede1ad0f6ced07d72dfd181071dde051863f1f79d7b
Status: Downloaded newer image for nginx:latest
1a530e04f14be082811b72ea8b6ea5a95dad3037301ee8a1351a0108ff8d3b30
</output_code>
  <markdown>Isso cria um servidor, vamos listar novamente os cont√™ineres que est√£o em execu√ß√£o.</markdown>
  <input_code>!docker ps</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND                  CREATED        STATUS                  PORTS     NAMES
1a530e04f14b   nginx     "/docker-entrypoint.‚Ä¶"   1 second ago   Up Less than a second   80/tcp    proxy
</output_code>
  <markdown>Agora aparece uma nova coluna com a porta, e nos diz que o servidor que acabamos de criar est√° na porta `80` sob o protocolo `tcp`.

Se abrirmos um navegador e tentarmos nos conectar ao servidor atrav√©s de ``http://localhost:80``, n√£o conseguiremos conectar. Isso acontece porque cada cont√™iner tem sua pr√≥pria interface de rede. Ou seja, o servidor est√° ouvindo na porta ``80`` do cont√™iner, mas n√≥s estamos tentando conectar √† porta ``80`` do host.</markdown>
  <markdown>Paramos o cont√™iner para relan√ß√°-lo de outra forma</markdown>
  <input_code>!docker stop proxy</input_code>
  <output_code>proxy
</output_code>
  <markdown>Se listarmos os cont√™ineres, n√£o aparece em execu√ß√£o</markdown>
  <input_code>!docker ps</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
</output_code>
  <markdown>O apagamos para recri√°-lo</markdown>
  <input_code>!docker rm proxy</input_code>
  <output_code>proxy
</output_code>
  <markdown>Se listarmos todos os cont√™ineres, j√° n√£o est√°</markdown>
  <input_code>!docker ps -a</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND               CREATED          STATUS                       PORTS     NAMES
ce4d60427dcd   ubuntu    "tail -f /dev/null"   19 minutes ago   Exited (137) 5 minutes ago             alwaysup
5b633e9d838f   ubuntu    "bash"                24 minutes ago   Exited (0) 20 minutes ago              funny_mirzakhani
da16b3a85178   ubuntu    "bash"                24 minutes ago   Exited (0) 24 minutes ago              hardcore_kare
</output_code>
  <markdown>Para recriar o cont√™iner com o servidor e poder v√™-lo do host, temos que usar a op√ß√£o ``-p`` (``publish``), indicando em primeiro lugar a porta na qual queremos v√™-la no host e em seguida a porta do cont√™iner, ou seja, ``-p &lt;ip host&gt;:&lt;ip cont√™iner&gt;``</markdown>
  <input_code>!docker run -d --name proxy -p 8080:80 nginx</input_code>
  <output_code>c199235e42f76a30266f6e1af972e0a59811806eb3d3a9afdd873f6fa1785eae
</output_code>
  <markdown>Listamos os cont√™ineres</markdown>
  <input_code>!docker ps</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS          PORTS                                   NAMES
c199235e42f7   nginx     "/docker-entrypoint.‚Ä¶"   22 seconds ago   Up 21 seconds   0.0.0.0:8080-&gt;80/tcp, :::8080-&gt;80/tcp   proxy
</output_code>
  <markdown>Vemos que o porto do contentor √© `0.0.0.0:8080-&gt;80/tcp`. Se agora formos a um navegador e introduzirmos `0.0.0.0:8080` poderemos aceder ao servidor do contentor</markdown>
  <markdown>Ao listar os cont√™ineres, na coluna ``PORTS`` indica ``0.0.0.0:8080-&gt;80/tcp``, o que nos ajuda a ver a rela√ß√£o de portas</markdown>
  <markdown>Para ver os logs do cont√™iner, atrav√©s do comando ``docker logs &lt;name&gt;`` posso ver os registros do cont√™iner</markdown>
  <input_code>!docker logs proxy</input_code>
  <output_code>/docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration
/docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d/
/docker-entrypoint.sh: Launching /docker-entrypoint.d/10-listen-on-ipv6-by-default.sh
10-listen-on-ipv6-by-default.sh: info: Getting the checksum of /etc/nginx/conf.d/default.conf
10-listen-on-ipv6-by-default.sh: info: Enabled listen on IPv6 in /etc/nginx/conf.d/default.conf
/docker-entrypoint.sh: Launching /docker-entrypoint.d/20-envsubst-on-templates.sh
/docker-entrypoint.sh: Launching /docker-entrypoint.d/30-tune-worker-processes.sh
/docker-entrypoint.sh: Configuration complete; ready for start up
2022/09/13 13:24:06 [notice] 1#1: using the "epoll" event method
2022/09/13 13:24:06 [notice] 1#1: nginx/1.23.1
2022/09/13 13:24:06 [notice] 1#1: built by gcc 10.2.1 20210110 (Debian 10.2.1-6) 
2022/09/13 13:24:06 [notice] 1#1: OS: Linux 5.15.0-46-generic
2022/09/13 13:24:06 [notice] 1#1: getrlimit(RLIMIT_NOFILE): 1048576:1048576
2022/09/13 13:24:06 [notice] 1#1: start worker processes
2022/09/13 13:24:06 [notice] 1#1: start worker process 31
2022/09/13 13:24:06 [notice] 1#1: start worker process 32
2022/09/13 13:24:06 [notice] 1#1: start worker process 33
2022/09/13 13:24:06 [notice] 1#1: start worker process 34
2022/09/13 13:24:06 [notice] 1#1: start worker process 35
2022/09/13 13:24:06 [notice] 1#1: start worker process 36
2022/09/13 13:24:06 [notice] 1#1: start worker process 37
2022/09/13 13:24:06 [notice] 1#1: start worker process 38
2022/09/13 13:24:06 [notice] 1#1: start worker process 39
2022/09/13 13:24:06 [notice] 1#1: start worker process 40
2022/09/13 13:24:06 [notice] 1#1: start worker process 41
...
172.17.0.1 - - [13/Sep/2022:13:24:40 +0000] "GET /favicon.ico HTTP/1.1" 404 555 "http://0.0.0.0:8080/" "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36" "-"
172.17.0.1 - - [13/Sep/2022:13:25:00 +0000] "\x16\x03\x01\x02\x00\x01\x00\x01\xFC\x03\x03\xE2\x19V$Zqi'\xD7\xFC[\x80\xEF\xBA\xE5\xC7\xE8\xF7&amp;3nS\xEB\xC9\xEC\x91\xC2\xD8\xD1\x89\x9E\xBE \xC7?\xE1\xFA\x04a\x1C\xCE\x90\x0F\x8F\x98u\xE3/\xD8RfOH\xEC\x92+\x93\x5C\xBB\xB1\xBF\xD2m\xB09\x00 \xFA\xFA\x13\x01\x13\x02\x13\x03\xC0+\xC0/\xC0,\xC00\xCC\xA9\xCC\xA8\xC0\x13\xC0\x14\x00\x9C\x00\x9D\x00/\x005\x01\x00\x01\x93\x9A\x9A\x00\x00\x00\x00\x00\x0E\x00\x0C\x00\x00\x09localhost\x00\x17\x00\x00\xFF\x01\x00\x01\x00\x00" 400 157 "-" "-" "-"
172.17.0.1 - - [13/Sep/2022:13:25:00 +0000] "\x16\x03\x01\x02\x00\x01\x00\x01\xFC\x03\x03)\x9A\x8FbC\xD9m\xF1\x86\xEBd\x22\xCF\xC4E\x87#~L\xC1\x84\x7F\xB5\x91k\x98\xABl\xEE\x1E[0 \xD0\xD2`\x85\xC6\x8B\x85R\x8B\x87\xEAq{P\xF2\xFB\xE2\xA8\x9DI\xF4tH\x99\x13\x10~\xCA1-|\x8E\x00 \xEA\xEA\x13\x01\x13\x02\x13\x03\xC0+\xC0/\xC0,\xC00\xCC\xA9\xCC\xA8\xC0\x13\xC0\x14\x00\x9C\x00\x9D\x00/\x005\x01\x00\x01\x93" 400 157 "-" "-" "-"
172.17.0.1 - - [13/Sep/2022:13:26:28 +0000] "GET / HTTP/1.1" 304 0 "-" "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36" "-"
</output_code>
  <markdown>Agora posso ver todas as solicita√ß√µes que foram feitas ao servidor. Mas se eu quiser ver os logs em tempo real, usando ``docker logs -f &lt;name&gt;`` posso fazer isso.</markdown>
  <input_code>!docker logs -f proxy</input_code>
  <output_code />
  <markdown>Agora posso ver os logs em tempo real. Para sair, pressione ``CTRL+C``</markdown>
  <markdown>Como pode chegar um momento em que haja muitos logs, se voc√™ quiser apenas os √∫ltimos logs, atrav√©s da op√ß√£o ``--tail &lt;num&gt;`` voc√™ pode ver os √∫ltimos ``&lt;num&gt;`` logs. Se adicionar a op√ß√£o ``-f`` estaremos vendo sempre os √∫ltimos ``&lt;num&gt;`` logs.</markdown>
  <input_code>!docker logs --tail 10 proxy</input_code>
  <output_code>2022/09/13 13:24:06 [notice] 1#1: start worker process 41
2022/09/13 13:24:06 [notice] 1#1: start worker process 42
172.17.0.1 - - [13/Sep/2022:13:24:16 +0000] "\x16\x03\x01\x02\x00\x01\x00\x01\xFC\x03\x03\x01E\x14\x8E\xB6\x0BEg\xF3\xC9\x9A\x19\x9C\xCA\xEC\xA7y#3\x92\x05\x95\xDCQ\x07\x19\x1D\xEF\xEA$\xBF# \x0B\x83\xF7-,s\x1B!r\xEA|\xAE\xDF\xA1\x9DLZ\xAA4y\xB3t\xAB\xC0\xCE_\xB8\xE7\xFF'\xCF\x86\x00 \xEA\xEA\x13\x01\x13\x02\x13\x03\xC0+\xC0/\xC0,\xC00\xCC\xA9\xCC\xA8\xC0\x13\xC0\x14\x00\x9C\x00\x9D\x00/\x005\x01\x00\x01\x93\x8A\x8A\x00\x00\x00\x00\x00\x0E\x00\x0C\x00\x00\x09localhost\x00\x17\x00\x00\xFF\x01\x00\x01\x00\x00" 400 157 "-" "-" "-"
172.17.0.1 - - [13/Sep/2022:13:24:16 +0000] "\x16\x03\x01\x02\x00\x01\x00\x01\xFC\x03\x03}\xA9Dr{\x8C;\x90z\x82\xAD\xBC\x8Az\xC2x\xDF\x1E\x9A\xE6l?\xA7\xE0DoK\x91'g\xBB\xB5 %\xBB\xFD\xD9\x82?\xDB\x80\xB3T\xF6cJ\xF7\xE5\xC2\xD2\x11\xBC\xA2\x1F\x90\x14\xA3\xEB\xBD=R\xBC\x83\x89\x85\x00 \xCA\xCA\x13\x01\x13\x02\x13\x03\xC0+\xC0/\xC0,\xC00\xCC\xA9\xCC\xA8\xC0\x13\xC0\x14\x00\x9C\x00\x9D\x00/\x005\x01\x00\x01\x93\x9A\x9A\x00\x00\x00\x00\x00\x0E\x00\x0C\x00\x00\x09localhost\x00\x17\x00\x00\xFF\x01\x00\x01\x00\x00" 400 157 "-" "-" "-"
172.17.0.1 - - [13/Sep/2022:13:24:39 +0000] "GET / HTTP/1.1" 200 615 "-" "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36" "-"
2022/09/13 13:24:40 [error] 34#34: *3 open() "/usr/share/nginx/html/favicon.ico" failed (2: No such file or directory), client: 172.17.0.1, server: localhost, request: "GET /favicon.ico HTTP/1.1", host: "0.0.0.0:8080", referrer: "http://0.0.0.0:8080/"
172.17.0.1 - - [13/Sep/2022:13:24:40 +0000] "GET /favicon.ico HTTP/1.1" 404 555 "http://0.0.0.0:8080/" "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36" "-"
172.17.0.1 - - [13/Sep/2022:13:25:00 +0000] "\x16\x03\x01\x02\x00\x01\x00\x01\xFC\x03\x03\xE2\x19V$Zqi'\xD7\xFC[\x80\xEF\xBA\xE5\xC7\xE8\xF7&amp;3nS\xEB\xC9\xEC\x91\xC2\xD8\xD1\x89\x9E\xBE \xC7?\xE1\xFA\x04a\x1C\xCE\x90\x0F\x8F\x98u\xE3/\xD8RfOH\xEC\x92+\x93\x5C\xBB\xB1\xBF\xD2m\xB09\x00 \xFA\xFA\x13\x01\x13\x02\x13\x03\xC0+\xC0/\xC0,\xC00\xCC\xA9\xCC\xA8\xC0\x13\xC0\x14\x00\x9C\x00\x9D\x00/\x005\x01\x00\x01\x93\x9A\x9A\x00\x00\x00\x00\x00\x0E\x00\x0C\x00\x00\x09localhost\x00\x17\x00\x00\xFF\x01\x00\x01\x00\x00" 400 157 "-" "-" "-"
172.17.0.1 - - [13/Sep/2022:13:25:00 +0000] "\x16\x03\x01\x02\x00\x01\x00\x01\xFC\x03\x03)\x9A\x8FbC\xD9m\xF1\x86\xEBd\x22\xCF\xC4E\x87#~L\xC1\x84\x7F\xB5\x91k\x98\xABl\xEE\x1E[0 \xD0\xD2`\x85\xC6\x8B\x85R\x8B\x87\xEAq{P\xF2\xFB\xE2\xA8\x9DI\xF4tH\x99\x13\x10~\xCA1-|\x8E\x00 \xEA\xEA\x13\x01\x13\x02\x13\x03\xC0+\xC0/\xC0,\xC00\xCC\xA9\xCC\xA8\xC0\x13\xC0\x14\x00\x9C\x00\x9D\x00/\x005\x01\x00\x01\x93" 400 157 "-" "-" "-"
172.17.0.1 - - [13/Sep/2022:13:26:28 +0000] "GET / HTTP/1.1" 304 0 "-" "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36" "-"
</output_code>
  <markdown>Se adicionarmos a op√ß√£o `-t`, podemos ver a data e hora de cada log. Dessa forma, se tivermos um problema, podemos saber em que momento ele ocorreu.</markdown>
  <input_code>!docker logs --tail -t 10 proxy</input_code>
  <output_code>2022-09-13T13:24:06.573362728Z 2022/09/13 13:24:06 [notice] 1#1: start worker process 41
2022-09-13T13:24:06.651127107Z 2022/09/13 13:24:06 [notice] 1#1: start worker process 42
2022-09-13T13:24:16.651160189Z 172.17.0.1 - - [13/Sep/2022:13:24:16 +0000] "\x16\x03\x01\x02\x00\x01\x00\x01\xFC\x03\x03\x01E\x14\x8E\xB6\x0BEg\xF3\xC9\x9A\x19\x9C\xCA\xEC\xA7y#3\x92\x05\x95\xDCQ\x07\x19\x1D\xEF\xEA$\xBF# \x0B\x83\xF7-,s\x1B!r\xEA|\xAE\xDF\xA1\x9DLZ\xAA4y\xB3t\xAB\xC0\xCE_\xB8\xE7\xFF'\xCF\x86\x00 \xEA\xEA\x13\x01\x13\x02\x13\x03\xC0+\xC0/\xC0,\xC00\xCC\xA9\xCC\xA8\xC0\x13\xC0\x14\x00\x9C\x00\x9D\x00/\x005\x01\x00\x01\x93\x8A\x8A\x00\x00\x00\x00\x00\x0E\x00\x0C\x00\x00\x09localhost\x00\x17\x00\x00\xFF\x01\x00\x01\x00\x00" 400 157 "-" "-" "-"
2022-09-13T13:24:16.116817914Z 172.17.0.1 - - [13/Sep/2022:13:24:16 +0000] "\x16\x03\x01\x02\x00\x01\x00\x01\xFC\x03\x03}\xA9Dr{\x8C;\x90z\x82\xAD\xBC\x8Az\xC2x\xDF\x1E\x9A\xE6l?\xA7\xE0DoK\x91'g\xBB\xB5 %\xBB\xFD\xD9\x82?\xDB\x80\xB3T\xF6cJ\xF7\xE5\xC2\xD2\x11\xBC\xA2\x1F\x90\x14\xA3\xEB\xBD=R\xBC\x83\x89\x85\x00 \xCA\xCA\x13\x01\x13\x02\x13\x03\xC0+\xC0/\xC0,\xC00\xCC\xA9\xCC\xA8\xC0\x13\xC0\x14\x00\x9C\x00\x9D\x00/\x005\x01\x00\x01\x93\x9A\x9A\x00\x00\x00\x00\x00\x0E\x00\x0C\x00\x00\x09localhost\x00\x17\x00\x00\xFF\x01\x00\x01\x00\x00" 400 157 "-" "-" "-"
2022-09-13T13:24:39.117398081Z 172.17.0.1 - - [13/Sep/2022:13:24:39 +0000] "GET / HTTP/1.1" 200 615 "-" "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36" "-"
2022-09-13T13:24:39.117412408Z 2022/09/13 13:24:40 [error] 34#34: *3 open() "/usr/share/nginx/html/favicon.ico" failed (2: No such file or directory), client: 172.17.0.1, server: localhost, request: "GET /favicon.ico HTTP/1.1", host: "0.0.0.0:8080", referrer: "http://0.0.0.0:8080/"
2022-09-13T13:24:40.117419389Z 172.17.0.1 - - [13/Sep/2022:13:24:40 +0000] "GET /favicon.ico HTTP/1.1" 404 555 "http://0.0.0.0:8080/" "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36" "-"
2022-09-13T13:25:00.117434249Z 172.17.0.1 - - [13/Sep/2022:13:25:00 +0000] "\x16\x03\x01\x02\x00\x01\x00\x01\xFC\x03\x03\xE2\x19V$Zqi'\xD7\xFC[\x80\xEF\xBA\xE5\xC7\xE8\xF7&amp;3nS\xEB\xC9\xEC\x91\xC2\xD8\xD1\x89\x9E\xBE \xC7?\xE1\xFA\x04a\x1C\xCE\x90\x0F\x8F\x98u\xE3/\xD8RfOH\xEC\x92+\x93\x5C\xBB\xB1\xBF\xD2m\xB09\x00 \xFA\xFA\x13\x01\x13\x02\x13\x03\xC0+\xC0/\xC0,\xC00\xCC\xA9\xCC\xA8\xC0\x13\xC0\x14\x00\x9C\x00\x9D\x00/\x005\x01\x00\x01\x93\x9A\x9A\x00\x00\x00\x00\x00\x0E\x00\x0C\x00\x00\x09localhost\x00\x17\x00\x00\xFF\x01\x00\x01\x00\x00" 400 157 "-" "-" "-"
2022-09-13T13:25:00.223560881Z 172.17.0.1 - - [13/Sep/2022:13:25:00 +0000] "\x16\x03\x01\x02\x00\x01\x00\x01\xFC\x03\x03)\x9A\x8FbC\xD9m\xF1\x86\xEBd\x22\xCF\xC4E\x87#~L\xC1\x84\x7F\xB5\x91k\x98\xABl\xEE\x1E[0 \xD0\xD2`\x85\xC6\x8B\x85R\x8B\x87\xEAq{P\xF2\xFB\xE2\xA8\x9DI\xF4tH\x99\x13\x10~\xCA1-|\x8E\x00 \xEA\xEA\x13\x01\x13\x02\x13\x03\xC0+\xC0/\xC0,\xC00\xCC\xA9\xCC\xA8\xC0\x13\xC0\x14\x00\x9C\x00\x9D\x00/\x005\x01\x00\x01\x93" 400 157 "-" "-" "-"
2022-09-13T13:26:25.223596738Z 172.17.0.1 - - [13/Sep/2022:13:26:28 +0000] "GET / HTTP/1.1" 304 0 "-" "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36" "-"
</output_code>
  <markdown>Paramos e apagamos o cont√™iner</markdown>
  <input_code>!docker rm -f proxy</input_code>
  <output_code>proxy
</output_code>
  <input_code>!docker ps -a</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND               CREATED          STATUS                        PORTS     NAMES
ce4d60427dcd   ubuntu    "tail -f /dev/null"   26 minutes ago   Exited (137) 13 minutes ago             alwaysup
5b633e9d838f   ubuntu    "bash"                31 minutes ago   Exited (0) 27 minutes ago               funny_mirzakhani
da16b3a85178   ubuntu    "bash"                32 minutes ago   Exited (0) 32 minutes ago               hardcore_kare
</output_code>
  <markdown>## Dados no Docker</markdown>
  <markdown>### Montagens bind</markdown>
  <markdown>Vamos ver os cont√™ineres que temos parados</markdown>
  <input_code>!docker ps -a</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND               CREATED          STATUS                        PORTS     NAMES
ce4d60427dcd   ubuntu    "tail -f /dev/null"   26 minutes ago   Exited (137) 13 minutes ago             alwaysup
5b633e9d838f   ubuntu    "bash"                31 minutes ago   Exited (0) 28 minutes ago               funny_mirzakhani
da16b3a85178   ubuntu    "bash"                32 minutes ago   Exited (0) 32 minutes ago               hardcore_kare
</output_code>
  <markdown>Vamos a apagar os dois do Ubuntu nos quais seu comando principal √© o Bash e vamos deixar o que ficou como n√£o opera√ß√£o.</markdown>
  <input_code>!docker rm funny_mirzakhani</input_code>
  <output_code>funny_mirzakhani
</output_code>
  <input_code>!docker rm hardcore_kare</input_code>
  <output_code>hardcore_kare
</output_code>
  <input_code>!docker ps -a</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND               CREATED          STATUS                        PORTS     NAMES
ce4d60427dcd   ubuntu    "tail -f /dev/null"   27 minutes ago   Exited (137) 14 minutes ago             alwaysup
</output_code>
  <markdown>Vamos a voltar a executar o cont√™iner do Ubuntu que deixamos, isso √© feito atrav√©s do comando `start`</markdown>
  <input_code>!docker start alwaysup</input_code>
  <output_code>alwaysup
</output_code>
  <markdown>N√≥s entramos novamente dentro de el</markdown>
  <input_code>!docker exec -it alwaysup bash</input_code>
  <output_code>root@ce4d60427dcd:/#
</output_code>
  <markdown>No cont√™iner, posso criar uma nova pasta chamada `dockerfolder`</markdown>
  <input_code>!mkdir dockerfolder</input_code>
  <output_code />
  <markdown>Se listarmos os arquivos, aparecer√° a nova pasta</markdown>
  <input_code>!ls</input_code>
  <output_code>bin  boot  dev  dockerfolder  etc  home  lib  lib32  lib64  libx32  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</output_code>
  <markdown>Se sairmos do cont√™iner</markdown>
  <input_code>!exit</input_code>
  <output_code>exit</output_code>
  <markdown>E o apagamos</markdown>
  <input_code>!docker rm -f alwaysup</input_code>
  <output_code>alwaysup
</output_code>
  <markdown>Se listarmos todos os cont√™ineres, o √∫ltimo que criamos j√° n√£o aparece.</markdown>
  <input_code>!docker ps -a</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
</output_code>
  <markdown>Vamos a fazer tudo de novo, mas primeiro vamos criar uma pasta no host na qual compartilharemos os dados com o cont√™iner</markdown>
  <input_code>!mkdir dockerHostFolder</input_code>
  <markdown>Vemos que dentro da pasta n√£o h√° nada</markdown>
  <input_code>!ls dockerHostFolder</input_code>
  <markdown>Agora obtemos nosso caminho absoluto</markdown>
  <input_code>!pwd</input_code>
  <output_code>/home/wallabot/Documentos/web/portafolio/posts
</output_code>
  <markdown>Recriamos o cont√™iner, mas adicionando a op√ß√£o ``-v`` (``bind mount``). Em seguida, adiciona-se o caminho absoluto da pasta do host e o caminho absoluto da pasta no cont√™iner, ``-v &lt;host path&gt;:&lt;container path&gt;``.</markdown>
  <input_code>!docker run -d --name alwaysup -v ~/Documentos/web/portafolio/posts/dockerHostFolder:/dockerContainerFolder ubuntu tail -f /dev/null</input_code>
  <output_code>4ede4512c293bdcc155e9c8e874dfb4a28e5163f4d5c7ddda24ad2863f28921b
</output_code>
  <markdown>Entreamos no contentor, listamos os arquivos e j√° aparece a pasta que hav√≠amos criado</markdown>
  <input_code>!docker exec -it alwaysup bash</input_code>
  <output_code>root@4ede4512c293:/#</output_code>
  <input_code>root@4ede4512c293:/# ls</input_code>
  <output_code>bin   dev                    etc   lib    lib64   media  opt   root  sbin  sys  usr
boot  dockerContainerFolder  home  lib32  libx32  mnt    proc  run   srv   tmp  var
</output_code>
  <markdown>Vamos ao diret√≥rio do cont√™iner que compartilhamos, criamos um arquivo e sa√≠mos do cont√™iner</markdown>
  <input_code>root@4ede4512c293:/# cd dockerContainerFolder</input_code>
  <output_code />
  <input_code>root@4ede4512c293:/dockerContainerFolder# touch bindFile.txt</input_code>
  <output_code />
  <input_code>root@4ede4512c293:/dockerContainerFolder# exit</input_code>
  <output_code>exit</output_code>
  <markdown>Vamos ver o que tem dentro da pasta compartida</markdown>
  <input_code>!ls dockerHostFolder</input_code>
  <output_code>bindFile.txt
</output_code>
  <markdown>Mas ainda, se apagarmos o cont√™iner, o arquivo continua l√°.</markdown>
  <input_code>!docker rm -f alwaysup</input_code>
  <output_code>alwaysup
</output_code>
  <input_code>!ls dockerHostFolder</input_code>
  <output_code>bindFile.txt
</output_code>
  <markdown>Se eu criar novamente um cont√™iner compartilhando as pastas, todos os arquivos estar√£o no cont√™iner.</markdown>
  <input_code>!docker run -d --name alwaysup -v ~/Documentos/web/portafolio/posts/dockerHostFolder:/dockerContainerFolder ubuntu tail -f /dev/null</input_code>
  <output_code>6c021d37ea29d8b23fe5cd4968baa446085ae1756682f65340288b4c851c362d
</output_code>
  <input_code>!docker exec -it alwaysup bash</input_code>
  <output_code>root@6c021d37ea29:/#</output_code>
  <input_code>!root@6c021d37ea29:/# ls dockerContainerFolder/</input_code>
  <output_code>bindFile.txt:/#</output_code>
  <markdown>Eliminamos o cont√™iner</markdown>
  <input_code>!docker rm -f alwaysup</input_code>
  <output_code>alwaysup
</output_code>
  <input_code>!docker ps -a</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
</output_code>
  <markdown>### Volumes</markdown>
  <markdown>Os volumes foram criados como uma evolu√ß√£o dos ``bind mounts`` para fornecer mais seguran√ßa. Podemos listar todos os volumes do Docker usando ``docker volume ls``.</markdown>
  <input_code>!docker volume ls</input_code>
  <output_code>DRIVER    VOLUME NAME
</output_code>
  <markdown>Vamos a criar um novo volume para o cont√™iner do Ubuntu, para isso usamos o comando ``docker volume create &lt;nome_do_volume&gt;``</markdown>
  <input_code>!docker volume create ubuntuVolume</input_code>
  <output_code>ubuntuVolume
</output_code>
  <markdown>Se listarmos os volumes novamente, aparecer√° o que acabamos de criar.</markdown>
  <input_code>!docker volume ls</input_code>
  <output_code>DRIVER    VOLUME NAME
local     ubuntuVolume
</output_code>
  <markdown>No entanto, n√£o aparece como uma pasta no sistema de arquivos do host. Com `ls -d */` listamos todas as pastas</markdown>
  <input_code>!ls -d */</input_code>
  <output_code>dockerHostFolder/  __pycache__/
</output_code>
  <markdown>Vamos a voltar a criar um cont√™iner, mas agora o criamos com o volume que acabamos de criar com a op√ß√£o ``--mount``, indicando o volume fonte mediante ``src=&lt;nome do volume&gt;`` (se o volume n√£o existisse, docker o criaria), a seguir o destino separado por uma ``,``, ``dst=&lt;caminho do cont√™iner&gt;``, ou seja ``--mount src=&lt;nome do volume&gt;,dst=&lt;caminho do cont√™iner&gt;``</markdown>
  <input_code>!docker run -d --name alwaysup --mount src=ubuntuVolume,dst=/dockerVolumeFolder ubuntu tail -f /dev/null</input_code>
  <output_code>42cdcddf4e46dc298a87b0570115e0b2fc900cb4c6db5eea22a61409b8cb271d
</output_code>
  <markdown>Uma vez criado, podemos ver os volumes do cont√™iner usando o comando ``inspect`` e filtrando por `'{{.Mounts}}'`

```bash
$ docker inspect --format '{{.Mountns}}' alwaysup
[
    {
        volume ubuntuVolume /var/lib/docker/volumes/ubuntuVolume/_data /dockerVolumeFolder local z true
    }
]
```</markdown>
  <markdown>Vemos que o volume se chama `ubuntuVolume` e al√©m disso podemos ver o caminho onde est√° armazenado, neste caso em `/var/lib/docker/volumes/ubuntuVolume/_data`. Fazemos o mesmo que antes, entramos no cont√™iner, criamos um arquivo no caminho do volume, sa√≠mos e vemos no host se foi criado.

```bash
$ docker exec -it alwaysup bash
root@42cdcddf4e46:/# touch dockerVolumeFolder/volumeFile.txt
root@42cdcddf4e46:/# exit
```


```bash
$ sudo ls /var/lib/docker/volumes/ubuntuVolume/_data
volumeFile.txt
```</markdown>
  <markdown>O arquivo est√° criado.</markdown>
  <markdown>### Inserir e extrair arquivos de um cont√™iner</markdown>
  <markdown>Primeiro vamos criar um arquivo que queremos copiar dentro de um cont√™iner</markdown>
  <input_code>!touch dockerHostFolder/text.txt</input_code>
  <markdown>Entramos no cont√™iner

```bash
$ docker exec -it alwaysup bash
root@42cdcddf4e46:/#
```</markdown>
  <markdown>Criamos uma nova pasta onde vamos copiar o arquivo e sair.

```bash
root@42cdcddf4e46:/# mkdir folderToCopy
root@42cdcddf4e46:/# ls
bin  boot  dev  dockerVolumeFolder  etc  folderToCopy  home  lib  lib32  lib64  libx32  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
root@42cdcddf4e46:/# exit
sair
```</markdown>
  <markdown>Copiamos dentro do cont√™iner o arquivo por meio do comando ``cp``, indicando o arquivo que **quero** copiar, o cont√™iner onde queremos copi√°-lo e o caminho dentro do cont√™iner, ``docker cp &lt;file&gt; &lt;container&gt;:&lt;container path&gt;``</markdown>
  <input_code>!docker cp dockerHostFolder/text.txt alwaysup:/folderToCopy</input_code>
  <markdown>Voltamos a entrar no cont√™iner e verificamos se o arquivo est√° l√°.

```bash
$ docker exec -it alwaysup bash
root@42cdcddf4e46:/# ls folderToCopy/
Parece que hay un malentendido. No has proporcionado el contenido de `text.txt` para que pueda traducirlo. Por favor, comparte el texto markdown que deseas traducir al portugu√©s.
```</markdown>
  <markdown>Sair do cont√™iner

```bash
/# sair
sa√≠da
```</markdown>
  <markdown>Agora vamos extrair o arquivo do cont√™iner e salv√°-lo no host com outro nome. Para isso, usamos novamente o comando ``cp``, mas indicando agora o cont√™iner, o caminho do arquivo no cont√™iner e o caminho e nome que queremos que o arquivo tenha no host, ``docker cp &lt;container&gt;:&lt;caminho_do_arquivo_no_docker&gt; &lt;caminho_do_arquivo_no_host&gt;``</markdown>
  <input_code>!docker cp alwaysup:/folderToCopy/text.txt dockerHostFolder/fileExtract.txt</input_code>
  <markdown>Vemos que est√° no host</markdown>
  <input_code>!ls dockerHostFolder</input_code>
  <output_code>bindFile.txt  fileExtract.txt  text.txt
</output_code>
  <markdown>Embora o cont√™iner esteja parado, tamb√©m √© poss√≠vel copiar arquivos.</markdown>
  <markdown>Por √∫ltimo, apagamos o cont√™iner</markdown>
  <input_code>!docker rm -f alwaysup</input_code>
  <output_code>alwaysup
</output_code>
  <markdown>## Imagens</markdown>
  <markdown>### Conceitos fundamentais</markdown>
  <markdown>As imagens s√£o os arquivos ("modelos") com toda a configura√ß√£o para criar um cont√™iner. Cada vez que criamos um cont√™iner, ele √© criado a partir de uma imagem. Quando cri√°vamos cont√™ineres novos, a primeira vez aparecia uma mensagem dizendo que n√£o t√≠nhamos a imagem e que iria baix√°-la. No Docker Hub existem muitas imagens com todo tipo de m√°quinas, mas para um ambiente de desenvolvimento muito espec√≠fico podemos criar nosso pr√≥prio modelo para pass√°-lo a algu√©m e trabalhar em um cont√™iner com a mesma configura√ß√£o que o nosso.</markdown>
  <markdown>Podemos ver todas as imagens que temos salvas no nosso computador atrav√©s do comando ``docker image ls``</markdown>
  <input_code>!docker image ls</input_code>
  <output_code>REPOSITORY    TAG       IMAGE ID       CREATED         SIZE
nginx         latest    2d389e545974   8 hours ago     142MB
ubuntu        latest    2dc39ba059dc   11 days ago     77.8MB
hello-world   latest    feb5d9fea6a5   11 months ago   13.3kB
</output_code>
  <markdown>Podemos ver os tamanhos, e podemos ver como a de `nginx` ocupa muito e por isso demorou mais para baixar do que as outras.</markdown>
  <markdown>Outra coluna que podemos ver √© a de ``TAG``, isso indica a vers√£o da imagem. Em todas est√° escrito ``latest``, o que significa que √© a mais recente. Isso significa que, no momento do download, baixamos a √∫ltima vers√£o dispon√≠vel no Docker Hub. Isso n√£o √© ideal em um ambiente de desenvolvimento, pois podemos baixar uma imagem do Ubuntu sem especificar a vers√£o, por exemplo, a 20.04. Mas depois de algum tempo, algu√©m pode querer desenvolver com voc√™ e baixar essa imagem, mas como a vers√£o n√£o foi especificada, ser√° baixada novamente a mais recente, que no caso pode ser a 22.04. Isso pode levar a problemas e fazer com que algo funcione para uma pessoa e n√£o para a outra.</markdown>
  <markdown>Podemos ver todas as imagens que h√° no Docker Hub indo a `https://hub.docker.com/`. L√° voc√™ poder√° buscar a imagem que melhor se adapte ao projeto que quiser fazer. Se navegarmos at√© a imagem do Ubuntu, por exemplo, podemos ver as vers√µes (`tags`) das imagens.</markdown>
  <markdown>Vamos a baixar, **mas n√£o executar** uma imagem. Para isso usamos o comando ``docker pull &lt;hub&gt; &lt;image name&gt;:&lt;tag&gt;``. Se n√£o indicarmos o hub, ele ser√° baixado do docker hub por padr√£o, mas podemos indicar outro, por exemplo um privado da nossa organiza√ß√£o. Tamb√©m, se n√£o indicarmos o tag, por padr√£o baixar√° a √∫ltima vers√£o.</markdown>
  <input_code>!docker pull ubuntu:20.04</input_code>
  <output_code>20.04: Pulling from library/ubuntu

[1BDigest: sha256:35ab2bf57814e9ff49e365efd5a5935b6915eede5c7f8581e9e1b85e0eecbe16[1A[2K[1A[2K[1A[2K[1A[2K[1A[2K[1A[2K[1A[2K[1A[2K[1A[2K
Status: Downloaded newer image for ubuntu:20.04
docker.io/library/ubuntu:20.04
</output_code>
  <markdown>Se voltarmos a listar as imagens, veremos que agora temos duas imagens do Ubuntu, uma com o tag `20.04` e outra com o tag `latest`</markdown>
  <input_code>!docker image ls</input_code>
  <output_code>REPOSITORY    TAG       IMAGE ID       CREATED         SIZE
nginx         latest    2d389e545974   8 hours ago     142MB
ubuntu        latest    2dc39ba059dc   11 days ago     77.8MB
ubuntu        20.04     a0ce5a295b63   11 days ago     72.8MB
hello-world   latest    feb5d9fea6a5   11 months ago   13.3kB
</output_code>
  <markdown>### Criar imagens atrav√©s de `Dockerfile`</markdown>
  <markdown>Criamos um diret√≥rio no host chamado `dockerImages` para trabalhar nele.</markdown>
  <input_code>!mkdir dockerImages</input_code>
  <markdown>Criamos um arquivo `Dockerfile` com o qual criaremos uma imagem</markdown>
  <input_code>!touch dockerImages/Dockerfile</input_code>
  <markdown>Abrimos o arquivo criado com nosso editor preferido e escrevemos o seguinte:

```Dockerfile
FROM ubuntu:latest
```

Isso diz ao Docker para criar a imagem a partir da imagem `latest` do Ubuntu.</markdown>
  <markdown>A seguir, escrevemos um comando que ser√° executado em tempo de compila√ß√£o

```Dockerfile
RUN touch /test.txt
```

Isso significa que quando o `Dockerfile` for compilado, esse comando ser√° executado, mas n√£o quando o cont√™iner da imagem for executado.</markdown>
  <markdown>No final o `Dockerfile` fica assim:
```dockerfile
FROM ubuntu:latest
RUN touch /test.txt
```</markdown>
  <markdown>Compilamos o `Dockerfile` atrav√©s do comando `build`, com a op√ß√£o `-t` podemos dar-lhe um `tag`. Por √∫ltimo, √© necess√°rio indicar a rota do contexto de `build`, mais tarde explicaremos isso.</markdown>
  <input_code>!docker build -t ubuntu:test ./dockerImages</input_code>
  <output_code>Sending build context to Docker daemon  2.048kB
Step 1/2 : FROM ubuntu:latest
 ---&gt; 2dc39ba059dc
Step 2/2 : RUN touch /test.txt
 ---&gt; Using cache
 ---&gt; a78cf3ea16d8
Successfully built a78cf3ea16d8
Successfully tagged ubuntu:test

Use 'docker scan' to run Snyk tests against images to find vulnerabilities and learn how to fix them
</output_code>
  <markdown>Como podemos ver, a compila√ß√£o ocorre em 2 etapas, cada uma possui uma `id`, cada uma dessas `id`s s√£o camadas da imagem, isso tamb√©m ser√° abordado posteriormente.

Voltamos a ver as imagens que temos salvias no nosso computador e aparece a que acabamos de criar</markdown>
  <input_code>!docker image ls</input_code>
  <output_code>REPOSITORY    TAG       IMAGE ID       CREATED         SIZE
ubuntu        test      a78cf3ea16d8   8 minutes ago   77.8MB
nginx         latest    2d389e545974   8 hours ago     142MB
ubuntu        latest    2dc39ba059dc   11 days ago     77.8MB
ubuntu        20.04     a0ce5a295b63   11 days ago     72.8MB
hello-world   latest    feb5d9fea6a5   11 months ago   13.3kB
</output_code>
  <markdown>Executamos o cont√™iner a partir da imagem que acabamos de criar

```bash
$ docker run -it ubuntu:test
root@b57b9d4eedeb:/#
```

Entramos no bash do cont√™iner. Como dissemos, o comando RUN √© executado durante a compila√ß√£o da imagem, portanto, o arquivo que pedimos para ser criado deve estar em nosso cont√™iner.

```bash
root@b57b9d4eedeb:/# ls
bin  boot  dev  etc  home  lib  lib32  lib64  libx32  media  mnt  opt  proc  root  run  sbin  srv  sys  test.txt  tmp  usr  var
```

√â importante entender que esse arquivo foi criado quando a imagem foi constru√≠da, ou seja, a imagem do cont√™iner j√° possui esse arquivo. Ele n√£o √© criado quando o cont√™iner √© iniciado.

Saimos do cont√™iner

```bash
root@b57b9d4eedeb:/# exit
sa√≠da
```</markdown>
  <markdown>J√° que j√° temos uma imagem, poder√≠amos envi√°-la para o hub do Docker, mas vamos listar as imagens novamente antes disso.</markdown>
  <input_code>!docker image ls</input_code>
  <output_code>REPOSITORY    TAG       IMAGE ID       CREATED          SIZE
ubuntu        test      a78cf3ea16d8   20 minutes ago   77.8MB
nginx         latest    2d389e545974   8 hours ago      142MB
ubuntu        latest    2dc39ba059dc   11 days ago      77.8MB
ubuntu        20.04     a0ce5a295b63   11 days ago      72.8MB
hello-world   latest    feb5d9fea6a5   11 months ago    13.3kB
</output_code>
  <markdown>Se v√™, est√° nos dizendo que a imagem que acabamos de criar pertence ao reposit√≥rio do Ubuntu, mas n√≥s n√£o temos acesso ao reposit√≥rio do Ubuntu, ent√£o no Docker Hub precisamos criar uma conta para poder enviar a imagem ao nosso reposit√≥rio. No meu caso, meu reposit√≥rio se chama `maximofn`, ent√£o altero o reposit√≥rio da imagem usando o comando `tag`, indicando a imagem que queremos mudar de reposit√≥rio e o novo reposit√≥rio. No novo reposit√≥rio, geralmente indica-se o nome do reposit√≥rio seguido do tipo de imagem e o tag, no meu caso `maximofn/ubuntu:test`</markdown>
  <input_code>!docker tag ubuntu:test maximofn/ubuntu:test</input_code>
  <markdown>Se agora listarmos as imagens novamente</markdown>
  <input_code>!docker image ls</input_code>
  <output_code>REPOSITORY        TAG       IMAGE ID       CREATED          SIZE
ubuntu            test      a78cf3ea16d8   24 minutes ago   77.8MB
maximofn/ubuntu   test      a78cf3ea16d8   24 minutes ago   77.8MB
nginx             latest    2d389e545974   8 hours ago      142MB
ubuntu            latest    2dc39ba059dc   11 days ago      77.8MB
ubuntu            20.04     a0ce5a295b63   11 days ago      72.8MB
hello-world       latest    feb5d9fea6a5   11 months ago    13.3kB
</output_code>
  <markdown>Agora devemos fazer login no Docker Hub para poder enviar a imagem, para isso usamos o comando `login`

```bash
$ docker login
Fa√ßa login com seu Docker ID para enviar e receber imagens do Docker Hub. Se voc√™ n√£o tiver um Docker ID, v√° at√© https://hub.docker.com para criar um.
Nome de usu√°rio: maximofn
Senha:

Login bem-sucedido
```</markdown>
  <markdown>Agora podemos fazer o upload da imagem atrav√©s do comando `push`</markdown>
  <input_code>!docker push maximofn/ubuntu:test</input_code>
  <output_code>The push refers to repository [docker.io/maximofn/ubuntu]

[1B06994357: Preparing 
[2B06994357: Pushed  from library/ubuntu [2A[2Ktest: digest: sha256:318d83fc3c35ff930d695b0dc1c5ad1b0ea54e1ec6e3478b8ca85c05fd793c4e size: 735
</output_code>
  <markdown>Ele apenas carregou a primeira camada, a segunda, como usei a partir da imagem do Ubuntu, o que faz √© colocar um ponteiro para essa imagem para n√£o ter camadas carregadas mais de uma vez.</markdown>
  <markdown>Deve-se ter em conta que este reposit√≥rio √© p√∫blico, portanto n√£o deve enviar imagens com dados sens√≠veis. Al√©m disso, se uma imagem n√£o tiver uso em 6 meses, ela ser√° exclu√≠da.</markdown>
  <markdown>### O sistema de camadas</markdown>
  <markdown>Com o comando `history` podemos ver as camadas de uma imagem. Se formos ver as camadas da imagem que acabamos de criar, usamos `docker history ubuntu:test`</markdown>
  <input_code>!docker history ubuntu:test</input_code>
  <output_code>IMAGE          CREATED        CREATED BY                                      SIZE      COMMENT
a78cf3ea16d8   3 minutes ago  /bin/sh -c touch /test.txt                      0B        
2dc39ba059dc   12 days ago    /bin/sh -c #(nop)  CMD ["bash"]                 0B        
&lt;missing&gt;      12 days ago    /bin/sh -c #(nop) ADD file:a7268f82a86219801‚Ä¶   77.8MB    
</output_code>
  <markdown>Vemos que a primeira camada tem o comando que introduzimos no `Dockerfile`, al√©m de dizer que foi criada h√° 3 minutos. No entanto, o resto das camadas foram criadas h√° 12 dias, e s√£o as camadas da imagem do Ubuntu na qual nos baseamos.</markdown>
  <markdown>Ao `Dockerfile` que criamos anteriormente adicionamos a linha

```docker
RUN rm /test.txt
```</markdown>
  <markdown>No final o `Dockerfile` fica assim:
```dockerfile
FROM ubuntu:latest
RUN touch /test.txt
RUN rm /test.txt
```</markdown>
  <markdown>Se recompilarmos, veremos o que acontece</markdown>
  <input_code>!docker build -t ubuntu:test ./dockerImages</input_code>
  <output_code>Sending build context to Docker daemon  2.048kB
Step 1/3 : FROM ubuntu:latest
 ---&gt; 2dc39ba059dc
Step 2/3 : RUN touch /test.txt
 ---&gt; Using cache
 ---&gt; a78cf3ea16d8
Step 3/3 : RUN rm /test.txt
 ---&gt; Running in c2e6887f2025
Removing intermediate container c2e6887f2025
 ---&gt; 313243a9b573
Successfully built 313243a9b573
Successfully tagged ubuntu:test

Use 'docker scan' to run Snyk tests against images to find vulnerabilities and learn how to fix them
</output_code>
  <markdown>Como podemos ver, h√° uma camada adicional com a nova linha que adicionamos. Se voltarmos a ver as camadas da imagem com `history`</markdown>
  <input_code>!docker history ubuntu:test</input_code>
  <output_code>IMAGE          CREATED              CREATED BY                                      SIZE      COMMENT
313243a9b573   About a minute ago   /bin/sh -c rm /test.txt                         0B        
a78cf3ea16d8   3 minutes ago        /bin/sh -c touch /test.txt                      0B        
2dc39ba059dc   12 days ago          /bin/sh -c #(nop)  CMD ["bash"]                 0B        
&lt;missing&gt;      12 days ago          /bin/sh -c #(nop) ADD file:a7268f82a86219801‚Ä¶   77.8MB    
</output_code>
  <markdown>Vemos que as primeiras camadas s√£o iguais √†s de antes e adicionou uma nova camada com o novo comando</markdown>
  <markdown>### Pesquisa no Docker Hub</markdown>
  <markdown>N√£o √© necess√°rio entrar na p√°gina do Docker Hub para procurar imagens, isso pode ser feito diretamente da terminal. Para isso, usamos o comando `docker search &lt;nome da imagem&gt;`</markdown>
  <input_code>!docker search ubuntu</input_code>
  <output_code>NAME                             DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
ubuntu                           Ubuntu is a Debian-based Linux operating sys‚Ä¶   16425     [OK]       
websphere-liberty                WebSphere Liberty multi-architecture images ‚Ä¶   297       [OK]       
open-liberty                     Open Liberty multi-architecture images based‚Ä¶   62        [OK]       
neurodebian                      NeuroDebian provides neuroscience research s‚Ä¶   104       [OK]       
ubuntu-debootstrap               DEPRECATED; use "ubuntu" instead                52        [OK]       
ubuntu-upstart                   DEPRECATED, as is Upstart (find other proces‚Ä¶   115       [OK]       
ubuntu/nginx                     Nginx, a high-performance reverse proxy &amp; we‚Ä¶   98                   
ubuntu/squid                     Squid is a caching proxy for the Web. Long-t‚Ä¶   66                   
ubuntu/cortex                    Cortex provides storage for Prometheus. Long‚Ä¶   4                    
ubuntu/apache2                   Apache, a secure &amp; extensible open-source HT‚Ä¶   60                   
ubuntu/kafka                     Apache Kafka, a distributed event streaming ‚Ä¶   35                   
ubuntu/mysql                     MySQL open source fast, stable, multi-thread‚Ä¶   53                   
ubuntu/bind9                     BIND 9 is a very flexible, full-featured DNS‚Ä¶   62                   
ubuntu/prometheus                Prometheus is a systems and service monitori‚Ä¶   51                   
ubuntu/zookeeper                 ZooKeeper maintains configuration informatio‚Ä¶   12                   
ubuntu/postgres                  PostgreSQL is an open source object-relation‚Ä¶   31                   
ubuntu/redis                     Redis, an open source key-value store. Long-‚Ä¶   19                   
ubuntu/grafana                   Grafana, a feature rich metrics dashboard &amp; ‚Ä¶   9                    
ubuntu/memcached                 Memcached, in-memory keyvalue store for smal‚Ä¶   5                    
ubuntu/dotnet-aspnet             Chiselled Ubuntu runtime image for ASP.NET a‚Ä¶   11                   
ubuntu/dotnet-deps               Chiselled Ubuntu for self-contained .NET &amp; A‚Ä¶   11                   
ubuntu/prometheus-alertmanager   Alertmanager handles client alerts from Prom‚Ä¶   9                    
ubuntu/dotnet-runtime            Chiselled Ubuntu runtime image for .NET apps‚Ä¶   10                   
ubuntu/cassandra                 Cassandra, an open source NoSQL distributed ‚Ä¶   2                    
ubuntu/telegraf                  Telegraf collects, processes, aggregates &amp; w‚Ä¶   4                    
</output_code>
  <markdown>## Uso do Docker para criar aplica√ß√µes</markdown>
  <markdown>### Exposi√ß√£o de portas</markdown>
  <markdown>Antes vimos como pod√≠amos vincular um porta de um cont√™iner a uma porta do computador (`-p 8080:80`). Mas para que isso seja poss√≠vel, na hora de criar a imagem √© preciso expor a porta, isso se faz adicionando ao Dockerfile a linha `EXPOSE &lt;port&gt;`, no caso anterior

```docker
EXPOSE 80
```

Ou usar imagens como base que j√° tenham portas expostas</markdown>
  <markdown>### Reutiliza√ß√£o do cache de camadas ao compilar</markdown>
  <markdown>Quando compilamos uma imagem, se alguma das camadas que definimos j√° foram compiladas antes, o Docker detecta e as usa, n√£o as recompila. Se recompilarmos a imagem que definimos no `Dockerfile`, agora levar√° muito pouco tempo, pois todas as camadas j√° est√£o compiladas e o Docker n√£o as recompila.</markdown>
  <input_code>!docker build -t ubuntu:test ./dockerImages</input_code>
  <output_code>Sending build context to Docker daemon  2.048kB
Step 1/3 : FROM ubuntu:latest
 ---&gt; 2dc39ba059dc
Step 2/3 : RUN touch /test.txt
 ---&gt; Using cache
 ---&gt; a78cf3ea16d8
Step 3/3 : RUN rm /test.txt
 ---&gt; Using cache
 ---&gt; 313243a9b573
Successfully built 313243a9b573
Successfully tagged ubuntu:test

Use 'docker scan' to run Snyk tests against images to find vulnerabilities and learn how to fix them
</output_code>
  <markdown>Na segunda e terceira camada aparece o texto `Using cache`

Como isso √© um caderno Jupyter, ao executar as c√©lulas ele fornece a informa√ß√£o do tempo que elas levam para serem executadas. Da √∫ltima vez que compilei a imagem, demorou 1,4 segundos, enquanto agora levou 0,5 segundos.</markdown>
  <markdown>Mas se agora eu mudar o Dockerfile, e na primeira linha, onde dizia que est√°vamos baseados na vers√£o mais recente do Ubuntu, mudamos para a vers√£o 20.04

```docker
FROM ubuntu:20.04
```</markdown>
  <markdown>No final o `Dockerfile` fica assim:
```dockerfile
FROM ubuntu:20.04
RUN touch /test.txt
RUN rm /test.txt
```</markdown>
  <markdown>Se recompilarmos, levar√° muito mais tempo.</markdown>
  <input_code>!docker build -t ubuntu:test ./dockerImages</input_code>
  <output_code>Sending build context to Docker daemon  2.048kB
Step 1/3 : FROM ubuntu:20.04
 ---&gt; a0ce5a295b63
Step 2/3 : RUN touch /test.txt
 ---&gt; Running in a40fe8df2c0d
Removing intermediate container a40fe8df2c0d
 ---&gt; 0bb9b452c11f
Step 3/3 : RUN rm /test.txt
 ---&gt; Running in 2e14919f3685
Removing intermediate container 2e14919f3685
 ---&gt; fdc248fa833b
Successfully built fdc248fa833b
Successfully tagged ubuntu:test

Use 'docker scan' to run Snyk tests against images to find vulnerabilities and learn how to fix them
</output_code>
  <markdown>Demorou 1,9 segundos e o texto `Using cache` n√£o aparece mais.</markdown>
  <markdown>Ao alterar a primeira camada, o Docker recompila todas as camadas. Isso pode ser um problema porque, durante o desenvolvimento de c√≥digo, pode ocorrer o seguinte caso
* Desenvolvemos o c√≥digo em nosso computador
* Ao construir a imagem, copiamos todo o c√≥digo do nosso computador para o cont√™iner
* Em seguida, pedimos √† imagem para instalar as bibliotecas necess√°rias

Isso pode fazer com que ao alterar qualquer parte do c√≥digo, ao ter que recompilar a imagem, a camada na qual as bibliotecas s√£o instaladas precise ser recompilada novamente, pois uma camada anterior foi alterada.</markdown>
  <markdown>Para resolver isso, a ideia seria que na hora de criar a imagem, primeiro pe√ßamos que se instalem as bibliotecas e depois que se copie o c√≥digo do nosso computador para o cont√™iner. Assim, cada vez que alterarmos o c√≥digo e recompilarmos a imagem, apenas ser√° recompilada a camada em que se copia o c√≥digo, portanto, a compila√ß√£o ser√° mais r√°pida</markdown>
  <markdown>Voc√™ pode pensar que √© melhor compartilhar uma pasta entre o host e o cont√™iner (`bind mount`) onde teremos o c√≥digo e assim n√£o ser√° necess√°rio recompilar a imagem toda vez que alterarmos o c√≥digo. E a resposta √© que √© verdade, coloquei apenas este exemplo porque √© muito f√°cil de entender, mas √© para ilustrar que na hora de criar imagens √© preciso pensar bem de forma que, se for necess√°rio recompil√°-la, recompile o menor n√∫mero poss√≠vel de camadas.</markdown>
  <markdown>### Escrever corretamente um Dockerfile</markdown>
  <markdown>Como vimos, o Docker n√£o recompila as camadas de um Dockerfile se j√° as tiver compilado anteriormente, portanto, as carrega do cache. Vamos ver como deve ser a forma correta de escrever um Dockerfile para aproveitar isso.</markdown>
  <markdown>Vamos a partir deste Dockerfile para ir comentando poss√≠veis corre√ß√µes

``` Dockerfile
DE ubuntu
COPY ./sourceCode /sourceCode
RUN apt-get update
RUN apt-get install -y python3 ssh
CMD ["python3", "/sourceCode/sourceApp/app.py"]
```

Como pode ser visto, parte-se de uma imagem do Ubuntu, copia-se a pasta com o c√≥digo, atualizam-se os reposit√≥rios, instala-se o Python, instala-se tamb√©m o SSH e executa-se a aplica√ß√£o.</markdown>
  <markdown>#### Copiar o c√≥digo antes da execu√ß√£o</markdown>
  <markdown>Como dissem antes, se primeiro copiarmos o c√≥digo e depois instalarmos o Python, cada vez que fizermos uma mudan√ßa no c√≥digo e compilarmos a imagem, ela ser√° compilada inteira, mas se copiarmos o c√≥digo ap√≥s instalar o Python, cada vez que alterarmos o c√≥digo e compilarmos a imagem, apenas compilar√° a partir da c√≥pia do c√≥digo e n√£o reinstalar√° o Python, por isso o Dockerfile deveria ficar assim

``` Dockerfile
DE ubuntu
RUN apt-get update
RUN apt-get install -y python3 ssh
COPY ./sourceCode /sourceCode
CMD ["python3", "/sourceCode/sourceApp/app.py"]
```</markdown>
  <markdown>#### Copiar apenas o c√≥digo necess√°rio</markdown>
  <markdown>Estamos copiando a pasta com todo o c√≥digo, mas talvez dentro temos c√≥digo que n√£o precisamos, por isso √© necess√°rio copiar apenas o c√≥digo que realmente precisamos para a aplica√ß√£o, desta forma a imagem ocupar√° menos mem√≥ria. De modo que o Dockerfile ficaria assim

``` Dockerfile
DE ubuntu
RUN apt-get update
RUN apt-get install -y python3 ssh
COPY ./sourceCode/sourceApp /sourceCode/sourceApp
CMD ["python3", "/sourceCode/sourceApp/app.py"]
```</markdown>
  <markdown>#### Atualizar reposit√≥rios e instalar python na mesma linha</markdown>
  <markdown>Estamos atualizando os reposit√≥rios em uma linha e em outra instalando python3.

``` Dockerfile
DE ubuntu
RUN apt-get update &amp;&amp; apt-get install -y python3 ssh
COPY ./sourceCode/sourceApp /sourceCode/sourceApp
CMD ["python3", "/sourceCode/sourceApp/app.py"]
```</markdown>
  <markdown>#### N√£o instalar ssh</markdown>
  <markdown>Hav√≠amos instalado ssh na imagem para poder depurar em caso de precisar, mas isso faz com que a imagem ocupe mais mem√≥ria. Em caso de precisarmos depurar, dever√≠amos entrar no cont√™iner, instalar ssh e, em seguida, depurar. Por isso, removemos a instala√ß√£o do ssh.

``` Dockerfile
DE ubuntu
RUN apt-get update &amp;&amp; apt-get install -y python3
COPY ./sourceCode/sourceApp /sourceCode/sourceApp
CMD ["python3", "/sourceCode/sourceApp/app.py"]
```</markdown>
  <markdown>#### Usar `--no-install-recommends`</markdown>
  <markdown>Quando instalamos algo no Ubuntu, ele instala pacotes recomendados, mas que n√£o precisamos, por isso a imagem ocupa mais espa√ßo. Ent√£o, para evit√°-lo, adicionamos √† instala√ß√£o `--no-install-recommends`

``` Dockerfile
DE ubuntu
RUN apt-get update &amp;&amp; apt-get install -y python3 --no-install-recommends
COPY ./sourceCode/sourceApp /sourceCode/sourceApp
CMD ["python3", "/sourceCode/sourceApp/app.py"]
```</markdown>
  <markdown>#### Apagar lista de reposit√≥rios atualizados</markdown>
  <markdown>N√≥s atualizamos a lista de reposit√≥rios e instalamos o python, mas uma vez feito, j√° n√£o precisamos da lista de reposit√≥rios atualizados, pois tudo o que far√£o √© aumentar o tamanho da imagem, ent√£o os removemos ap√≥s instalar o python e na mesma linha.

``` Dockerfile
DE ubuntu
RUN apt-get update &amp;&amp; apt-get install -y python3 --no-install-recommends &amp;&amp; rm -rf /var/lib/apt/lists/*
COPY ./sourceCode/sourceApp /sourceCode/sourceApp
CMD ["python3", "/sourceCode/sourceApp/app.py"]
```</markdown>
  <markdown>#### Usar uma imagem de Python</markdown>
  <markdown>Tudo o que fizemos para atualizar a lista de pacotes e instalar o Python n√£o √© necess√°rio, j√° que existem imagens do Python baseadas no Ubuntu, que com certeza seguiram boas pr√°ticas e podem at√© ter feito melhor do que n√≥s, al√©m de ter sido escaneada em busca de vulnerabilidades pelo Docker Hub. Portanto, removemos tudo isso e partimos de uma imagem do Python.

``` Dockerfile
DE python
COPY ./sourceCode/sourceApp /sourceCode/sourceApp
CMD ["python3", "/sourceCode/sourceApp/app.py"]
```</markdown>
  <markdown>#### Especificar a imagem do Python</markdown>
  <markdown>Ao n√£o especificar a imagem do Python, est√° sendo baixada a √∫ltima, mas dependendo de quando voc√™ construir o cont√™iner, pode ser baixada uma ou outra, por isso √© necess√°rio adicionar a tag com a vers√£o do Python desejada.

``` Dockerfile
FROM python:3.9.18
COPY ./sourceCode/sourceApp /sourceCode/sourceApp
CMD ["python3", "/sourceCode/sourceApp/app.py"]
```</markdown>
  <markdown>#### Escolher uma tag pequena</markdown>
  <markdown>Escolhemos a tag `3.9.18`, mas essa vers√£o do Python tem um monte de bibliotecas que provavelmente n√£o precisamos, ent√£o podemos usar as vers√µes `3.9.18-slim` que t√™m muitas menos bibliotecas instaladas, ou a vers√£o `3.9.18-alpine` que √© uma vers√£o do Python baseada no Alpine e n√£o no Ubuntu. O Alpine √© uma distribui√ß√£o Linux muito leve que tem muito poucos pacotes instalados e que costuma ser usada bastante em cont√™ineres Docker para ocupar muito pouco espa√ßo.

A imagem de python `3.9.18` ocupa 997 MB, a `3.9.18-slim` ocupa 126 MB e a `3.9.18-alpine` ocupa 47,8 MB

``` Dockerfile
FROM python:3.9.18-alpine
COPY ./sourceCode/sourceApp /sourceCode/sourceApp
CMD ["python3", "/sourceCode/sourceApp/app.py"]
```</markdown>
  <markdown>#### Indique o workspace</markdown>
  <markdown>Em vez de indicar o caminho da imagem `/sourceCode/sourceApp`, estabelecemos que esse caminho seja o workspace da imagem. Assim, quando copiarmos o c√≥digo ou executarmos a aplica√ß√£o, n√£o √© necess√°rio indicar o caminho.

``` Dockerfile
FROM python:3.9.18-alpine
WORKDIR /sourceCode/sourceApp
COPY ./sourceCode/sourceApp .
CMD ["python3", "app.py"]
```</markdown>
  <markdown>#### Indique o workspace</markdown>
  <markdown>Em vez de indicar o caminho da imagem `/sourceCode/sourceApp`, estabelecemos que esse caminho seja o workspace da imagem. Assim, quando copiarmos o c√≥digo ou executarmos a aplica√ß√£o, n√£o √© necess√°rio indicar o caminho.

``` Dockerfile
FROM python:3.9.18-alpine
WORKDIR /sourceCode/sourceApp
COPY ./sourceCode/sourceApp .
CMD ["python3", "app.py"]
```</markdown>
  <markdown>### C√≥digo compartilhado em uma pasta `bind mount`</markdown>
  <markdown>Hav√≠amos criado uma pasta chamada `dockerHostFolder` na qual hav√≠amos compartilhado arquivos entre o host e um cont√™iner. Dentro, al√©m disso, deveriam haver tr√™s arquivos.</markdown>
  <input_code>!ls dockerHostFolder</input_code>
  <output_code>bindFile.txt  fileExtract.txt  text.txt
</output_code>
  <markdown>Vamos aproveitar o arquivo `text.txt` para ver isso. Vamos ver o que h√° dentro de `text.txt`</markdown>
  <input_code>!cat dockerHostFolder/text.txt</input_code>
  <markdown>N√£o h√° sa√≠da, o arquivo est√° vazio. Vamos criar novamente um cont√™iner do Ubuntu compartilhando a pasta `dockerHostFolder`.</markdown>
  <input_code>!docker run --name alwaysup -d -v ~/Documentos/web/portafolio/posts/dockerHostFolder:/dockerContainerFolder ubuntu tail -f /dev/null</input_code>
  <output_code>24adbded61f507cdf7f192eb5e246e43ee3ffafc9944b7c57918eb2d547dff19
</output_code>
  <markdown>Vemos que o cont√™iner est√° rodando</markdown>
  <input_code>!docker ps</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND               CREATED          STATUS          PORTS     NAMES
24adbded61f5   ubuntu    "tail -f /dev/null"   16 seconds ago   Up 15 seconds             alwaysup
</output_code>
  <markdown>Entramos no cont√™iner, vemos que est√° `text.txt` e que est√° vazio

```bash
$ docker exec -it alwaysup bash
root@24adbded61f5:/# ls dockerContainerFolder/
bindFile.txt  fileExtract.txt  text.txt
root@24adbded61f5:/# cat dockerContainerFolder/text.txt
root@24adbded61f5:/#
```

Agora abrimos no host o arquivo `text.txt` com o editor de textos que quisermos, escrevemos `Hola mundo` e salvamos. Se agora vemos o que h√° dentro do arquivo no cont√™iner, veremos o mesmo texto.

```bash
root@24adbded61f5:/# cat dockerContainerFolder/text.txt
Ol√° mundo
```

Agora editamos o arquivo no cont√™iner e sa√≠mos do cont√™iner

```bash
root@24adbded61f5:/# echo ol√° cont√™iner &gt; dockerContainerFolder/text.txt
root@24adbded61f5:/# cat dockerContainerFolder/text.txt
ol√° cont√™iner
root@24adbded61f5:/# exit
sa√≠da
```

Se olharmos para o arquivo no host, veremos o texto que escrevemos no cont√™iner</markdown>
  <input_code>!cat dockerHostFolder/text.txt</input_code>
  <output_code>hola contenedor
</output_code>
  <markdown>Apagamos o cont√™iner</markdown>
  <input_code>!docker rm -f alwaysup</input_code>
  <output_code>alwaysup
</output_code>
  <markdown>### Conectar contentores por rede</markdown>
  <markdown>Em caso de quisermos ter v√°rios cont√™ineres rodando e querermos que eles se comuniquem, podemos fazer com que se comuniquem por rede. O Docker nos d√° a possibilidade de fazer isso atrav√©s de suas redes virtuais.</markdown>
  <markdown>Vamos ver quais redes o Docker tem atrav√©s do comando `docker network ls`</markdown>
  <input_code>!docker network ls</input_code>
  <output_code>NETWORK ID     NAME      DRIVER    SCOPE
de6e8b7b737e   bridge    bridge    local
da1f5f6fccc0   host      host      local
d3b0d93993c0   none      null      local
</output_code>
  <markdown>Vemos que por padr√£o o Docker tem tr√™s redes
* bridge: Est√° por retrocompatibilidade com vers√µes anteriores, mas n√£o dever√≠amos us√°-la mais
* host: √â a rede do host
* none: Esta √© a op√ß√£o que devemos usar se quisermos que um cont√™iner n√£o tenha acesso √† internet</markdown>
  <markdown>Podemos criar novas redes √†s quais outros cont√™ineres possam se conectar, para isso usamos o comando `docker network create &lt;name&gt;`, para que outros cont√™ineres possam se conectar tamb√©m devemos adicionar a op√ß√£o `--attachable`</markdown>
  <input_code>!docker network create --attachable myNetwork</input_code>
  <output_code>2f6f3ddbfa8642e9f6819aa0965c16339e9e910be7bcf56ebb718fcac324cc27
</output_code>
  <markdown>Podemos inspecion√°-la atrav√©s do comando `docker network inspect &lt;name&gt;`</markdown>
  <input_code>!docker network inspect myNetwork</input_code>
  <output_code>[
    {
        "Name": "myNetwork",
        "Id": "2f6f3ddbfa8642e9f6819aa0965c16339e9e910be7bcf56ebb718fcac324cc27",
        "Created": "2022-09-14T15:20:08.539830161+02:00",
        "Scope": "local",
        "Driver": "bridge",
        "EnableIPv6": false,
        "IPAM": {
            "Driver": "default",
            "Options": {},
            "Config": [
                {
                    "Subnet": "172.18.0.0/16",
                    "Gateway": "172.18.0.1"
                }
            ]
        },
        "Internal": false,
        "Attachable": true,
        "Ingress": false,
        "ConfigFrom": {
            "Network": ""
        },
        "ConfigOnly": false,
        "Containers": {},
        "Options": {},
        "Labels": {}
    }
]
</output_code>
  <markdown>Agora temos que criar dois cont√™ineres para que eles possam se comunicar.</markdown>
  <markdown>Vamos a criar um novo cont√™iner, que chamaremos de `container1`, com uma pasta compartilhada e que dentro dele se chamar√° `folder1`</markdown>
  <input_code>!docker run --name container1 -d -v ~/Documentos/web/portafolio/posts/dockerHostFolder:/folder1 ubuntu tail -f /dev/null</input_code>
  <output_code>a5fca8ba1e4ff0a67002f8f1b8cc3cd43185373c2a7e295546f774059ad8dd1a
</output_code>
  <markdown>Agora criamos outro cont√™iner, chamado `container2`, com outra pasta compartilhada, mas que se chame `folder2`</markdown>
  <input_code>!docker run --name container2 -d -v ~/Documentos/web/portafolio/posts/dockerHostFolder:/folder2 ubuntu tail -f /dev/null</input_code>
  <output_code>6c8dc18315488ef686f7548516c19b3d716728dd8a173cdb889ec0dd082232f9
</output_code>
  <markdown>Vemos os cont√™ineres rodando e vemos que est√£o os dois</markdown>
  <input_code>!docker ps</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND               CREATED         STATUS         PORTS     NAMES
6c8dc1831548   ubuntu    "tail -f /dev/null"   3 seconds ago   Up 2 seconds             container2
a5fca8ba1e4f   ubuntu    "tail -f /dev/null"   4 seconds ago   Up 3 seconds             container1
</output_code>
  <markdown>Agora temos que conectar os cont√™ineres √† rede, para isso usamos o comando `docker network connect &lt;network name&gt; &lt;container name&gt;`</markdown>
  <input_code>!docker network connect myNetwork container1</input_code>
  <input_code>!docker network connect myNetwork container2</input_code>
  <markdown>Para verificar que foram conectados corretamente, podemos inspecionar a rede, mas filtrando pelos cont√™ineres conectados.

```bash
$ docker network inspect --format '{{.Containers}}' myNetwork
 mapa
[
6c8dc18315488ef686f7548516c19b3d716728dd8a173cdb889ec0dd082232f9:
{
container2
f828d211e894f7a5a992ce41a2a0def8e2424e9737fb4e1485fc09cc2d607b69
02:42:ac:12:00:03
172.18.0.3/16
}
a5fca8ba1e4ff0a67002f8f1b8cc3cd43185373c2a7e295546f774059ad8dd1a:
{
container1
cff762e6286ebc169804b2a675bbff904102de796751d367c18d4b490c994c45
02:42:ac:12:00:02
172.18.0.2/16
}
]
```

Como podemos ver o contentor `container1` tem o IP `172.18.0.2` e o contentor `container2` tem o IP `172.18.0.3`</markdown>
  <markdown>Entramos no cont√™iner `container1` e instalamos `ping`

``` bash
$ docker exec -it container1 bash
root@a5fca8ba1e4f:/# apt update
...
root@a5fca8ba1e4f:/# apt install iputils-ping
Claro, por favor proporciona el texto markdown que deseas que traduzca al portug√©s.
root@a5fca8ba1e4f:/#
```</markdown>
  <markdown>Entramos no cont√™iner `container2` e instalamos `ping`

```bash
$ docker exec -it container2 bash
root@a5fca8ba1e4f:/# apt update
...
root@a5fca8ba1e4f:/# apt install iputils-ping
...
root@a5fca8ba1e4f:/#
```</markdown>
  <markdown>Agora do cont√™iner `container1` fazemos um ping ao IP `172.18.0.3`, que pertence ao cont√™iner `container2`

```bash
root@a5fca8ba1e4f:/# ping 172.18.0.3
PING 172.18.0.3 (172.18.0.3) 56(84) bytes de dados.
64 bytes de 172.18.0.3: icmp_seq=1 ttl=64 tempo=0.115 ms
64 bytes de 172.18.0.3: icmp_seq=2 ttl=64 time=0.049 ms
64 bytes de 172.18.0.3: icmp_seq=3 ttl=64 tempo=0.056 ms
64 bytes de 172.18.0.3: icmp_seq=4 ttl=64 tempo=0,060 ms
^C
--- estat√≠sticas do ping para 172.18.0.3 ---
4 pacotes transmitidos, 4 recebidos, 0% de perda de pacotes, tempo 3068ms
rtt min/avg/max/mdev = 0,049/0,070/0,115/0,026 ms
```</markdown>
  <markdown>E do cont√™iner `container2` fazemos um ping ao IP `172.18.0.2`, que pertence ao cont√™iner `container1`

```bash
root@6c8dc1831548:/# ping 172.18.0.2
PING 172.18.0.2 (172.18.0.2) 56(84) bytes de dados.
64 bytes de 172.18.0.2: icmp_seq=1 ttl=64 time=0.076 ms
64 bytes de 172.18.0.2: icmp_seq=2 ttl=64 time=0.045 ms
64 bytes de 172.18.0.2: icmp_seq=3 ttl=64 time=0.049 ms
64 bytes de 172.18.0.2: icmp_seq=4 ttl=64 time=0.051 ms
^C
--- estat√≠sticas de ping para 172.18.0.2 ---
4 pacotes transmitidos, 4 recebidos, 0% de perda de pacotes, tempo 3074ms
rtt min/avg/max/mdev = 0,045/0,055/0,076/0,012 ms
```</markdown>
  <markdown>Mas h√° uma coisa melhor que nos permite fazer com o Docker: se eu n√£o souber o IP do cont√™iner ao qual quero me conectar, em vez de escrever seu IP, posso escrever seu nome.</markdown>
  <markdown>Agora, do cont√™iner `container1`, fazemos um ping ao IP de `container2`.

```bash
root@a5fca8ba1e4f:/# ping container2
PING container2 (172.18.0.3) 56(84) bytes de dados.
64 bytes de container2.myNetwork (172.18.0.3): icmp_seq=1 ttl=64 time=0.048 ms
64 bytes de container2.myNetwork (172.18.0.3): icmp_seq=2 ttl=64 time=0.050 ms
64 bytes de container2.myNetwork (172.18.0.3): icmp_seq=3 ttl=64 time=0,052 ms
64 bytes de container2.myNetwork (172.18.0.3): icmp_seq=4 ttl=64 tempo=0,053 ms
^C
--- estat√≠sticas do ping do container2 ---
4 pacotes transmitidos, 4 recebidos, 0% de perda de pacotes, tempo 3071ms
rtt min/avg/max/mdev = 0,048/0,050/0,053/0,002 ms
```

Como vemos, o Docker sabe que o IP do cont√™iner `container2` √© a `172.18.0.3`</markdown>
  <markdown>E do cont√™iner `container2` fazemos um ping ao IP de `container1`

```bash
root@6c8dc1831548:/# ping container1
PING container1 (172.18.0.2) 56(84) bytes de dados.
64 bytes de container1.myNetwork (172.18.0.2): icmp_seq=1 ttl=64 tempo=0.051 ms
64 bytes de container1.myNetwork (172.18.0.2): icmp_seq=2 ttl=64 time=0.058 ms
64 bytes de container1.myNetwork (172.18.0.2): icmp_seq=3 ttl=64 time=0,052 ms
64 bytes de container1.myNetwork (172.18.0.2): icmp_seq=4 ttl=64 time=0,056 ms
^C
--- estat√≠sticas do container1 ping ---
4 pacotes transmitidos, 4 recebidos, 0% de perda de pacotes, tempo 3057ms
rtt min/avg/max/mdev = 0,051/0,054/0,058/0,003 ms
```

Como vemos, o Docker sabe que o IP do cont√™iner `container1` √© a `172.18.0.2`</markdown>
  <markdown>Saimos dos cont√™ineres e os apagamos</markdown>
  <input_code>!docker rm -f container1 container2</input_code>
  <output_code>container1
container2
</output_code>
  <markdown>Apagamos tamb√©m a rede que criamos</markdown>
  <input_code>!docker network rm myNetwork</input_code>
  <output_code>myNetwork
</output_code>
  <markdown>## Uso de GPUs</markdown>
  <markdown>Para poder usar as GPUs do host dentro dos cont√™ineres Docker, √© necess√°rio seguir os passos descritos na p√°gina de instala√ß√£o do [Nvidia container toolkit](https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/install-guide.html).</markdown>
  <markdown>### Configurar o reposit√≥rio e a chave GPG</markdown>
  <markdown>Temos que configurar o reposit√≥rio do `nvidia container toolkit` e a chave GPG. Para isso, execute o seguinte comando no terminal:

``` bash
distribui√ß√£o=$(. /etc/os-release;echo $ID$VERSION_ID) \
&amp;&amp; curl -fsSL https://nvidia.github.io/libnvidia-container/gpgkey | sudo gpg --dearmor -o /usr/share/keyrings/nvidia-container-toolkit-keyring.gpg \
&amp;&amp; curl -s -L https://nvidia.github.io/libnvidia-container/$distribution/libnvidia-container.list | \
sed 's#deb https://#deb [signed-by=/usr/share/keyrings/nvidia-container-toolkit-keyring.gpg] https://#g' | \
sudo tee /etc/apt/sources.list.d/nvidia-container-toolkit.list
```</markdown>
  <markdown>### Instala√ß√£o do `nvidia container toolkit`</markdown>
  <markdown>Uma vez atualizamos o reposit√≥rio e a chave, atualizamos os reposit√≥rios por meio do comando
``` bash
sudo apt update
```

E instalamos `nvidia container toolkit`
``` bash
sudo apt install -y nvidia-docker2
```</markdown>
  <markdown>### Rein√≠cio do Docker</markdown>
  <markdown>Uma vez que tenhamos terminado, temos que reiniciar o dem√¥nio do Docker atrav√©s de
``` bash
sudo systemctl restart docker
```</markdown>
  <markdown>### Uso de GPUs</markdown>
  <markdown>Agora que configuramos o Docker para poder usar as GPUs do host dentro dos cont√™ineres, podemos test√°-lo atrav√©s da op√ß√£o `--gpus all`. Se houver mais de uma GPU e quiser usar apenas 1, seria necess√°rio especific√°-la, mas por enquanto aqui explicamos apenas como usar todas.</markdown>
  <markdown>Criamos um cont√™iner que n√£o ser√° executado em segundo plano, mas sim ir√° executar o comando `nvidia-smi` para que possamos verificar se ele tem acesso √†s GPUs.</markdown>
  <input_code>!docker run --name container_gpus --gpus all ubuntu nvidia-smi</input_code>
  <output_code>Unable to find image 'ubuntu:latest' locally
latest: Pulling from library/ubuntu

[1B6a12be2b: Pull complete .54MB/29.54MBB[1A[2K[1A[2K[1A[2K[1A[2K[1A[2K[1A[2K[1A[2K[1A[2K[1A[2K[1A[2K[1A[2K[1A[2K[1A[2K[1A[2K[1A[2K[1A[2K[1A[2K[1A[2K[1A[2K[1A[2K[1A[2KDigest: sha256:aabed3296a3d45cede1dc866a24476c4d7e093aa806263c27ddaadbdce3c1054
Status: Downloaded newer image for ubuntu:latest
Mon Sep  4 07:10:36 2023       
+-----------------------------------------------------------------------------+
| NVIDIA-SMI 510.39.01    Driver Version: 510.39.01    CUDA Version: 11.6     |
|-------------------------------+----------------------+----------------------+
| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |
| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |
|                               |                      |               MIG M. |
|===============================+======================+======================|
|   0  Quadro T1000        On   | 00000000:01:00.0 Off |                  N/A |
| N/A   44C    P0    15W /  N/A |      9MiB /  4096MiB |      0%      Default |
|                               |                      |                  N/A |
+-------------------------------+----------------------+----------------------+
                                                                               
+-----------------------------------------------------------------------------+
| Processes:                                                                  |
|  GPU   GI   CI        PID   Type   Process name                  GPU Memory |
|        ID   ID                                                   Usage      |
|=============================================================================|
|    0   N/A  N/A      2545      G                                       4MiB |
|    0   N/A  N/A      3421      G                                       4MiB |
+-----------------------------------------------------------------------------+
</output_code>
  <markdown>Apagamos o cont√™iner</markdown>
  <input_code>!doker rm container_gpus</input_code>
  <markdown>## Docker compose</markdown>
  <markdown>### Docker compose vs docker-compose</markdown>
  <markdown>`docker-compose` foi uma ferramenta criada para ajudar no mantenimiento de imagens e cont√™ineres, e era necess√°rio instal√°-la separadamente do Docker. No entanto, o Docker incorporou essa funcionalidade em suas √∫ltimas vers√µes, e agora n√£o √© mais necess√°rio instal√°-la separadamente. Para us√°-la, em vez de usar o comando `docker-compose`, voc√™ deve usar o comando `docker compose`. Em muitos lugares, voc√™ encontrar√° informa√ß√µes usando `docker-compose`, mas ao instalar o Docker, o `docker compose` j√° vir√° instalado, portanto tudo que podia ser feito com `docker-compose` √© compat√≠vel com `docker compose`.</markdown>
  <markdown>### Docker compose</markdown>
  <markdown>Docker Compose √© uma ferramenta do Docker que faz tudo o que vimos at√© agora, mas nos economizando tempo e esfor√ßo. Editando um arquivo `.yml`, podemos dizer ao Docker Compose para criar todos os cont√™ineres que quisermos.

Para usar uma vez n√£o haver√° muita diferen√ßa entre escrever todos os comandos que vimos antes ou escrever o arquivo `.yml`, mas quando quiser ter a mesma configura√ß√£o de cont√™ineres funcionando novamente, basta chamar o arquivo `.yml` e ele recriar√° toda a configura√ß√£o.</markdown>
  <markdown>Vamos a criar uma pasta onde armazenaremos os arquivos do Docker Compose</markdown>
  <input_code>!mkdir dockerComposeFiles</input_code>
  <markdown>Criamos o arquivo .yml dentro</markdown>
  <input_code>!touch dockerComposeFiles/docker-compose.yml</input_code>
  <markdown>Um arquivo Docker Compose deve come√ßar com a vers√£o

```json
vers√£o: "&lt;v.v&gt;"
```

No momento de escrever isso, a √∫ltima vers√£o √© a `3.8` ent√£o escrevemos essa</markdown>
  <markdown>*docker-compose.yml*:

```json
vers√£o: "3.8"
```</markdown>
  <markdown>A seguir est√£o indicados os servi√ßos, que s√£o os contentores. Em cada servi√ßo tem de especificar a imagem e, al√©m disso, podem ser adicionados outros par√¢metros como portas, vari√°veis de ambiente, etc.

```json
servi√ßos:
container1:
image: ubuntu
    
container2:
image: ubuntu
```</markdown>
  <markdown>O `docker-compose.yml` ficaria assim:

```json
vers√£o: "3.8"

servi√ßos:
container1:
imagem: ubuntu
    
container2:
image: ubuntu
```</markdown>
  <markdown>Uma vez que temos criado o arquivo, em seu caminho, podemos executar tudo atrav√©s do comando `docker compose up`, mas adicionando a op√ß√£o `-d` faremos com que ele rode em segundo plano.</markdown>
  <input_code>!cd dockerComposeFiles &amp;&amp; docker compose up -d</input_code>
  <output_code>[1A[1B[0G[?25l[+] Running 1/0
[34m ‚†ø Network dockercomposefiles_default         Created                      0.1s
[0m[37m ‚†ã Container dockercomposefiles-container2-1  Creating                     0.0s
[0m[37m ‚†ã Container dockercomposefiles-container1-1  Creating                     0.0s
[0m[?25h[1A[1A[1A[1A[0G[?25l[+] Running 1/3
[34m ‚†ø Network dockercomposefiles_default         Created                      0.1s
[0m[37m ‚†ô Container dockercomposefiles-container2-1  Creating                     0.1s
[0m[37m ‚†ô Container dockercomposefiles-container1-1  Creating                     0.1s
[0m[?25h[1A[1A[1A[1A[0G[?25l[+] Running 1/3
[34m ‚†ø Network dockercomposefiles_default         Created                      0.1s
[0m[37m ‚†ø Container dockercomposefiles-container2-1  Starting                     0.2s
[0m[37m ‚†ø Container dockercomposefiles-container1-1  Starting                     0.2s
[0m[?25h[1A[1A[1A[1A[0G[?25l[+] Running 1/3
[34m ‚†ø Network dockercomposefiles_default         Created                      0.1s
[0m[37m ‚†ø Container dockercomposefiles-container2-1  Starting                     0.3s
[0m[37m ‚†ø Container dockercomposefiles-container1-1  Starting                     0.3s
[0m[?25h[1A[1A[1A[1A[0G[?25l[+] Running 1/3
[34m ‚†ø Network dockercomposefiles_default         Created                      0.1s
[0m[37m ‚†ø Container dockercomposefiles-container2-1  Starting                     0.4s
[0m[37m ‚†ø Container dockercomposefiles-container1-1  Starting                     0.4s
[0m[?25h[1A[1A[1A[1A[0G[?25l[+] Running 1/3
[34m ‚†ø Network dockercomposefiles_default         Created                      0.1s
[0m[37m ‚†ø Container dockercomposefiles-container2-1  Starting                     0.5s
[0m[37m ‚†ø Container dockercomposefiles-container1-1  Starting                     0.5s
[0m[?25h[1A[1A[1A[1A[0G[?25l[+] Running 2/3
[34m ‚†ø Network dockercomposefiles_default         Created                      0.1s
[0m[34m ‚†ø Container dockercomposefiles-container2-1  Started                      0.5s
[0m[37m ‚†ø Container dockercomposefiles-container1-1  Starting                     0.6s
[0m[?25h[1A[1A[1A[1A[0G[?25l[34m[+] Running 3/3[0m
[34m ‚†ø Network dockercomposefiles_default         Created                      0.1s
[0m[34m ‚†ø Container dockercomposefiles-container2-1  Started                      0.5s
[0m[34m ‚†ø Container dockercomposefiles-container1-1  Started                      0.7s
[0m[?25h</output_code>
  <markdown>Se podemos observar, ele criou dois contentores `dockercomposefiles-container1-1` e `dockercomposefiles-container2-1` e a rede que os conecta `dockercomposefiles_default`</markdown>
  <markdown>Vamos a apagar os dois cont√™ineres</markdown>
  <input_code>!docker rm -f dockercomposefiles-container1-1 dockercomposefiles-container2-1</input_code>
  <output_code>dockercomposefiles-container1-1
dockercomposefiles-container2-1
</output_code>
  <markdown>E apagamos a rede que foi criada</markdown>
  <input_code>!docker network rm dockercomposefiles_default</input_code>
  <output_code>dockercomposefiles_default
</output_code>
  <markdown>Vamos tentar fazer o que fizemos anteriormente com o que sabemos at√© agora. Vamos criar uma nova imagem que venha com `ping` instalado.

*Arquivo Dockerfile*:
```docker
FROM ubuntu:20.04
RUN apt update
RUN apt install iputils-ping -y
```

E a compilamos</markdown>
  <input_code>!docker build -t ubuntu:ping ./dockerImages</input_code>
  <output_code>Sending build context to Docker daemon  2.048kB
Step 1/3 : FROM ubuntu:20.04
 ---&gt; a0ce5a295b63
Step 2/3 : RUN apt update
 ---&gt; Running in 3bd5278d39b4
[91m
WARNING: apt does not have a stable CLI interface. Use with caution in scripts.

[0mGet:1 http://security.ubuntu.com/ubuntu focal-security InRelease [114 kB]
Get:2 http://archive.ubuntu.com/ubuntu focal InRelease [265 kB]
Get:3 http://security.ubuntu.com/ubuntu focal-security/universe amd64 Packages [898 kB]
Get:4 http://archive.ubuntu.com/ubuntu focal-updates InRelease [114 kB]
Get:5 http://archive.ubuntu.com/ubuntu focal-backports InRelease [108 kB]
Get:6 http://archive.ubuntu.com/ubuntu focal/universe amd64 Packages [11.3 MB]
Get:7 http://security.ubuntu.com/ubuntu focal-security/main amd64 Packages [2133 kB]
Get:8 http://security.ubuntu.com/ubuntu focal-security/multiverse amd64 Packages [27.5 kB]
Get:9 http://security.ubuntu.com/ubuntu focal-security/restricted amd64 Packages [1501 kB]
Get:10 http://archive.ubuntu.com/ubuntu focal/main amd64 Packages [1275 kB]
Get:11 http://archive.ubuntu.com/ubuntu focal/restricted amd64 Packages [33.4 kB]
Get:12 http://archive.ubuntu.com/ubuntu focal/multiverse amd64 Packages [177 kB]
Get:13 http://archive.ubuntu.com/ubuntu focal-updates/main amd64 Packages [2594 kB]
Get:14 http://archive.ubuntu.com/ubuntu focal-updates/restricted amd64 Packages [1613 kB]
Get:15 http://archive.ubuntu.com/ubuntu focal-updates/multiverse amd64 Packages [30.2 kB]
Get:16 http://archive.ubuntu.com/ubuntu focal-updates/universe amd64 Packages [1200 kB]
Get:17 http://archive.ubuntu.com/ubuntu focal-backports/universe amd64 Packages [27.4 kB]
...
Successfully built c3d32aa9de02
Successfully tagged ubuntu:ping

Use 'docker scan' to run Snyk tests against images to find vulnerabilities and learn how to fix them
</output_code>
  <markdown>Verificamos que foi criado</markdown>
  <input_code>!docker image ls</input_code>
  <output_code>REPOSITORY        TAG       IMAGE ID       CREATED              SIZE
ubuntu            ping      c3d32aa9de02   About a minute ago   112MB
maximofn/ubuntu   test      a78cf3ea16d8   25 hours ago         77.8MB
nginx             latest    2d389e545974   33 hours ago         142MB
ubuntu            latest    2dc39ba059dc   12 days ago          77.8MB
ubuntu            20.04     a0ce5a295b63   12 days ago          72.8MB
hello-world       latest    feb5d9fea6a5   11 months ago        13.3kB
</output_code>
  <markdown>Mudamos o tag</markdown>
  <input_code>!docker tag ubuntu:ping maximofn/ubuntu:ping</input_code>
  <input_code>!docker image ls</input_code>
  <output_code>REPOSITORY        TAG       IMAGE ID       CREATED              SIZE
ubuntu            ping      c3d32aa9de02   About a minute ago   112MB
maximofn/ubuntu   ping      c3d32aa9de02   About a minute ago   112MB
maximofn/ubuntu   test      c3d32aa9de02   About a minute ago   112MB
nginx             latest    2d389e545974   33 hours ago         142MB
ubuntu            latest    2dc39ba059dc   12 days ago          77.8MB
ubuntu            20.04     a0ce5a295b63   12 days ago          72.8MB
hello-world       latest    feb5d9fea6a5   11 months ago        13.3kB
</output_code>
  <markdown>Editamos o arquivo Docker Compose para que utilize as imagens que acabamos de criar

*docker-compose.yml*:
```json
vers√£o: "3.8"

servi√ßos:
container1:
image: maximofn/ubuntu:ping

container2:
image: maximofn/ubuntu:ping
```

E al√©m disso, dizemos para executar uma n√£o opera√ß√£o

O `docker-compose.yml` ficaria assim:
```json
vers√£o: "3.8"

servi√ßos:
container1:
imagem: ubuntu
command: tail -f /dev/null

container2:
imagem: ubuntu
command: tail -f /dev/null
```

O levantamos</markdown>
  <input_code>!cd dockerComposeFiles &amp;&amp; docker compose up -d</input_code>
  <output_code>[1A[1B[0G[?25l[+] Running 0/0
[37m ‚†ã Container dockercomposefiles-container1-1  Recreate                     0.1s
[0m[37m ‚†ã Container dockercomposefiles-container2-1  Recreate                     0.1s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 1/2
[34m ‚†ø Container dockercomposefiles-container1-1  Recreated                    0.1s
[0m[37m ‚†ô Container dockercomposefiles-container2-1  Recreate                     0.2s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 1/2
[34m ‚†ø Container dockercomposefiles-container1-1  Recreated                    0.1s
[0m[37m ‚†π Container dockercomposefiles-container2-1  Recreate                     0.3s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 1/2
[34m ‚†ø Container dockercomposefiles-container1-1  Recreated                    0.1s
[0m[37m ‚†∏ Container dockercomposefiles-container2-1  Recreate                     0.4s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 1/2
[34m ‚†ø Container dockercomposefiles-container1-1  Recreated                    0.1s
[0m[37m ‚†º Container dockercomposefiles-container2-1  Recreate                     0.5s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 1/2
[34m ‚†ø Container dockercomposefiles-container1-1  Recreated                    0.1s
[0m[37m ‚†¥ Container dockercomposefiles-container2-1  Recreate                     0.6s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 1/2
[34m ‚†ø Container dockercomposefiles-container1-1  Recreated                    0.1s
[0m[37m ‚†¶ Container dockercomposefiles-container2-1  Recreate                     0.7s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 1/2
[34m ‚†ø Container dockercomposefiles-container1-1  Recreated                    0.1s
[0m[37m ‚†ß Container dockercomposefiles-container2-1  Recreate                     0.8s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 1/2
[34m ‚†ø Container dockercomposefiles-container1-1  Recreated                    0.1s
[0m[37m ‚†á Container dockercomposefiles-container2-1  Recreate                     0.9s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 1/2
[34m ‚†ø Container dockercomposefiles-container1-1  Recreated                    0.1s
[0m[37m ‚†è Container dockercomposefiles-container2-1  Recreate                     1.0s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 1/2
[34m ‚†ø Container dockercomposefiles-container1-1  Recreated                    0.1s
[0m[37m ‚†ã Container dockercomposefiles-container2-1  Recreate                     1.1s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 1/2
[34m ‚†ø Container dockercomposefiles-container1-1  Recreated                    0.1s
[0m[37m ‚†ô Container dockercomposefiles-container2-1  Recreate                     1.2s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 1/2
[34m ‚†ø Container dockercomposefiles-container1-1  Recreated                    0.1s
[0m[37m ‚†π Container dockercomposefiles-container2-1  Recreate                     1.3s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 1/2
[34m ‚†ø Container dockercomposefiles-container1-1  Recreated                    0.1s
[0m[37m ‚†∏ Container dockercomposefiles-container2-1  Recreate                     1.4s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 1/2
[34m ‚†ø Container dockercomposefiles-container1-1  Recreated                    0.1s
...
[0m[?25h[1A[1A[1A[0G[?25l[34m[+] Running 2/2[0m
[34m ‚†ø Container dockercomposefiles-container1-1  Started                     10.8s
[0m[34m ‚†ø Container dockercomposefiles-container2-1  Started                     10.9s
[0m[?25h[1A[1A[1A[0G[?25l[34m[+] Running 2/2[0m
[34m ‚†ø Container dockercomposefiles-container1-1  Started                     10.8s
[0m[34m ‚†ø Container dockercomposefiles-container2-1  Started                     10.9s
[0m[?25h</output_code>
  <markdown>Vemos os cont√™ineres que est√£o rodando</markdown>
  <input_code>!docker ps</input_code>
  <output_code>CONTAINER ID   IMAGE                  COMMAND               CREATED          STATUS          PORTS     NAMES
935939e5a75d   maximofn/ubuntu:ping   "tail -f /dev/null"   15 seconds ago   Up 13 seconds             dockercomposefiles-container2-1
f9138d7064dd   maximofn/ubuntu:ping   "tail -f /dev/null"   25 seconds ago   Up 13 seconds             dockercomposefiles-container1-1
</output_code>
  <markdown>Os dois cont√™ineres est√£o em execu√ß√£o, agora vamos entrar em um deles e tentar fazer `ping` no outro.

```bash
$ docker exec -it dockercomposefiles-container1-1 bash
root@f9138d7064dd:/# ping dockercomposefiles-container2-1
PING dockercomposefiles-container2-1 (172.21.0.3) 56(84) bytes de dados.
64 bytes de dockercomposefiles-container2-1.dockercomposefiles_default (172.21.0.3): icmp_seq=1 ttl=64 tempo=0,110 ms
64 bytes de dockercomposefiles-container2-1.dockercomposefiles_default (172.21.0.3): icmp_seq=2 ttl=64 time=0.049 ms
64 bytes de dockercomposefiles-container2-1.dockercomposefiles_default (172.21.0.3): icmp_seq=3 ttl=64 time=0.049 ms
64 bytes de dockercomposefiles-container2-1.dockercomposefiles_default (172.21.0.3): icmp_seq=4 ttl=64 tempo=0,075 ms
^C
--- estat√≠sticas do ping do container2-1 do dockercomposefiles ---
4 pacotes transmitidos, 4 recebidos, 0% de perda de pacotes, tempo 3068ms
rtt min/avg/max/mdev = 0,049/0,070/0,110/0,025 ms
```

Como vemos, podemos fazer `ping`, criamos a imagem com `ping` instalado. Al√©m disso, no docker-compose fizemos com que seja executada uma opera√ß√£o nula para que os cont√™ineres continuem em execu√ß√£o.</markdown>
  <markdown>Apagamos os dois cont√™ineres e a rede que criamos</markdown>
  <input_code>!docker rm -f dockercomposefiles-container1-1 dockercomposefiles-container2-1</input_code>
  <output_code>dockercomposefiles-container1-1
dockercomposefiles-container2-1
</output_code>
  <input_code>!docker network rm dockercomposefiles_default</input_code>
  <output_code>dockercomposefiles_default
</output_code>
  <markdown>### Como o Docker Compose nomeia os cont√™ineres</markdown>
  <markdown>Se n√≥s observarmos, os cont√™ineres criados pelo Docker se chamam `dockercomposefiles-container1-1` e `dockercomposefiles-container2-1`. Isso ocorre porque a pasta em que est√° o arquivo do Docker Compose est√° dentro de uma pasta chamada `dockerComposeFiles`, por isso a primeira parte do nome dos cont√™ineres √© `dockercomposefiles`, seguida pelo nome do servi√ßo que demos no arquivo do Docker Compose (`container1` e `container2`) e, por fim, um n√∫mero para poder criar mais se necess√°rio.

O mesmo ocorre com o nome da rede que foi criada `dockercomposefiles_default`</markdown>
  <markdown>### Logs no docker compose</markdown>
  <markdown>Vamos agora a mudar o arquivo Docker Compose, nas linhas em que t√≠nhamos `command: tail -f /dev/null`, vamos colocar `command: ping 0.0.0.0`

E al√©m disso, dizemos para ele executar uma n√£o opera√ß√£o.

O `docker-compose.yml` ficaria assim:
```json
vers√£o: "3.8"

servi√ßos:
container1:
imagem: ubuntu
comando: ping 0.0.0.0

container2:
imagem: ubuntu
comando: ping 0.0.0.0
```

Isso fazemos para que cada cont√™iner esteja enviando o ping constantemente, assim simulamos alguns logs

Se executarmos novamente o docker compose</markdown>
  <input_code>!cd dockerComposeFiles &amp;&amp; docker compose up -d</input_code>
  <output_code>[1A[1B[0G[?25l[+] Running 0/0
[37m ‚†ã Container dockercomposefiles-container1-1  Recreate                     0.1s
[0m[37m ‚†ã Container dockercomposefiles-container2-1  Recreate                     0.1s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 0/2
[37m ‚†ô Container dockercomposefiles-container1-1  Recreate                     0.2s
[0m[37m ‚†ô Container dockercomposefiles-container2-1  Recreate                     0.2s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 0/2
[37m ‚†π Container dockercomposefiles-container1-1  Recreate                     0.3s
[0m[37m ‚†π Container dockercomposefiles-container2-1  Recreate                     0.3s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 0/2
[37m ‚†∏ Container dockercomposefiles-container1-1  Recreate                     0.4s
[0m[37m ‚†∏ Container dockercomposefiles-container2-1  Recreate                     0.4s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 0/2
[37m ‚†º Container dockercomposefiles-container1-1  Recreate                     0.5s
[0m[37m ‚†º Container dockercomposefiles-container2-1  Recreate                     0.5s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 0/2
[37m ‚†¥ Container dockercomposefiles-container1-1  Recreate                     0.6s
[0m[37m ‚†¥ Container dockercomposefiles-container2-1  Recreate                     0.6s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 0/2
[37m ‚†¶ Container dockercomposefiles-container1-1  Recreate                     0.7s
[0m[37m ‚†¶ Container dockercomposefiles-container2-1  Recreate                     0.7s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 0/2
[37m ‚†ß Container dockercomposefiles-container1-1  Recreate                     0.8s
[0m[37m ‚†ß Container dockercomposefiles-container2-1  Recreate                     0.8s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 0/2
...
[37m ‚†ø Container dockercomposefiles-container1-1  Starting                    11.0s
[0m[34m ‚†ø Container dockercomposefiles-container2-1  Started                     11.0s
[0m[?25h[1A[1A[1A[0G[?25l[34m[+] Running 2/2[0m
[34m ‚†ø Container dockercomposefiles-container1-1  Started                     11.1s
[0m[34m ‚†ø Container dockercomposefiles-container2-1  Started                     11.0s
[0m[?25h</output_code>
  <markdown>Agora podemos ver os logs dos dois cont√™ineres atrav√©s do comando `docker compose logs`</markdown>
  <input_code>!cd dockerComposeFiles &amp;&amp; docker compose logs</input_code>
  <output_code>[36mdockercomposefiles-container2-1  | [0mPING 0.0.0.0 (127.0.0.1) 56(84) bytes of data.
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.042 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.025 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=3 ttl=64 time=0.022 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=4 ttl=64 time=0.030 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=5 ttl=64 time=0.021 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=6 ttl=64 time=0.021 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=7 ttl=64 time=0.030 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=8 ttl=64 time=0.028 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=9 ttl=64 time=0.028 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=10 ttl=64 time=0.026 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=11 ttl=64 time=0.028 ms
[33mdockercomposefiles-container1-1  | [0mPING 0.0.0.0 (127.0.0.1) 56(84) bytes of data.
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=12 ttl=64 time=0.027 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=13 ttl=64 time=0.039 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=14 ttl=64 time=0.035 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=15 ttl=64 time=0.034 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=16 ttl=64 time=0.036 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=17 ttl=64 time=0.034 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=18 ttl=64 time=0.036 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=19 ttl=64 time=0.032 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=20 ttl=64 time=0.032 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=21 ttl=64 time=0.033 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=22 ttl=64 time=0.034 ms
[33mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.037 ms
...
[33mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=214 ttl=64 time=0.015 ms
[33mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=215 ttl=64 time=0.021 ms
[33mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=216 ttl=64 time=0.020 ms
[33mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=217 ttl=64 time=0.049 ms
</output_code>
  <markdown>Como vemos, podemos ver os logs dos dois cont√™ineres, mas no caso de querer ver apenas os de um, podemos especificar o **nome do servi√ßo**</markdown>
  <input_code>!cd dockerComposeFiles &amp;&amp; docker compose logs container1</input_code>
  <output_code>[36mdockercomposefiles-container1-1  | [0mPING 0.0.0.0 (127.0.0.1) 56(84) bytes of data.
[36mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.037 ms
[36mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.025 ms
[36mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=3 ttl=64 time=0.023 ms
[36mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=4 ttl=64 time=0.031 ms
[36mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=5 ttl=64 time=0.034 ms
[36mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=6 ttl=64 time=0.033 ms
[36mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=7 ttl=64 time=0.034 ms
[36mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=8 ttl=64 time=0.022 ms
[36mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=9 ttl=64 time=0.032 ms
[36mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=10 ttl=64 time=0.029 ms
[36mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=11 ttl=64 time=0.031 ms
[36mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=12 ttl=64 time=0.024 ms
[36mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=13 ttl=64 time=0.029 ms
[36mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=14 ttl=64 time=0.032 ms
[36mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=15 ttl=64 time=0.033 ms
[36mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=16 ttl=64 time=0.034 ms
[36mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=17 ttl=64 time=0.028 ms
[36mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=18 ttl=64 time=0.034 ms
...
[36mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=332 ttl=64 time=0.027 ms
[36mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=333 ttl=64 time=0.030 ms
[36mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=334 ttl=64 time=0.033 ms
[36mdockercomposefiles-container1-1  | [0m64 bytes from 127.0.0.1: icmp_seq=335 ttl=64 time=0.036 ms
</output_code>
  <input_code>!cd dockerComposeFiles &amp;&amp; docker compose logs container2</input_code>
  <output_code>[36mdockercomposefiles-container2-1  | [0mPING 0.0.0.0 (127.0.0.1) 56(84) bytes of data.
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.042 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.025 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=3 ttl=64 time=0.022 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=4 ttl=64 time=0.030 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=5 ttl=64 time=0.021 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=6 ttl=64 time=0.021 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=7 ttl=64 time=0.030 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=8 ttl=64 time=0.028 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=9 ttl=64 time=0.028 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=10 ttl=64 time=0.026 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=11 ttl=64 time=0.028 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=12 ttl=64 time=0.027 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=13 ttl=64 time=0.039 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=14 ttl=64 time=0.035 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=15 ttl=64 time=0.034 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=16 ttl=64 time=0.036 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=17 ttl=64 time=0.034 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=18 ttl=64 time=0.036 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=19 ttl=64 time=0.032 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=20 ttl=64 time=0.032 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=21 ttl=64 time=0.033 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=22 ttl=64 time=0.034 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=23 ttl=64 time=0.035 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=24 ttl=64 time=0.037 ms
...
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=340 ttl=64 time=0.034 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=341 ttl=64 time=0.033 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=342 ttl=64 time=0.034 ms
[36mdockercomposefiles-container2-1  | [0m64 bytes from 127.0.0.1: icmp_seq=343 ttl=64 time=0.036 ms
</output_code>
  <markdown>Se quisermos ver os logs continuamente, podemos adicionar a op√ß√£o `-f`: `docker compose logs -f &lt;service name&gt;`</markdown>
  <markdown>Se eu criei um docker compose com mais de dois servi√ßos, quando se quiser ver os logs de v√°rios servi√ßos basta adicionar mais nomes ao comando, `docker compose logs &lt;nome servi√ßo 1&gt; &lt;nome servi√ßo 2&gt; ...`</markdown>
  <markdown>### Exec servi√ßos</markdown>
  <markdown>Como vimos, atrav√©s do comando `exec` podemos entrar em um cont√™iner indicando o nome do cont√™iner, o comando que se deseja executar e a op√ß√£o `-it`. Com Docker Compose isso √© mais simples, pois apenas √© necess√°rio o nome do servi√ßo e o comando, mas n√£o √© necess√°ria a op√ß√£o `-it`, j√° que o Docker Compose assume essa op√ß√£o por padr√£o.

```bash
$ docker compose exec container1 bash
root@a7cf282fe66c:/#
```</markdown>
  <markdown>### Parando docker compose</markdown>
  <markdown>Quando terminamos de trabalhar, com um √∫nico comando (`stop`), o Docker Compose para tudo, n√£o √© necess√°rio parar um a um cada cont√™iner.</markdown>
  <input_code>!cd dockerComposeFiles &amp;&amp; docker compose stop</input_code>
  <output_code>[1A[1B[0G[?25l[+] Running 0/0
[37m ‚†ã Container dockercomposefiles-container2-1  Stopping                     0.1s
[0m[37m ‚†ã Container dockercomposefiles-container1-1  Stopping                     0.1s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 0/2
[37m ‚†ô Container dockercomposefiles-container2-1  Stopping                     0.2s
[0m[37m ‚†ô Container dockercomposefiles-container1-1  Stopping                     0.2s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 0/2
[37m ‚†π Container dockercomposefiles-container2-1  Stopping                     0.3s
[0m[37m ‚†π Container dockercomposefiles-container1-1  Stopping                     0.3s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 0/2
[37m ‚†∏ Container dockercomposefiles-container2-1  Stopping                     0.4s
[0m[37m ‚†∏ Container dockercomposefiles-container1-1  Stopping                     0.4s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 0/2
[37m ‚†º Container dockercomposefiles-container2-1  Stopping                     0.5s
[0m[37m ‚†º Container dockercomposefiles-container1-1  Stopping                     0.5s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 0/2
[37m ‚†¥ Container dockercomposefiles-container2-1  Stopping                     0.6s
[0m[37m ‚†¥ Container dockercomposefiles-container1-1  Stopping                     0.6s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 0/2
[37m ‚†¶ Container dockercomposefiles-container2-1  Stopping                     0.7s
[0m[37m ‚†¶ Container dockercomposefiles-container1-1  Stopping                     0.7s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 0/2
[37m ‚†ß Container dockercomposefiles-container2-1  Stopping                     0.8s
[0m[37m ‚†ß Container dockercomposefiles-container1-1  Stopping                     0.8s
...
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 1/2
[34m ‚†ø Container dockercomposefiles-container2-1  Stopped                     10.4s
[0m[37m ‚†∏ Container dockercomposefiles-container1-1  Stopping                    10.4s
[0m[?25h[1A[1A[1A[0G[?25l[34m[+] Running 2/2[0m
[34m ‚†ø Container dockercomposefiles-container2-1  Stopped                     10.4s
[0m[34m ‚†ø Container dockercomposefiles-container1-1  Stopped                     10.4s
[0m[?25h</output_code>
  <markdown>Como se pode ver, o Docker Compose parou os dois cont√™ineres, mas n√£o os excluiu, nem excluiu a rede.</markdown>
  <input_code>!docker ps</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
</output_code>
  <input_code>!docker ps -a</input_code>
  <output_code>CONTAINER ID   IMAGE                  COMMAND          CREATED          STATUS                        PORTS     NAMES
1e6c1dd9adb2   maximofn/ubuntu:ping   "ping 0.0.0.0"   16 minutes ago   Exited (137) 25 seconds ago             dockercomposefiles-container2-1
a7cf282fe66c   maximofn/ubuntu:ping   "ping 0.0.0.0"   16 minutes ago   Exited (137) 25 seconds ago             dockercomposefiles-container1-1
</output_code>
  <input_code>!docker network ls</input_code>
  <output_code>NETWORK ID     NAME                         DRIVER    SCOPE
13cc632147f3   bridge                       bridge    local
d4a2f718cd83   dockercomposefiles_default   bridge    local
da1f5f6fccc0   host                         host      local
d3b0d93993c0   none                         null      local
</output_code>
  <markdown>### Docker compose como ferramenta de desenvolvimento</markdown>
  <markdown>Assim como vimos antes, para poder desenvolver, o ideal seria compartilhar a pasta que tem o c√≥digo com o servi√ßo. Isso com docker compose se faz adicionando a etiqueta `volumes` ao arquivo docker compose. Primeiro temos que adicionar a rota da pasta onde est√° o c√≥digo no host e depois a rota no cont√™iner.

*docker-compose.yml*:
```json
vers√£o: "3.8"

servi√ßos:
container1:
image: ubuntu
comando: ping 0.0.0.0
volumes:
- ../dockerHostFolder/:/dockerContainerFolder

container2:
image: ubuntu
comando: ping 0.0.0.0
```

Como se pode ver, o caminho da pasta do host coloquei relativo

Se subirmos o Docker Compose</markdown>
  <input_code>!cd dockerComposeFiles &amp;&amp; docker compose up -d</input_code>
  <output_code>[1A[1B[0G[?25l[+] Running 1/0
[37m ‚†ã Container dockercomposefiles-container1-1  Recreate                     0.1s
[0m[34m ‚†ø Container dockercomposefiles-container2-1  Created                      0.0s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 0/2
[37m ‚†ø Container dockercomposefiles-container1-1  Starting                     0.2s
[0m[37m ‚†ø Container dockercomposefiles-container2-1  Starting                     0.2s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 0/2
[37m ‚†ø Container dockercomposefiles-container1-1  Starting                     0.3s
[0m[37m ‚†ø Container dockercomposefiles-container2-1  Starting                     0.3s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 0/2
[37m ‚†ø Container dockercomposefiles-container1-1  Starting                     0.4s
[0m[37m ‚†ø Container dockercomposefiles-container2-1  Starting                     0.4s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 1/2
[34m ‚†ø Container dockercomposefiles-container1-1  Started                      0.5s
[0m[37m ‚†ø Container dockercomposefiles-container2-1  Starting                     0.5s
[0m[?25h[1A[1A[1A[0G[?25l[34m[+] Running 2/2[0m
[34m ‚†ø Container dockercomposefiles-container1-1  Started                      0.5s
[0m[34m ‚†ø Container dockercomposefiles-container2-1  Started                      0.6s
[0m[?25h</output_code>
  <markdown>Se entrarmos no cont√™iner, podemos ver o que h√° dentro do arquivo text.txt

```bash
$ docker compose exec container1 bash
root@c8aae9d619d3:/# ls dockerContainerFolder/
bindFile.txt  fileExtract.txt  text.txt
root@c8aae9d619d3:/# cat dockerContainerFolder/text.txt
ol√° cont√™iner
```

Se agora o abrirmos no host, escrevemos `hola host` e voltamos a ver no cont√™iner

```bash
root@c8aae9d619d3:/# cat dockerContainerFolder/text.txt
ol√° host
```

E agora ao contr√°rio, se o modificarmos no cont√™iner

```bash
root@c8aae9d619d3:/# echo ol√° compose &gt; dockerContainerFolder/text.txt
root@c8aae9d619d3:/# exit
sair
```

Se o vemos do host, devemos obter `hola compose`</markdown>
  <input_code>!cat dockerHostFolder/text.txt</input_code>
  <output_code>hola compose
</output_code>
  <markdown>### Exposi√ß√£o de portas no docker compose</markdown>
  <markdown>Tamb√©m podemos configurar as portas no arquivo do Docker Compose, atrav√©s da etiqueta `ports`, indicando a porta do host e em seguida o IP do servi√ßo

```json
portos:
- &lt;porta do host&gt;:&lt;porta do servi√ßo&gt;
```</markdown>
  <markdown>### Docker compose em equipe - docker override</markdown>
  <markdown>Se formos um grupo de pessoas desenvolvendo com Docker e Docker Compose, √© prov√°vel que muitas pessoas estejam alterando o arquivo Docker Compose, o que pode fazer com que n√£o se sincronizem bem e haja conflitos.

Para resolver isso, o Docker oferece uma ferramenta chamada Docker Override. Dessa forma, pode haver um arquivo Docker Compose base e cada um pode modific√°-lo por meio do Docker Override.

Para fazer isso, agora temos que criar um arquivo chamado `docker-compose.override.yml` que ser√° o que poderemos editar</markdown>
  <input_code>!touch dockerComposeFiles/docker-compose.override.yml</input_code>
  <markdown>Se agora tentarmos subir o Docker Compose, vamos receber um erro.</markdown>
  <input_code>!cd dockerComposeFiles &amp;&amp; docker compose up -d</input_code>
  <output_code>Top-level object must be a mapping
</output_code>
  <markdown>E isso porque o Docker Compose detectou que h√° um arquivo chamado `docker-compose.override.yml` e que est√° vazio, ent√£o vamos edit√°-lo. O arquivo `docker-compose.override.yml` serve para editar o arquivo `docker-compose.yml`, ent√£o, se quisermos fazer uma altera√ß√£o no servi√ßo `container2` para adicionar um volume, escrever√≠amos assim o arquivo `docker-compose.override.yml`

*docker-compose.override.yml*:
```json
vers√£o: "3.8"

servi√ßos:
container2:
volumes:
- ../dockerHostFolder/:/dockerOverrideFolder
```

Note que a pasta compartida no servi√ßo foi chamada de `dockerOverrideFolder`, ent√£o vamos iniciar o docker compose e verificar se vemos essa pasta no cont√™iner `container2`.</markdown>
  <input_code>!cd dockerComposeFiles &amp;&amp; docker compose up -d</input_code>
  <output_code>[1A[1B[0G[?25l[+] Running 1/0
[37m ‚†ã Container dockercomposefiles-container2-1  Recreate                     0.1s
[0m[34m ‚†ø Container dockercomposefiles-container1-1  Running                      0.0s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 1/2
[37m ‚†ô Container dockercomposefiles-container2-1  Recreate                     0.2s
[0m[34m ‚†ø Container dockercomposefiles-container1-1  Running                      0.0s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 1/2
[37m ‚†π Container dockercomposefiles-container2-1  Recreate                     0.3s
[0m[34m ‚†ø Container dockercomposefiles-container1-1  Running                      0.0s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 1/2
[37m ‚†∏ Container dockercomposefiles-container2-1  Recreate                     0.4s
[0m[34m ‚†ø Container dockercomposefiles-container1-1  Running                      0.0s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 1/2
[37m ‚†º Container dockercomposefiles-container2-1  Recreate                     0.5s
[0m[34m ‚†ø Container dockercomposefiles-container1-1  Running                      0.0s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 1/2
[37m ‚†¥ Container dockercomposefiles-container2-1  Recreate                     0.6s
[0m[34m ‚†ø Container dockercomposefiles-container1-1  Running                      0.0s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 1/2
[37m ‚†¶ Container dockercomposefiles-container2-1  Recreate                     0.7s
[0m[34m ‚†ø Container dockercomposefiles-container1-1  Running                      0.0s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 1/2
[37m ‚†ß Container dockercomposefiles-container2-1  Recreate                     0.8s
[0m[34m ‚†ø Container dockercomposefiles-container1-1  Running                      0.0s
...
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 1/2
[37m ‚†ø Container dockercomposefiles-container2-1  Starting                    10.8s
[0m[34m ‚†ø Container dockercomposefiles-container1-1  Running                      0.0s
[0m[?25h[1A[1A[1A[0G[?25l[34m[+] Running 2/2[0m
[34m ‚†ø Container dockercomposefiles-container2-1  Started                     10.8s
[0m[34m ‚†ø Container dockercomposefiles-container1-1  Running                      0.0s
[0m[?25h</output_code>
  <markdown>Vemos que levou 10 segundos para iniciar o servi√ßo `container2`, isso se deve ao fato de estar aplicando as altera√ß√µes.

```bash
$ docker compose exec container2 bash
root@d8777a4e611a:/# ls dockerOverrideFolder/
bindFile.txt  fileExtract.txt  text.txt
root@d8777a4e611a:/# cat dockerOverrideFolder/text.txt
ol√° compose
root@d8777a4e611a:/# exit
sa√≠da
```</markdown>
  <markdown>Descemos o Compose e apagamos os cont√™ineres e a rede criada</markdown>
  <input_code>!cd dockerComposeFiles &amp;&amp; docker compose down</input_code>
  <output_code>[1A[1B[0G[?25l[+] Running 0/0
[37m ‚†ã Container dockercomposefiles-container2-1  Stopping                     0.1s
[0m[37m ‚†ã Container dockercomposefiles-container1-1  Stopping                     0.1s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 0/2
[37m ‚†ô Container dockercomposefiles-container2-1  Stopping                     0.2s
[0m[37m ‚†ô Container dockercomposefiles-container1-1  Stopping                     0.2s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 0/2
[37m ‚†π Container dockercomposefiles-container2-1  Stopping                     0.3s
[0m[37m ‚†π Container dockercomposefiles-container1-1  Stopping                     0.3s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 0/2
[37m ‚†∏ Container dockercomposefiles-container2-1  Stopping                     0.4s
[0m[37m ‚†∏ Container dockercomposefiles-container1-1  Stopping                     0.4s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 0/2
[37m ‚†º Container dockercomposefiles-container2-1  Stopping                     0.5s
[0m[37m ‚†º Container dockercomposefiles-container1-1  Stopping                     0.5s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 0/2
[37m ‚†¥ Container dockercomposefiles-container2-1  Stopping                     0.6s
[0m[37m ‚†¥ Container dockercomposefiles-container1-1  Stopping                     0.6s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 0/2
[37m ‚†¶ Container dockercomposefiles-container2-1  Stopping                     0.7s
[0m[37m ‚†¶ Container dockercomposefiles-container1-1  Stopping                     0.7s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 0/2
[37m ‚†ß Container dockercomposefiles-container2-1  Stopping                     0.8s
[0m[37m ‚†ß Container dockercomposefiles-container1-1  Stopping                     0.8s
...
[37m ‚†∏ Container dockercomposefiles-container2-1  Stopping                    10.4s
[0m[37m ‚†∏ Container dockercomposefiles-container1-1  Stopping                    10.4s
[0m[?25h[1A[1A[1A[0G[?25l[+] Running 1/2
[34m ‚†ø Container dockercomposefiles-container2-1  Removed                     10.4s
[0m[37m ‚†ø Container dockercomposefiles-container1-1  Removing                    10.5s
[0m[?25h[1A[1A[1A[0G[?25l[34m[+] Running 2/2[0m
[34m ‚†ø Container dockercomposefiles-container2-1  Removed                     10.4s
[0m[34m ‚†ø Container dockercomposefiles-container1-1  Removed                     10.5s
[0m[37m ‚†ã Network dockercomposefiles_default         Removing                     0.1s
[0m[?25h[1A[1A[1A[1A[0G[?25l[34m[+] Running 3/3[0m
[34m ‚†ø Container dockercomposefiles-container2-1  Removed                     10.4s
[0m[34m ‚†ø Container dockercomposefiles-container1-1  Removed                     10.5s
[0m[34m ‚†ø Network dockercomposefiles_default         Removed                      0.2s
[0m[?25h</output_code>
  <markdown>Neste caso, apenas com `down` o Docker Compose parou e removeu tudo, pois, como podemos ver nos cont√™ineres e na rede, est√° escrito `Removed`</markdown>
  <markdown>### Docker compose reiniciar</markdown>
  <markdown>Ao escrever um docker compose, podemos adicionar a tag `restart` para que, se o cont√™iner cair, ele seja reiniciado automaticamente.

```json
restart: sempre
```

Desta forma, se o cont√™iner cair, ele ser√° reiniciado automaticamente. Se quisermos que ele seja reiniciado apenas um n√∫mero de vezes, podemos adicionar a op√ß√£o `on-failure`.

```json
restart: on-failure:&lt;n√∫mero&gt;
```

Agora o cont√™iner ser√° reiniciado um n√∫mero de vezes, mas se cair mais vezes, n√£o ser√° reiniciado. Se quisermos que seja reiniciado sempre, podemos adicionar a op√ß√£o `unless-stopped`.

```json
restart: unless-stopped
```

Agora o cont√™iner ser√° reiniciado sempre, a menos que seja parado manualmente.</markdown>
  <markdown>## Docker avan√ßado</markdown>
  <markdown>### Gerenciar ambiente de trabalho</markdown>
  <markdown>#### Remo√ß√£o de cont√™ineres desligados</markdown>
  <markdown>Depois de um tempo desenvolvendo, podemos ter v√°rios cont√™ineres desligados, mas armazenados no computador. Isso acaba ocupando mem√≥ria, ent√£o com `docker container prune` podemos eliminar todos os que est√£o parados.</markdown>
  <input_code>!docker run ubuntu</input_code>
  <input_code>!docker ps</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
</output_code>
  <input_code>!docker ps -a</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND   CREATED          STATUS                      PORTS     NAMES
effcee24f54a   ubuntu    "bash"    37 seconds ago   Exited (0) 36 seconds ago             musing_rosalind
</output_code>
  <markdown>``` bash
$ docker container prune
AVISO! Isso remover√° todos os cont√™ineres parados.
Tem certeza de que deseja continuar? [s/N] s
Cont√™ineres Exclu√≠dos:
effcee24f54aab22e34fdea2465b3b7af132d8c627e5432ba3e915a370876977

Espa√ßo total recuperado: 0B
```

Neste caso, economizamos 0 bytes, mas no deixar cont√™ineres desligados ap√≥s muito desenvolvimento com certeza resultar√° em maior economia de mem√≥ria.</markdown>
  <markdown>#### Exclus√£o de todos os cont√™ineres</markdown>
  <markdown>Em caso de ter cont√™ineres em execu√ß√£o, podemos eliminar todos os cont√™ineres por meio de outro comando

O comando `docker ps -q` nos retorna o ID de todos os cont√™ineres, portanto, com o comando `docker rm -f $(docker ps -aq)` pararemos e apagaremos todos.</markdown>
  <input_code>!docker run -d ubuntu tail -f /dev/null</input_code>
  <output_code>c22516186ef7e3561fb1ad0d508a914857dbc61274a218f297c4d80b1fc33863
</output_code>
  <input_code>!docker ps</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND               CREATED              STATUS              PORTS     NAMES
c22516186ef7   ubuntu    "tail -f /dev/null"   About a minute ago   Up About a minute             agitated_knuth
</output_code>
  <input_code>!docker rm -f $(docker ps -aq)</input_code>
  <output_code>c22516186ef7
</output_code>
  <input_code>!docker ps -a</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
</output_code>
  <markdown>#### Exclus√£o de tudo</markdown>
  <markdown>Como vimos, o Docker tamb√©m cria redes, imagens, volumes, etc, ent√£o com o comando `docker system prune` podemos apagar todos os cont√™ineres parados, todas as redes que n√£o estejam sendo usadas por pelo menos um cont√™iner, as imagens duplicadas, e o que estiver duplicado no cache de compila√ß√£o.

``` bash
$ docker system prune
AVISO! Isso remover√°:
- todos os cont√™ineres parados
- todas as redes n√£o utilizadas por pelo menos um cont√™iner
- todas as imagens pendentes
- todos os caches de constru√ß√£o pendentes

Tem certeza de que deseja continuar? [s/N] s
Espa√ßo total recuperado: 0B
```

Assim como antes, n√£o se economizou muito espa√ßo, mas ap√≥s muito tempo desenvolvendo, a economia ser√° consider√°vel.</markdown>
  <markdown>### Uso de recursos do host por parte dos cont√™ineres</markdown>
  <markdown>Por exemplo, ao criar um cont√™iner, podemos limitar a RAM que o host pode usar atrav√©s da op√ß√£o `--memory`</markdown>
  <input_code>!docker run -d --memory 1g ubuntu tail -f /dev/null</input_code>
  <output_code>d84888eafe531831ef8915d2270422365adec02678122bf59580e2da782e6972
</output_code>
  <markdown>Mas com `docker ps` n√£o temos acesso aos recursos que o cont√™iner est√° consumindo.</markdown>
  <input_code>!docker ps</input_code>
  <output_code>CONTAINER ID   IMAGE     COMMAND               CREATED          STATUS          PORTS     NAMES
d84888eafe53   ubuntu    "tail -f /dev/null"   35 seconds ago   Up 34 seconds             musing_ritchie
</output_code>
  <markdown>Para isso temos o comando `docker stats`

```bash
$ docker stats
ID DO CONTAINER   NOME             CPU %     USO DE MEM√ìRIA / LIMITE   MEM %     REDE I/O       BLOCO I/O   PIDS
d84888eafe53   musing_ritchie   0,00%     540KiB / 1GiB       0,05%     5,62kB / 0B   0B / 0B     1
```

Isso √© muito √∫til se quisermos simular um ambiente com um limite de RAM</markdown>
  <markdown>### Parando cont√™ineres corretamente: SHELL vs EXEC</markdown>
  <markdown>Como explicamos, quando atribu√≠mos um processo a um cont√™iner, quando esse processo termina, o cont√™iner para, mas √†s vezes podemos nos deparar com problemas com isso. Vamos criar uma nova pasta chamada Dockerfile_loop</markdown>
  <input_code>!mkdir Dockerfile_loop</input_code>
  <markdown>Agora vamos a criar um arquivo chamado `loop.sh` dentro de `Dockerfile_loop`</markdown>
  <input_code>!touch Dockerfile_loop/loop.sh</input_code>
  <markdown>E vamos a escrever o seguinte dentro de `loop.sh`

``` shell
#!/usr/bin/env bash
trap "exit 0" SIGTERM
while true; do :; done
```

Se eu executar este script no host, ele ser√° executado at√© que eu insira `CTRL+C`


``` bash
./loop
^C
```
Por favor, forne√ßa o texto em markdown que voc√™ gostaria que eu traduzisse para o portugu√™s.</markdown>
  <markdown>Agora vamos a criar um arquivo `Dockerfile` dentro de `Dockerfile_loop`</markdown>
  <input_code>!touch Dockerfile_loop/Dockerfile</input_code>
  <markdown>*Arquivo Dockerfile*:
``` docker
DE ubuntu:trusty
COPY ["loop.sh", "/"]
CMD /loop.sh
```</markdown>
  <markdown>Vamos a criar uma imagem baseada no Ubuntu que copia o script para dentro e o executa, e o script √© executado at√© receber o sinal `SIGTERM` do sistema operacional. Compilamos a imagem</markdown>
  <input_code>!docker build -t ubuntu:loop ./Dockerfile_loop</input_code>
  <output_code>Sending build context to Docker daemon  3.072kB
Step 1/3 : FROM ubuntu:trusty
 ---&gt; 13b66b487594
Step 2/3 : COPY ["loop.sh", "/"]
 ---&gt; 89f2bbd25a88
Step 3/3 : CMD /loop.sh
 ---&gt; Running in ff52569c35fd
Removing intermediate container ff52569c35fd
 ---&gt; feb091e4efa3
Successfully built feb091e4efa3
Successfully tagged ubuntu:loop

Use 'docker scan' to run Snyk tests against images to find vulnerabilities and learn how to fix them
</output_code>
  <markdown>Executamos o cont√™iner

``` bash
docker run -d --name looper ubuntu:loop bash
```</markdown>
  <input_code>!docker run -d --name looper ubuntu:loop</input_code>
  <output_code>8a28f8cc9892213c4e0603dfdde320edf52c091b82c60510083549a391cd6645
</output_code>
  <markdown>Verificamos e vemos que o cont√™iner est√° rodando</markdown>
  <input_code>!docker ps</input_code>
  <output_code>CONTAINER ID   IMAGE         COMMAND                 CREATED         STATUS         PORTS     NAMES
8a28f8cc9892   ubuntu:loop   "/bin/sh -c /loop.sh"   4 seconds ago   Up 3 seconds             looper
</output_code>
  <markdown>Tentamos parar o cont√™iner com `docker stop looper`. O Docker stop tenta parar o cont√™iner enviando-lhe o sinal `SIGTERM`.</markdown>
  <input_code>%%time
!docker stop looper</input_code>
  <output_code>looper
CPU times: user 89.2 ms, sys: 21.7 ms, total: 111 ms
Wall time: 10.6 s
</output_code>
  <markdown>Isso levou cerca de 10 segundos para parar, quando deveria ser imediato. Isso aconteceu porque `stop` enviou o sinal `SIGTERM` para parar o cont√™iner, mas como ele n√£o parava, depois de um tempo enviou um `SIGKILL` para for√ßar a parada. Vamos ver o que acontece se listarmos os cont√™ineres.</markdown>
  <input_code>!docker ps -a</input_code>
  <output_code>CONTAINER ID   IMAGE         COMMAND                 CREATED          STATUS                       PORTS     NAMES
8a28f8cc9892   ubuntu:loop   "/bin/sh -c /loop.sh"   23 seconds ago   Exited (137) 2 seconds ago             looper
</output_code>
  <markdown>Podemos ver que o sinal de `Exited` √© `137`, isso equivale a SIGKILL, ou seja, o Docker teve que for√ßar o desligamento.</markdown>
  <markdown>Vamos a apagar o cont√™iner e a execut√°-lo novamente</markdown>
  <input_code>!docker rm looper</input_code>
  <output_code>looper
</output_code>
  <input_code>!docker run -d --name looper ubuntu:loop</input_code>
  <output_code>84bc37f944d270be5f84a952968db2b8cf5372c61146d29383468198ceed18fd
</output_code>
  <markdown>Se agora tentarmos parar o cont√™iner com `docker kill looper`</markdown>
  <input_code>%%time
!docker kill looper</input_code>
  <output_code>looper
CPU times: user 9.1 ms, sys: 857 ¬µs, total: 9.96 ms
Wall time: 545 ms
</output_code>
  <markdown>Vemos que o tempo s√£o cerca de 500 ms, ou seja, o Docker o parou em um momento enviando a ordem `SIGKILL`. Porque `kill` n√£o envia `SIGTERM` e se em um tempo n√£o foi parado o cont√™iner, ele envia `SIGKILL`, o que faz √© enviar `SIGKILL` desde o in√≠cio.

Se vemos os cont√™ineres, vemos que o sinal de sa√≠da √© o mesmo, `137`</markdown>
  <input_code>!docker ps -a</input_code>
  <output_code>CONTAINER ID   IMAGE         COMMAND                 CREATED         STATUS                       PORTS     NAMES
84bc37f944d2   ubuntu:loop   "/bin/sh -c /loop.sh"   6 seconds ago   Exited (137) 2 seconds ago             looper
</output_code>
  <markdown>Esta n√£o √© a maneira correta de desligar um cont√™iner, pois quando quisermos deslig√°-lo, dever√≠amos fazer isso atrav√©s do sinal `SIGTERM`, para que ele possa terminar de processar o que estivesse fazendo e ent√£o se desligue.</markdown>
  <markdown>Se apagarmos o cont√™iner e o reexecutarmos</markdown>
  <input_code>!docker rm looper</input_code>
  <output_code>looper
</output_code>
  <input_code>!docker run -d --name looper ubuntu:loop</input_code>
  <output_code>b9d9f370cc0de7569eb09d0a85cd67e8ea6babc0754a517ccba5c5057f5cc50e
</output_code>
  <markdown>Se agora olharmos para os processos que est√£o sendo executados dentro do cont√™iner</markdown>
  <input_code>!docker exec looper ps -ef</input_code>
  <output_code>UID          PID    PPID  C STIME TTY          TIME CMD
root           1       0  0 14:05 ?        00:00:00 /bin/sh -c /loop.sh
root           7       1 93 14:05 ?        00:00:02 bash /loop.sh
root           8       0  0 14:05 ?        00:00:00 ps -ef
</output_code>
  <markdown>Na verdade o processo principal, o 1, n√£o √© `/loop.sh` mas sim `/bin/sh -c /loop.sh`, ou seja, √© um processo filho do `shell`. Portanto, quando a sinal `SIGTERM` chegava ao `shell`, este n√£o a encaminhava para seus processos filhos, por isso ela n√£o chegava a `loop.sh`</markdown>
  <markdown>Para que isso n√£o aconte√ßa, √© necess√°rio alterar o `Dockerfile` para o seguinte:

*Arquivo Dockerfile*:
``` docker
FROM ubuntu:trusty
COPY ["loop.sh", "/"]
CMD ["/loop.sh"]    # antes era CMD /loop.sh
```

Esta forma se chama `exec form`, enquanto a anterior se chama `shell form`. Na forma anterior, o processo √© executado como um filho do `shell`, enquanto na forma `exec form` executa diretamente o processo que indicarmos. Ent√£o, apagamos o cont√™iner, recompilamos e reiniciamos o cont√™iner com a imagem.</markdown>
  <input_code>!docker rm -f looper</input_code>
  <output_code>looper
</output_code>
  <input_code>!docker build -t ubuntu:loop ./Dockerfile_loop</input_code>
  <output_code>Sending build context to Docker daemon  3.072kB
Step 1/3 : FROM ubuntu:trusty
 ---&gt; 13b66b487594
Step 2/3 : COPY ["loop.sh", "/"]
 ---&gt; Using cache
 ---&gt; 89f2bbd25a88
Step 3/3 : CMD ["/loop.sh"]
 ---&gt; Running in 6b8d92fcd57c
Removing intermediate container 6b8d92fcd57c
 ---&gt; 35a7bb2b1892
Successfully built 35a7bb2b1892
Successfully tagged ubuntu:loop

Use 'docker scan' to run Snyk tests against images to find vulnerabilities and learn how to fix them
</output_code>
  <input_code>!docker run -d --name looper ubuntu:loop</input_code>
  <output_code>850ae70c071426850b28428ac60dcbf875c6d35d9b7cc66c17cf391a23392965
</output_code>
  <markdown>Agora vejo os processos dentro do cont√™iner.</markdown>
  <input_code>!docker exec looper ps -ef</input_code>
  <output_code>UID          PID    PPID  C STIME TTY          TIME CMD
root           1       0 88 14:14 ?        00:00:02 bash /loop.sh
root           7       0  0 14:14 ?        00:00:00 ps -ef
</output_code>
  <markdown>Agora vejo que o processo principal, o 1, √© `/loop.sh`

Se agora eu tentar parar o cont√™iner</markdown>
  <input_code>%%time
!docker stop looper</input_code>
  <output_code>looper
CPU times: user 989 ¬µs, sys: 7.55 ms, total: 8.54 ms
Wall time: 529 ms
</output_code>
  <markdown>Vemos que demora mais. Vejamos o c√≥digo com o qual parou.</markdown>
  <input_code>!docker ps -a</input_code>
  <output_code>CONTAINER ID   IMAGE         COMMAND      CREATED              STATUS                      PORTS     NAMES
850ae70c0714   ubuntu:loop   "/loop.sh"   About a minute ago   Exited (0) 33 seconds ago             looper
</output_code>
  <markdown>### Contentores execut√°veis</markdown>
  <markdown>Se quisermos um bin√°rio que rode como um execut√°vel, no `dockerfile` √© preciso especificar o comando em `ENTRYPOINT` e os par√¢metros do comando em `CMD`, vamos ver isso.</markdown>
  <markdown>Vamos a criar uma nova pasta onde guardaremos o `Dockerfile`</markdown>
  <input_code>!mkdir dockerfile_ping</input_code>
  <markdown>Agora criamos um Dockerfile dentro</markdown>
  <input_code>!touch dockerfile_ping/Dockerfile</input_code>
  <markdown>Escrevemos dentro do Dockerfile o seguinte

``` docker
FROM ubuntu:trusty
ENTRYPOINT [ "/bin/ping", "-c", "3" ]
CMD [ "localhost" ]
```

Compilamos a imagem</markdown>
  <input_code>!docker build -t ubuntu:ping ./dockerfile_ping</input_code>
  <output_code>Sending build context to Docker daemon  3.072kB
Step 1/3 : FROM ubuntu:trusty
 ---&gt; 13b66b487594
Step 2/3 : ENTRYPOINT [ "/bin/ping", "-c", "3" ]
 ---&gt; Using cache
 ---&gt; 1cebcfb542b1
Step 3/3 : CMD [ "localhost" ]
 ---&gt; Using cache
 ---&gt; 04ddc3de52a2
Successfully built 04ddc3de52a2
Successfully tagged ubuntu:ping

Use 'docker scan' to run Snyk tests against images to find vulnerabilities and learn how to fix them
</output_code>
  <markdown>Se agora executarmos a imagem sem passar um par√¢metro, o cont√™iner far√° um ping a si mesmo</markdown>
  <input_code>!docker run --name ping_localhost ubuntu:ping</input_code>
  <output_code>PING localhost (127.0.0.1) 56(84) bytes of data.
64 bytes from localhost (127.0.0.1): icmp_seq=1 ttl=64 time=0.041 ms
64 bytes from localhost (127.0.0.1): icmp_seq=2 ttl=64 time=0.058 ms
64 bytes from localhost (127.0.0.1): icmp_seq=3 ttl=64 time=0.054 ms

--- localhost ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2027ms
rtt min/avg/max/mdev = 0.041/0.051/0.058/0.007 ms
</output_code>
  <markdown>Mas se passarmos um par√¢metro agora, ele far√° ping no endere√ßo que dissermos</markdown>
  <input_code>!docker run --name ping_google ubuntu:ping google.com</input_code>
  <output_code>PING google.com (216.58.209.78) 56(84) bytes of data.
64 bytes from waw02s06-in-f14.1e100.net (216.58.209.78): icmp_seq=1 ttl=111 time=3.93 ms
64 bytes from waw02s06-in-f14.1e100.net (216.58.209.78): icmp_seq=2 ttl=111 time=6.80 ms
64 bytes from waw02s06-in-f14.1e100.net (216.58.209.78): icmp_seq=3 ttl=111 time=6.92 ms

--- google.com ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2002ms
rtt min/avg/max/mdev = 3.930/5.886/6.920/1.383 ms
</output_code>
  <markdown>Apagamos os cont√™ineres</markdown>
  <input_code>!docker rm ping_localhost ping_google</input_code>
  <output_code>ping_localhost
ping_google
</output_code>
  <markdown>### O contexto de `build`</markdown>
  <markdown>Vamos a criar uma pasta chamada `dockerfile_contexto`</markdown>
  <input_code>!mkdir dokerfile_contexto</input_code>
  <markdown>Agora criamos nela dois arquivos: um `test.txt` e o `Dockerfile`</markdown>
  <input_code>!touch dokerfile_contexto/Dockerfile dokerfile_contexto/text.txt</input_code>
  <markdown>Modificamos o Dockerfile e colocamos o seguinte

``` docker
FROM ubuntu:trusty
COPY [".", "/"]
```

Isso vai fazer com que tudo o que est√° na pasta onde se encontra o `Dockerfile` seja copiado para dentro da imagem. Compilamos a imagem.</markdown>
  <input_code>!docker build -t ubuntu:contexto ./dokerfile_contexto</input_code>
  <output_code>Sending build context to Docker daemon   2.56kB
Step 1/2 : FROM ubuntu:trusty
 ---&gt; 13b66b487594
Step 2/2 : COPY [".", "/"]
 ---&gt; 3ab79fdce389
Successfully built 3ab79fdce389
Successfully tagged ubuntu:contexto

Use 'docker scan' to run Snyk tests against images to find vulnerabilities and learn how to fix them
</output_code>
  <markdown>Vamos ver o que tem dentro do cont√™iner</markdown>
  <input_code>!docker run --name ls ubuntu:contexto ls</input_code>
  <output_code>Dockerfile
bin
boot
dev
etc
home
lib
lib64
media
mnt
opt
proc
root
run
sbin
srv
sys
text.txt
tmp
usr
var
</output_code>
  <markdown>Como vemos est√° o arquivo `text.txt`. Mas √© poss√≠vel que dentro da pasta que est√° no mesmo diret√≥rio que o `Dockerfile` haja arquivos ou pastas que n√£o queremos que sejam copiados para a imagem, por qualquer raz√£o, ent√£o assim como no git temos o `.gitignore`, no docker temos o `.dockerignore`, onde colocamos os arquivos ou pastas que n√£o queremos que sejam levados em conta na hora de compilar.

Ent√£o criamos um arquivo `.dockerignore`</markdown>
  <input_code>!touch dokerfile_contexto/.dockerignore</input_code>
  <markdown>E dentro adicionamos o `text.txt`, e de passo o `Dockerfile` que n√£o precisamos dentro da imagem

*.dockerignore*:
```
Dockerfile
Parece que hay un malentendido. El archivo `text.txt` no foi fornecido. Por favor, forne√ßa o conte√∫do do arquivo em formato markdown para que eu possa traduzi-lo.
```</markdown>
  <markdown>Apagamos o cont√™iner que t√≠nhamos criado, recompilamos e vemos o que h√° dentro do cont√™iner</markdown>
  <input_code>!docker rm ls</input_code>
  <output_code>ls
</output_code>
  <input_code>!docker build -t ubuntu:contexto ./dokerfile_contexto</input_code>
  <output_code>Sending build context to Docker daemon  3.072kB
Step 1/2 : FROM ubuntu:trusty
 ---&gt; 13b66b487594
Step 2/2 : COPY [".", "/"]
 ---&gt; 7a6689546da4
Successfully built 7a6689546da4
Successfully tagged ubuntu:contexto

Use 'docker scan' to run Snyk tests against images to find vulnerabilities and learn how to fix them
</output_code>
  <input_code>!docker run --name ls ubuntu:contexto ls</input_code>
  <output_code>bin
boot
dev
etc
home
lib
lib64
media
mnt
opt
proc
root
run
sbin
srv
sys
tmp
usr
var
</output_code>
  <markdown>Vemos que agora n√£o est√£o nem `Dockerfile` nem `text.txt`. Apagamos o contentor.</markdown>
  <input_code>!docker rm ls</input_code>
  <output_code>ls
</output_code>
  <markdown>### Constru√ß√£o em m√∫ltiplas etapas</markdown>
  <markdown>No final de um desenvolvimento, n√£o queremos que todo o c√≥digo esteja na imagem que vai ser enviada para produ√ß√£o.

Podemos dividir o `dockerfile` em dois, por exemplo, o `developer.Dockerfile` e o `production.Dockerfile`, onde no desenvolvimento haver√° mais coisas do que na produ√ß√£o. Na hora de compil√°-los, atrav√©s da op√ß√£o `-f` escolhemos o `dockerfile` que queremos usar

``` bash
docker build -t &lt;tag&gt; -f developer.Dockerfile
docker build -t &lt;tag&gt; -f production.Dockerfile
```</markdown>
  <markdown>Mas para n√£o ter que criar dois arquivos `Dockerfile`, o Docker criou os `multi stage builds`. Com um √∫nico `Dockerfile` vamos resolver o problema.</markdown>
  <markdown>Criamos a pasta onde vamos salvar o `Dockerfile`</markdown>
  <input_code>!mkdir docker_multi_stage</input_code>
  <markdown>E dentro criamos o arquivo `Dockerfile`</markdown>
  <input_code>!cd docker_multi_stage &amp;&amp; touch Dockerfile</input_code>
  <markdown>Editamos o arquivo, inserindo o seguinte

``` dockerfile
# Etapa 1: Gerar o execut√°vel com Python baseado em Alpine
FROM python:3.9-alpine como build-stage
WORKDIR /app
# Instalar depend√™ncias para PyInstaller
RUN apk add --no-cache gcc musl-dev libc-dev
# Gerar hello.py
RUN echo 'print("Ol√° do Alpine!")' &gt; hello.py
# Instalar PyInstaller
RUN pip install pyinstaller
# Usar PyInstaller para criar um execut√°vel independente
RUN pyinstaller --onefile hello.py

# Etapa 2: Executar o execut√°vel em uma imagem do Alpine
FROM alpine:latest
WORKDIR /app
# Copiar o execut√°vel da etapa de build
COPY --from=build-stage /app/dist/hello .
# Comando padr√£o para executar o execut√°vel
CMD ["./hello"]
```

Como se pode ver, o `Dockerfile` est√° dividido em duas partes. De um lado, trabalhamos sobre a imagem `python:3.9-alpine`, que √© chamada de `build-stage`. Do outro lado, trabalhamos sobre a imagem `alpine:latest`, que √© uma imagem de Linux muito leve e √© utilizada muito em produ√ß√£o.

O compilamos</markdown>
  <input_code>!docker build -t maximofn/multistagebuild:latest ./docker_multi_stage</input_code>
  <output_code>[1A[1B[0G[?25l[+] Building 0.0s (0/2)                                          docker:default
[?25h</output_code>
  <output_code>[1A[0G[?25l[+] Building 0.2s (4/6)                                          docker:default
[34m =&gt; [internal] load build definition from Dockerfile                       0.0s
[0m[34m =&gt; =&gt; transferring dockerfile: 722B                                       0.0s
[0m[34m =&gt; [internal] load .dockerignore                                          0.0s
[0m[34m =&gt; =&gt; transferring context: 2B                                            0.0s
[0m =&gt; [internal] load metadata for docker.io/library/alpine:latest           0.1s
 =&gt; [internal] load metadata for docker.io/library/python:3.9-alpine       0.1s
...
[0m[34m =&gt; CACHED [stage-1 3/3] COPY --from=build-stage /app/dist/hello .         0.0s
[0m[34m =&gt; exporting to image                                                     0.0s
[0m[34m =&gt; =&gt; exporting layers                                                    0.0s
[0m[34m =&gt; =&gt; writing image sha256:7fb090d1495d00e892118b6bc3c03400b63a435fd4703  0.0s
[0m[34m =&gt; =&gt; naming to docker.io/maximofn/multistagebuild:latest                 0.0s
[0m[?25h</output_code>
  <markdown>Se agora olharmos para as imagens que temos</markdown>
  <input_code>!docker image ls</input_code>
  <output_code>REPOSITORY                 TAG       IMAGE ID       CREATED         SIZE
maximofn/multistagebuild   latest    7fb090d1495d   8 minutes ago   13.6MB
</output_code>
  <markdown>Vamos baixar a imagem do Python para ver quanto ela pesa</markdown>
  <input_code>!docker pull python:3.9-alpine</input_code>
  <output_code>3.9-alpine: Pulling from library/python

[1Ba8db6415: Already exists 
[1Bd5e70e42: Already exists 
[1B3fe96417: Already exists 
[1Baa4dddbb: Already exists 
[1B518be9f7: Already exists Digest: sha256:6e508b43604ff9a81907ec17405c9ad5c13664e45a5affa2206af128818c7486
Status: Downloaded newer image for python:3.9-alpine
docker.io/library/python:3.9-alpine
</output_code>
  <input_code>!docker image ls</input_code>
  <output_code>REPOSITORY                 TAG          IMAGE ID       CREATED         SIZE
maximofn/multistagebuild   latest       7fb090d1495d   9 minutes ago   13.6MB
python                     3.9-alpine   6946662f018b   9 days ago      47.8MB
</output_code>
  <markdown>Podemos ver que enquanto nossa imagem pesa apenas 13,6 MB, a de Python com a qual foi constru√≠do o aplicativo pesa 47,8 MB. Portanto, podemos tirar duas conclus√µes: com a primeira imagem, a de Python, foi constru√≠do o aplicativo, gerou-se o execut√°vel e esse execut√°vel √© o que usamos na segunda imagem, a de Alpine. Al√©m disso, podemos ver que, embora a primeira imagem usada seja a de Python, ela n√£o √© baixada no nosso sistema, j√° que tivemos que baix√°-la n√≥s mesmos.</markdown>
  <markdown>Ent√£o s√≥ resta test√°-lo.</markdown>
  <input_code>!docker run --rm --name multi_stage_build maximofn/multistagebuild</input_code>
  <output_code>Hello from Alpine!
</output_code>
  <markdown>Funciona!</markdown>
  <markdown>### Builds multi arquitetura</markdown>
  <markdown>Suponhamos que queremos fazer uma imagem que possa ser executada em um computador e em uma Raspberry. O computador provavelmente ter√° um micro com arquitetura AMD64, enquanto a Raspberry tem um micro com arquitetura ARM. Portanto, n√£o podemos criar a mesma imagem para os dois. Ou seja, quando criamos uma imagem, a criamos com um `Dockerfile` que geralmente come√ßa assim

``` Dockerfile
DE ...
```

Portanto, o `Dockerfile` da imagem do computador poderia come√ßar assim

``` Dockerfile
FROM ubuntu:latest
```

Enquanto o da Raspberry poderia come√ßar assim

``` Dockerfile
FROM arm64v8/ubuntu:latest
```</markdown>
  <markdown>Ter√≠amos que criar dois arquivos `Dockerfile`, compil√°-los e no computador usar uma imagem e na raspberry usar outra.</markdown>
  <markdown>Para evitar ter que ver a arquitetura do computador e ver qual imagem temos que usar, o Docker cria os `manifest`, que como seu nome indica √© um manifesto que indica, com base na arquitetura de micro que tenhamos, usa uma imagem ou outra.</markdown>
  <markdown>Ent√£o vamos ver como fazer isso</markdown>
  <markdown>Em primeiro lugar, criamos uma pasta onde vamos criar nossos arquivos `Dockerfile`</markdown>
  <input_code>!mkdir docker_multi_arch</input_code>
  <markdown>Agora criamos os dois Dockerfiles</markdown>
  <input_code>!cd docker_multi_arch &amp;&amp; touch Dockerfile_arm64 Dockerfile_amd64</input_code>
  <markdown>Escrevemos o `Dockerfile` para AMD64</markdown>
  <input_code>!cd docker_multi_arch &amp;&amp; echo "FROM ubuntu:20.04" &gt;&gt; Dockerfile_amd64 &amp;&amp; echo "CMD echo 'Hello from amd64'" &gt;&gt; Dockerfile_amd64</input_code>
  <input_code>!cd docker_multi_arch &amp;&amp; echo "FROM arm64v8/ubuntu:latest" &gt;&gt; Dockerfile_arm &amp;&amp; echo "CMD echo 'Hello from ARM'" &gt;&gt; Dockerfile_arm</input_code>
  <markdown>Agora combinamos as duas imagens</markdown>
  <input_code>!cd docker_multi_arch &amp;&amp; docker build -t maximofn/multiarch:arm -f Dockerfile_arm .</input_code>
  <output_code>[1A[1B[0G[?25l[+] Building 0.0s (0/1)                                          docker:default
[?25h[1A[0G[?25l[+] Building 0.2s (2/3)                                          docker:default
[34m =&gt; [internal] load build definition from Dockerfile_amd64                 0.1s
[0m[34m =&gt; =&gt; transferring dockerfile: 89B                                        0.0s
[0m[34m =&gt; [internal] load .dockerignore                                          0.1s
[0m[34m =&gt; =&gt; transferring context: 2B                                            0.0s
[0m =&gt; [internal] load metadata for docker.io/library/ubuntu:20.04            0.1s
[?25h[1A[1A[1A[1A[1A[1A[0G[?25l[+] Building 0.3s (2/3)                                          docker:default
[34m =&gt; [internal] load build definition from Dockerfile_amd64                 0.1s
[0m[34m =&gt; =&gt; transferring dockerfile: 89B                                        0.0s
[0m[34m =&gt; [internal] load .dockerignore                                          0.1s
[0m[34m =&gt; =&gt; transferring context: 2B                                            0.0s
[0m =&gt; [internal] load metadata for docker.io/library/ubuntu:20.04            0.2s
[?25h[1A[1A[1A[1A[1A[1A[0G[?25l[+] Building 0.5s (2/3)                                          docker:default
[34m =&gt; [internal] load build definition from Dockerfile_amd64                 0.1s
[0m[34m =&gt; =&gt; transferring dockerfile: 89B                                        0.0s
[0m[34m =&gt; [internal] load .dockerignore                                          0.1s
[0m[34m =&gt; =&gt; transferring context: 2B                                            0.0s
[0m =&gt; [internal] load metadata for docker.io/library/ubuntu:20.04            0.4s
[?25h[1A[1A[1A[1A[1A[1A[0G[?25l[+] Building 0.6s (2/3)                                          docker:default
[34m =&gt; [internal] load build definition from Dockerfile_amd64                 0.1s
[0m[34m =&gt; =&gt; transferring dockerfile: 89B                                        0.0s
[0m[34m =&gt; [internal] load .dockerignore                                          0.1s
[0m[34m =&gt; =&gt; transferring context: 2B                                            0.0s
[0m =&gt; [internal] load metadata for docker.io/library/ubuntu:20.04            0.5s
...
[0m[34m =&gt; =&gt; transferring context: 2B                                            0.0s
[0m[34m =&gt; [internal] load build definition from Dockerfile_arm                   0.0s
[0m[34m =&gt; =&gt; transferring dockerfile: 94B                                        0.0s
[0m[34m =&gt; [internal] load metadata for docker.io/arm64v8/ubuntu:latest           1.8s
[0m[34m =&gt; [auth] arm64v8/ubuntu:pull token for registry-1.docker.io              0.0s
[0m[34m =&gt; CACHED [1/1] FROM docker.io/arm64v8/ubuntu:latest@sha256:94d12db896d0  0.0s
[0m[34m =&gt; exporting to image                                                     0.0s
[0m[34m =&gt; =&gt; exporting layers                                                    0.0s
[0m[34m =&gt; =&gt; writing image sha256:a9732c1988756dc8e836fd96e5c9512e349c97ea5af46  0.0s
[0m[34m =&gt; =&gt; naming to docker.io/maximofn/multiarch:arm                          0.0s
[0m[?25h</output_code>
  <markdown>Vamos ver se temos as duas imagens compiladas</markdown>
  <input_code>!docker image ls</input_code>
  <output_code>REPOSITORY           TAG       IMAGE ID       CREATED       SIZE
maximofn/multiarch   arm       a9732c198875   4 weeks ago   69.2MB
maximofn/multiarch   amd64     5b612c83025f   6 weeks ago   72.8MB
</output_code>
  <markdown>Vemos que compilamos as duas imagens. Para poder criar um manifesto, primeiro temos que enviar as imagens para o Docker Hub, ent√£o as enviamos.</markdown>
  <input_code>!docker push maximofn/multiarch:amd64</input_code>
  <output_code>The push refers to repository [docker.io/maximofn/multiarch]

[1B82bdeb5f: Mounted from library/ubuntu amd64: digest: sha256:30e820f2a11a24ad4d8fb624ae485f7c1bcc299e8cfc72c88adce1acd0447e1d size: 529
</output_code>
  <input_code>!docker push maximofn/multiarch:arm</input_code>
  <output_code>The push refers to repository [docker.io/maximofn/multiarch]
</output_code>
  <output_code>
[1Beda53374: Layer already exists arm: digest: sha256:6ec5a0752d49d3805061314147761bf25b5ff7430ce143adf34b70d4eda15fb8 size: 529
</output_code>
  <markdown>Se eu for ao meu Docker Hub posso ver que minha imagem `maximofn/multiarch` tem os tags `amd64` e `arm`

![docker_multi_arch_tags](https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/docker_multi_arch_tags.webp)</markdown>
  <markdown>Agora vamos a criar o `manifest` baseado nestas duas imagens</markdown>
  <input_code>!docker manifest create maximofn/multiarch:latest maximofn/multiarch:amd64 maximofn/multiarch:arm</input_code>
  <output_code>Created manifest list docker.io/maximofn/multiarch:latest
</output_code>
  <markdown>Uma vez criado, temos que indicar as arquiteturas das CPUs a que corresponde cada uma.</markdown>
  <input_code>!docker manifest annotate maximofn/multiarch:latest maximofn/multiarch:amd64 --os linux --arch amd64</input_code>
  <input_code>!docker manifest annotate maximofn/multiarch:latest maximofn/multiarch:arm64 --os linux --arch arm64</input_code>
  <output_code>manifest for image maximofn/multiarch:arm64 does not exist in maximofn/multiarch:latest
</output_code>
  <markdown>Uma vez criado e anotado, podemos enviar o `manifest` para o Docker Hub</markdown>
  <input_code>!docker manifest push maximofn/multiarch:latest</input_code>
  <output_code>sha256:1ea28e9a04867fe0e0d8b0efa455ce8e4e29e7d9fd4531412b75dbd0325e9304
</output_code>
  <markdown>Se eu olhar novamente os tags da minha imagem `maximofn/multiarch`, tamb√©m vejo o de `latest`

![docker_multi_arch_tags_manifest](https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/docker_multi_arch_tags_manifest.webp)</markdown>
  <markdown>Agora, tanto se eu quiser usar minha imagem de uma m√°quina com CPU AMD64 ou CPU ARM ao fazer `FROM maximofn/multiarch:latest`, o Docker verificar√° a arquitetura da CPU e baixar√° o tag `amd64` ou o tag `arm`. Vamos ver isso, se do meu computador eu executar a imagem obtenho</markdown>
  <input_code>!docker run maximofn/multiarch:latest</input_code>
  <output_code>Unable to find image 'maximofn/multiarch:latest' locally
</output_code>
  <output_code>latest: Pulling from maximofn/multiarch
Digest: sha256:7cef0de10f7fa2b3b0dca0fbf398d1f48af17a0bbc5b9beca701d7c427c9fd84
Status: Downloaded newer image for maximofn/multiarch:latest
Hello from amd64
</output_code>
  <markdown>Como n√£o a tem, baixa-a</markdown>
  <markdown>Se eu me conectar agora via ssh a uma Raspberry Pi e tentar o mesmo, obtenho

```bash
raspberrry@raspberrypi:~ $ docker run maximofn/multiarch:latest
Imposs√≠vel encontrar a imagem 'maximofn/multiarch:latest' localmente
latest: Pulling from maximofn/multiarch
Digesto: sha256:1ea28e9a04867fe0e0d8b0efa455ce8e4e29e7d9fd4531412b75dbd0325e9304
Status: Baixada a imagem mais recente para maximofn/multiarch:latest
Ol√° do ARM
```

Aparece `Hello from ARM` pois o Raspberry Pi possui um microprocessador com arquitetura ARM</markdown>
  <markdown>Como pode ser visto, cada m√°quina baixou a imagem de que precisava.</markdown>
  <markdown>### Escrita correta de Dockerfiles avan√ßados</markdown>
  <markdown>J√° vimos a maneira de escrever Dockerfiles corretamente, mas h√° uma coisa a mais que podemos fazer agora que conhecemos o multi-stage build e √© criar um cont√™iner para criar o execut√°vel e outro menor para execut√°-lo.

Chegamos √† conclus√£o de que um bom Dockerfile poderia ser este

``` Dockerfile
FROM python:3.9.18-alpine
WORKDIR /sourceCode/sourceApp
COPY ./sourceCode/sourceApp .
CMD ["python3", "app.py"]
```

Vamos a criar agora um execut√°vel em um cont√™iner builder e em outro menor o executamos

``` dockerfile
FROM python:3.9.18-alpine como builder
WORKDIR /sourceCode/sourceApp
RUN apk add --no-cache gcc musl-dev libc-dev &amp;&amp; pip install pyinstaller
COPY ./sourceCode/sourceApp .
RUN pyinstaller --onefile app.py

DE alpine:3.18.3
WORKDIR /sourceCode/sourceApp
COPY --from=builder /sourceCode/sourceApp/dist/app .
CMD ["./app"]
```</markdown>
  <markdown>Criamos o c√≥digo Python no caminho necess√°rio</markdown>
  <input_code>!mkdir multistagebuild/sourceCode
!mkdir multistagebuild/sourceCode/sourceApp
!touch multistagebuild/sourceCode/sourceApp/app.py
!echo 'print("Hello from Alpine!")' &gt; multistagebuild/sourceCode/sourceApp/app.py</input_code>
  <markdown>Agora compilando a imagem</markdown>
  <input_code>!docker build -t maximofn/multistagebuild:alpine-3.18.3 ./multistagebuild</input_code>
  <output_code>[1A[1B[0G[?25l[+] Building 0.0s (0/0)                                          docker:default
[?25h[1A[0G[?25l[+] Building 0.0s (0/1)                                          docker:default
[?25h[1A[0G[?25l[+] Building 0.2s (3/5)                                          docker:default
[34m =&gt; [internal] load build definition from Dockerfile                       0.1s
[0m[34m =&gt; =&gt; transferring dockerfile: 357B                                       0.0s
[0m[34m =&gt; [internal] load .dockerignore                                          0.1s
[0m[34m =&gt; =&gt; transferring context: 2B                                            0.0s
[0m =&gt; [internal] load metadata for docker.io/library/alpine:3.18.3           0.1s
 =&gt; [internal] load metadata for docker.io/library/python:3.9.18-alpine    0.1s
[34m =&gt; [auth] library/alpine:pull token for registry-1.docker.io              0.0s
[0m[?25h[1A[1A[1A[1A[1A[1A[1A[1A[0G[?25l[+] Building 0.3s (3/5)                                          docker:default
[34m =&gt; [internal] load build definition from Dockerfile                       0.1s
[0m[34m =&gt; =&gt; transferring dockerfile: 357B                                       0.0s
[0m[34m =&gt; [internal] load .dockerignore                                          0.1s
[0m[34m =&gt; =&gt; transferring context: 2B                                            0.0s
[0m =&gt; [internal] load metadata for docker.io/library/alpine:3.18.3           0.2s
 =&gt; [internal] load metadata for docker.io/library/python:3.9.18-alpine    0.2s
[34m =&gt; [auth] library/alpine:pull token for registry-1.docker.io              0.0s
[0m[?25h[1A[1A[1A[1A[1A[1A[1A[1A[0G[?25l[+] Building 0.5s (4/6)                                          docker:default
[34m =&gt; [internal] load build definition from Dockerfile                       0.1s
[0m[34m =&gt; =&gt; transferring dockerfile: 357B                                       0.0s
[0m[34m =&gt; [internal] load .dockerignore                                          0.1s
[0m[34m =&gt; =&gt; transferring context: 2B                                            0.0s
[0m =&gt; [internal] load metadata for docker.io/library/alpine:3.18.3           0.4s
...
[0m[34m =&gt; exporting to image                                                     0.1s
[0m[34m =&gt; =&gt; exporting layers                                                    0.1s
[0m[34m =&gt; =&gt; writing image sha256:8a22819145c6fee17e138e818610ccf46d7e13c786825  0.0s
[0m[34m =&gt; =&gt; naming to docker.io/maximofn/multistagebuild:alpine-3.18.3          0.0s
[0m[?25h</output_code>
  <markdown>A executamos</markdown>
  <input_code>!docker run --rm --name multi_stage_build maximofn/multistagebuild:alpine-3.18.3</input_code>
  <output_code>Hello from Alpine!
</output_code>
  <markdown>A imagem `maximofn/multistagebuild:alpine-3.18.3` s√≥ pesa 13,6 MB</markdown>
  <markdown>### Diferen√ßa entre RUN, CMD e ENTRYPOINT</markdown>
  <markdown>#### EXECUTAR</markdown>
  <markdown>O comando `RUN` √© o mais simples, ele apenas executa um comando no momento da compila√ß√£o da imagem. Por exemplo, se quisermos instalar um pacote na imagem, fazemos isso atrav√©s do `RUN`.

Portanto, √© importante, `RUN` √© executado no momento da compila√ß√£o da imagem, n√£o quando o cont√™iner √© executado.</markdown>
  <markdown>#### CMD</markdown>
  <markdown>O comando `CMD` √© o comando que √© executado quando o cont√™iner √© iniciado. Por exemplo, se quisermos que o cont√™iner execute um comando ao ser iniciado, fazemos isso atrav√©s do `CMD`. Por exemplo, se tivermos uma aplica√ß√£o Python em um cont√™iner, com `CMD` podemos indicar que, quando o cont√™iner for iniciado, ele execute a aplica√ß√£o Python.

Desta forma, quando o cont√™iner for iniciado, a aplica√ß√£o Python ser√° executada. Isso significa que, se fizermos `docker run &lt;image&gt;`, a aplica√ß√£o Python ser√° executada. No entanto, `CMD` nos permite sobrescrever o comando que √© executado ao iniciar o cont√™iner, por exemplo, se fizermos `docker run &lt;image&gt; bash`, o `bash` ser√° executado em vez da aplica√ß√£o Python.</markdown>
  <markdown>#### ENTRYPOINT</markdown>
  <markdown>O comando `ENTRYPOINT` √© similar ao comando `CMD`, mas com uma diferen√ßa: o `ENTRYPOINT` n√£o est√° destinado a ser sobrescrito. Isso significa que, se tivermos uma aplica√ß√£o Python em um cont√™iner, podemos usar `ENTRYPOINT` para indicar que, quando o cont√™iner for executado, ele execute a aplica√ß√£o Python. No entanto, se fizermos `docker run &lt;image&gt; bash`, ser√° executada a aplica√ß√£o Python, n√£o o `bash`.

Um uso muito comum de `ENTRYPOINT` √© quando queremos que o cont√™iner seja um execut√°vel, por exemplo, se quisermos que o cont√™iner seja um execut√°vel de uma vers√£o do Python que n√£o temos em nosso host, porque, por exemplo, queremos testar a nova vers√£o do Python que foi lan√ßada podemos fazer

``` Dockerfile
FROM python:3.9.18-alpine
ENTRYPOINT ["python3"]
```

Desta forma, quando o cont√™iner for iniciado, o Python ser√° executado. Isso significa que, se fizermos `docker run &lt;image&gt;`, o Python ser√° executado. Mas `ENTRYPOINT` nos permite sobrescrever o comando que √© executado ao iniciar o cont√™iner, por exemplo, se fizermos `docker run &lt;image&gt; myapp.py`, ser√° executado `python3 myapp.py` dentro do cont√™iner. Assim podemos testar nossa aplica√ß√£o Python na nova vers√£o do Python.</markdown>
  <markdown>### Mudan√ßas em um cont√™iner</markdown>
  <markdown>Com `docker diff` podemos ver as diferen√ßas entre o cont√™iner e a imagem, o que √© o mesmo que a diferen√ßa no cont√™iner desde sua cria√ß√£o at√© agora.

Vamos a executar um cont√™iner e dentro criamos um arquivo</markdown>
  <input_code>!docker run --rm -it --name ubuntu-20.04 ubuntu:20.04 bash</input_code>
  <output_code>root@895a19aef124:/# touch file.txt
</output_code>
  <markdown>Agora podemos ver a diferen√ßa</markdown>
  <input_code>!docker diff ubuntu-20.04</input_code>
  <output_code>C /root
A /root/.bash_history
A /file.txt
</output_code>
  <markdown>`A` significa que foi adicionado, `C` significa que foi alterado e `D` significa que foi exclu√≠do.</markdown>
  <markdown>### Docker no Docker</markdown>
  <markdown>Suponhamos que temos cont√™ineres que precisam iniciar ou desligar outros cont√™ineres. Isso √© feito da seguinte maneira

Dado que no Linux tudo √© um arquivo e o host se comunica com o Docker por meio de um socket. Portanto, para o Linux, esse socket √© um arquivo. Ent√£o, se montarmos esse socket como um arquivo no cont√™iner, ele poder√° se comunicar com o Docker.</markdown>
  <markdown>Primeiro vamos a montar um cont√™iner com Ubuntu</markdown>
  <input_code>!docker run -d --name ubuntu ubuntu:latest tail -f /dev/null</input_code>
  <output_code>144091e4a3325c9068064ff438f8865b40f944af5ce649c7156ca55a3453e423
</output_code>
  <markdown>Vamos a montar o cont√™iner que vai poder se comunicar com o Docker montando a pasta `/var/run/docker.sock`

``` bash
$ docker run -it --rm --name main -v /var/run/docker.sock:/var/run/docker.sock docker:19.03.12
/ #
```

Entramos em um cont√™iner, e se executarmos `docker ps` dentro dele

``` bash
# docker ps
ID DO CONT√äINER     IMAGEM              COMANDO                  CRIADO              STATUS              PORTAS              NOMES
9afb778d6c20        docker:19.03.12     "docker-entrypoint.s‚Ä¶"   3 segundos atr√°s    Up 2 segundos                            main
144091e4a332        ubuntu:latest       "tail -f /dev/null"      19 segundos atr√°s   Up 18 segundos                          ubuntu
```

Como podemos ver, dentro do Docker podemos ver os cont√™ineres do host</markdown>
  <markdown>Podemos executar um novo cont√™iner

``` bash
# docker run -d --name ubuntu_from_main ubuntu:latest tail -f /dev/null
362654a72bb0fb047c13968707a6f16b87fed7ce051eb5c1a146b15828589a1a
/ #
```

E se voltarmos a ver os cont√™ineres

``` bash
# docker ps
ID DO CONTAINER     IMAGEM              COMANDO                  CRIADO               STATUS              PORTAS              NOMES
362654a72bb0        ubuntu:latest       "tail -f /dev/null"      3 segundos atr√°s     Up 3 segundos                            ubuntu_from_main
9afb778d6c20        docker:19.03.12     "docker-entrypoint.s‚Ä¶"   H√° um minuto         Up H√° um minuto                           main
144091e4a332        ubuntu:latest       "tail -f /dev/null"      2 minutos atr√°s      Up H√° cerca de um minuto                       ubuntu
```

Mas se agora executarmos uma nova terminal do host, veremos o cont√™iner criado a partir de dentro do cont√™iner</markdown>
  <input_code>!docker ps</input_code>
  <output_code>CONTAINER ID   IMAGE             COMMAND                  CREATED              STATUS              PORTS     NAMES
362654a72bb0   ubuntu:latest     "tail -f /dev/null"      About a minute ago   Up About a minute             ubuntu_from_main
9afb778d6c20   docker:19.03.12   "docker-entrypoint.s‚Ä¶"   3 minutes ago        Up 3 minutes                  main
144091e4a332   ubuntu:latest     "tail -f /dev/null"      3 minutes ago        Up 3 minutes                  ubuntu
</output_code>
  <markdown>Tudo o que fizermos a partir do cont√™iner `main` ser√° refletido no host</markdown>
  <markdown>Isso tem a vantagem de podermos instalar programas em um cont√™iner que tem acesso ao host para n√£o ter que instal√°-los no host. Por exemplo, [dive](https://github.com/wagoodman/dive) √© uma ferramenta para explorar cont√™ineres, mas se voc√™ n√£o quiser instal√°-la no host, pode instal√°-la em um cont√™iner com acesso ao host, assim, a partir desse cont√™iner `main`, voc√™ pode explorar o resto dos cont√™ineres sem ter que instal√°-la no host.</markdown>
</notebook>