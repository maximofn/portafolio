<?xml version='1.0' encoding='utf-8'?>
<notebook>
  <markdown># SSH</markdown>
  <markdown>## Introducción histórica</markdown>
  <markdown>En los primeros días de internet se creó el protocolo `telnet` para poder comunicar varios ordenadores, pero tenía el problema de que no estaba cifrado, por lo que cualquiera que se metiera en medio podía leer la comunicación sin problema, por eso se creó `SSH` (Secure Shell)</markdown>
  <markdown>## Cifrado de `SSH`</markdown>
  <markdown>El sistema de cifrado de `SSH` funciona mediante el sistema de clave pública y clave privada, de manera que si se encripta la comunicación con una de las dos claves, solo puede ser descifrada por la otra clave

¿Y por qué hay una clave pública y una clave privada? La clave pública es la que le das a todo el mundo y la clave privada es la que solo tienes que poseer tú.

De manera que si te quieres comunicar con otro equipo por `SSH`, primero le das tu clave pública, a continuación encriptas el mensaje con tu clave privada y solo se puede desencriptar el mensaje con la clave pública que le has dado al otro equipo

De la misma manera ocurre al revés, si el otro equipo te quiere mandar un mensaje, lo encripta con tu clave pública y solo se puede desencriptar con la clave privada que solo tú posees</markdown>
  <markdown>## Requerimentos `SSH`</markdown>
  <markdown>### Servicio `SSH`</markdown>
  <markdown>Para poder usar `SSH` necesitas tener un servicio de `SSH`. En `Linux` normalmente ya viene instalado, pero si no es así lo puedes instalar mediante</markdown>
  <input_code>!apt install openssh-server</input_code>
  <markdown>Durante el proceso de instalación, te pedirá tu ubicación para ajustar el time zone</markdown>
  <markdown>A continuación, levantamos el servicio</markdown>
  <input_code>!systemctl enable ssh</input_code>
  <markdown>### Cliente `SSH`</markdown>
  <markdown>Una vez tengas el servicio necesitas un cliente, aunque en `Linux` suele venir instalado, pero si no es así lo puedes instalar mediante</markdown>
  <input_code>!apt install openssh-client</input_code>
  <markdown>## Conexión por `SSH`</markdown>
  <markdown>Para conectarte por `SSH` necesitas introducir el comando `ssh &lt;user&gt;@&lt;ip&gt;`</markdown>
  <input_code>!ssh root@172.17.0.1</input_code>
  <output_code>The authenticity of host '172.17.0.1 (172.17.0.1)' can't be established.
ECDSA key fingerprint is SHA256:M+qsqSC4HiYztm1ij8iDkh9KHJz+pxrTm9GTZIf2N9k.
Are you sure you want to continue connecting (yes/no/[fingerprint])?
</output_code>
  <markdown>Como puedes ver, la primera vez te pregunta si quieres guardar el `fingerprint`, esto es para que si la próxima vez que te conectes a la misma máquina (a la misma clave pública) ha cambiado el `fingerprint` debes tener cuidado porque puede haber algo peligroso, como que se hagan pasar por esa máquina.

Si nos fiamos introducimos `yes`</markdown>
  <input_code>!ssh root@172.17.0.1</input_code>
  <output_code>The authenticity of host '172.17.0.1 (172.17.0.1)' can't be established.
ECDSA key fingerprint is SHA256:M+qsqSC4HiYztm1ij8iDkh9KHJz+pxrTm9GTZIf2N9k.
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '172.17.0.1' (ECDSA) to the list of known hosts.
root@172.17.0.1's password:
</output_code>
  <markdown>A continuación, la máquina a la que nos conectamos nos pide la contraseña, la introducimos y ya estaremos dentro de la máquina</markdown>
  <input_code>!ssh root@172.17.0.1</input_code>
  <output_code>The authenticity of host '172.17.0.1 (172.17.0.1)' can't be established.
ECDSA key fingerprint is SHA256:M+qsqSC4HiYztm1ij8iDkh9KHJz+pxrTm9GTZIf2N9k.
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '172.17.0.1' (ECDSA) to the list of known hosts.
root@172.17.0.1's password: 
Welcome to Ubuntu 20.04.5 LTS (GNU/Linux 5.15.0-58-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

1 device has a firmware upgrade available.
Run `fwupdmgr get-upgrades` for more information.


 * Introducing Expanded Security Maintenance for Applications.
   Receive updates to over 25,000 software packages with your
   Ubuntu Pro subscription. Free for personal use.

     https://ubuntu.com/pro

Se pueden aplicar 0 actualizaciones de forma inmediata.

Your Hardware Enablement Stack (HWE) is supported until April 2025.
Last login: Thu Dec  1 16:32:23 2022 from 127.0.0.1
root@172.17.0.1:~$
</output_code>
  <markdown>## Conexión sin necesidad de contraseña</markdown>
  <markdown>Como hemos visto, cuando nos conectamos nos pide la contraseña de la máquina de destino, pero si es una máquina a la que nos vamos a conectar mucho, podemos hacer que no nos pida la contraseña cada vez que nos queramos conectar.</markdown>
  <markdown>Para ello, en primer lugar generamos una clave `ssh` mediante `ssh-keygen`</markdown>
  <input_code>!ssh-keygen</input_code>
  <output_code>Generating public/private rsa key pair.
Enter file in which to save the key (/root/.ssh/id_rsa): 
Enter passphrase (empty for no passphrase): 
Enter same passphrase again: 
Your identification has been saved in /root/.ssh/id_rsa
Your public key has been saved in /root/.ssh/id_rsa.pub
The key fingerprint is:
SHA256:4HxRXkVkcK5kNXNyzakfQ6t8a24wRGCUYz4s5KL5ZEc root@e108f6f395b3
The key's randomart image is:
+---[RSA 3072]----+
|          o+==@.=|
|         +.= * Oo|
|      . + = = + .|
|     o o E * + + |
|      = S . = o o|
|     o + .   = o |
|      + .     + .|
|       .       + |
|              +. |
+----[SHA256]-----+
</output_code>
  <markdown>Como vemos, primero nos pregunta dónde queremos guardar la clave, si no introducimos nada nos la guarda en la ruta por defecto. Y a continuación una frase para generar la clave, **si escribes una frase debes recordarla siempre**. Además, si escribes una frase, te la pedirá cada vez que intentes acceder a la clave, por lo que cada vez que queramos acceder a la máquina por medio de `SSH`, no nos pedirá la contraseña de la máquina, pero sí esta frase. Por lo que tú eliges si no introduces una frase para que nunca te la pida, o si sí la introduces y siempre las vas a meter.</markdown>
  <markdown>A continuación, le pedimos a la máquina remota que se guarde nuestra clave mediante `ssh-copy-id &lt;user&gt;@&lt;id&gt;:`</markdown>
  <input_code>!ssh-copy-id root@172.17.0.1:</input_code>
  <output_code>/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: "/root/.ssh/id_rsa.pub"
/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed
/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys
root@172.17.0.1's password: 

Number of key(s) added: 1

Now try logging into the machine, with:   "ssh 'root@172.17.0.1'"
and check to make sure that only the key(s) you wanted were added.

root@103b6040196a:/# ssh root@172.17.0.1
Welcome to Ubuntu 20.04.5 LTS (GNU/Linux 5.15.0-58-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

4 devices have a firmware upgrade available.
Run `fwupdmgr get-upgrades` for more information.


58 updates can be applied immediately.
41 of these updates are standard security updates.
To see these additional updates run: apt list --upgradable

New release '22.04.1 LTS' available.
Run 'do-release-upgrade' to upgrade to it.

Your Hardware Enablement Stack (HWE) is supported until April 2025.
Last login: Thu Feb  2 08:05:48 2023 from 172.17.0.2
(base) root@172.17.0.1:~$
</output_code>
  <markdown>## Usar la terminal remota por `SSH`</markdown>
  <markdown>A lo mejor no nos hace falta tener que meternos a la máquina remota porque solo necesitamos ejecutar un solo comando, por lo que podemos usar remotamente su terminal añadiendo el flag `-t` al comando `SSH`, es decir, mediante `ssh -t &lt;user&gt;@&lt;id&gt; &lt;command&gt;`</markdown>
  <input_code>!ssh -t root@172.17.0.1 ping -c 4 google.com</input_code>
  <output_code>PING google.com (172.217.168.174) 56(84) bytes of data.
64 bytes from mad07s10-in-f14.1e100.net (172.217.168.174): icmp_seq=1 ttl=111 time=2.94 ms
64 bytes from mad07s10-in-f14.1e100.net (172.217.168.174): icmp_seq=2 ttl=111 time=2.55 ms
64 bytes from mad07s10-in-f14.1e100.net (172.217.168.174): icmp_seq=3 ttl=111 time=2.78 ms
64 bytes from mad07s10-in-f14.1e100.net (172.217.168.174): icmp_seq=4 ttl=111 time=2.69 ms

--- google.com ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 3005ms
rtt min/avg/max/mdev = 2.550/2.739/2.940/0.142 ms
Connection to 172.17.0.1 closed.
</output_code>
  <markdown>Como se puede ver se realiza el comando en la máquina remota y cuando termina, en la última línea nos dice que se cierra la conexión</markdown>
  <markdown>## Proxy `SSH`</markdown>
  <markdown>Si estás navegando en un lugar no muy seguro, o en un lugar que tiene un proxy que no te deja acceder a algunos puertos, puedes navegar a través del proxy de otra máquina mediante `SSH`, esto se puede hacer añadiendo el flag `-D` y el puerto por el que quieres realizar la conexión al proxy remoto, como el puerto para el `tcp/ip` es el `9999` el comando podría quedar como `ssh -D 9999 &lt;user&gt;@&lt;id&gt;`</markdown>
  <markdown>Para que esto se vea mejor, antes de ejecutarlo obtengo mi IP pública</markdown>
  <input_code>!curl ifconfig.me</input_code>
  <output_code>188.127.184.59</output_code>
  <markdown>Ahora uso el proxy de un servidor web que tengo levantado</markdown>
  <input_code>!ssh -D 9999 root@194.62.99.222</input_code>
  <output_code>Welcome to Ubuntu 22.04.1 LTS (GNU/Linux 5.15.0-53-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Wed Feb 22 06:08:51 AM UTC 2023

  System load:           0.02978515625
  Usage of /:            11.7% of 24.53GB
  Memory usage:          33%
  Swap usage:            0%
  Processes:             89
  Users logged in:       0
  IPv4 address for eth0: 194.62.99.222
  IPv4 address for eth1: 10.7.0.168
  IPv6 address for eth2: 2a04:3542:8000:1000:d48a:cbff:fefb:5b1


0 updates can be applied immediately.


The list of available updates is more than a week old.
To check for new updates run: sudo apt update

Last login: Wed Feb 22 06:02:35 2023 from 188.127.184.59
root@server1:~#
</output_code>
  <markdown>Cambio la configuración del proxy de mi ordenador

![proxy ssh](https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/proxy_ssh.webp)</markdown>
  <markdown>Ahora vuelvo a mirar mi IP pública, pero usando el proxy recientemente configurado</markdown>
  <input_code>!curl -x socks5h://localhost:9999 ifconfig.me</input_code>
  <output_code>194.62.99.222</output_code>
  <markdown>Vemos que obtenemos la IP pública del servidor</markdown>
  <markdown>## Interfaz gráfica remota por `SSH`</markdown>
  <markdown>En Linux la interfaz gráfica es un servidor, por lo que nos podemos beneficiar de ello y podemos ejecutar programas con interfaces gráficas que están en una máquina remota por `SSH`, para ello hay que usar el flag `-X`. El comando quedaría `ssh -X &lt;user&gt;@&lt;id&gt;`</markdown>
  <markdown>Primero entro a mi servidor e instalo `xeyes` mediante `sudo apt install x11-apps` y después lo ejecuto remotamente desde mi ordenador</markdown>
  <input_code>!ssh -X root@194.62.99.222</input_code>
  <output_code>Welcome to Ubuntu 22.04.1 LTS (GNU/Linux 5.15.0-53-generic x86_64)

Last login: Wed Feb 22 06:39:52 2023 from 188.127.184.59
/usr/bin/xauth:  file /root/.Xauthority does not exist
root@server1:~sudo apt install x11-apps
root@server1:~#xeyes
</output_code>
  <markdown>Ahora en mi ordenador se abre la ventana de `xeyes` pero no se está ejecutando en mi ordenador

![xeyes](https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/xeyes.webp)</markdown>
  <markdown>## Tunel `SSH`</markdown>
  <markdown>Como he comentado, he levantado un servidor al que tengo acceso por SSH</markdown>
  <input_code>!ssh root@194.62.99.222</input_code>
  <output_code>Welcome to Ubuntu 22.04.1 LTS (GNU/Linux 5.15.0-53-generic x86_64)

Last login: Wed Feb 22 06:40:58 2023 from 188.127.184.59
root@server1:~#
</output_code>
  <markdown>Y levanto también un segundo servidor desde el que tengo acceso desde el `server1`, pero no tengo acceso desde mi ordenador</markdown>
  <markdown>A continuación, intento acceder al `server2` desde mi ordenador y vemos que no puedo</markdown>
  <input_code>!ssh root@194.62.99.235</input_code>
  <output_code>ssh: connect to host 194.62.99.235 port 22: Connection timed out
</output_code>
  <markdown>Y a continuación intento acceder al `server2` desde el `server1` y vemos que sí puedo</markdown>
  <input_code>!root@server1:~# ssh root@10.7.2.228</input_code>
  <output_code>Welcome to Ubuntu 22.04.1 LTS (GNU/Linux 5.15.0-53-generic x86_64)

Last login: Wed Feb 22 06:59:01 2023 from 10.7.0.168
root@server2:~#
</output_code>
  <markdown>Así que lo que creamos es un túnel desde mi ordenador hasta el `server2` a través del `server1`, para ello usamos el flag `-L`. Para crear el túnel hay que indicar el puerto de tu ordenador en el que vas a crear el túnel, a continuación la `IP` de destino del túnel, el puerto por el que irá el túnel y por último el dispositivo que creará el túnel. Quedaría así

``` bash
ssh -L &amp;ltHOST PORT&amp;gt:&amp;ltDEST IP&amp;gt:&amp;ltTUNNEL PORT&amp;gt &amp;ltTUNNEL CREATOR USER&amp;gt@&amp;ltTUNNEL CREATOR IP&amp;gt
```

Veámoslo con mi ejemplo, tengo el `server1` con una `IP` pública que podemos llamar `ip_pub1` y al que tengo acceso por `SSH` y una `IP` privada que podemos llamar `ip_priv1` que está dentro de la misma red que `server2`. Y tengo el `server2` con una `IP` pública que podemos llamar `ip_pub2` a la que no tengo acceso por `SSH` y una `IP` que podemos llamar `ip_priv2` dentro de la misma red de `server1`

Primero creo el túnel

``` bash
ssh -L host_port:ip_priv2:22 root@ip_pub1
```

He creado un túnel hasta la `IP` privada del `server2` a través de la `IP` pública del `server1`

Por último, para conectarme al `server2` lo hago a través del `localhost` y del puerto del host que he declarado en el túnel

``` bash
ssh -p 2020 root@localhost
```</markdown>
  <markdown>Vamos a verlo en la realidad, las `IP`s de mis servidores son

 * `server1`:
   * `IP` pública: `194.62.99.222`
   * `IP` privada: `10.7.0.168`
 * `server2`:
   * `IP` pública: `194.62.99.235`
   * `IP` privada: `10.7.2.228`

Primero creo el túnel</markdown>
  <input_code>!ssh -L 2020:10.7.2.228:22 root@194.62.99.222</input_code>
  <output_code>Welcome to Ubuntu 22.04.1 LTS (GNU/Linux 5.15.0-53-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Wed Feb 22 11:13:39 AM UTC 2023

  System load:           0.0
  Usage of /:            13.3% of 24.53GB
  Memory usage:          36%
  Swap usage:            0%
  Processes:             91
  Users logged in:       1
  IPv4 address for eth0: 194.62.99.222
  IPv4 address for eth1: 10.7.0.168
  IPv6 address for eth2: 2a04:3542:8000:1000:d48a:cbff:fefb:5b1


101 updates can be applied immediately.
60 of these updates are standard security updates.
To see these additional updates run: apt list --upgradable


Last login: Wed Feb 22 09:29:52 2023 from 188.127.184.59
[?2004h]0;root@server1: ~[01;32mroot@server1[00m:[01;34m~[00m# ^C[?2004l
[?2004l
[?2004h]0;root@server1: ~[01;32mroot@server1[00m:[01;34m~[00m# </output_code>
  <markdown>Con el túnel creado ya me puedo conectar al `server2` desde mi ordenador</markdown>
  <input_code>!ssh -p 2020 root@localhost</input_code>
  <output_code>Welcome to Ubuntu 22.04.1 LTS (GNU/Linux 5.15.0-53-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Wed Feb 22 11:14:15 AM UTC 2023

  System load:           0.0
  Usage of /:            13.3% of 24.53GB
  Memory usage:          33%
  Swap usage:            0%
  Processes:             90
  Users logged in:       0
  IPv4 address for eth0: 194.62.99.235
  IPv4 address for eth1: 10.7.2.228
  IPv6 address for eth2: 2a04:3542:8000:1000:d48a:cbff:fefb:7f47

 * Strictly confined Kubernetes makes edge and IoT secure. Learn how MicroK8s
   just raised the bar for easy, resilient and secure K8s cluster deployment.

   https://ubuntu.com/engage/secure-kubernetes-at-the-edge

101 updates can be applied immediately.
60 of these updates are standard security updates.
To see these additional updates run: apt list --upgradable


Last login: Wed Feb 22 11:14:16 2023 from 10.7.0.168
[?2004h]0;root@server2: ~[01;32mroot@server2[00m:[01;34m~[00m# ^C[?2004l
[?2004l
[?2004h]0;root@server2: ~[01;32mroot@server2[00m:[01;34m~[00m# </output_code>
  <markdown>## Conexión reversa</markdown>
  <markdown>Volvamos a suponer que me quiero conectar al `server2`, pero ahora no puedo hacer, por la razón que sea, un túnel desde el `server1`. Lo que podemos hacer es crear una conexión reversa desde otro servidor.

Supongamos que tengo un tercer servidor, llamado `server3`, al que se tiene acceso por `SSH` desde cualquier lado, es decir, tanto yo desde mi ordenador como el `server2` tienen acceso. Por lo que si podemos acceder físicamente al `server2` se puede hacer una conexión reversa desde el `server2` al `server3`

```
ssh -R &amp;ltserver3port&amp;gt:localhost:22 root@&amp;ltIPserver3&amp;gt
```

Con esto, lo que he hecho es habilitar una conexión desde el `server3` al `server2` (cosa que antes no se podía), a través del `localhost` y puerto `server3port` del `server3`

Ahora desde mi ordenador me puedo conectar al `server3` y desde el `server3` me puedo conectar al `server2` mediante

``` bash
ssh -p &amp;ltserver3port&amp;gt root@localhost
```</markdown>
  <markdown>Veámoslo con los datos de mis servidores

* `server2`:
   * `IP` pública: `194.62.99.235`
 * `server3`:
   * `IP` pública: `194.62.96.236`</markdown>
  <markdown>Primero hago la conexión reversa desde el `server2` al `server3`</markdown>
  <input_code>!root@server2:~# ssh -R 2020:localhost:22 root@194.62.96.236</input_code>
  <output_code>Welcome to Ubuntu 22.04.1 LTS (GNU/Linux 5.15.0-53-generic x86_64)

Last login: Wed Feb 22 15:25:58 2023 from 188.127.184.59
root@server3:~#
</output_code>
  <markdown>Ahora me conecto al `server3`</markdown>
  <input_code>!ssh root@194.62.96.236</input_code>
  <output_code>Welcome to Ubuntu 22.04.1 LTS (GNU/Linux 5.15.0-53-generic x86_64)

Last login: Wed Feb 22 15:12:19 2023 from 188.127.184.59
root@server3:~#
</output_code>
  <markdown>Y ahora que estoy en el `server3` me conecto al `server2`</markdown>
  <input_code>!root@server3:~# ssh -p 2020 root@localhost</input_code>
  <output_code>Welcome to Ubuntu 22.04.1 LTS (GNU/Linux 5.15.0-53-generic x86_64)

Last login: Wed Feb 22 15:12:07 2023 from 188.127.184.59
root@server2:~#
</output_code>
  <markdown>¡Conseguido! A través de mi ordenador no puedo conectarme directamente al `server2`, pero al conectarme al `server3` he podido acceder al `server2` gracias a la conexión inversa que había hecho del `server2` al `server3`</markdown>
  <markdown>## Jump</markdown>
  <markdown>Por último, otra manera de entrar al `server2` es entrando al `server1` y a continuación, desde el `server1` entrar al `server2`. Pero esto es un poco engorroso, porque primero hay que hacer una conexión `SSH` al `server1` y luego otra al `server2`, así que para hacerlo todo de una podemos usar el flag `-J` (`jump`), es decir, quedaría `ssh -J server1 server2`</markdown>
  <markdown>Resumen, primero haríamos `ssh root@194.62.99.222` y luego `ssh root@10.7.2.228` (ya que dentro de `server1` nos conectamos a `server2` mediante la `IP` privada).

Así que podríamos hacer todo de una haciendo `ssh -J root@194.62.99.222 root@10.7.2.228`

Vamos a probar</markdown>
  <input_code>!ssh -J root@194.62.99.222 root@10.7.2.228</input_code>
  <output_code>Welcome to Ubuntu 22.04.1 LTS (GNU/Linux 5.15.0-60-generic x86_64)

Last login: Fri Feb 24 06:46:11 2023 from 10.7.0.168
root@server2:~#
</output_code>
  <markdown>¡Hemos podido hacer los saltos!</markdown>
  <markdown>## Archivo de configuración `SSH` del usuario</markdown>
  <markdown>### Dispositivos con Alias</markdown>
  <markdown>En todo ordenador hay un archivo de configuración para el `SSH` que suele estar en la carpeta del usuario</markdown>
  <input_code>!cat ~/.ssh/config</input_code>
  <output_code># Read more about SSH config files: https://linux.die.net/man/5/ssh_config
Host 192.168.1.138
    HostName 192.168.1.138
    User maximo.fernandez
</output_code>
  <markdown>En este archivo tengo guardadas las credenciales de usuario e IP de algunos dispositivos a los que me suelo conectar y así no tengo que rellenar todo yo. Veámoslo con los servidores que tengo

Mi servidor `server1` tiene el usuario `root` y la IP `194.62.99.222`, por lo que lo añado a la lista</markdown>
  <input_code>!echo "Host server1\n    HostName 194.62.99.222\n    User root" &gt;&gt; ~/.ssh/config</input_code>
  <markdown>Volvamos a ver cómo ha quedado el archivo de configuración</markdown>
  <input_code>!cat ~/.ssh/config</input_code>
  <output_code># Read more about SSH config files: https://linux.die.net/man/5/ssh_config
Host 192.168.1.138
    HostName 192.168.1.138
    User maximo.fernandez

Host server1
    HostName 194.62.99.222
    User root
</output_code>
  <markdown>Ahora que lo hemos añadido para conectarnos al `server1`, ya solo nos hace falta hacer `ssh server1`</markdown>
  <input_code>!ssh server1 </input_code>
  <output_code>Welcome to Ubuntu 22.04.1 LTS (GNU/Linux 5.15.0-60-generic x86_64)

Last login: Fri Feb 24 05:18:59 2023 from 188.127.184.59
root@server1:~# 
</output_code>
  <markdown>### Proxy</markdown>
  <markdown>Como ya vimos, añadiendo el flag `-D &amp;ltport&amp;gt` podíamos cambiar la proxy. Para dejar esto guardado en el archivo de configuración solo tenemos que añadir la línea `DynamicForward &amp;ltport&amp;gt` al host que estamos guardando</markdown>
  <markdown>Repitiendo el ejemplo anterior en el que usamos el `server1` como un proxy del puerto `TCP/IP` (`9999`), en el archivo de configuración quedaría así

```
Host proxyServer1
    HostName 194.62.99.222
    User root
    DynamicForward 9999
```

Lo añadimos</markdown>
  <input_code>!echo "Host proxyServer1\n    HostName 194.62.99.222\n    User root\n    DynamicForward 9999" &gt;&gt; ~/.ssh/config</input_code>
  <markdown>Veamos cómo queda el archivo de configuración</markdown>
  <input_code>!cat ~/.ssh/config</input_code>
  <output_code># Read more about SSH config files: https://linux.die.net/man/5/ssh_config
Host 192.168.1.138
    HostName 192.168.1.138
    User maximo.fernandez

Host server1
    HostName 194.62.99.222
    User root
Host proxyServer1
    HostName 194.62.99.222
    User root
    DynamicForward 9999
</output_code>
  <markdown>Obtengo mi `IP` pública</markdown>
  <input_code>!curl ifconfig.me</input_code>
  <output_code>188.127.184.59</output_code>
  <markdown>Me conecto al servidor proxy</markdown>
  <input_code>!ssh proxyServer1 </input_code>
  <output_code>Welcome to Ubuntu 22.04.1 LTS (GNU/Linux 5.15.0-60-generic x86_64)

Last login: Fri Feb 24 05:42:32 2023 from 188.127.184.59
root@server1:~#
</output_code>
  <markdown>Cambio la configuración del proxy de mi ordenador

![proxy ssh](https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/proxy_ssh.webp)</markdown>
  <markdown>Vuelvo a ver mi `IP` pública, pero usando el proxy recientemente configurado</markdown>
  <input_code>!curl -x socks5h://localhost:9999 ifconfig.me</input_code>
  <output_code>194.62.99.222</output_code>
  <markdown>Vemos que obtenemos la IP pública del servidor</markdown>
  <markdown>### Tunel SSH</markdown>
  <markdown>Si como antes quiero crear un túnel hasta el `server2` a través del `server1`, antes teníamos que hacer `ssh &amp;ltHOST PORT&amp;gt:&amp;ltDEST IP&amp;gt:&amp;ltTUNNEL PORT&amp;gt &amp;ltTUNNEL CREATOR USER&amp;gt@&amp;ltTUNNEL CREATOR IP&amp;gt`, ahora tenemos que añadir la línea

``` bash
LocalForward &amp;ltlocalhost&amp;gt:&amp;ltHOST PORT&amp;gt &amp;ltDEST IP&amp;gt:&amp;ltTUNNEL PORT&amp;gt
```</markdown>
  <markdown>Es decir, el archivo de configuración quedaría

```
Host tunelToServer2
    HostName 194.62.99.222
    User root
    LocalForward 127.0.0.1:2020 10.7.2.228:22
```</markdown>
  <markdown>Pero como así no se entiende muy bien veámoslo con algo concreto

 * `server1`:
   * `IP` pública: `194.62.99.222`
   * `IP` privada: `10.7.0.168`
 * `server2`:
   * `IP` pública: `194.62.99.235`
   * `IP` privada: `10.7.2.228`

Antes, el comando era

``` bash
ssh -L 2020:10.7.2.228:22 root@194.62.99.222
```

De modo que el archivo de configuración tiene que quedar

```
Host tunelToServer2
    HostName 194.62.99.222
    User root
    LocalForward 127.0.0.1:2020 10.7.2.228:22
```

Veamos si funciona</markdown>
  <markdown>Añadimos la nueva configuración</markdown>
  <input_code>!echo "Host tunelToServer2\n    HostName 194.62.99.222\n    User root\n    LocalForward 127.0.0.1:2020 10.7.2.228:22" &gt;&gt; ~/.ssh/config</input_code>
  <markdown>Veamos cómo ha quedado el archivo de configuración</markdown>
  <input_code>!cat ~/.ssh/config</input_code>
  <output_code># Read more about SSH config files: https://linux.die.net/man/5/ssh_config
Host 192.168.1.138
    HostName 192.168.1.138
    User maximo.fernandez

Host server1
    HostName 194.62.99.222
    User root
Host proxyServer1
    HostName 194.62.99.222
    User root
    DynamicForward 9999
Host tunelToServer2
    HostName 194.62.99.222
    User root
    LocalForward 127.0.0.1:2020 10.7.2.228:22
</output_code>
  <markdown>Creamos el túnel</markdown>
  <input_code>!ssh tunelToServer2 </input_code>
  <output_code>Welcome to Ubuntu 22.04.1 LTS (GNU/Linux 5.15.0-60-generic x86_64)

Last login: Fri Feb 24 06:02:20 2023 from 188.127.184.59
root@server1:~#
</output_code>
  <markdown>Ahora intentamos conectarnos al `server2` desde mi ordenador.</markdown>
  <input_code>!ssh -p 2020 root@localhost</input_code>
  <output_code>Welcome to Ubuntu 22.04.1 LTS (GNU/Linux 5.15.0-60-generic x86_64)

Last login: Fri Feb 24 06:02:36 2023 from 10.7.0.168
root@server2:~# 
</output_code>
  <markdown>¡Conseguido! Pero podemos dejarlo un poco más limpio todo, podemos añadir esta última conexión al archivo de configuración</markdown>
  <input_code>!echo "Host server2ByTunel\n    HostName localhost\n    User root\n    Port 2020" &gt;&gt; ~/.ssh/config</input_code>
  <markdown>Veamos cómo queda el archivo de configuración</markdown>
  <input_code>!cat ~/.ssh/config</input_code>
  <output_code># Read more about SSH config files: https://linux.die.net/man/5/ssh_config
Host 192.168.1.138
    HostName 192.168.1.138
    User maximo.fernandez

Host server1
    HostName 194.62.99.222
    User root
Host proxyServer1
    HostName 194.62.99.222
    User root
    DynamicForward 9999
Host tunelToServer2
    HostName 194.62.99.222
    User root
    LocalForward 127.0.0.1:2020 10.7.2.228:22
Host server2ByTunel
    HostName localhost
    User root
    Port 2020
</output_code>
  <markdown>Ahora nos volvemos a conectar al `server2` desde mi ordenador, a través del túnel, pero con la última configuración que acabamos de guardar</markdown>
  <input_code>!ssh server2ByTunel </input_code>
  <output_code>Welcome to Ubuntu 22.04.1 LTS (GNU/Linux 5.15.0-60-generic x86_64)

Last login: Fri Feb 24 06:13:33 2023 from 10.7.0.168
root@server2:~# 
</output_code>
  <markdown>En resumen, con todo lo que hemos hecho, podemos crear el túnel hasta el `server2` con el comando `ssh tunelToServer2` y a continuación conectarnos al `server2` con el comando `ssh server2ByTunel`

¡Impresionante!</markdown>
  <markdown>### Conexión reversa</markdown>
  <markdown>Recordamos que ahora nuestro problema era que no nos podíamos conectar al `server2` a través del túnel del `server1`. De modo que creando una conexión reversa desde el `server2` (tenemos alguien en el `server2` que puede hacer esa conexión reversa, o lo dejamos hecho nosotros antes de irnos) hasta un `server3`, desde mi ordenador me puedo conectar al `server3` y a continuación conectarme al `server2`</markdown>
  <markdown>Primero tenemos que hacer la conexión reversa desde el `server2` al `server3`. Esto lo podríamos hacer mediante un comando

``` bash
ssh -R &amp;ltserver3port&amp;gt:localhost:22 root@&amp;ltIPserver3&amp;gt
```

O guardar la conexión en el archivo de configuración añadiendo

```
Host reverseToServer3
    HostName &amp;ltIPserver3&amp;gt
    User root
    RemoteForward &amp;ltserver3port&amp;gt localhost:22
```

Y hacer la conexión inversa mediante

``` bash
ssh reverseToServer3
```</markdown>
  <markdown>Como así no se entiende bien, veámoslo con datos concretos

 * `server2`:
   * `IP` pública: `194.62.99.235`
 * `server3`:
   * `IP` pública: `194.62.96.236`

Para hacer la conexión inversa habría que usar el comando

``` bash
ssh -R 2020:localhost:22 root@194.62.96.236
```

o guardar la siguiente configuración

``` bash
Host reverseToServer3
    HostName 194.62.96.236
    User root
    RemoteForward 2020 localhost:22
```

Y conectarse mediante

``` bash
ssh reverseToServer3
```</markdown>
  <markdown>De modo que guardo la configuración en el servidor 2 y hago la conexión</markdown>
  <input_code>!root@server2:~# echo "Host reverseToServer3\n    HostName 194.62.96.236\n    User root\n    RemoteForward 2020 localhost:22" &gt;&gt; ~/.ssh/config</input_code>
  <markdown>Veamos que se ha guardado bien</markdown>
  <input_code>!root@server2:~# cat .ssh/config</input_code>
  <output_code>
Host reverseToServer3
    HostName 194.62.96.236
    User root
    RemoteForward 2020 localhost:22
</output_code>
  <markdown>Hago la conexión inversa</markdown>
  <input_code>!root@server2:~# ssh reverseToServer3 </input_code>
  <output_code>Welcome to Ubuntu 22.04.1 LTS (GNU/Linux 5.15.0-53-generic x86_64)

Last login: Wed Feb 22 15:26:18 2023 from 194.62.99.235
root@server3:~# 
</output_code>
  <markdown>### Jump</markdown>
  <markdown>Como hemos dicho hacíamos saltos mediante el flag `-J`, de manera que con el comando `ssh -J root@194.62.99.222 root@10.7.2.228` podíamos conectarnos al `server2`</markdown>
  <markdown>Para configurar el archivo de configuración, hay dos opciones</markdown>
  <markdown>La primera es que como ya tenemos el `server1` guardado en el archivo de configuración, solamente añadimos `server2`

``` bash
Host server2
    HostName 10.7.2.228
    User root
```

Y a continuación nos podríamos conectar mediante

``` bash
ssh -J server1 server2
```

Vamos a probarlo</markdown>
  <input_code>!echo "Host server2\n    HostName 10.7.2.228\n    User root\n" &gt;&gt; ~/.ssh/config</input_code>
  <markdown>Vemos el archivo de configuración</markdown>
  <input_code>!cat ~/.ssh/config</input_code>
  <output_code># Read more about SSH config files: https://linux.die.net/man/5/ssh_config
Host 192.168.1.138
    HostName 192.168.1.138
    User maximo.fernandez

Host server1
    HostName 194.62.99.222
    User root
Host proxyServer1
    HostName 194.62.99.222
    User root
    DynamicForward 9999
Host tunelToServer2
    HostName 194.62.99.222
    User root
    LocalForward 127.0.0.1:2020 10.7.2.228:22
Host server2ByTunel
    HostName localhost
    User root
    Port 2020
Host server2
    HostName 10.7.2.228
    User root

</output_code>
  <markdown>Ahora nos conectamos mediante los saltos</markdown>
  <input_code>!ssh -J server1 server2</input_code>
  <output_code>Welcome to Ubuntu 22.04.1 LTS (GNU/Linux 5.15.0-60-generic x86_64)

Last login: Fri Feb 24 12:05:16 2023 from 10.7.0.168
root@server2:~#
</output_code>
  <markdown>Esta ha sido la primera opción: guardar cada servidor y establecer los saltos; pero una segunda opción es guardar todos los saltos en una sola configuración, que quedaría así

``` bash
Host server2jumping
    HostName 10.7.2.228
    User root
    ProxyJump root@194.62.99.222
```

Y ya solo faltaría conectarse mediante

```
ssh server2jumping
```

Vamos a probar</markdown>
  <input_code>!echo "Host server2jumping\n    HostName 10.7.2.228\n    User root\n    ProxyJump root@194.62.99.222" &gt;&gt; ~/.ssh/config</input_code>
  <markdown>Vamos a ver el archivo de configuración</markdown>
  <input_code>!cat ~/.ssh/config</input_code>
  <output_code># Read more about SSH config files: https://linux.die.net/man/5/ssh_config
Host 192.168.1.138
    HostName 192.168.1.138
    User maximo.fernandez

Host server1
    HostName 194.62.99.222
    User root
Host proxyServer1
    HostName 194.62.99.222
    User root
    DynamicForward 9999
Host tunelToServer2
    HostName 194.62.99.222
    User root
    LocalForward 127.0.0.1:2020 10.7.2.228:22
Host server2ByTunel
    HostName localhost
    User root
    Port 2020
Host server2
    HostName 10.7.2.228
    User root
Host server2jumping
    HostName 10.7.2.228
    User root
    ProxyJump root@194.62.99.222
</output_code>
  <markdown>Ahora intentamos conectarnos</markdown>
  <input_code>!ssh server2jumping</input_code>
  <output_code>Welcome to Ubuntu 22.04.1 LTS (GNU/Linux 5.15.0-60-generic x86_64)

Last login: Fri Feb 24 12:06:22 2023 from 10.7.0.168
root@server2:~# 
</output_code>
  <markdown>## Archivo de configuración `SSH` del sistema</markdown>
  <markdown>Antes vimos el archivo de configuración de `SSH` del usuario, donde guardamos configuraciones de máquinas donde nos queríamos conectar por `SSH`, pero hay otro archivo de configuración de `SSH` pero en este caso del sistema, que se encuentra en `/etc/ssh/ssh_config`, vamos a verlo</markdown>
  <input_code>!cat /etc/ssh/sshd_config</input_code>
  <output_code>#	$OpenBSD: sshd_config,v 1.103 2018/04/09 20:41:22 tj Exp $

# This is the sshd server system-wide configuration file.  See
# sshd_config(5) for more information.

# This sshd was compiled with PATH=/usr/bin:/bin:/usr/sbin:/sbin

# The strategy used for options in the default sshd_config shipped with
# OpenSSH is to specify options with their default value where
# possible, but leave them commented.  Uncommented options override the
# default value.

Include /etc/ssh/sshd_config.d/*.conf

#Port 22
#AddressFamily any
#ListenAddress 0.0.0.0
#ListenAddress ::

#HostKey /etc/ssh/ssh_host_rsa_key
#HostKey /etc/ssh/ssh_host_ecdsa_key
#HostKey /etc/ssh/ssh_host_ed25519_key

# Ciphers and keying
#RekeyLimit default none

# Logging
#SyslogFacility AUTH
#LogLevel INFO

# Authentication:

#LoginGraceTime 2m
#PermitRootLogin prohibit-password
#StrictModes yes
#MaxAuthTries 6
#MaxSessions 10

#PubkeyAuthentication yes

# Expect .ssh/authorized_keys2 to be disregarded by default in future.
#AuthorizedKeysFile	.ssh/authorized_keys .ssh/authorized_keys2

#AuthorizedPrincipalsFile none

#AuthorizedKeysCommand none
#AuthorizedKeysCommandUser nobody

# For this to work you will also need host keys in /etc/ssh/ssh_known_hosts
#HostbasedAuthentication no
# Change to yes if you don't trust ~/.ssh/known_hosts for
# HostbasedAuthentication
#IgnoreUserKnownHosts no
# Don't read the user's ~/.rhosts and ~/.shosts files
#IgnoreRhosts yes

# To disable tunneled clear text passwords, change to no here!
#PasswordAuthentication yes
#PermitEmptyPasswords no

# Change to yes to enable challenge-response passwords (beware issues with
# some PAM modules and threads)
ChallengeResponseAuthentication no

# Kerberos options
#KerberosAuthentication no
#KerberosOrLocalPasswd yes
#KerberosTicketCleanup yes
#KerberosGetAFSToken no

# GSSAPI options
#GSSAPIAuthentication no
#GSSAPICleanupCredentials yes
#GSSAPIStrictAcceptorCheck yes
#GSSAPIKeyExchange no

# Set this to 'yes' to enable PAM authentication, account processing,
# and session processing. If this is enabled, PAM authentication will
# be allowed through the ChallengeResponseAuthentication and
# PasswordAuthentication.  Depending on your PAM configuration,
# PAM authentication via ChallengeResponseAuthentication may bypass
# the setting of "PermitRootLogin without-password".
# If you just want the PAM account and session checks to run without
# PAM authentication, then enable this but set PasswordAuthentication
# and ChallengeResponseAuthentication to 'no'.
UsePAM yes

#AllowAgentForwarding yes
#AllowTcpForwarding yes
#GatewayPorts no
X11Forwarding yes
#X11DisplayOffset 10
#X11UseLocalhost yes
#PermitTTY yes
PrintMotd no
#PrintLastLog yes
#TCPKeepAlive yes
#PermitUserEnvironment no
#Compression delayed
#ClientAliveInterval 0
#ClientAliveCountMax 3
#UseDNS no
#PidFile /var/run/sshd.pid
#MaxStartups 10:30:100
#PermitTunnel no
#ChrootDirectory none
#VersionAddendum none

# no default banner path
#Banner none

# Allow client to pass locale environment variables
AcceptEnv LANG LC_*

# override default of no subsystems
Subsystem	sftp	/usr/lib/openssh/sftp-server

# Example of overriding settings on a per-user basis
#Match User anoncvs
#	X11Forwarding no
#	AllowTcpForwarding no
#	PermitTTY no
#	ForceCommand cvs server
</output_code>
  <markdown>Con este archivo podemos cambiar la configuración de cómo funciona `SSH` en nuestro ordenador. Por ejemplo, podemos ver una línea comentada que pone

``` bash
#Port 22
```

Si la descomentamos y cambiamos el número `SSH` dejará de ir por el puerto 22, que es su puerto por defecto, e irá por el número de puerto que ahí se especifique.</markdown>
  <markdown>## Copia de archivos por `SSH`</markdown>
  <markdown>Podemos copiar archivos por `SSH` mediante el comando `scp` (secure copy). Para ello, la sintaxis es

``` bash
scp &amp;ltpath local file&amp;gt &amp;ltuser&amp;gt@&amp;ltIP&amp;gt:&amp;ltpath to save&amp;gt
```

o

``` bash
scp &amp;ltuser&amp;gt@&amp;ltip&amp;gt:&amp;ltpath to remote file&amp;gt &amp;ltpath to save&amp;gt
```

De la primera forma se copia un archivo de nuestro ordenador a otro y, de la segunda, de otro al nuestro</markdown>
  <markdown>Por ejemplo, hagamos un `ls` del `server1`</markdown>
  <input_code>!ssh -t server1 "ls"</input_code>
  <output_code>snap
Connection to 194.62.99.222 closed.
</output_code>
  <markdown>Veamos ahora qué tenemos en local que le podamos pasar</markdown>
  <input_code>!ls</input_code>
  <output_code> 2021-02-11-Introduccion-a-Python.ipynb         html_files
 2021-04-23-Calculo-matricial-con-Numpy.ipynb   html.ipynb
 2021-06-15-Manejo-de-datos-con-Pandas.ipynb    introduccion_python
 2022-09-12-Introduccion-a-la-terminal.ipynb    mi_paquete_de_python
 2023-01-22-Docker.ipynb		        movies.csv
 2023-02-01-Bash-scripting.ipynb	        movies.dat
 2023-02-04-Blip-2.ipynb		        notebooks_translated
 2023-XX-XX-SSH.ipynb			        __pycache__
 california_housing_train.csv		        scripts_bash
 command-line-cheat-sheet.pdf		        ssh.ipynb
 CSS.ipynb				        test.ipynb
'Expresiones regulares.ipynb'
</output_code>
  <markdown>Vamos a enviar al servidor el archivo `html.ipynb` ya que ocupa poco</markdown>
  <input_code>!scp html.ipynb server1:/root/</input_code>
  <output_code>html.ipynb                                    100%   14KB 229.0KB/s   00:00    
</output_code>
  <markdown>Volvemos a ver qué hay dentro de `server1`</markdown>
  <input_code>!ssh -t server1 "ls"</input_code>
  <output_code>html.ipynb  snap
Connection to 194.62.99.222 closed.
</output_code>
  <markdown>Se ha copiado</markdown>
  <markdown>## Sincroniazción de archivos por `SSH`</markdown>
  <markdown>Lo malo del comando `scp` es que si en medio de la copia pasa algo y no se termina de copiar el archivo, cuando se vuelva a intentar hay que empezar desde cero, esto sobre todo es un problema con archivos muy grandes</markdown>
  <markdown>Para solucionar esto se puede usar `rsync`, la sintaxis es

``` bash
rsync --partial --progress --rsh=ssh &lt;path local file&gt; &lt;user&gt;@&lt;IP&gt;:&lt;path to save&gt;
```

o

``` bash
rsync --partial --progress --rsh=ssh &lt;user&gt;@&lt;ip&gt;:&lt;path to remote file&gt; &lt;path to save&gt;
```

Al igual que antes, de la primera forma se copia un archivo de nuestro ordenador a otro y de la segunda de otro al nuestro. El flag `--partial` es para indicar que se guarden archivos parcialmente copiados, es decir, que si se para la copia antes de que termine, lo que se haya copiado se mantenga. El flag `--progress` es para indicar que muestre el progreso de la copia. El flag `--rsh=ssh` es para indicar que la transferencia de archivos se haga por `SSH`</markdown>
  <markdown>Pasamos un archivo</markdown>
  <input_code>!rsync --partial --progress -rsh=ssh 2021-06-15-Manejo-de-datos-con-Pandas.ipynb  server1:/root/</input_code>
  <output_code>sending incremental file list
2021-06-15-Manejo-de-datos-con-Pandas.ipynb
        608.34K 100%  197.78MB/s    0:00:00 (xfr#1, to-chk=0/1)
</output_code>
  <markdown>Y vemos si se ha copiado</markdown>
  <input_code>!ssh -t server1 "ls"</input_code>
  <output_code>2021-06-15-Manejo-de-datos-con-Pandas.ipynb  html.ipynb  snap
Connection to 194.62.99.222 closed.
</output_code>
  <markdown>## Montar carpetas remotas en local</markdown>
  <markdown>En el caso que queramos tener una carpeta de otra máquina como si estuviese en nuestro ordenador tenemos que usar `sshfs`

Primero es necesario instalarlo mediante 

``` bash
sudo apt install sshfs
```

Y una vez esté instalado, se usa con la sintaxis

``` bash
sshfs &amp;ltuser&amp;gt@&amp;ltip&amp;gt:&amp;ltremote path&amp;gt &amp;ltlocal path to mount&amp;gt
```</markdown>
  <markdown>Vamos a montar la carpeta `/root` del `server1`, pero para ello primero vamos a crear una carpeta en la que lo vamos a montar</markdown>
  <input_code>!mkdir server1folder</input_code>
  <markdown>Vemos que, dentro de la carpeta que hemos montado, no hay nada</markdown>
  <input_code>!ls server1folder</input_code>
  <markdown>Ahora montamos la carpeta del servidor</markdown>
  <input_code>!!sshfs server1:/root/ server1folder</input_code>
  <markdown>Volvemos a ver qué hay dentro</markdown>
  <input_code>!ls server1folder</input_code>
  <output_code>2021-06-15-Manejo-de-datos-con-Pandas.ipynb  html.ipynb  snap
</output_code>
  <markdown>Cuando ya no queramos tener más la carpeta montada, la podemos desmontar mediante `fusermount -u server1folder`</markdown>
  <input_code>!!fusermount -u server1folder</input_code>
  <markdown>Volvemos a mirar qué hay dentro para ver si no hay nada</markdown>
  <input_code>!ls server1folder</input_code>
  <markdown>## Depurar la conexión `SSH`</markdown>
  <markdown>Podemos depurar la conexión `SSH` añadiendo desde `-v`, hasta `-vvvv` a la conexión, cuantas más `v`s pongamos, mayor nivel de información</markdown>
  <input_code>!ssh -v server1</input_code>
  <output_code>OpenSSH_8.2p1 Ubuntu-4ubuntu0.5, OpenSSL 1.1.1f  31 Mar 2020
debug1: Reading configuration data /home/wallabot/.ssh/config
debug1: /home/wallabot/.ssh/config line 6: Applying options for server1
debug1: Reading configuration data /etc/ssh/ssh_config
debug1: /etc/ssh/ssh_config line 19: include /etc/ssh/ssh_config.d/*.conf matched no files
debug1: /etc/ssh/ssh_config line 21: Applying options for *
debug1: Connecting to 194.62.99.222 [194.62.99.222] port 22.
debug1: Connection established.
debug1: identity file /home/wallabot/.ssh/id_rsa type 0
debug1: identity file /home/wallabot/.ssh/id_rsa-cert type -1
debug1: identity file /home/wallabot/.ssh/id_dsa type -1
debug1: identity file /home/wallabot/.ssh/id_dsa-cert type -1
debug1: identity file /home/wallabot/.ssh/id_ecdsa type -1
debug1: identity file /home/wallabot/.ssh/id_ecdsa-cert type -1
debug1: identity file /home/wallabot/.ssh/id_ecdsa_sk type -1
debug1: identity file /home/wallabot/.ssh/id_ecdsa_sk-cert type -1
debug1: identity file /home/wallabot/.ssh/id_ed25519 type -1
debug1: identity file /home/wallabot/.ssh/id_ed25519-cert type -1
debug1: identity file /home/wallabot/.ssh/id_ed25519_sk type -1
debug1: identity file /home/wallabot/.ssh/id_ed25519_sk-cert type -1
debug1: identity file /home/wallabot/.ssh/id_xmss type -1
debug1: identity file /home/wallabot/.ssh/id_xmss-cert type -1
debug1: Local version string SSH-2.0-OpenSSH_8.2p1 Ubuntu-4ubuntu0.5
debug1: Remote protocol version 2.0, remote software version OpenSSH_8.9p1 Ubuntu-3
debug1: match: OpenSSH_8.9p1 Ubuntu-3 pat OpenSSH* compat 0x04000000
debug1: Authenticating to 194.62.99.222:22 as 'root'
debug1: SSH2_MSG_KEXINIT sent
debug1: SSH2_MSG_KEXINIT received
debug1: kex: algorithm: curve25519-sha256
debug1: kex: host key algorithm: ecdsa-sha2-nistp256
debug1: kex: server-&gt;client cipher: chacha20-poly1305@openssh.com MAC: &lt;implicit&gt; compression: none
debug1: kex: client-&gt;server cipher: chacha20-poly1305@openssh.com MAC: &lt;implicit&gt; compression: none
debug1: expecting SSH2_MSG_KEX_ECDH_REPLY
debug1: Server host key: ecdsa-sha2-nistp256 SHA256:jwpQt2a69LQcuvvYPPKL32bBwTi1Je/ZmUdr4zEiD1Y
debug1: Host '194.62.99.222' is known and matches the ECDSA host key.
debug1: Found key in /home/wallabot/.ssh/known_hosts:14
debug1: rekey out after 134217728 blocks
debug1: SSH2_MSG_NEWKEYS sent
debug1: expecting SSH2_MSG_NEWKEYS
debug1: SSH2_MSG_NEWKEYS received
debug1: rekey in after 134217728 blocks
debug1: Will attempt key: /home/wallabot/.ssh/id_rsa RSA SHA256:ID3HcrbyPBGjFx/qeiJK50eqihLGrpDVu02oRSyKGh4 agent
debug1: Will attempt key: wallabot@wallabot RSA SHA256:Qlq6hXbToInW+efEK666BFT26EeUSpBhzcqxTLrDBpQ agent
debug1: Will attempt key: /home/wallabot/.ssh/id_dsa 
debug1: Will attempt key: /home/wallabot/.ssh/id_ecdsa 
debug1: Will attempt key: /home/wallabot/.ssh/id_ecdsa_sk 
debug1: Will attempt key: /home/wallabot/.ssh/id_ed25519 
debug1: Will attempt key: /home/wallabot/.ssh/id_ed25519_sk 
debug1: Will attempt key: /home/wallabot/.ssh/id_xmss 
debug1: SSH2_MSG_EXT_INFO received
debug1: kex_input_ext_info: server-sig-algs=&lt;ssh-ed25519,sk-ssh-ed25519@openssh.com,ssh-rsa,rsa-sha2-256,rsa-sha2-512,ssh-dss,ecdsa-sha2-nistp256,ecdsa-sha2-nistp384,ecdsa-sha2-nistp521,sk-ecdsa-sha2-nistp256@openssh.com,webauthn-sk-ecdsa-sha2-nistp256@openssh.com&gt;
debug1: kex_input_ext_info: publickey-hostbound@openssh.com (unrecognised)
debug1: SSH2_MSG_SERVICE_ACCEPT received
debug1: Authentications that can continue: publickey
debug1: Next authentication method: publickey
debug1: Offering public key: /home/wallabot/.ssh/id_rsa RSA SHA256:ID3HcrbyPBGjFx/qeiJK50eqihLGrpDVu02oRSyKGh4 agent
debug1: Authentications that can continue: publickey
debug1: Offering public key: wallabot@wallabot RSA SHA256:Qlq6hXbToInW+efEK666BFT26EeUSpBhzcqxTLrDBpQ agent
debug1: Server accepts key: wallabot@wallabot RSA SHA256:Qlq6hXbToInW+efEK666BFT26EeUSpBhzcqxTLrDBpQ agent
debug1: Authentication succeeded (publickey).
Authenticated to 194.62.99.222 ([194.62.99.222]:22).
debug1: channel 0: new [client-session]
debug1: Requesting no-more-sessions@openssh.com
debug1: Entering interactive session.
debug1: pledge: network
debug1: client_input_global_request: rtype hostkeys-00@openssh.com want_reply 0
debug1: Remote: /root/.ssh/authorized_keys:1: key options: agent-forwarding port-forwarding pty user-rc x11-forwarding
debug1: Remote: /root/.ssh/authorized_keys:1: key options: agent-forwarding port-forwarding pty user-rc x11-forwarding
debug1: Sending environment.
debug1: Sending env LANG = es_ES.UTF-8
Welcome to Ubuntu 22.04.1 LTS (GNU/Linux 5.15.0-60-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Fri Feb 24 01:25:10 PM UTC 2023

  System load:           0.0
  Usage of /:            15.2% of 24.53GB
  Memory usage:          34%
  Swap usage:            0%
  Processes:             89
  Users logged in:       0
  IPv4 address for eth0: 194.62.99.222
  IPv4 address for eth1: 10.7.0.168
  IPv6 address for eth2: 2a04:3542:8000:1000:d48a:cbff:fefb:5b1

 * Strictly confined Kubernetes makes edge and IoT secure. Learn how MicroK8s
   just raised the bar for easy, resilient and secure K8s cluster deployment.

   https://ubuntu.com/engage/secure-kubernetes-at-the-edge

43 updates can be applied immediately.
To see these additional updates run: apt list --upgradable


Last login: Fri Feb 24 13:10:05 2023 from 188.127.184.59
[?2004h]0;root@server1: ~[01;32mroot@server1[00m:[01;34m~[00m# ^C[?2004l
[?2004l
[?2004h]0;root@server1: ~[01;32mroot@server1[00m:[01;34m~[00m# </output_code>
</notebook>