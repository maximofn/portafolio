<?xml version='1.0' encoding='utf-8'?>
<notebook>
  <markdown># SSH</markdown>
  <markdown>## Introducci√≥n hist√≥rica</markdown>
  <markdown>En los primeros d√≠as de internet se cre√≥ el protocolo `telnet` para poder comunicar varios ordenadores, pero ten√≠a el problema de que no estaba cifrado, por lo que cualquiera que se metiera en medio pod√≠a leer la comunicaci√≥n sin problema, por eso se cre√≥ `SSH` (Secure Shell)</markdown>
  <markdown>## Cifrado de `SSH`</markdown>
  <markdown>El sistema de cifrado de `SSH` funciona mediante el sistema de clave p√∫blica y clave privada, de manera que si se encripta la comunicaci√≥n con una de las dos claves, solo puede ser descifrada por la otra clave

¬øY por qu√© hay una clave p√∫blica y una clave privada? La clave p√∫blica es la que le das a todo el mundo y la clave privada es la que solo tienes que poseer t√∫.

De manera que si te quieres comunicar con otro equipo por `SSH`, primero le das tu clave p√∫blica, a continuaci√≥n encriptas el mensaje con tu clave privada y solo se puede desencriptar el mensaje con la clave p√∫blica que le has dado al otro equipo

De la misma manera ocurre al rev√©s, si el otro equipo te quiere mandar un mensaje, lo encripta con tu clave p√∫blica y solo se puede desencriptar con la clave privada que solo t√∫ posees</markdown>
  <markdown>## Requerimentos `SSH`</markdown>
  <markdown>### Servicio `SSH`</markdown>
  <markdown>Para poder usar `SSH` necesitas tener un servicio de `SSH`. En `Linux` normalmente ya viene instalado, pero si no es as√≠ lo puedes instalar mediante</markdown>
  <input_code>!apt install openssh-server</input_code>
  <markdown>Durante el proceso de instalaci√≥n, te pedir√° tu ubicaci√≥n para ajustar el time zone</markdown>
  <markdown>A continuaci√≥n, levantamos el servicio</markdown>
  <input_code>!systemctl enable ssh</input_code>
  <markdown>### Cliente `SSH`</markdown>
  <markdown>Una vez tengas el servicio necesitas un cliente, aunque en `Linux` suele venir instalado, pero si no es as√≠ lo puedes instalar mediante</markdown>
  <input_code>!apt install openssh-client</input_code>
  <markdown>## Conexi√≥n por `SSH`</markdown>
  <markdown>Para conectarte por `SSH` necesitas introducir el comando `ssh &lt;user&gt;@&lt;ip&gt;`</markdown>
  <input_code>!ssh root@172.17.0.1</input_code>
  <output_code>The authenticity of host '172.17.0.1 (172.17.0.1)' can't be established.
ECDSA key fingerprint is SHA256:M+qsqSC4HiYztm1ij8iDkh9KHJz+pxrTm9GTZIf2N9k.
Are you sure you want to continue connecting (yes/no/[fingerprint])?
</output_code>
  <markdown>Como puedes ver, la primera vez te pregunta si quieres guardar el `fingerprint`, esto es para que si la pr√≥xima vez que te conectes a la misma m√°quina (a la misma clave p√∫blica) ha cambiado el `fingerprint` debes tener cuidado porque puede haber algo peligroso, como que se hagan pasar por esa m√°quina.

Si nos fiamos introducimos `yes`</markdown>
  <input_code>!ssh root@172.17.0.1</input_code>
  <output_code>The authenticity of host '172.17.0.1 (172.17.0.1)' can't be established.
ECDSA key fingerprint is SHA256:M+qsqSC4HiYztm1ij8iDkh9KHJz+pxrTm9GTZIf2N9k.
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '172.17.0.1' (ECDSA) to the list of known hosts.
root@172.17.0.1's password:
</output_code>
  <markdown>A continuaci√≥n, la m√°quina a la que nos conectamos nos pide la contrase√±a, la introducimos y ya estaremos dentro de la m√°quina</markdown>
  <input_code>!ssh root@172.17.0.1</input_code>
  <output_code>The authenticity of host '172.17.0.1 (172.17.0.1)' can't be established.
ECDSA key fingerprint is SHA256:M+qsqSC4HiYztm1ij8iDkh9KHJz+pxrTm9GTZIf2N9k.
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '172.17.0.1' (ECDSA) to the list of known hosts.
root@172.17.0.1's password: 
Welcome to Ubuntu 20.04.5 LTS (GNU/Linux 5.15.0-58-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

1 device has a firmware upgrade available.
Run `fwupdmgr get-upgrades` for more information.


 * Introducing Expanded Security Maintenance for Applications.
   Receive updates to over 25,000 software packages with your
   Ubuntu Pro subscription. Free for personal use.

     https://ubuntu.com/pro

Se pueden aplicar 0 actualizaciones de forma inmediata.

Your Hardware Enablement Stack (HWE) is supported until April 2025.
Last login: Thu Dec  1 16:32:23 2022 from 127.0.0.1
root@172.17.0.1:~$
</output_code>
  <markdown>## Conexi√≥n sin necesidad de contrase√±a</markdown>
  <markdown>Como hemos visto, cuando nos conectamos nos pide la contrase√±a de la m√°quina de destino, pero si es una m√°quina a la que nos vamos a conectar mucho, podemos hacer que no nos pida la contrase√±a cada vez que nos queramos conectar.</markdown>
  <markdown>Para ello, en primer lugar generamos una clave `ssh` mediante `ssh-keygen`</markdown>
  <input_code>!ssh-keygen</input_code>
  <output_code>Generating public/private rsa key pair.
Enter file in which to save the key (/root/.ssh/id_rsa): 
Enter passphrase (empty for no passphrase): 
Enter same passphrase again: 
Your identification has been saved in /root/.ssh/id_rsa
Your public key has been saved in /root/.ssh/id_rsa.pub
The key fingerprint is:
SHA256:4HxRXkVkcK5kNXNyzakfQ6t8a24wRGCUYz4s5KL5ZEc root@e108f6f395b3
The key's randomart image is:
+---[RSA 3072]----+
|          o+==@.=|
|         +.= * Oo|
|      . + = = + .|
|     o o E * + + |
|      = S . = o o|
|     o + .   = o |
|      + .     + .|
|       .       + |
|              +. |
+----[SHA256]-----+
</output_code>
  <markdown>Como vemos, primero nos pregunta d√≥nde queremos guardar la clave, si no introducimos nada nos la guarda en la ruta por defecto. Y a continuaci√≥n una frase para generar la clave, **si escribes una frase debes recordarla siempre**. Adem√°s, si escribes una frase, te la pedir√° cada vez que intentes acceder a la clave, por lo que cada vez que queramos acceder a la m√°quina por medio de `SSH`, no nos pedir√° la contrase√±a de la m√°quina, pero s√≠ esta frase. Por lo que t√∫ eliges si no introduces una frase para que nunca te la pida, o si s√≠ la introduces y siempre las vas a meter.</markdown>
  <markdown>A continuaci√≥n, le pedimos a la m√°quina remota que se guarde nuestra clave mediante `ssh-copy-id &lt;user&gt;@&lt;id&gt;:`</markdown>
  <input_code>!ssh-copy-id root@172.17.0.1:</input_code>
  <output_code>/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: "/root/.ssh/id_rsa.pub"
/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed
/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys
root@172.17.0.1's password: 

Number of key(s) added: 1

Now try logging into the machine, with:   "ssh 'root@172.17.0.1'"
and check to make sure that only the key(s) you wanted were added.

root@103b6040196a:/# ssh root@172.17.0.1
Welcome to Ubuntu 20.04.5 LTS (GNU/Linux 5.15.0-58-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

4 devices have a firmware upgrade available.
Run `fwupdmgr get-upgrades` for more information.


58 updates can be applied immediately.
41 of these updates are standard security updates.
To see these additional updates run: apt list --upgradable

New release '22.04.1 LTS' available.
Run 'do-release-upgrade' to upgrade to it.

Your Hardware Enablement Stack (HWE) is supported until April 2025.
Last login: Thu Feb  2 08:05:48 2023 from 172.17.0.2
(base) root@172.17.0.1:~$
</output_code>
  <markdown>## Usar la terminal remota por `SSH`</markdown>
  <markdown>A lo mejor no nos hace falta tener que meternos a la m√°quina remota porque solo necesitamos ejecutar un solo comando, por lo que podemos usar remotamente su terminal a√±adiendo el flag `-t` al comando `SSH`, es decir, mediante `ssh -t &lt;user&gt;@&lt;id&gt; &lt;command&gt;`</markdown>
  <input_code>!ssh -t root@172.17.0.1 ping -c 4 google.com</input_code>
  <output_code>PING google.com (172.217.168.174) 56(84) bytes of data.
64 bytes from mad07s10-in-f14.1e100.net (172.217.168.174): icmp_seq=1 ttl=111 time=2.94 ms
64 bytes from mad07s10-in-f14.1e100.net (172.217.168.174): icmp_seq=2 ttl=111 time=2.55 ms
64 bytes from mad07s10-in-f14.1e100.net (172.217.168.174): icmp_seq=3 ttl=111 time=2.78 ms
64 bytes from mad07s10-in-f14.1e100.net (172.217.168.174): icmp_seq=4 ttl=111 time=2.69 ms

--- google.com ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 3005ms
rtt min/avg/max/mdev = 2.550/2.739/2.940/0.142 ms
Connection to 172.17.0.1 closed.
</output_code>
  <markdown>Como se puede ver se realiza el comando en la m√°quina remota y cuando termina, en la √∫ltima l√≠nea nos dice que se cierra la conexi√≥n</markdown>
  <markdown>## Proxy `SSH`</markdown>
  <markdown>Si est√°s navegando en un lugar no muy seguro, o en un lugar que tiene un proxy que no te deja acceder a algunos puertos, puedes navegar a trav√©s del proxy de otra m√°quina mediante `SSH`, esto se puede hacer a√±adiendo el flag `-D` y el puerto por el que quieres realizar la conexi√≥n al proxy remoto, como el puerto para el `tcp/ip` es el `9999` el comando podr√≠a quedar como `ssh -D 9999 &lt;user&gt;@&lt;id&gt;`</markdown>
  <markdown>Para que esto se vea mejor, antes de ejecutarlo obtengo mi IP p√∫blica</markdown>
  <input_code>!curl ifconfig.me</input_code>
  <output_code>188.127.184.59</output_code>
  <markdown>Ahora uso el proxy de un servidor web que tengo levantado</markdown>
  <input_code>!ssh -D 9999 root@194.62.99.222</input_code>
  <output_code>Welcome to Ubuntu 22.04.1 LTS (GNU/Linux 5.15.0-53-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Wed Feb 22 06:08:51 AM UTC 2023

  System load:           0.02978515625
  Usage of /:            11.7% of 24.53GB
  Memory usage:          33%
  Swap usage:            0%
  Processes:             89
  Users logged in:       0
  IPv4 address for eth0: 194.62.99.222
  IPv4 address for eth1: 10.7.0.168
  IPv6 address for eth2: 2a04:3542:8000:1000:d48a:cbff:fefb:5b1


0 updates can be applied immediately.


The list of available updates is more than a week old.
To check for new updates run: sudo apt update

Last login: Wed Feb 22 06:02:35 2023 from 188.127.184.59
root@server1:~#
</output_code>
  <markdown>Cambio la configuraci√≥n del proxy de mi ordenador

![proxy ssh](https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/proxy_ssh.webp)</markdown>
  <markdown>Ahora vuelvo a mirar mi IP p√∫blica, pero usando el proxy recientemente configurado</markdown>
  <input_code>!curl -x socks5h://localhost:9999 ifconfig.me</input_code>
  <output_code>194.62.99.222</output_code>
  <markdown>Vemos que obtenemos la IP p√∫blica del servidor</markdown>
  <markdown>## Interfaz gr√°fica remota por `SSH`</markdown>
  <markdown>En Linux la interfaz gr√°fica es un servidor, por lo que nos podemos beneficiar de ello y podemos ejecutar programas con interfaces gr√°ficas que est√°n en una m√°quina remota por `SSH`, para ello hay que usar el flag `-X`. El comando quedar√≠a `ssh -X &lt;user&gt;@&lt;id&gt;`</markdown>
  <markdown>Primero entro a mi servidor e instalo `xeyes` mediante `sudo apt install x11-apps` y despu√©s lo ejecuto remotamente desde mi ordenador</markdown>
  <input_code>!ssh -X root@194.62.99.222</input_code>
  <output_code>Welcome to Ubuntu 22.04.1 LTS (GNU/Linux 5.15.0-53-generic x86_64)

Last login: Wed Feb 22 06:39:52 2023 from 188.127.184.59
/usr/bin/xauth:  file /root/.Xauthority does not exist
root@server1:~sudo apt install x11-apps
root@server1:~#xeyes
</output_code>
  <markdown>Ahora en mi ordenador se abre la ventana de `xeyes` pero no se est√° ejecutando en mi ordenador

![xeyes](https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/xeyes.webp)</markdown>
  <markdown>## Tunel `SSH`</markdown>
  <markdown>Como he comentado, he levantado un servidor al que tengo acceso por SSH</markdown>
  <input_code>!ssh root@194.62.99.222</input_code>
  <output_code>Welcome to Ubuntu 22.04.1 LTS (GNU/Linux 5.15.0-53-generic x86_64)

Last login: Wed Feb 22 06:40:58 2023 from 188.127.184.59
root@server1:~#
</output_code>
  <markdown>Y levanto tambi√©n un segundo servidor desde el que tengo acceso desde el `server1`, pero no tengo acceso desde mi ordenador</markdown>
  <markdown>A continuaci√≥n, intento acceder al `server2` desde mi ordenador y vemos que no puedo</markdown>
  <input_code>!ssh root@194.62.99.235</input_code>
  <output_code>ssh: connect to host 194.62.99.235 port 22: Connection timed out
</output_code>
  <markdown>Y a continuaci√≥n intento acceder al `server2` desde el `server1` y vemos que s√≠ puedo</markdown>
  <input_code>!root@server1:~# ssh root@10.7.2.228</input_code>
  <output_code>Welcome to Ubuntu 22.04.1 LTS (GNU/Linux 5.15.0-53-generic x86_64)

Last login: Wed Feb 22 06:59:01 2023 from 10.7.0.168
root@server2:~#
</output_code>
  <markdown>As√≠ que lo que creamos es un t√∫nel desde mi ordenador hasta el `server2` a trav√©s del `server1`, para ello usamos el flag `-L`. Para crear el t√∫nel hay que indicar el puerto de tu ordenador en el que vas a crear el t√∫nel, a continuaci√≥n la `IP` de destino del t√∫nel, el puerto por el que ir√° el t√∫nel y por √∫ltimo el dispositivo que crear√° el t√∫nel. Quedar√≠a as√≠

``` bash
ssh -L &amp;ltHOST PORT&amp;gt:&amp;ltDEST IP&amp;gt:&amp;ltTUNNEL PORT&amp;gt &amp;ltTUNNEL CREATOR USER&amp;gt@&amp;ltTUNNEL CREATOR IP&amp;gt
```

Ve√°moslo con mi ejemplo, tengo el `server1` con una `IP` p√∫blica que podemos llamar `ip_pub1` y al que tengo acceso por `SSH` y una `IP` privada que podemos llamar `ip_priv1` que est√° dentro de la misma red que `server2`. Y tengo el `server2` con una `IP` p√∫blica que podemos llamar `ip_pub2` a la que no tengo acceso por `SSH` y una `IP` que podemos llamar `ip_priv2` dentro de la misma red de `server1`

Primero creo el t√∫nel

``` bash
ssh -L host_port:ip_priv2:22 root@ip_pub1
```

He creado un t√∫nel hasta la `IP` privada del `server2` a trav√©s de la `IP` p√∫blica del `server1`

Por √∫ltimo, para conectarme al `server2` lo hago a trav√©s del `localhost` y del puerto del host que he declarado en el t√∫nel

``` bash
ssh -p 2020 root@localhost
```</markdown>
  <markdown>Vamos a verlo en la realidad, las `IP`s de mis servidores son

 * `server1`:
   * `IP` p√∫blica: `194.62.99.222`
   * `IP` privada: `10.7.0.168`
 * `server2`:
   * `IP` p√∫blica: `194.62.99.235`
   * `IP` privada: `10.7.2.228`

Primero creo el t√∫nel</markdown>
  <input_code>!ssh -L 2020:10.7.2.228:22 root@194.62.99.222</input_code>
  <output_code>Welcome to Ubuntu 22.04.1 LTS (GNU/Linux 5.15.0-53-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Wed Feb 22 11:13:39 AM UTC 2023

  System load:           0.0
  Usage of /:            13.3% of 24.53GB
  Memory usage:          36%
  Swap usage:            0%
  Processes:             91
  Users logged in:       1
  IPv4 address for eth0: 194.62.99.222
  IPv4 address for eth1: 10.7.0.168
  IPv6 address for eth2: 2a04:3542:8000:1000:d48a:cbff:fefb:5b1


101 updates can be applied immediately.
60 of these updates are standard security updates.
To see these additional updates run: apt list --upgradable


Last login: Wed Feb 22 09:29:52 2023 from 188.127.184.59
[?2004h]0;root@server1: ~[01;32mroot@server1[00m:[01;34m~[00m# ^C[?2004l
[?2004l
[?2004h]0;root@server1: ~[01;32mroot@server1[00m:[01;34m~[00m# </output_code>
  <markdown>Con el t√∫nel creado ya me puedo conectar al `server2` desde mi ordenador</markdown>
  <input_code>!ssh -p 2020 root@localhost</input_code>
  <output_code>Welcome to Ubuntu 22.04.1 LTS (GNU/Linux 5.15.0-53-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Wed Feb 22 11:14:15 AM UTC 2023

  System load:           0.0
  Usage of /:            13.3% of 24.53GB
  Memory usage:          33%
  Swap usage:            0%
  Processes:             90
  Users logged in:       0
  IPv4 address for eth0: 194.62.99.235
  IPv4 address for eth1: 10.7.2.228
  IPv6 address for eth2: 2a04:3542:8000:1000:d48a:cbff:fefb:7f47

 * Strictly confined Kubernetes makes edge and IoT secure. Learn how MicroK8s
   just raised the bar for easy, resilient and secure K8s cluster deployment.

   https://ubuntu.com/engage/secure-kubernetes-at-the-edge

101 updates can be applied immediately.
60 of these updates are standard security updates.
To see these additional updates run: apt list --upgradable


Last login: Wed Feb 22 11:14:16 2023 from 10.7.0.168
[?2004h]0;root@server2: ~[01;32mroot@server2[00m:[01;34m~[00m# ^C[?2004l
[?2004l
[?2004h]0;root@server2: ~[01;32mroot@server2[00m:[01;34m~[00m# </output_code>
  <markdown>## Conexi√≥n reversa</markdown>
  <markdown>Volvamos a suponer que me quiero conectar al `server2`, pero ahora no puedo hacer, por la raz√≥n que sea, un t√∫nel desde el `server1`. Lo que podemos hacer es crear una conexi√≥n reversa desde otro servidor.

Supongamos que tengo un tercer servidor, llamado `server3`, al que se tiene acceso por `SSH` desde cualquier lado, es decir, tanto yo desde mi ordenador como el `server2` tienen acceso. Por lo que si podemos acceder f√≠sicamente al `server2` se puede hacer una conexi√≥n reversa desde el `server2` al `server3`

```
ssh -R &amp;ltserver3port&amp;gt:localhost:22 root@&amp;ltIPserver3&amp;gt
```

Con esto, lo que he hecho es habilitar una conexi√≥n desde el `server3` al `server2` (cosa que antes no se pod√≠a), a trav√©s del `localhost` y puerto `server3port` del `server3`

Ahora desde mi ordenador me puedo conectar al `server3` y desde el `server3` me puedo conectar al `server2` mediante

``` bash
ssh -p &amp;ltserver3port&amp;gt root@localhost
```</markdown>
  <markdown>Ve√°moslo con los datos de mis servidores

* `server2`:
   * `IP` p√∫blica: `194.62.99.235`
 * `server3`:
   * `IP` p√∫blica: `194.62.96.236`</markdown>
  <markdown>Primero hago la conexi√≥n reversa desde el `server2` al `server3`</markdown>
  <input_code>!root@server2:~# ssh -R 2020:localhost:22 root@194.62.96.236</input_code>
  <output_code>Welcome to Ubuntu 22.04.1 LTS (GNU/Linux 5.15.0-53-generic x86_64)

Last login: Wed Feb 22 15:25:58 2023 from 188.127.184.59
root@server3:~#
</output_code>
  <markdown>Ahora me conecto al `server3`</markdown>
  <input_code>!ssh root@194.62.96.236</input_code>
  <output_code>Welcome to Ubuntu 22.04.1 LTS (GNU/Linux 5.15.0-53-generic x86_64)

Last login: Wed Feb 22 15:12:19 2023 from 188.127.184.59
root@server3:~#
</output_code>
  <markdown>Y ahora que estoy en el `server3` me conecto al `server2`</markdown>
  <input_code>!root@server3:~# ssh -p 2020 root@localhost</input_code>
  <output_code>Welcome to Ubuntu 22.04.1 LTS (GNU/Linux 5.15.0-53-generic x86_64)

Last login: Wed Feb 22 15:12:07 2023 from 188.127.184.59
root@server2:~#
</output_code>
  <markdown>¬°Conseguido! A trav√©s de mi ordenador no puedo conectarme directamente al `server2`, pero al conectarme al `server3` he podido acceder al `server2` gracias a la conexi√≥n inversa que hab√≠a hecho del `server2` al `server3`</markdown>
  <markdown>## Jump</markdown>
  <markdown>Por √∫ltimo, otra manera de entrar al `server2` es entrando al `server1` y a continuaci√≥n, desde el `server1` entrar al `server2`. Pero esto es un poco engorroso, porque primero hay que hacer una conexi√≥n `SSH` al `server1` y luego otra al `server2`, as√≠ que para hacerlo todo de una podemos usar el flag `-J` (`jump`), es decir, quedar√≠a `ssh -J server1 server2`</markdown>
  <markdown>Resumen, primero har√≠amos `ssh root@194.62.99.222` y luego `ssh root@10.7.2.228` (ya que dentro de `server1` nos conectamos a `server2` mediante la `IP` privada).

As√≠ que podr√≠amos hacer todo de una haciendo `ssh -J root@194.62.99.222 root@10.7.2.228`

Vamos a probar</markdown>
  <input_code>!ssh -J root@194.62.99.222 root@10.7.2.228</input_code>
  <output_code>Welcome to Ubuntu 22.04.1 LTS (GNU/Linux 5.15.0-60-generic x86_64)

Last login: Fri Feb 24 06:46:11 2023 from 10.7.0.168
root@server2:~#
</output_code>
  <markdown>¬°Hemos podido hacer los saltos!</markdown>
  <markdown>## Archivo de configuraci√≥n `SSH` del usuario</markdown>
  <markdown>### Dispositivos con Alias</markdown>
  <markdown>En todo ordenador hay un archivo de configuraci√≥n para el `SSH` que suele estar en la carpeta del usuario</markdown>
  <input_code>!cat ~/.ssh/config</input_code>
  <output_code># Read more about SSH config files: https://linux.die.net/man/5/ssh_config
Host 192.168.1.138
    HostName 192.168.1.138
    User maximo.fernandez
</output_code>
  <markdown>En este archivo tengo guardadas las credenciales de usuario e IP de algunos dispositivos a los que me suelo conectar y as√≠ no tengo que rellenar todo yo. Ve√°moslo con los servidores que tengo

Mi servidor `server1` tiene el usuario `root` y la IP `194.62.99.222`, por lo que lo a√±ado a la lista</markdown>
  <input_code>!echo "Host server1\n    HostName 194.62.99.222\n    User root" &gt;&gt; ~/.ssh/config</input_code>
  <markdown>Volvamos a ver c√≥mo ha quedado el archivo de configuraci√≥n</markdown>
  <input_code>!cat ~/.ssh/config</input_code>
  <output_code># Read more about SSH config files: https://linux.die.net/man/5/ssh_config
Host 192.168.1.138
    HostName 192.168.1.138
    User maximo.fernandez

Host server1
    HostName 194.62.99.222
    User root
</output_code>
  <markdown>Ahora que lo hemos a√±adido para conectarnos al `server1`, ya solo nos hace falta hacer `ssh server1`</markdown>
  <input_code>!ssh server1 </input_code>
  <output_code>Welcome to Ubuntu 22.04.1 LTS (GNU/Linux 5.15.0-60-generic x86_64)

Last login: Fri Feb 24 05:18:59 2023 from 188.127.184.59
root@server1:~# 
</output_code>
  <markdown>### Proxy</markdown>
  <markdown>Como ya vimos, a√±adiendo el flag `-D &amp;ltport&amp;gt` pod√≠amos cambiar la proxy. Para dejar esto guardado en el archivo de configuraci√≥n solo tenemos que a√±adir la l√≠nea `DynamicForward &amp;ltport&amp;gt` al host que estamos guardando</markdown>
  <markdown>Repitiendo el ejemplo anterior en el que usamos el `server1` como un proxy del puerto `TCP/IP` (`9999`), en el archivo de configuraci√≥n quedar√≠a as√≠

```
Host proxyServer1
    HostName 194.62.99.222
    User root
    DynamicForward 9999
```

Lo a√±adimos</markdown>
  <input_code>!echo "Host proxyServer1\n    HostName 194.62.99.222\n    User root\n    DynamicForward 9999" &gt;&gt; ~/.ssh/config</input_code>
  <markdown>Veamos c√≥mo queda el archivo de configuraci√≥n</markdown>
  <input_code>!cat ~/.ssh/config</input_code>
  <output_code># Read more about SSH config files: https://linux.die.net/man/5/ssh_config
Host 192.168.1.138
    HostName 192.168.1.138
    User maximo.fernandez

Host server1
    HostName 194.62.99.222
    User root
Host proxyServer1
    HostName 194.62.99.222
    User root
    DynamicForward 9999
</output_code>
  <markdown>Obtengo mi `IP` p√∫blica</markdown>
  <input_code>!curl ifconfig.me</input_code>
  <output_code>188.127.184.59</output_code>
  <markdown>Me conecto al servidor proxy</markdown>
  <input_code>!ssh proxyServer1 </input_code>
  <output_code>Welcome to Ubuntu 22.04.1 LTS (GNU/Linux 5.15.0-60-generic x86_64)

Last login: Fri Feb 24 05:42:32 2023 from 188.127.184.59
root@server1:~#
</output_code>
  <markdown>Cambio la configuraci√≥n del proxy de mi ordenador

![proxy ssh](https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/proxy_ssh.webp)</markdown>
  <markdown>Vuelvo a ver mi `IP` p√∫blica, pero usando el proxy recientemente configurado</markdown>
  <input_code>!curl -x socks5h://localhost:9999 ifconfig.me</input_code>
  <output_code>194.62.99.222</output_code>
  <markdown>Vemos que obtenemos la IP p√∫blica del servidor</markdown>
  <markdown>### Tunel SSH</markdown>
  <markdown>Si como antes quiero crear un t√∫nel hasta el `server2` a trav√©s del `server1`, antes ten√≠amos que hacer `ssh &amp;ltHOST PORT&amp;gt:&amp;ltDEST IP&amp;gt:&amp;ltTUNNEL PORT&amp;gt &amp;ltTUNNEL CREATOR USER&amp;gt@&amp;ltTUNNEL CREATOR IP&amp;gt`, ahora tenemos que a√±adir la l√≠nea

``` bash
LocalForward &amp;ltlocalhost&amp;gt:&amp;ltHOST PORT&amp;gt &amp;ltDEST IP&amp;gt:&amp;ltTUNNEL PORT&amp;gt
```</markdown>
  <markdown>Es decir, el archivo de configuraci√≥n quedar√≠a

```
Host tunelToServer2
    HostName 194.62.99.222
    User root
    LocalForward 127.0.0.1:2020 10.7.2.228:22
```</markdown>
  <markdown>Pero como as√≠ no se entiende muy bien ve√°moslo con algo concreto

 * `server1`:
   * `IP` p√∫blica: `194.62.99.222`
   * `IP` privada: `10.7.0.168`
 * `server2`:
   * `IP` p√∫blica: `194.62.99.235`
   * `IP` privada: `10.7.2.228`

Antes, el comando era

``` bash
ssh -L 2020:10.7.2.228:22 root@194.62.99.222
```

De modo que el archivo de configuraci√≥n tiene que quedar

```
Host tunelToServer2
    HostName 194.62.99.222
    User root
    LocalForward 127.0.0.1:2020 10.7.2.228:22
```

Veamos si funciona</markdown>
  <markdown>A√±adimos la nueva configuraci√≥n</markdown>
  <input_code>!echo "Host tunelToServer2\n    HostName 194.62.99.222\n    User root\n    LocalForward 127.0.0.1:2020 10.7.2.228:22" &gt;&gt; ~/.ssh/config</input_code>
  <markdown>Veamos c√≥mo ha quedado el archivo de configuraci√≥n</markdown>
  <input_code>!cat ~/.ssh/config</input_code>
  <output_code># Read more about SSH config files: https://linux.die.net/man/5/ssh_config
Host 192.168.1.138
    HostName 192.168.1.138
    User maximo.fernandez

Host server1
    HostName 194.62.99.222
    User root
Host proxyServer1
    HostName 194.62.99.222
    User root
    DynamicForward 9999
Host tunelToServer2
    HostName 194.62.99.222
    User root
    LocalForward 127.0.0.1:2020 10.7.2.228:22
</output_code>
  <markdown>Creamos el t√∫nel</markdown>
  <input_code>!ssh tunelToServer2 </input_code>
  <output_code>Welcome to Ubuntu 22.04.1 LTS (GNU/Linux 5.15.0-60-generic x86_64)

Last login: Fri Feb 24 06:02:20 2023 from 188.127.184.59
root@server1:~#
</output_code>
  <markdown>Ahora intentamos conectarnos al `server2` desde mi ordenador.</markdown>
  <input_code>!ssh -p 2020 root@localhost</input_code>
  <output_code>Welcome to Ubuntu 22.04.1 LTS (GNU/Linux 5.15.0-60-generic x86_64)

Last login: Fri Feb 24 06:02:36 2023 from 10.7.0.168
root@server2:~# 
</output_code>
  <markdown>¬°Conseguido! Pero podemos dejarlo un poco m√°s limpio todo, podemos a√±adir esta √∫ltima conexi√≥n al archivo de configuraci√≥n</markdown>
  <input_code>!echo "Host server2ByTunel\n    HostName localhost\n    User root\n    Port 2020" &gt;&gt; ~/.ssh/config</input_code>
  <markdown>Veamos c√≥mo queda el archivo de configuraci√≥n</markdown>
  <input_code>!cat ~/.ssh/config</input_code>
  <output_code># Read more about SSH config files: https://linux.die.net/man/5/ssh_config
Host 192.168.1.138
    HostName 192.168.1.138
    User maximo.fernandez

Host server1
    HostName 194.62.99.222
    User root
Host proxyServer1
    HostName 194.62.99.222
    User root
    DynamicForward 9999
Host tunelToServer2
    HostName 194.62.99.222
    User root
    LocalForward 127.0.0.1:2020 10.7.2.228:22
Host server2ByTunel
    HostName localhost
    User root
    Port 2020
</output_code>
  <markdown>Ahora nos volvemos a conectar al `server2` desde mi ordenador, a trav√©s del t√∫nel, pero con la √∫ltima configuraci√≥n que acabamos de guardar</markdown>
  <input_code>!ssh server2ByTunel </input_code>
  <output_code>Welcome to Ubuntu 22.04.1 LTS (GNU/Linux 5.15.0-60-generic x86_64)

Last login: Fri Feb 24 06:13:33 2023 from 10.7.0.168
root@server2:~# 
</output_code>
  <markdown>En resumen, con todo lo que hemos hecho, podemos crear el t√∫nel hasta el `server2` con el comando `ssh tunelToServer2` y a continuaci√≥n conectarnos al `server2` con el comando `ssh server2ByTunel`

¬°Impresionante!</markdown>
  <markdown>### Conexi√≥n reversa</markdown>
  <markdown>Recordamos que ahora nuestro problema era que no nos pod√≠amos conectar al `server2` a trav√©s del t√∫nel del `server1`. De modo que creando una conexi√≥n reversa desde el `server2` (tenemos alguien en el `server2` que puede hacer esa conexi√≥n reversa, o lo dejamos hecho nosotros antes de irnos) hasta un `server3`, desde mi ordenador me puedo conectar al `server3` y a continuaci√≥n conectarme al `server2`</markdown>
  <markdown>Primero tenemos que hacer la conexi√≥n reversa desde el `server2` al `server3`. Esto lo podr√≠amos hacer mediante un comando

``` bash
ssh -R &amp;ltserver3port&amp;gt:localhost:22 root@&amp;ltIPserver3&amp;gt
```

O guardar la conexi√≥n en el archivo de configuraci√≥n a√±adiendo

```
Host reverseToServer3
    HostName &amp;ltIPserver3&amp;gt
    User root
    RemoteForward &amp;ltserver3port&amp;gt localhost:22
```

Y hacer la conexi√≥n inversa mediante

``` bash
ssh reverseToServer3
```</markdown>
  <markdown>Como as√≠ no se entiende bien, ve√°moslo con datos concretos

 * `server2`:
   * `IP` p√∫blica: `194.62.99.235`
 * `server3`:
   * `IP` p√∫blica: `194.62.96.236`

Para hacer la conexi√≥n inversa habr√≠a que usar el comando

``` bash
ssh -R 2020:localhost:22 root@194.62.96.236
```

o guardar la siguiente configuraci√≥n

``` bash
Host reverseToServer3
    HostName 194.62.96.236
    User root
    RemoteForward 2020 localhost:22
```

Y conectarse mediante

``` bash
ssh reverseToServer3
```</markdown>
  <markdown>De modo que guardo la configuraci√≥n en el servidor 2 y hago la conexi√≥n</markdown>
  <input_code>!root@server2:~# echo "Host reverseToServer3\n    HostName 194.62.96.236\n    User root\n    RemoteForward 2020 localhost:22" &gt;&gt; ~/.ssh/config</input_code>
  <markdown>Veamos que se ha guardado bien</markdown>
  <input_code>!root@server2:~# cat .ssh/config</input_code>
  <output_code>
Host reverseToServer3
    HostName 194.62.96.236
    User root
    RemoteForward 2020 localhost:22
</output_code>
  <markdown>Hago la conexi√≥n inversa</markdown>
  <input_code>!root@server2:~# ssh reverseToServer3 </input_code>
  <output_code>Welcome to Ubuntu 22.04.1 LTS (GNU/Linux 5.15.0-53-generic x86_64)

Last login: Wed Feb 22 15:26:18 2023 from 194.62.99.235
root@server3:~# 
</output_code>
  <markdown>### Jump</markdown>
  <markdown>Como hemos dicho hac√≠amos saltos mediante el flag `-J`, de manera que con el comando `ssh -J root@194.62.99.222 root@10.7.2.228` pod√≠amos conectarnos al `server2`</markdown>
  <markdown>Para configurar el archivo de configuraci√≥n, hay dos opciones</markdown>
  <markdown>La primera es que como ya tenemos el `server1` guardado en el archivo de configuraci√≥n, solamente a√±adimos `server2`

``` bash
Host server2
    HostName 10.7.2.228
    User root
```

Y a continuaci√≥n nos podr√≠amos conectar mediante

``` bash
ssh -J server1 server2
```

Vamos a probarlo</markdown>
  <input_code>!echo "Host server2\n    HostName 10.7.2.228\n    User root\n" &gt;&gt; ~/.ssh/config</input_code>
  <markdown>Vemos el archivo de configuraci√≥n</markdown>
  <input_code>!cat ~/.ssh/config</input_code>
  <output_code># Read more about SSH config files: https://linux.die.net/man/5/ssh_config
Host 192.168.1.138
    HostName 192.168.1.138
    User maximo.fernandez

Host server1
    HostName 194.62.99.222
    User root
Host proxyServer1
    HostName 194.62.99.222
    User root
    DynamicForward 9999
Host tunelToServer2
    HostName 194.62.99.222
    User root
    LocalForward 127.0.0.1:2020 10.7.2.228:22
Host server2ByTunel
    HostName localhost
    User root
    Port 2020
Host server2
    HostName 10.7.2.228
    User root

</output_code>
  <markdown>Ahora nos conectamos mediante los saltos</markdown>
  <input_code>!ssh -J server1 server2</input_code>
  <output_code>Welcome to Ubuntu 22.04.1 LTS (GNU/Linux 5.15.0-60-generic x86_64)

Last login: Fri Feb 24 12:05:16 2023 from 10.7.0.168
root@server2:~#
</output_code>
  <markdown>Esta ha sido la primera opci√≥n: guardar cada servidor y establecer los saltos; pero una segunda opci√≥n es guardar todos los saltos en una sola configuraci√≥n, que quedar√≠a as√≠

``` bash
Host server2jumping
    HostName 10.7.2.228
    User root
    ProxyJump root@194.62.99.222
```

Y ya solo faltar√≠a conectarse mediante

```
ssh server2jumping
```

Vamos a probar</markdown>
  <input_code>!echo "Host server2jumping\n    HostName 10.7.2.228\n    User root\n    ProxyJump root@194.62.99.222" &gt;&gt; ~/.ssh/config</input_code>
  <markdown>Vamos a ver el archivo de configuraci√≥n</markdown>
  <input_code>!cat ~/.ssh/config</input_code>
  <output_code># Read more about SSH config files: https://linux.die.net/man/5/ssh_config
Host 192.168.1.138
    HostName 192.168.1.138
    User maximo.fernandez

Host server1
    HostName 194.62.99.222
    User root
Host proxyServer1
    HostName 194.62.99.222
    User root
    DynamicForward 9999
Host tunelToServer2
    HostName 194.62.99.222
    User root
    LocalForward 127.0.0.1:2020 10.7.2.228:22
Host server2ByTunel
    HostName localhost
    User root
    Port 2020
Host server2
    HostName 10.7.2.228
    User root
Host server2jumping
    HostName 10.7.2.228
    User root
    ProxyJump root@194.62.99.222
</output_code>
  <markdown>Ahora intentamos conectarnos</markdown>
  <input_code>!ssh server2jumping</input_code>
  <output_code>Welcome to Ubuntu 22.04.1 LTS (GNU/Linux 5.15.0-60-generic x86_64)

Last login: Fri Feb 24 12:06:22 2023 from 10.7.0.168
root@server2:~# 
</output_code>
  <markdown>## Archivo de configuraci√≥n `SSH` del sistema</markdown>
  <markdown>Antes vimos el archivo de configuraci√≥n de `SSH` del usuario, donde guardamos configuraciones de m√°quinas donde nos quer√≠amos conectar por `SSH`, pero hay otro archivo de configuraci√≥n de `SSH` pero en este caso del sistema, que se encuentra en `/etc/ssh/ssh_config`, vamos a verlo</markdown>
  <input_code>!cat /etc/ssh/sshd_config</input_code>
  <output_code>#	$OpenBSD: sshd_config,v 1.103 2018/04/09 20:41:22 tj Exp $

# This is the sshd server system-wide configuration file.  See
# sshd_config(5) for more information.

# This sshd was compiled with PATH=/usr/bin:/bin:/usr/sbin:/sbin

# The strategy used for options in the default sshd_config shipped with
# OpenSSH is to specify options with their default value where
# possible, but leave them commented.  Uncommented options override the
# default value.

Include /etc/ssh/sshd_config.d/*.conf

#Port 22
#AddressFamily any
#ListenAddress 0.0.0.0
#ListenAddress ::

#HostKey /etc/ssh/ssh_host_rsa_key
#HostKey /etc/ssh/ssh_host_ecdsa_key
#HostKey /etc/ssh/ssh_host_ed25519_key

# Ciphers and keying
#RekeyLimit default none

# Logging
#SyslogFacility AUTH
#LogLevel INFO

# Authentication:

#LoginGraceTime 2m
#PermitRootLogin prohibit-password
#StrictModes yes
#MaxAuthTries 6
#MaxSessions 10

#PubkeyAuthentication yes

# Expect .ssh/authorized_keys2 to be disregarded by default in future.
#AuthorizedKeysFile	.ssh/authorized_keys .ssh/authorized_keys2

#AuthorizedPrincipalsFile none

#AuthorizedKeysCommand none
#AuthorizedKeysCommandUser nobody

# For this to work you will also need host keys in /etc/ssh/ssh_known_hosts
#HostbasedAuthentication no
# Change to yes if you don't trust ~/.ssh/known_hosts for
# HostbasedAuthentication
#IgnoreUserKnownHosts no
# Don't read the user's ~/.rhosts and ~/.shosts files
#IgnoreRhosts yes

# To disable tunneled clear text passwords, change to no here!
#PasswordAuthentication yes
#PermitEmptyPasswords no

# Change to yes to enable challenge-response passwords (beware issues with
# some PAM modules and threads)
ChallengeResponseAuthentication no

# Kerberos options
#KerberosAuthentication no
#KerberosOrLocalPasswd yes
#KerberosTicketCleanup yes
#KerberosGetAFSToken no

# GSSAPI options
#GSSAPIAuthentication no
#GSSAPICleanupCredentials yes
#GSSAPIStrictAcceptorCheck yes
#GSSAPIKeyExchange no

# Set this to 'yes' to enable PAM authentication, account processing,
# and session processing. If this is enabled, PAM authentication will
# be allowed through the ChallengeResponseAuthentication and
# PasswordAuthentication.  Depending on your PAM configuration,
# PAM authentication via ChallengeResponseAuthentication may bypass
# the setting of "PermitRootLogin without-password".
# If you just want the PAM account and session checks to run without
# PAM authentication, then enable this but set PasswordAuthentication
# and ChallengeResponseAuthentication to 'no'.
UsePAM yes

#AllowAgentForwarding yes
#AllowTcpForwarding yes
#GatewayPorts no
X11Forwarding yes
#X11DisplayOffset 10
#X11UseLocalhost yes
#PermitTTY yes
PrintMotd no
#PrintLastLog yes
#TCPKeepAlive yes
#PermitUserEnvironment no
#Compression delayed
#ClientAliveInterval 0
#ClientAliveCountMax 3
#UseDNS no
#PidFile /var/run/sshd.pid
#MaxStartups 10:30:100
#PermitTunnel no
#ChrootDirectory none
#VersionAddendum none

# no default banner path
#Banner none

# Allow client to pass locale environment variables
AcceptEnv LANG LC_*

# override default of no subsystems
Subsystem	sftp	/usr/lib/openssh/sftp-server

# Example of overriding settings on a per-user basis
#Match User anoncvs
#	X11Forwarding no
#	AllowTcpForwarding no
#	PermitTTY no
#	ForceCommand cvs server
</output_code>
  <markdown>Con este archivo podemos cambiar la configuraci√≥n de c√≥mo funciona `SSH` en nuestro ordenador. Por ejemplo, podemos ver una l√≠nea comentada que pone

``` bash
#Port 22
```

Si la descomentamos y cambiamos el n√∫mero `SSH` dejar√° de ir por el puerto 22, que es su puerto por defecto, e ir√° por el n√∫mero de puerto que ah√≠ se especifique.</markdown>
  <markdown>## Copia de archivos por `SSH`</markdown>
  <markdown>Podemos copiar archivos por `SSH` mediante el comando `scp` (secure copy). Para ello, la sintaxis es

``` bash
scp &amp;ltpath local file&amp;gt &amp;ltuser&amp;gt@&amp;ltIP&amp;gt:&amp;ltpath to save&amp;gt
```

o

``` bash
scp &amp;ltuser&amp;gt@&amp;ltip&amp;gt:&amp;ltpath to remote file&amp;gt &amp;ltpath to save&amp;gt
```

De la primera forma se copia un archivo de nuestro ordenador a otro y, de la segunda, de otro al nuestro</markdown>
  <markdown>Por ejemplo, hagamos un `ls` del `server1`</markdown>
  <input_code>!ssh -t server1 "ls"</input_code>
  <output_code>snap
Connection to 194.62.99.222 closed.
</output_code>
  <markdown>Veamos ahora qu√© tenemos en local que le podamos pasar</markdown>
  <input_code>!ls</input_code>
  <output_code> 2021-02-11-Introduccion-a-Python.ipynb         html_files
 2021-04-23-Calculo-matricial-con-Numpy.ipynb   html.ipynb
 2021-06-15-Manejo-de-datos-con-Pandas.ipynb    introduccion_python
 2022-09-12-Introduccion-a-la-terminal.ipynb    mi_paquete_de_python
 2023-01-22-Docker.ipynb		        movies.csv
 2023-02-01-Bash-scripting.ipynb	        movies.dat
 2023-02-04-Blip-2.ipynb		        notebooks_translated
 2023-XX-XX-SSH.ipynb			        __pycache__
 california_housing_train.csv		        scripts_bash
 command-line-cheat-sheet.pdf		        ssh.ipynb
 CSS.ipynb				        test.ipynb
'Expresiones regulares.ipynb'
</output_code>
  <markdown>Vamos a enviar al servidor el archivo `html.ipynb` ya que ocupa poco</markdown>
  <input_code>!scp html.ipynb server1:/root/</input_code>
  <output_code>html.ipynb                                    100%   14KB 229.0KB/s   00:00    
</output_code>
  <markdown>Volvemos a ver qu√© hay dentro de `server1`</markdown>
  <input_code>!ssh -t server1 "ls"</input_code>
  <output_code>html.ipynb  snap
Connection to 194.62.99.222 closed.
</output_code>
  <markdown>Se ha copiado</markdown>
  <markdown>## Sincroniazci√≥n de archivos por `SSH`</markdown>
  <markdown>Lo malo del comando `scp` es que si en medio de la copia pasa algo y no se termina de copiar el archivo, cuando se vuelva a intentar hay que empezar desde cero, esto sobre todo es un problema con archivos muy grandes</markdown>
  <markdown>Para solucionar esto se puede usar `rsync`, la sintaxis es

``` bash
rsync --partial --progress --rsh=ssh &lt;path local file&gt; &lt;user&gt;@&lt;IP&gt;:&lt;path to save&gt;
```

o

``` bash
rsync --partial --progress --rsh=ssh &lt;user&gt;@&lt;ip&gt;:&lt;path to remote file&gt; &lt;path to save&gt;
```

Al igual que antes, de la primera forma se copia un archivo de nuestro ordenador a otro y de la segunda de otro al nuestro. El flag `--partial` es para indicar que se guarden archivos parcialmente copiados, es decir, que si se para la copia antes de que termine, lo que se haya copiado se mantenga. El flag `--progress` es para indicar que muestre el progreso de la copia. El flag `--rsh=ssh` es para indicar que la transferencia de archivos se haga por `SSH`</markdown>
  <markdown>Pasamos un archivo</markdown>
  <input_code>!rsync --partial --progress -rsh=ssh 2021-06-15-Manejo-de-datos-con-Pandas.ipynb  server1:/root/</input_code>
  <output_code>sending incremental file list
2021-06-15-Manejo-de-datos-con-Pandas.ipynb
        608.34K 100%  197.78MB/s    0:00:00 (xfr#1, to-chk=0/1)
</output_code>
  <markdown>Y vemos si se ha copiado</markdown>
  <input_code>!ssh -t server1 "ls"</input_code>
  <output_code>2021-06-15-Manejo-de-datos-con-Pandas.ipynb  html.ipynb  snap
Connection to 194.62.99.222 closed.
</output_code>
  <markdown>## Montar carpetas remotas en local</markdown>
  <markdown>En el caso que queramos tener una carpeta de otra m√°quina como si estuviese en nuestro ordenador tenemos que usar `sshfs`

Primero es necesario instalarlo mediante 

``` bash
sudo apt install sshfs
```

Y una vez est√© instalado, se usa con la sintaxis

``` bash
sshfs &amp;ltuser&amp;gt@&amp;ltip&amp;gt:&amp;ltremote path&amp;gt &amp;ltlocal path to mount&amp;gt
```</markdown>
  <markdown>Vamos a montar la carpeta `/root` del `server1`, pero para ello primero vamos a crear una carpeta en la que lo vamos a montar</markdown>
  <input_code>!mkdir server1folder</input_code>
  <markdown>Vemos que, dentro de la carpeta que hemos montado, no hay nada</markdown>
  <input_code>!ls server1folder</input_code>
  <markdown>Ahora montamos la carpeta del servidor</markdown>
  <input_code>!!sshfs server1:/root/ server1folder</input_code>
  <markdown>Volvemos a ver qu√© hay dentro</markdown>
  <input_code>!ls server1folder</input_code>
  <output_code>2021-06-15-Manejo-de-datos-con-Pandas.ipynb  html.ipynb  snap
</output_code>
  <markdown>Cuando ya no queramos tener m√°s la carpeta montada, la podemos desmontar mediante `fusermount -u server1folder`</markdown>
  <input_code>!!fusermount -u server1folder</input_code>
  <markdown>Volvemos a mirar qu√© hay dentro para ver si no hay nada</markdown>
  <input_code>!ls server1folder</input_code>
  <markdown>## Depurar la conexi√≥n `SSH`</markdown>
  <markdown>Podemos depurar la conexi√≥n `SSH` a√±adiendo desde `-v`, hasta `-vvvv` a la conexi√≥n, cuantas m√°s `v`s pongamos, mayor nivel de informaci√≥n</markdown>
  <input_code>!ssh -v server1</input_code>
  <output_code>OpenSSH_8.2p1 Ubuntu-4ubuntu0.5, OpenSSL 1.1.1f  31 Mar 2020
debug1: Reading configuration data /home/wallabot/.ssh/config
debug1: /home/wallabot/.ssh/config line 6: Applying options for server1
debug1: Reading configuration data /etc/ssh/ssh_config
debug1: /etc/ssh/ssh_config line 19: include /etc/ssh/ssh_config.d/*.conf matched no files
debug1: /etc/ssh/ssh_config line 21: Applying options for *
debug1: Connecting to 194.62.99.222 [194.62.99.222] port 22.
debug1: Connection established.
debug1: identity file /home/wallabot/.ssh/id_rsa type 0
debug1: identity file /home/wallabot/.ssh/id_rsa-cert type -1
debug1: identity file /home/wallabot/.ssh/id_dsa type -1
debug1: identity file /home/wallabot/.ssh/id_dsa-cert type -1
debug1: identity file /home/wallabot/.ssh/id_ecdsa type -1
debug1: identity file /home/wallabot/.ssh/id_ecdsa-cert type -1
debug1: identity file /home/wallabot/.ssh/id_ecdsa_sk type -1
debug1: identity file /home/wallabot/.ssh/id_ecdsa_sk-cert type -1
debug1: identity file /home/wallabot/.ssh/id_ed25519 type -1
debug1: identity file /home/wallabot/.ssh/id_ed25519-cert type -1
debug1: identity file /home/wallabot/.ssh/id_ed25519_sk type -1
debug1: identity file /home/wallabot/.ssh/id_ed25519_sk-cert type -1
debug1: identity file /home/wallabot/.ssh/id_xmss type -1
debug1: identity file /home/wallabot/.ssh/id_xmss-cert type -1
debug1: Local version string SSH-2.0-OpenSSH_8.2p1 Ubuntu-4ubuntu0.5
debug1: Remote protocol version 2.0, remote software version OpenSSH_8.9p1 Ubuntu-3
debug1: match: OpenSSH_8.9p1 Ubuntu-3 pat OpenSSH* compat 0x04000000
debug1: Authenticating to 194.62.99.222:22 as 'root'
debug1: SSH2_MSG_KEXINIT sent
debug1: SSH2_MSG_KEXINIT received
debug1: kex: algorithm: curve25519-sha256
debug1: kex: host key algorithm: ecdsa-sha2-nistp256
debug1: kex: server-&gt;client cipher: chacha20-poly1305@openssh.com MAC: &lt;implicit&gt; compression: none
debug1: kex: client-&gt;server cipher: chacha20-poly1305@openssh.com MAC: &lt;implicit&gt; compression: none
debug1: expecting SSH2_MSG_KEX_ECDH_REPLY
debug1: Server host key: ecdsa-sha2-nistp256 SHA256:jwpQt2a69LQcuvvYPPKL32bBwTi1Je/ZmUdr4zEiD1Y
debug1: Host '194.62.99.222' is known and matches the ECDSA host key.
debug1: Found key in /home/wallabot/.ssh/known_hosts:14
debug1: rekey out after 134217728 blocks
debug1: SSH2_MSG_NEWKEYS sent
debug1: expecting SSH2_MSG_NEWKEYS
debug1: SSH2_MSG_NEWKEYS received
debug1: rekey in after 134217728 blocks
debug1: Will attempt key: /home/wallabot/.ssh/id_rsa RSA SHA256:ID3HcrbyPBGjFx/qeiJK50eqihLGrpDVu02oRSyKGh4 agent
debug1: Will attempt key: wallabot@wallabot RSA SHA256:Qlq6hXbToInW+efEK666BFT26EeUSpBhzcqxTLrDBpQ agent
debug1: Will attempt key: /home/wallabot/.ssh/id_dsa 
debug1: Will attempt key: /home/wallabot/.ssh/id_ecdsa 
debug1: Will attempt key: /home/wallabot/.ssh/id_ecdsa_sk 
debug1: Will attempt key: /home/wallabot/.ssh/id_ed25519 
debug1: Will attempt key: /home/wallabot/.ssh/id_ed25519_sk 
debug1: Will attempt key: /home/wallabot/.ssh/id_xmss 
debug1: SSH2_MSG_EXT_INFO received
debug1: kex_input_ext_info: server-sig-algs=&lt;ssh-ed25519,sk-ssh-ed25519@openssh.com,ssh-rsa,rsa-sha2-256,rsa-sha2-512,ssh-dss,ecdsa-sha2-nistp256,ecdsa-sha2-nistp384,ecdsa-sha2-nistp521,sk-ecdsa-sha2-nistp256@openssh.com,webauthn-sk-ecdsa-sha2-nistp256@openssh.com&gt;
debug1: kex_input_ext_info: publickey-hostbound@openssh.com (unrecognised)
debug1: SSH2_MSG_SERVICE_ACCEPT received
debug1: Authentications that can continue: publickey
debug1: Next authentication method: publickey
debug1: Offering public key: /home/wallabot/.ssh/id_rsa RSA SHA256:ID3HcrbyPBGjFx/qeiJK50eqihLGrpDVu02oRSyKGh4 agent
debug1: Authentications that can continue: publickey
debug1: Offering public key: wallabot@wallabot RSA SHA256:Qlq6hXbToInW+efEK666BFT26EeUSpBhzcqxTLrDBpQ agent
debug1: Server accepts key: wallabot@wallabot RSA SHA256:Qlq6hXbToInW+efEK666BFT26EeUSpBhzcqxTLrDBpQ agent
debug1: Authentication succeeded (publickey).
Authenticated to 194.62.99.222 ([194.62.99.222]:22).
debug1: channel 0: new [client-session]
debug1: Requesting no-more-sessions@openssh.com
debug1: Entering interactive session.
debug1: pledge: network
debug1: client_input_global_request: rtype hostkeys-00@openssh.com want_reply 0
debug1: Remote: /root/.ssh/authorized_keys:1: key options: agent-forwarding port-forwarding pty user-rc x11-forwarding
debug1: Remote: /root/.ssh/authorized_keys:1: key options: agent-forwarding port-forwarding pty user-rc x11-forwarding
debug1: Sending environment.
debug1: Sending env LANG = es_ES.UTF-8
Welcome to Ubuntu 22.04.1 LTS (GNU/Linux 5.15.0-60-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Fri Feb 24 01:25:10 PM UTC 2023

  System load:           0.0
  Usage of /:            15.2% of 24.53GB
  Memory usage:          34%
  Swap usage:            0%
  Processes:             89
  Users logged in:       0
  IPv4 address for eth0: 194.62.99.222
  IPv4 address for eth1: 10.7.0.168
  IPv6 address for eth2: 2a04:3542:8000:1000:d48a:cbff:fefb:5b1

 * Strictly confined Kubernetes makes edge and IoT secure. Learn how MicroK8s
   just raised the bar for easy, resilient and secure K8s cluster deployment.

   https://ubuntu.com/engage/secure-kubernetes-at-the-edge

43 updates can be applied immediately.
To see these additional updates run: apt list --upgradable


Last login: Fri Feb 24 13:10:05 2023 from 188.127.184.59
[?2004h]0;root@server1: ~[01;32mroot@server1[00m:[01;34m~[00m# ^C[?2004l
[?2004l
[?2004h]0;root@server1: ~[01;32mroot@server1[00m:[01;34m~[00m# </output_code>
</notebook>