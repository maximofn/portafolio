<?xml version='1.0' encoding='utf-8'?>
<notebook>
  <markdown># Git</markdown>
  <markdown>## Introducci√≥n</markdown>
  <markdown>Git es un software de control de versiones creado por Linus Torvalds, quien lo cre√≥ para poder tener un buen control de versiones cuando desarroll√≥ el kernel de Linux.</markdown>
  <markdown>## Las √°reas de git</markdown>
  <markdown>Git tiene tres √°reas, aunque tambi√©n se puede considerar una cuarta.

![git states](https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/git-states.webp)

 * La primera es nuestro espacio de trabajo, en √©l es donde tenemos todo nuestro c√≥digo. Aqu√≠ cuando modificamos o creamos un archivo este pasa a estar como no trackeado, por lo que tenemos que pasarlo al √°rea de `staged`
 * La segunda √°rea es la de `staged`. Aqu√≠ los archivos que hab√≠amos modificado o creado y que estaban no *trackeados* pasan a estar trackeados, es decir, git les hace un seguimiento. Aqu√≠ mandaremos los archivos al siguiente √°rea de `head`
 * La tercera √°rea es la de `head`. En ella hemos grabado una versi√≥n de nuestro c√≥digo. De esta manera, grabando versiones podemos volver a versiones pasadas si es necesario. La versi√≥n grabada de nuestro c√≥digo puede ser mandada a un servidor de manera que sea accesible por varias personas
 * Las tres √°reas anteriores corresponden al trabajo en local, pero hay una √°rea m√°s y es la de `remote server`. Aqu√≠ lo que hacemos es mandar la versi√≥n grabada de nuestro c√≥digo a un servidor de manera que tengamos acceso al c√≥digo desde cualquier lugar, o que tenga acceso m√°s personas

Para hacer un s√≠mil, es como un escenario en el que vas a hacer una foto. Primero tienes tus archivos modificados, de manera que los que quieres inmortalizar los mandas al √°rea de `staged`, es decir al escenario. En el momento que has mandado todos los archivos que consideras, haces la foto, por lo que mandas todos los archivos al √°rea de `head`. De esta manera, puedes ir haciendo muchas fotos, seg√∫n va evolucionando el c√≥digo, de manera que puedes tener en un √°lbum de fotos la evoluci√≥n del c√≥digo. Por √∫ltimo puedes subir esa foto a un servidor para que sea accesible por m√°s gente, es decir, los mandas al √°rea de `remote server`</markdown>
  <markdown>## Instalar git</markdown>
  <markdown>En la mayor√≠a de distribuciones Linux git ya viene instalado, podemos comprobarlo haciendo `git --version`</markdown>
  <input_code>!git --version</input_code>
  <output_code>git version 2.25.1
</output_code>
  <markdown>Si no lo tienes o quieres actualizar la versi√≥n de git solo tienes que ejecutar `sudo apt update` y a continuaci√≥n `sudo apt install git`</markdown>
  <input_code>!sudo apt update &amp;&amp; sudo apt install git</input_code>
  <output_code>[sudo] password for maximo.fernandez@AEROESPACIAL.SENER: 
</output_code>
  <markdown>Volvemos a comprobar la versi√≥n</markdown>
  <input_code>!git --version</input_code>
  <output_code>git version 2.25.1
</output_code>
  <markdown>En mi caso ya ten√≠a la √∫ltima versi√≥n</markdown>
  <markdown>## Configuraci√≥n inicial</markdown>
  <markdown>### Configuraci√≥n del nombre y el correo</markdown>
  <markdown>Antes de empezar a usar git es conveniente que hagas unas configuraciones m√≠nimas como el nombre de usuario y el correo, esta informaci√≥n es la que saldr√° a la hora de mostrar qui√©n ha hecho cambios en el c√≥digo. Para hacer esto hay que ejecutar


```bash
git config --global user.name "&lt;nombre de usuario&gt;"
git config --global user.email "&lt;email&gt;"
```

En mi caso meter√≠a

```bash
git config --global user.name "MaximoFN"
git config --global user.email "maximofn@gmail.com
```</markdown>
  <markdown>Como se puede ver el flag `--global` lo que hace es cambiar la configuraci√≥n global de git, pero si en un repositorio en concreto tienes que poner otros datos, simplemente navegas hasta el repositorio y quita el flag `--global` de los comandos anteriores

```bash
git config user.name "&lt;nombre de usuario&gt;"
git config user.email "&lt;email&gt;"
```</markdown>
  <markdown>### Configurar el editor por defecto</markdown>
  <markdown>Cuando m√°s adelante expliquemos qu√© son los `commit`s veremos que en una de las opciones se nos puede abrir un navegador. Por defecto git intentar√° usar `vim`, pero dado que no es un editor muy sencillo de usar, podemos modificarlo. A continuaci√≥n se muestra c√≥mo hacerlo con algunos editores comunes

```bash
git config --global core.editor "code"  # vscode como editor
git config --global core.editor "atom"  # Atom como editor
git config --global core.editor "subl"  # Sublime text como editor
git config --global core.editor "nano"  # Nano como editor
```</markdown>
  <markdown>### Comprobar configuraci√≥n de git</markdown>
  <markdown>Para revisar la configuraci√≥n de git podemos usar `git config --list`</markdown>
  <input_code>!git config --list</input_code>
  <output_code>user.name=maximofn
user.email=maximofn@gmail.com
user.user=maximofn
http.sslverify=true
core.repositoryformatversion=0
core.filemode=true
core.bare=false
core.logallrefupdates=true
remote.origin.url=https://github.com/maximofn/portafolio.git
remote.origin.fetch=+refs/heads/*:refs/remotes/origin/*
branch.main.remote=origin
branch.main.merge=refs/heads/main
</output_code>
  <markdown>Podemos usar los flags `--global`, `--local` y `--system` para ver solo la configuraci√≥n global, local (si existe) y de sistema (si existe)</markdown>
  <input_code>!git config --global --list</input_code>
  <output_code>user.name=maximofn
user.email=maximofn@gmail.com
user.user=maximofn
http.sslverify=true
</output_code>
  <input_code>!git config --local --list</input_code>
  <output_code>core.repositoryformatversion=0
core.filemode=true
core.bare=false
core.logallrefupdates=true
remote.origin.url=https://github.com/maximofn/portafolio.git
remote.origin.fetch=+refs/heads/*:refs/remotes/origin/*
branch.main.remote=origin
branch.main.merge=refs/heads/main
</output_code>
  <input_code>!git config --system --list</input_code>
  <output_code>fatal: unable to read config file '/etc/gitconfig': No such file or directory
</output_code>
  <markdown>En mi caso no existe configuraci√≥n de sistema</markdown>
  <markdown>Si se quiere saber solo el valor de un par√°metro de la configuraci√≥n valdr√≠a con introducir `git config &lt;parameter&gt;`</markdown>
  <input_code>!git config user.name</input_code>
  <output_code>maximofn
</output_code>
  <markdown>## Control de versiones de manera local</markdown>
  <markdown>### Inicializar un nuevo repositorio (`git init`)</markdown>
  <markdown>Hay dos maneras de inicializar un nuevo repositorio haciendo
 * Una es haciendo `git init &lt;nombre repositorio&gt;`. Esto crear√° una nueva carpeta con el nombre del repositorio
 * Otra es navegando a la carpeta donde queramos crear un repositorio y haciendo `git init`

Voy a crear un nuevo repositorio</markdown>
  <input_code>!git init notebook_git</input_code>
  <output_code>Inicializado repositorio Git vac√≠o en /home/wallabot/Documentos/web/portafolio/posts/notebook_git/.git/
</output_code>
  <markdown>Si ahora hacemos `ls` veremos que se ha creado una nueva carpeta llamada `notebook_git`</markdown>
  <input_code>!ls | grep notebook_git</input_code>
  <output_code>notebook_git
</output_code>
  <markdown>Nos movemos a ella</markdown>
  <input_code>!cd notebook_git</input_code>
  <markdown>Ahora dentro de la carpeta tenemos dos maneras de saber que se ha creado el repositorio, una haciendo `ls -a` que mostrar√° todos los archivos y veremos que hay una carpeta llamada `.git`. La otra manera es haciendo `git status` que nos dir√° el estado del repositorio</markdown>
  <input_code>!cd notebook_git &amp;&amp; ls -a</input_code>
  <output_code>.  ..  .git
</output_code>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama master

No hay commits todav√≠a

no hay nada para confirmar (crea/copia archivos y usa "git add" para hacerles seguimiento)
</output_code>
  <markdown>Como estamos en un notebook, cada celda tiene su `path` en el `path` del notebook, por eso las dos veces he tenido que hacer `cd notebook_git &amp;&amp;`, para que cambie a la carpeta con el repositorio que acabamos de crear.</markdown>
  <markdown>Si ahora pruebo `git status` en otro `path` donde no se haya inicializado un repositorio nos dar√° un error</markdown>
  <input_code>!cd ~/ &amp;&amp; git status</input_code>
  <output_code>fatal: no es un repositorio git (ni ninguno de los directorios superiores): .git
</output_code>
  <markdown>### Crear nuevos archivos</markdown>
  <markdown>En el momento en que hemos inicializado un repositorio podemos empezar a crear nuevos archivos, as√≠ que creamos uno y vemos qu√© ocurre</markdown>
  <input_code>!cd notebook_git &amp;&amp; echo "print('Hello World')" &gt; hello.py</input_code>
  <markdown>Si ahora volvemos a hacer `git status` vemos que nos aparece</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama master

No hay commits todav√≠a

Archivos sin seguimiento:
  (usa "git add &lt;archivo&gt;..." para incluirlo a lo que se ser√° confirmado)
	[31mhello.py[m

no hay nada agregado al commit pero hay archivos sin seguimiento presentes (usa "git add" para hacerles seguimiento)
</output_code>
  <markdown>Como se puede ver ahora nos est√° diciendo que el archivo `hello.py` no tiene seguimiento. Es decir, tenemos que a√±adir `hello.py` al √°rea de `staged`, que recordemos era como el escenario donde √≠bamos a poner todo lo que m√°s tarde le haremos una foto</markdown>
  <markdown>### Deshacer la creaci√≥n de un archivo nuevo</markdown>
  <markdown>En este caso, como son archivos que git a√∫n no est√° siguiendo, es decir, que a√∫n no est√°n en el √°rea de `staged` tendr√≠amos tres maneras de hacerlo</markdown>
  <markdown> * Borr√°ndolo simplemente: Como git a√∫n no sigue el archivo podr√≠amos hacer `rm hello.py` y listo
 * Borr√°ndolo mediante un comando de Git: Antes hemos borrado con `rm`, pero es posible que est√©s en un sistema que no tenga el comando `rm`. Por lo que, en ese caso, se puede usar el comando de Git `git rm hello.py`
 * Por √∫ltimo, podemos usar `git clean`. Este es √∫til, por ejemplo, cuando hay muchos archivos nuevos, y as√≠, en un solo comando, eliminamos todos.</markdown>
  <markdown>#### `git clean`</markdown>
  <markdown>Si ejecutamos `git clean` a secas, nos dar√° un error</markdown>
  <input_code>!cd notebook_git &amp;&amp; git clean</input_code>
  <output_code>fatal: clean.requireForce default en true y ninguno de -i, -n, ni -f entregado; rehusando el clean
</output_code>
  <markdown>Nos est√° diciendo que hace falta a√±adir uno de estos flags `-n`, `-i` o `-f`. Adem√°s vamos a ver el flag `-d`

 * `-n` (dry run): Nos dir√° qu√© archivos se van a borrar, pero no los borrar√°
 * `-i`: Nos preguntar√° por cada archivo que se va a borrar
 * `-f`: Forzar√° el borrado de los archivos
 * `-d`: Tambi√©n borrar√° carpetas</markdown>
  <markdown>Vamos a probarlo, primero hacemos `git clean -n` para saber qu√© archivos se borrar√≠an</markdown>
  <input_code>!cd notebook_git &amp;&amp; git clean -n</input_code>
  <output_code>Ser√° borrado hello.py
</output_code>
  <markdown>Ahora hacemos `git clean -f` para que lo borrar, ya que estamos de acuerdo en que lo borre</markdown>
  <input_code>!cd notebook_git &amp;&amp; git clean -f</input_code>
  <output_code>Borrando hello.py
</output_code>
  <markdown>Como vemos ha borrado `hello.py`</markdown>
  <markdown>### A√±adir un archivo al √°rea de staged (`git add`)</markdown>
  <markdown>Volvemos a crear un archivo</markdown>
  <input_code>!cd notebook_git &amp;&amp; echo "print('Hola mundo')" &gt; hola.py</input_code>
  <markdown>Volvemos a hacer un `git status` para comprobar que tenemos el archivo</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama master

No hay commits todav√≠a

Archivos sin seguimiento:
  (usa "git add &lt;archivo&gt;..." para incluirlo a lo que se ser√° confirmado)
	[31mhola.py[m

no hay nada agregado al commit pero hay archivos sin seguimiento presentes (usa "git add" para hacerles seguimiento)
</output_code>
  <markdown>Vemos que tenemos el archivo `hola.py` pero que git no le est√° haciendo un seguimiento. Adem√°s vemos que nos ayuda y nos dice `usa "git add" para hacerles seguimiento`

La sintaxis es la siguiente `git add &lt;archivo&gt;`, pero podemos hacerlo de varias maneras

 * Si queremos a√±adir m√°s de un archivo lo podemos hacer poniendo todos los archivos que queremos a√±adir al √°rea de staged, separados por un espacio: `git add &lt;archivo1&gt; &lt;archivo2&gt; &lt;archivo3&gt;`
 * Si queremos a√±adir todos los archivos de un mismo formato, por ejemplo, si queremos a√±adir todos los archivos de Python ser√≠a `git add *.py`
 * Si queremos a√±adir todos los archivos de una carpeta `git add &lt;folder&gt;/`
 * Si queremos a√±adir todos los archivos tenemos tres maneras: `git add --all`, `git add -A` o `git add .`</markdown>
  <markdown>Vamos a a√±adir el nuevo archivo creado</markdown>
  <input_code>!cd notebook_git &amp;&amp; git add hola.py</input_code>
  <markdown>Hacemos un `git status` para ver qu√© ha pasado</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama master

No hay commits todav√≠a

Cambios a ser confirmados:
  (usa "git rm --cached &lt;archivo&gt;..." para sacar del √°rea de stage)
	[32mnuevos archivos: hola.py[m

</output_code>
  <markdown>Como vemos, nos dice que tenemos un nuevo archivo al que le hace seguimiento y que est√° pendiente de ser confirmado `hola.py`</markdown>
  <markdown>### Sacar un archivo del √°rea de staged (`git reset`)</markdown>
  <markdown>En caso de que a√±adamos un archivo al √°rea de staged y lo queramos sacar, tenemos que usar `git reset &lt;archivo&gt;`, vamos a verlo</markdown>
  <markdown>Creamos y a√±adimos al √°rea de stage un nuevo archivo</markdown>
  <input_code>!cd notebook_git &amp;&amp; echo "print('Este no')" &gt; adios.py &amp;&amp; git add adios.py</input_code>
  <markdown>Hacemos `git status` para comprobar que est√° en el √°rea de stage</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama master

No hay commits todav√≠a

Cambios a ser confirmados:
  (usa "git rm --cached &lt;archivo&gt;..." para sacar del √°rea de stage)
	[32mnuevos archivos: adios.py[m
	[32mnuevos archivos: hola.py[m

</output_code>
  <markdown>Como vemos, est√°n `hola.py` y `adios.py`, as√≠ que usamos `git reset adios.py` para sacarlo del √°rea de staged</markdown>
  <input_code>!cd notebook_git &amp;&amp; git reset adios.py</input_code>
  <markdown>Hacemos un `git status` para comprobar que ha salido</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama master

No hay commits todav√≠a

Cambios a ser confirmados:
  (usa "git rm --cached &lt;archivo&gt;..." para sacar del √°rea de stage)
	[32mnuevos archivos: hola.py[m

Archivos sin seguimiento:
  (usa "git add &lt;archivo&gt;..." para incluirlo a lo que se ser√° confirmado)
	[31madios.py[m

</output_code>
  <markdown>Podemos ver que `adios.py` ya no tiene seguimiento por parte de git, lo ha sacado del √°rea de stage</markdown>
  <markdown>Hacemos `git clean -f` para borrarlo</markdown>
  <input_code>!cd notebook_git &amp;&amp; git clean -f &amp;&amp; git status</input_code>
  <output_code>Borrando adios.py
En la rama master

No hay commits todav√≠a

Cambios a ser confirmados:
  (usa "git rm --cached &lt;archivo&gt;..." para sacar del √°rea de stage)
	[32mnuevos archivos: hola.py[m

</output_code>
  <markdown>### Commit (`git commit`)</markdown>
  <markdown>Si volvemos al s√≠mil en el que dijimos que el √°rea de staged era el escenario donde mand√°bamos los archivos a los que quer√≠amos hacerles la foto, ahora toca hacer la foto para inmortalizar el estado actual. Esto es hacer un `commit`

De esta manera se registra el estado actual del c√≥digo, as√≠, con cada commit, se ir√° teniendo un registro de la evoluci√≥n del c√≥digo. Al igual que con un √°lbum de fotos, con cada foto vamos teniendo un registro de la evoluci√≥n de lo que ponemos en el escenario.</markdown>
  <markdown>Como a la hora de hacer el commit se est√° registrando el cambio del c√≥digo, git no nos deja hacer el commit si no hacemos un m√≠nimo comentario. Por lo que hay dos maneras de hacer commit

 * `git commit` de esta manera se abrir√° el editor que hayamos establecido en la configuraci√≥n de git. Si no hemos configurado un editor por defecto, se abrir√° `vi`. Si queremos cambiar la configuraci√≥n del editor podemos hacer por ejemplo `git config --global core.editor "code"` o `git config core.editor "code"` para establecer vscode como el editor por defecto de manera global o local.
 * `git commit -m "Mensaje de commit"`. De esta manera a√±adimos el mensaje directamente

Al hacer el commit de la primera forma podemos tener una primera l√≠nea que ser√° el t√≠tulo del commit y varias l√≠neas m√°s donde se explica en m√°s detalle. Si queremos poder hacer esto con el flag `-m` bastar√° con a√±adir varios flags `-m` seguidos: `git commit -m "Titulo del commit" -m "Primera linea explicando m√°s" -m "Segunda linea explicando m√°s"`</markdown>
  <markdown>Una vez hemos hecho el commit, esto guardar√° un registro del cambio de nuestro repositorio de manera local. Aun no hemos conectado con un servidor remoto</markdown>
  <markdown>Vamos a probar a hacer el commit</markdown>
  <input_code>!cd notebook_git &amp;&amp; git commit -m "Primer commit, hola.py"</input_code>
  <output_code>[master (commit-ra√≠z) 1c95e4f] Primer commit, hola.py
 1 file changed, 1 insertion(+)
 create mode 100644 hola.py
</output_code>
  <markdown>Hacemos un `git status`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama master
nada para hacer commit, el √°rbol de trabajo est√° limpio
</output_code>
  <markdown>Vemos que nos dice que no hay nada nuevo, tenemos todo nuestro repositorio totalmente controlado</markdown>
  <markdown>#### Commit saltandonos add (`git commit -a -m` o `git commit -am`)</markdown>
  <markdown>En el caso en el que todos los archivos que hayamos modificados los queramos llevar al √°rea de staged y luego hacerles un commit, podemos hacer todo esto en un solo paso mediante `git commit -a -m "mensaje"`, `git commit --all -m "mensaje"` o `git commit -am "mensaje"`

 &gt; Nota: Esto solo es v√°lido si se modifica un archivo. Si el archivo es nuevo y git no le hace seguimiento, esto no es v√°lido

Veamos un ejemplo, vamos a modificar `hola.py`</markdown>
  <input_code>!cd notebook_git &amp;&amp; echo "print('He a√±adido una nueva linea')" &gt;&gt; hola.py</input_code>
  <markdown>Vamos a hacer un `git status` para asegurarnos</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama master
Cambios no rastreados para el commit:
  (usa "git add &lt;archivo&gt;..." para actualizar lo que ser√° confirmado)
  (usa "git restore &lt;archivo&gt;..." para descartar los cambios en el directorio de trabajo)
	[31mmodificados:     hola.py[m

sin cambios agregados al commit (usa "git add" y/o "git commit -a")
</output_code>
  <markdown>Podemos ver que en la propia ayuda de git ya nos sugiere usar `git commit -a`, as√≠ que vamos a hacerlo</markdown>
  <input_code>!cd notebook_git &amp;&amp; git commit -am "Segundo commit, hola.py"</input_code>
  <output_code>[master 6e99e73] Segundo commit, hola.py
 1 file changed, 1 insertion(+)
</output_code>
  <markdown>Volvemos a hacer un `git status`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama master
nada para hacer commit, el √°rbol de trabajo est√° limpio
</output_code>
  <markdown>No hay nada para hacer commit, ya se ha hecho el commit del cambio</markdown>
  <markdown>### Modificar un archivo al que se le hab√≠a hecho commit</markdown>
  <markdown>Como mientras desarrollamos estamos modificando archivos, puede que en algun archivo al que ya le hab√≠amos hecho commit lo modifiquemos. En nuestro caso vamos a a√±adir una l√≠nea a `hola.py`</markdown>
  <input_code>!cd notebook_git &amp;&amp; echo "print('He a√±adido una tercera linea')" &gt;&gt; hola.py</input_code>
  <input_code>!cd notebook_git &amp;&amp; cat hola.py</input_code>
  <output_code>print('Hola mundo')
print('He a√±adido una nueva linea')
print('He a√±adido una tercera linea')
</output_code>
  <markdown>Si hacemos `git status` veremos que `hola.py` tiene modificaciones</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama master
Cambios no rastreados para el commit:
  (usa "git add &lt;archivo&gt;..." para actualizar lo que ser√° confirmado)
  (usa "git restore &lt;archivo&gt;..." para descartar los cambios en el directorio de trabajo)
	[31mmodificados:     hola.py[m

sin cambios agregados al commit (usa "git add" y/o "git commit -a")
</output_code>
  <markdown>### Ver cambios en un archivo (`git diff &lt;archivo&gt;`)</markdown>
  <markdown>Puede que llevemos un tiempo desarrollando desde el √∫ltimo commit y no sepamos qu√© modificaciones hemos hecho, para ello usamos `git diff &lt;archivo&gt;` que nos dir√° los cambios que hemos hecho</markdown>
  <input_code>!cd notebook_git &amp;&amp; git diff hola.py</input_code>
  <output_code>[1mdiff --git a/hola.py b/hola.py[m
[1mindex 91dee80..fba0d22 100644[m
[1m--- a/hola.py[m
[1m+++ b/hola.py[m
[36m@@ -1,2 +1,3 @@[m
 print('Hola mundo')[m
 print('He a√±adido una nueva linea')[m
[32m+[m[32mprint('He a√±adido una tercera linea')[m
</output_code>
  <markdown>Aunque no es muy intuitivo podemos ver que hemos a√±adido la √∫ltima l√≠nea en `hola.py`</markdown>
  <markdown>### Deshacer modificaciones en un archivo (`git restore &lt;archivo&gt;`)</markdown>
  <markdown>Si los cambios que hemos hecho no nos gustan y los queremos quitar lo que podemos hacer es `git restore &lt;archivo&gt;`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git restore hola.py</input_code>
  <markdown>Veamos qu√© ha pasado con un `git status`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama master
nada para hacer commit, el √°rbol de trabajo est√° limpio
</output_code>
  <markdown>Vemos que se han descartado los cambios en `hola.py` desde el √∫ltimo commit</markdown>
  <markdown>### Hist√≥rico de cambios (`git log`)</markdown>
  <markdown>Con git podemos ver el historial de todos los cambios que hemos ido commiteando, para ello usamos `git log`. Es como si nos pusi√©ramos a revisar nuestro √°lbum de fotos</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log</input_code>
  <output_code>[33mcommit 6e99e73cf0c5474078cc9f328ee6a54fb9ffb169[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmaster[m[33m)[m
Author: maximofn &lt;maximofn@gmail.com&gt;
Date:   Sun Apr 16 02:29:04 2023 +0200

    Segundo commit, hola.py

[33mcommit 1c95e4fd8388ceedee368e0121c4b0ef4900c2ac[m
Author: maximofn &lt;maximofn@gmail.com&gt;
Date:   Sun Apr 16 02:28:44 2023 +0200

    Primer commit, hola.py
</output_code>
  <markdown>Podemos ver el historial de cambios, hay que leerlo de abajo hacia arriba.

Primero vemos el commit con mensaje `Primer commit, hola.py`, podemos ver la fecha, el autor y el hash, que es su identificador √∫nico

A continuaci√≥n vemos el segundo commit con mensaje `Segundo commit, hola.py`, con su fecha, autor y hash. Adem√°s, nos muestra d√≥nde est√° el `HEAD` y en qu√© rama estamos</markdown>
  <markdown>Si usamos flags podemos obtener la informaci√≥n de distintas maneras, pero en funci√≥n de qu√© flags usemos puede que nos venga mejor. A continuaci√≥n se muestran algunos flags √∫tiles:

 * `git log --oneline`: Muestra los commits en una sola l√≠nea, con el hash abreviado y el mensaje del commit.
 * `git log --graph`: Muestra un gr√°fico de texto de la historia del repositorio, incluyendo ramas y fusiones.
 * `git log --decorate`: Muestra las referencias (ramas, etiquetas, HEAD, etc.) en el log junto con el commit al que apuntan.
 * `git log --author="&lt;autor&gt;"`: Filtra el historial de commits para mostrar solo aquellos realizados por un autor espec√≠fico.
 * `git log --since="&lt;fecha&gt;"`: Muestra los commits realizados desde una fecha espec√≠fica. Puedes usar diferentes formatos de fecha, como "1 week ago" o "2023-01-01".
 * `git log --until="&lt;fecha&gt;"`: Muestra los commits realizados hasta una fecha espec√≠fica.
 * `git log &lt;rama&gt;`: Muestra los commits de una rama espec√≠fica.
 * `git log &lt;commit1&gt;..&lt;commit2&gt;`: Muestra los commits que est√°n en el rango entre dos commits espec√≠ficos.
 * `git log --grep="&lt;palabra&gt;"`: Busca en los mensajes de commit por una palabra o frase espec√≠fica.
 * `git log -p`: Muestra las diferencias (en forma de parche) introducidas en cada commit.
 * `git log -n &lt;n√∫mero&gt;`: Muestra los √∫ltimos n√∫mero de commits. Por ejemplo, git log -n 5 mostrar√° los √∫ltimos 5 commits.
 * `git log --stat`: Muestra las estad√≠sticas de cambios en archivos para cada commit, como el n√∫mero de l√≠neas a√±adidas y eliminadas.

Por ejemplo una manera c√≥moda de ver el hist√≥rico es usar `git log --graph --oneline --decorate`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>* [33m6e99e73[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmaster[m[33m)[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Podemos ver que en vez de darnos el hash entero nos da solo unos pocos n√∫meros, esto es porque de momento el repositorio tiene tan poca historia, que con esos pocos n√∫meros es suficiente, si quisi√©semos volver al punto anterior, en vez de introducir el hash entero (`7c448f69e30ab1b5783f5cf9ee3ae5bc362ecd4d`), con introducir solo `7c448f6` valdr√≠a</markdown>
  <markdown>M√°s adelante hablaremos sobre las ramas, pero ahora vamos a ver qu√© es el `HEAD`</markdown>
  <markdown>### HEAD</markdown>
  <markdown>Mientras desarroll√°bamos hemos podido hacer cambios y commitearlos, es decir, hemos ido rellenando el album de fotos de nuestro c√≥digo. `HEAD` es la posici√≥n en el album en la que estamos.

Normalmente es la √∫ltima posici√≥n de todos los commits.</markdown>
  <markdown>Si queremos saber en qu√© punto estamos lo podemos hacer mediante `git rev-parse HEAD`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git rev-parse HEAD</input_code>
  <output_code>6e99e73cf0c5474078cc9f328ee6a54fb9ffb169
</output_code>
  <markdown>Como se puede ver, el hash obtenido coincide con el √∫ltimo obtenido al hacer `git log`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log</input_code>
  <output_code>[33mcommit 6e99e73cf0c5474078cc9f328ee6a54fb9ffb169[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmaster[m[33m)[m
Author: maximofn &lt;maximofn@gmail.com&gt;
Date:   Sun Apr 16 02:29:04 2023 +0200

    Segundo commit, hola.py

[33mcommit 1c95e4fd8388ceedee368e0121c4b0ef4900c2ac[m
Author: maximofn &lt;maximofn@gmail.com&gt;
Date:   Sun Apr 16 02:28:44 2023 +0200

    Primer commit, hola.py
</output_code>
  <markdown>### Modificar un commit (`git commit --amend`)</markdown>
  <markdown>Puede que queramos modificar un commit, porque queramos cambiar el mensaje, o porque queramos a√±adir m√°s archivos al commit, de modo que veremos los dos casos</markdown>
  <markdown>#### Modificar el mensaje de commit </markdown>
  <markdown>Si solo se quiere modificar el mensaje, lo que tenemos que hacer es `git commit --amend -m "Nuevo mensaje"`, veamos un ejemplo vamos a modificar `hola.py`</markdown>
  <input_code>!cd notebook_git &amp;&amp; echo "print('Esta es la tercera linea')" &gt;&gt; hola.py</input_code>
  <markdown>Hacemos un `git status`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama master
Cambios no rastreados para el commit:
  (usa "git add &lt;archivo&gt;..." para actualizar lo que ser√° confirmado)
  (usa "git restore &lt;archivo&gt;..." para descartar los cambios en el directorio de trabajo)
	[31mmodificados:     hola.py[m

sin cambios agregados al commit (usa "git add" y/o "git commit -a")
</output_code>
  <markdown>Efectivamente vemos que `hola.py` tiene modificaciones, de modo que hacemos un commit con estas modificaciones</markdown>
  <input_code>!cd notebook_git &amp;&amp; git commit -am "Tercer commot, hola.py"</input_code>
  <output_code>[master 60e2ffd] Tercer commot, hola.py
 1 file changed, 1 insertion(+)
</output_code>
  <markdown>Vamos a ver el historial de commits</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>* [33m60e2ffd[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmaster[m[33m)[m Tercer commot, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>**Oh no!** hemos escrito `commot` en vez de `commit`, as√≠ que vamos a modificar el mensaje</markdown>
  <input_code>!cd notebook_git &amp;&amp; git commit --amend -m "Tercer commit, hola.py"</input_code>
  <output_code>[master c4930d7] Tercer commit, hola.py
 Date: Sun Apr 16 02:29:59 2023 +0200
 1 file changed, 1 insertion(+)
</output_code>
  <markdown>Volvemos a ver el hostorial</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>* [33mc4930d7[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmaster[m[33m)[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Vemos que ahora est√° bien</markdown>
  <markdown>#### A√±adir archivos al √∫ltimo commit</markdown>
  <markdown>Supongamos que se nos ha olvidado a√±adir un archivo al √∫ltimo commit, simplemente hacemos un `git add` con ese archivo y hacemos `git commit --amend -m "mensaje"`</markdown>
  <markdown>Vamos a crear dos archivos nuevos</markdown>
  <input_code>!cd notebook_git &amp;&amp; echo "print('Este es el archivo 1')" &gt; archivo1.py</input_code>
  <input_code>!cd notebook_git &amp;&amp; echo "print('Este es el archivo 2')" &gt; archivo2.py</input_code>
  <markdown>Ahora hacemos commit solo de uno</markdown>
  <input_code>!cd notebook_git &amp;&amp; git add archivo1.py &amp;&amp; git commit -m "Commit con el archivo 1"</input_code>
  <output_code>[master 285b243] Commit con el archivo 1
 1 file changed, 1 insertion(+)
 create mode 100644 archivo1.py
</output_code>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama master
Archivos sin seguimiento:
  (usa "git add &lt;archivo&gt;..." para incluirlo a lo que se ser√° confirmado)
	[31marchivo2.py[m

no hay nada agregado al commit pero hay archivos sin seguimiento presentes (usa "git add" para hacerles seguimiento)
</output_code>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>* [33m285b243[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmaster[m[33m)[m Commit con el archivo 1
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Como vemos, nos hemos dejado el archivo 2, de modo que modificamos el commit y a√±adimos el archivo 2</markdown>
  <input_code>!cd notebook_git &amp;&amp; git add archivo2.py</input_code>
  <input_code>!cd notebook_git &amp;&amp; git commit --amend -m "Commit con los archivos 1 y 2"</input_code>
  <output_code>[master 04ebd1f] Commit con los archivos 1 y 2
 Date: Sun Apr 16 02:30:26 2023 +0200
 2 files changed, 2 insertions(+)
 create mode 100644 archivo1.py
 create mode 100644 archivo2.py
</output_code>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama master
nada para hacer commit, el √°rbol de trabajo est√° limpio
</output_code>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>* [33m04ebd1f[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmaster[m[33m)[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Ahora el √∫ltimo commit tiene los dos nuevos archivos</markdown>
  <markdown>### Deshacer un commit (`git reset HEAD~1`)</markdown>
  <markdown>Con este comando le decimos a git que retroceda una posici√≥n en el historial de commits. Hay dos opciones `--soft` que no borrar√°n los cambios que hayamos hecho y `--hard` que s√≠ lo har√°</markdown>
  <markdown>#### Deshacer un commit manteniendo los cambios (`git reset --soft HEAD~1`)</markdown>
  <markdown>Vamos a crear un nuevo archivo</markdown>
  <input_code>!cd notebook_git &amp;&amp; echo "print('Este es el archivo 3')" &gt; archivo3.py</input_code>
  <markdown>Hacemos un `git status`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama master
Archivos sin seguimiento:
  (usa "git add &lt;archivo&gt;..." para incluirlo a lo que se ser√° confirmado)
	[31marchivo3.py[m

no hay nada agregado al commit pero hay archivos sin seguimiento presentes (usa "git add" para hacerles seguimiento)
</output_code>
  <markdown>Hacemos un commit a√±adiendo este archivo</markdown>
  <input_code>!cd notebook_git &amp;&amp; git add archivo3.py &amp;&amp; git commit -m "Commit con el archivos 3"</input_code>
  <output_code>[master 6dc7be6] Commit con el archivos 3
 1 file changed, 1 insertion(+)
 create mode 100644 archivo3.py
</output_code>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>* [33m6dc7be6[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmaster[m[33m)[m Commit con el archivos 3
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Vemos que en el √∫ltimo commit se encuentra `archivo3.py`, vamos a eliminar el commit manteniendo `archivo3.py`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git reset --soft HEAD~1</input_code>
  <markdown>Hacemos ahora un `git log` para ver si se ha eliminado el √∫ltimo commit</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>* [33m04ebd1f[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmaster[m[33m)[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Efectivamente, vemos que se ha eliminado el √∫ltimo commit</markdown>
  <markdown>Hacemos un `git status` para ver si se ha conservado `archivo3.py`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama master
Cambios a ser confirmados:
  (usa "git restore --staged &lt;archivo&gt;..." para sacar del √°rea de stage)
	[32mnuevos archivos: archivo3.py[m

</output_code>
  <markdown>Se ha mantenido</markdown>
  <markdown>#### Deshacer un commit descartando los cambios (`git reset --hard HEAD~1`)</markdown>
  <markdown>Tenemos `archivo3.py` que lo hemos creado y lo tenemos en el √°rea de stage</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama master
Cambios a ser confirmados:
  (usa "git restore --staged &lt;archivo&gt;..." para sacar del √°rea de stage)
	[32mnuevos archivos: archivo3.py[m

</output_code>
  <markdown>Por lo tanto, hacemos un commit</markdown>
  <input_code>!cd notebook_git &amp;&amp; git commit -m "Commit con el archivo 3"</input_code>
  <output_code>[master 0147d65] Commit con el archivo 3
 1 file changed, 1 insertion(+)
 create mode 100644 archivo3.py
</output_code>
  <markdown>Hacemos un `git log` para comprobar que hay un commit con este archivo</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>* [33m0147d65[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmaster[m[33m)[m Commit con el archivo 3
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Efectivamente hay un commit a√±adiendo `archivo3.py`. Ahora eliminamos este commit descartando `archivo3.py`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git reset --hard HEAD~1</input_code>
  <output_code>HEAD est√° ahora en 04ebd1f Commit con los archivos 1 y 2
</output_code>
  <markdown>Hacemos un `git log` para comprobar que se ha eliminado el √∫ltimo commit</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>* [33m04ebd1f[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmaster[m[33m)[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Se ha eliminado el commit con `archivo3.py`, ahora hacemos un `git status` para comprobar qu√© ha pasado con `archivo3.py`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama master
nada para hacer commit, el √°rbol de trabajo est√° limpio
</output_code>
  <markdown>No aparece `archivo3.py` como un archivo al que haya que hacer commit, vamos a ver si efectivamente se ha eliminado del todo</markdown>
  <input_code>!cd notebook_git &amp;&amp; ls | grep archivo3</input_code>
  <markdown>Efectivamente se ha eliminado `archivo3.py` del sistema de ficheros</markdown>
  <markdown>### Modificar un commit remoto (`git push --force`)</markdown>
  <markdown>Aunque m√°s adelante veremos c√≥mo sincronizarnos con repositorios remotos, en el caso que hayas hecho un commit, lo hayas subido a un repositorio remoto (`git push`) y hayas modificado el commit en local (porque has modificado el mensaje o has deshecho el commit), para revertir los cambios en el repositorio remoto tienes que hacer `git push --force`

 &gt; **Cuidado!**: Este comando modifica el historial del repositorio remoto, por lo que puede afectar al resto de gente que est√© trabajando con ese repositorio, as√≠ que usa este comando con mucho cuidado y seguridad. Vale m√°s la pena tener un historial de commits, en el que primero est√° el commit en el que has puesto mal la descripci√≥n y luego el nuevo commit con la nueva descripci√≥n bien puesta, que andar modificando el historial.</markdown>
  <markdown>### Modificar un commit remoto (`git push --force-with-lease`)</markdown>
  <markdown>Si est√°s convencido de cambiar el historial, al menos usa `git push --force-with-lease`, que no modificar√° commits que haya habido posteriormente</markdown>
  <markdown>### Ignorar archivos (`.gitignore`)</markdown>
  <markdown>Supongamos que tenemos un archivo con `API key`s, este archivo en realidad no queremos que se guarde en el repositorio, porque si luego compartimos este repositorio, cualquiera tendr√≠a acceso a estas claves, por lo que hay que decirle a git que no haga seguimiento de este archivo

Esto se hace con el archivo `.gitignore`, en √©l se a√±ade la ruta de los archivos o directorios que no queremos que git haga seguimiento

Vamos a verlo</markdown>
  <markdown>Creamos el archivo con las claves</markdown>
  <input_code>!cd notebook_git &amp;&amp; touch api_keys.py</input_code>
  <markdown>Si hacemos `git status` vemos que Git lo contempla</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama master
Archivos sin seguimiento:
  (usa "git add &lt;archivo&gt;..." para incluirlo a lo que se ser√° confirmado)
	[31mapi_keys.py[m

no hay nada agregado al commit pero hay archivos sin seguimiento presentes (usa "git add" para hacerles seguimiento)
</output_code>
  <markdown>Si no hacemos nada puede que un d√≠a hagamos un `git add .` y lo metamos en el repositorio, as√≠ que por seguridad hay que decirle a git que no siga este archivo, para ello, lo que hacemos es crear el `.gitignore` a√±adiendo este archivo</markdown>
  <input_code>!cd notebook_git &amp;&amp; echo "api_keys.py" &gt;&gt; .gitignore</input_code>
  <markdown>Veamos qu√© pasa si ahora hacemos `git status`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama master
Archivos sin seguimiento:
  (usa "git add &lt;archivo&gt;..." para incluirlo a lo que se ser√° confirmado)
	[31m.gitignore[m

no hay nada agregado al commit pero hay archivos sin seguimiento presentes (usa "git add" para hacerles seguimiento)
</output_code>
  <markdown>Vemos que git ha dejado de contemplar `api_keys.py`, pero s√≠ contempla `.gitignore`, por lo que hacemos un commit para a√±adir `.gitignore`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git add .gitignore &amp;&amp; git commit -m "A√±adido .gitignore"</input_code>
  <output_code>[master 0b09cfa] A√±adido .gitignore
 1 file changed, 1 insertion(+)
 create mode 100644 .gitignore
</output_code>
  <markdown>#### ¬øQu√© archivos a√±adir al `.gitignore`?</markdown>
  <markdown> * Archivos que tengan credenciales o llaves de API (no deber√≠as subirlas al repositorio, simplemente inyectarlas por variable de entorno)
 * Carpetas de configuraci√≥n de tu editor (`/.vscode`)
 * Archivos de registro (log files)
 * Archivos de sistema como `.DS_Store`
 * Carpetas generadas con archivos est√°ticos o compilaciones como `/dist` o `/build`
 * Dependencias que pueden ser descargadas (`/node_modules`)
 * Coverage del testing (`/coverage`)</markdown>
  <markdown>#### ¬øC√≥mo ignorar siempre los mismos archivos?</markdown>
  <markdown>Si por ejemplo tu IDE siempre genera los mismos archivos de configuraci√≥n, estar√≠a bien poderle decir a git que siempre ignore esos archivos, para ello creamos un `.gitignore` global</markdown>
  <input_code>!touch ~/.gitignore_global</input_code>
  <markdown>En mi caso voy a a√±adir el directorio `__pycache__/`</markdown>
  <input_code>!echo "__pycache__/" &gt;&gt; ~/.gitignore_global</input_code>
  <markdown>Ahora hay que indicarle a Git que ese es nuestro `.gitignore` global</markdown>
  <input_code>!git config --global core.excludesfile ~/.gitignore_global</input_code>
  <markdown>Listo, a partir de ahora el directorio `__pycache__/` siempre ser√° ignorado</markdown>
  <markdown>GitHub tiene un [repositorio](https://github.com/github/gitignore) con `.gitignore`s para muchos lenguajes, yo me he guiado de [este](https://github.com/github/gitignore/blob/main/Python.gitignore) para Python</markdown>
  <markdown>### Eliminar un archivo de un commit</markdown>
  <markdown>Vamos a ver c√≥mo eliminar un archivo de un commit que hemos hecho. Primero creamos dos archivos y les hacemos commit</markdown>
  <input_code>!cd notebook_git &amp;&amp; echo "print('Este es el archivo 4')" &gt; archivo4.py</input_code>
  <input_code>!cd notebook_git &amp;&amp; echo "print('Este es el archivo 5')" &gt; archivo5.py</input_code>
  <markdown>Hacemos un commit con los dos archivos</markdown>
  <input_code>!cd notebook_git &amp;&amp; git add archivo4.py archivo5.py &amp;&amp; git commit -m "Commit con los archivos 4 y 5"</input_code>
  <output_code>[master e3153a5] Commit con los archivos 4 y 5
 2 files changed, 2 insertions(+)
 create mode 100644 archivo4.py
 create mode 100644 archivo5.py
</output_code>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>* [33me3153a5[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmaster[m[33m)[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>A partir de aqu√≠ hay dos opciones para eliminar un archivo de un commit:
 * Eliminar el archivo y crear un nuevo commit
 * Deshacer el commit y crearlo de nuevo sin el archivo</markdown>
  <markdown>#### Eliminar el archivo y crear un nuevo commit</markdown>
  <markdown>Supongamos que queremos eliminar el archivo `archivo5.py`, pues lo eliminamos con `git rm archivo5.py`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git rm archivo5.py</input_code>
  <output_code>rm 'archivo5.py'
</output_code>
  <markdown>Hagamos un `git status` a ver qu√© ocurre</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama master
Cambios a ser confirmados:
  (usa "git restore --staged &lt;archivo&gt;..." para sacar del √°rea de stage)
	[32mborrados:        archivo5.py[m

</output_code>
  <markdown>Como vemos, se ha borrado `archivo5.py`. Ahora creamos un nuevo commit</markdown>
  <input_code>!cd notebook_git &amp;&amp; git commit -m "Eliminado archivo5.py"</input_code>
  <output_code>[master ea615a9] Eliminado archivo5.py
 1 file changed, 1 deletion(-)
 delete mode 100644 archivo5.py
</output_code>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>* [33mea615a9[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmaster[m[33m)[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>#### Deshacer el commit y crearlo de nuevo sin el archivo</markdown>
  <markdown>Volvemos a crear dos archivos y hacer un commit</markdown>
  <input_code>!cd notebook_git &amp;&amp; echo "print('Este es el archivo 6')" &gt; archivo6.py &amp;&amp; echo "print('Este es el archivo 7')" &gt; archivo7.py</input_code>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama master
Archivos sin seguimiento:
  (usa "git add &lt;archivo&gt;..." para incluirlo a lo que se ser√° confirmado)
	[31marchivo6.py[m
	[31marchivo7.py[m

no hay nada agregado al commit pero hay archivos sin seguimiento presentes (usa "git add" para hacerles seguimiento)
</output_code>
  <input_code>!cd notebook_git &amp;&amp; git add archivo6.py archivo7.py &amp;&amp; git commit -m "Commit con los archivos 6 y 7"</input_code>
  <output_code>[master d6dc485] Commit con los archivos 6 y 7
 2 files changed, 2 insertions(+)
 create mode 100644 archivo6.py
 create mode 100644 archivo7.py
</output_code>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>* [33md6dc485[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmaster[m[33m)[m Commit con los archivos 6 y 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Primero deshacemos el √∫ltimo commit con `git reset --soft HEAD~1`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git reset --soft HEAD~1</input_code>
  <markdown>Hacemos un `git status` para ver qu√© ha ocurrido</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama master
Cambios a ser confirmados:
  (usa "git restore --staged &lt;archivo&gt;..." para sacar del √°rea de stage)
	[32mnuevos archivos: archivo6.py[m
	[32mnuevos archivos: archivo7.py[m

</output_code>
  <markdown>Vemos que he deshecho el commit, pero que los dos archivos se encuentran en el √°rea de staged, por lo que para sacar del commit uno de los archivos, primero hay que sacarlo del √°rea de staged, para ello hacemos `git reset archivo6.py`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git reset archivo6.py</input_code>
  <markdown>Volvemos a hacer un `git status`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama master
Cambios a ser confirmados:
  (usa "git restore --staged &lt;archivo&gt;..." para sacar del √°rea de stage)
	[32mnuevos archivos: archivo7.py[m

Archivos sin seguimiento:
  (usa "git add &lt;archivo&gt;..." para incluirlo a lo que se ser√° confirmado)
	[31marchivo6.py[m

</output_code>
  <markdown>Vemos que `archivo7.py` est√° en el √°rea de staged, mientras que `archivo6.py` ya no. Ahora podemos borrar archivo 6, para ello usamos `git clean`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git clean -n</input_code>
  <output_code>Ser√° borrado archivo6.py
</output_code>
  <input_code>!cd notebook_git &amp;&amp; git clean -f</input_code>
  <output_code>Borrando archivo6.py
</output_code>
  <markdown>Volvemos a hacer un `git status`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama master
Cambios a ser confirmados:
  (usa "git restore --staged &lt;archivo&gt;..." para sacar del √°rea de stage)
	[32mnuevos archivos: archivo7.py[m

</output_code>
  <markdown>Como vemos `archivo.py` ya no est√°, por lo que podemos hacer un nuevo commit</markdown>
  <input_code>!cd notebook_git &amp;&amp; git commit -m "Commit con el archivo 7"</input_code>
  <output_code>[master 4bb9d75] Commit con el archivo 7
 1 file changed, 1 insertion(+)
 create mode 100644 archivo7.py
</output_code>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>* [33m4bb9d75[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmaster[m[33m)[m Commit con el archivo 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Hemos eliminado el √∫ltimo commit y lo hemos sobrescrito con uno nuevo, eliminando el archivo que quer√≠amos</markdown>
  <markdown>### Hist√≥rico de cambios de un archivo (`git log &lt;archivo&gt;`)</markdown>
  <markdown>Aunque antes hemos visto c√≥mo pod√≠amos ver el historial del repositorio con `git log` puede que no nos interese el historial de todo el repositorio. Puede que tengamos un bug en un archivo de c√≥digo que al principio no ten√≠amos, por lo que es posible que queramos ver solo el historial de ese archivo, para eso usamos `git log &lt;archivo&gt;`</markdown>
  <markdown>Primero vemos los archivos que tenemos</markdown>
  <input_code>!cd notebook_git &amp;&amp; ls</input_code>
  <output_code>api_keys.py  archivo1.py  archivo2.py  archivo4.py  archivo7.py  hola.py
</output_code>
  <markdown>Supongamos que solo queremos ver los cambios en `hola.py`, por lo que hacemos `git log hola.py`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate hola.py</input_code>
  <output_code>* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Podemos ver que aparecen muchos menos resultados que si hubi√©semos hecho `git log`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>* [33m4bb9d75[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmaster[m[33m)[m Commit con el archivo 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>### Ver modificaciones de un archivo en un punto concreto del historial (`git show &lt;hash&gt; &lt;archivo&gt;` o `git diff &lt;archivo&gt;`)</markdown>
  <markdown>Supongamos que ya sabemos en qu√© punto se realiz√≥ un cambio en el archivo que contiene un bug, por lo que ahora queremos saber qu√© cambios se realizaron para saber qu√© puede estar causando el bug para ello podemos usar `git show &lt;hash&gt; &lt;archivo&gt;`</markdown>
  <markdown>Veamos qu√© cambios se produjeron en `hola.py` en el hash `c4930d7`, es decir cuando se hizo el tercer commit</markdown>
  <input_code>!cd notebook_git &amp;&amp; git show c4930d7 hola.py</input_code>
  <output_code>[33mcommit c4930d7267c3f8df389ab0cb1bda0b5fceabb5c2[m
Author: maximofn &lt;maximofn@gmail.com&gt;
Date:   Sun Apr 16 02:29:59 2023 +0200

    Tercer commit, hola.py

[1mdiff --git a/hola.py b/hola.py[m
[1mindex 91dee80..33bdb99 100644[m
[1m--- a/hola.py[m
[1m+++ b/hola.py[m
[36m@@ -1,2 +1,3 @@[m
 print('Hola mundo')[m
 print('He a√±adido una nueva linea')[m
[32m+[m[32mprint('Esta es la tercera linea')[m
</output_code>
  <markdown>La manera de ver los cambios en git no son muy intuitivas, pero podemos ver que se ha a√±adido la l√≠nea `print('Esta es la tercera linea')`</markdown>
  <markdown>Otra manera de ver cambios es con `git diff`, tenemos dos opciones, podemos ver los cambios del fichero en el momento actual con un punto concreto del historial, para ello hacemos `git diff &lt;hash&gt; &lt;archivo&gt;`.

Por ejemplo, si queremos ver los cambios de `hola.py` de cuando se hizo el primer commit (hash `1c95e4f`) con la situaci√≥n actual, hay que introducir (`git diff 1c95e4f hola.py`)</markdown>
  <input_code>!cd notebook_git &amp;&amp; git diff 1c95e4f hola.py</input_code>
  <output_code>[1mdiff --git a/hola.py b/hola.py[m
[1mindex f140969..33bdb99 100644[m
[1m--- a/hola.py[m
[1m+++ b/hola.py[m
[36m@@ -1 +1,3 @@[m
 print('Hola mundo')[m
[32m+[m[32mprint('He a√±adido una nueva linea')[m
[32m+[m[32mprint('Esta es la tercera linea')[m
</output_code>
  <markdown>Pero si lo que queremos es ver la diferencia entre un punto concreto del historial y otro punto concreto hay que introducir los hash de los dos momentos, es decir `git diff &lt;hash1&gt; &lt;hash2&gt; &lt;archivo&gt;`

Si queremos ver los cambios de `hola.py` entre el segundo commit (hash `6e99e73`) y el primer commit (hash `1c95e4f`) tendr√≠amos que introducir `git diff 1c95e4f 6e99e73 hola.py`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git diff 1c95e4f 6e99e73 hola.py</input_code>
  <output_code>[1mdiff --git a/hola.py b/hola.py[m
[1mindex f140969..91dee80 100644[m
[1m--- a/hola.py[m
[1m+++ b/hola.py[m
[36m@@ -1 +1,2 @@[m
 print('Hola mundo')[m
[32m+[m[32mprint('He a√±adido una nueva linea')[m
</output_code>
  <markdown>Lo anterior nos muestra los cambios del segundo commit con respecto al primero, pero si lo que queremos es los cambios del primer commit con respecto al segundo, solo hay que poner los hash al rev√©s de como los hemos puesto, es decir `git diff 6e99e73 1c95e4f hola.py`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git diff 6e99e73 1c95e4f hola.py</input_code>
  <output_code>[1mdiff --git a/hola.py b/hola.py[m
[1mindex 91dee80..f140969 100644[m
[1m--- a/hola.py[m
[1m+++ b/hola.py[m
[36m@@ -1,2 +1 @@[m
 print('Hola mundo')[m
[31m-print('He a√±adido una nueva linea')[m
</output_code>
  <markdown>### Viaje al pasado (`git reset --hard &lt;hash&gt;` o `git reset --soft &lt;hash&gt;`)</markdown>
  <markdown>Imaginemos que hemos encontrado que todo lo que hicimos despu√©s de generar el bug no sirve y tenemos que volver a trabajar desde ese punto, podemos volver a una posici√≥n del historial mediate `git reset --hard &lt;hash&gt;` (esto no mantendr√° los cambios) o `git reset --soft &lt;hash&gt;` (esto s√≠ mantendr√° los cambios)</markdown>
  <markdown>Primero veamos el historial</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>* [33m4bb9d75[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmaster[m[33m)[m Commit con el archivo 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Supongamos que queremos ir al momento en el que hicimos el tercer commit (hash `c4930d7`), adem√°s lo hacemos sin mantener los cambios, es decir, todas las modificaciones que hicimos despu√©s se borrar√°n, hacemos `git reset --hard c4930d7`</markdown>
  <markdown>Primero hacemos `ls` para ver los archivos que tenemos ahora</markdown>
  <input_code>!cd notebook_git &amp;&amp; ls</input_code>
  <output_code>api_keys.py  archivo1.py  archivo2.py  archivo4.py  archivo7.py  hola.py
</output_code>
  <markdown>Vamos al tercer commit</markdown>
  <input_code>!cd notebook_git &amp;&amp; git reset --hard c4930d7</input_code>
  <output_code>HEAD est√° ahora en c4930d7 Tercer commit, hola.py
</output_code>
  <markdown>Si hacemos `ls` veremos que ya no tenemos ni `archivo1.py`, ni `archivo2.py`, ni `archivo4.py`, ni `archivo7.py`</markdown>
  <input_code>!cd notebook_git &amp;&amp; ls</input_code>
  <output_code>api_keys.py  hola.py
</output_code>
  <markdown>### Regreso al futuro (`git reflog`)</markdown>
  <markdown>Supongamos que nos hemos arrepentido y queremos volver a donde est√°bamos, al √∫ltimo punto en el historial, una manera ser√≠a volver a hacer `git reset --hard &lt;hash&gt;`. Pero imaginemos que no sabemos el hash, porque no hicimos `git log` antes y si lo hacemos ahora solo nos da informaci√≥n del historial hasta el tercer commit</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>* [33mc4930d7[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmaster[m[33m)[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Aqu√≠ lo que podemos hacer es `git reflog`, que nos dar√° un historial incluyendo los salto</markdown>
  <input_code>!cd notebook_git &amp;&amp; git reflog</input_code>
  <output_code>[33mc4930d7[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmaster[m[33m)[m HEAD@{0}: reset: moving to c4930d7
[33m4bb9d75[m HEAD@{1}: commit: Commit con el archivo 7
[33mea615a9[m HEAD@{2}: reset: moving to HEAD~1
[33md6dc485[m HEAD@{3}: commit: Commit con los archivos 6 y 7
[33mea615a9[m HEAD@{4}: commit: Eliminado archivo5.py
[33me3153a5[m HEAD@{5}: commit: Commit con los archivos 4 y 5
[33m0b09cfa[m HEAD@{6}: commit: A√±adido .gitignore
[33m04ebd1f[m HEAD@{7}: reset: moving to HEAD~1
[33m0147d65[m HEAD@{8}: commit: Commit con el archivo 3
[33m04ebd1f[m HEAD@{9}: reset: moving to HEAD~1
[33m6dc7be6[m HEAD@{10}: commit: Commit con el archivos 3
[33m04ebd1f[m HEAD@{11}: commit (amend): Commit con los archivos 1 y 2
[33m285b243[m HEAD@{12}: commit: Commit con el archivo 1
[33mc4930d7[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmaster[m[33m)[m HEAD@{13}: commit (amend): Tercer commit, hola.py
[33m60e2ffd[m HEAD@{14}: commit: Tercer commot, hola.py
[33m6e99e73[m HEAD@{15}: commit: Segundo commit, hola.py
[33m1c95e4f[m HEAD@{16}: commit (initial): Primer commit, hola.py
</output_code>
  <markdown>Podemos ver que nos dice que est√°bamos en el commit con hash `4bb9d75`, es decir el √∫ltimo commit que hicimos, y de ah√≠ nos fuimos hasta el commit con hash `c4930d7`, que si te fijas, es el mismo hash que el commit con mensaje `Tercer commit, hola.py`. Por lo que ya sabemos el hash del √∫ltimo commit, el `4bb9d75`, as√≠ que para volver a la posici√≥n del √∫ltimo commit hacemos `git reset --hard 4bb9d75`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git reset --hard 4bb9d75</input_code>
  <output_code>HEAD est√° ahora en 4bb9d75 Commit con el archivo 7
</output_code>
  <markdown>Si ahora volvemos a hacer un log</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>* [33m4bb9d75[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmaster[m[33m)[m Commit con el archivo 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Vemos que efectivamente estamos en la posici√≥n del √∫ltimo commit, *hemos regresado al futuro*</markdown>
  <markdown>### B√∫squeda en ficheros (`git grep &lt;palabra&gt;`)</markdown>
  <markdown>Si queremos buscar en ficheros podemos hacerlo con la el comando `git grep`. Como en el repositorio que llevamos hecho es muy peque√±o y tiene muy pocos archivos vamos a bajarnos uno nuevo mediante un comando que veremos despu√©s m√°s en detalle</markdown>
  <input_code>!git clone https://github.com/facebookresearch/segment-anything.git</input_code>
  <output_code>Clonando en 'segment-anything'...
remote: Enumerating objects: 279, done.[K
remote: Counting objects: 100% (181/181), done.[K
remote: Compressing objects: 100% (77/77), done.[K
remote: Total 279 (delta 116), reused 104 (delta 104), pack-reused 98[K
Recibiendo objetos: 100% (279/279), 18.31 MiB | 21.25 MiB/s, listo.
Resolviendo deltas: 100% (140/140), listo.
</output_code>
  <markdown>El repositorio que hemos bajado es el del c√≥digo fuente de SAM, una red neuronal de Meta para segmentar cualquier objeto. Entramos en la carpeta del repositorio y buscamos, por ejemplo, cu√°ntas veces se ha escrito la palabra `softmax`</markdown>
  <input_code>!cd segment-anything &amp;&amp; git grep softmax</input_code>
  <output_code>segment_anything/modeling/image_encoder.py[36m:[m        attn = attn.[1;31msoftmax[m(dim=-1)
segment_anything/modeling/transformer.py[36m:[m        attn = torch.[1;31msoftmax[m(attn, dim=-1)
</output_code>
  <markdown>Vemos que se ha escrito en los archivos `segment_anything/modeling/image_encoder.py` y `segment_anything/modeling/transformer.py`.</markdown>
  <markdown>Si ahora adem√°s queremos saber en qu√© l√≠neas de los archivos se ha escrito usamos el flag `-n`</markdown>
  <input_code>!cd segment-anything &amp;&amp; git grep -n softmax</input_code>
  <output_code>segment_anything/modeling/image_encoder.py[36m:[m236[36m:[m        attn = attn.[1;31msoftmax[m(dim=-1)
segment_anything/modeling/transformer.py[36m:[m233[36m:[m        attn = torch.[1;31msoftmax[m(attn, dim=-1)
</output_code>
  <markdown>Si lo que queremos es contar cu√°ntas veces aparece la palabra podemos usar el flag `-c`</markdown>
  <input_code>!cd segment-anything &amp;&amp; git grep -c softmax</input_code>
  <output_code>segment_anything/modeling/image_encoder.py[36m:[m1
segment_anything/modeling/transformer.py[36m:[m1
</output_code>
  <markdown>Y vemos que aparece una vez en cada archivo</markdown>
  <markdown>Y nos dice que est√°n en las l√≠neas 236 y 233 respectivamente</markdown>
  <markdown>### B√∫squeda en commits (`git log -S &lt;palabra&gt;`)</markdown>
  <markdown>Si lo que queremos es buscar en el historial de commits podemos usar el comando `git log -S &lt;palabra&gt;`. Por ejemplo, busquemos en el historial de commits del repositorio que nos hemos bajado antes la palabra `fix`</markdown>
  <input_code>!cd segment-anything &amp;&amp; git log -S "collab"</input_code>
  <output_code>[33mcommit 2780a301de4483e5c46edb230ea781556159c658[m
Author: Eric Mintun &lt;eric.mintun@gmail.com&gt;
Date:   Mon Apr 10 10:50:17 2023 -0700

    Fix typo in notebook 'using_collab'-&gt;'using_colab' in other two notebooks.

[33mcommit 2c11ea23525970ac288f23dc74b203bcbfb4cc6a[m
Author: jp-x-g &lt;jpxg-dev@protonmail.com&gt;
Date:   Thu Apr 6 20:00:04 2023 -0700

    fix parameter name
    
    "using_collab" does not appear in subsequent text, replacing with "using_colab"

[33mcommit b47d02d68c308672751be29742fcef02a86e2f02[m
Author: Eric Mintun &lt;eric.mintun@gmail.com&gt;
Date:   Wed Apr 5 06:13:09 2023 -0700

    Fix broken links in notebook Colab setup.

[33mcommit 571794162e0887c15d12b809505b902c7bf8b4db[m
Author: Eric Mintun &lt;eric.mintun@gmail.com&gt;
Date:   Tue Apr 4 22:25:49 2023 -0700

    Initial commit
</output_code>
  <markdown>Borramos la carpeta de SAM</markdown>
  <input_code>!rm -r segment-anything</input_code>
  <markdown>## Ramas</markdown>
  <markdown>![branches](https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/GIT-Branchand-its-Operations.webp)

El uso de ramas es muy √∫til, ya que podemos empezar a desarrollar una nueva caracter√≠stica sin tener que modificar el c√≥digo original</markdown>
  <markdown>### Crear una rama (`git branch &lt;branch name&gt;`)</markdown>
  <markdown> &gt; **Nota**: Antes de nada hay que decir que para crear una rama en un repositorio debe haber al menos un commit, si se intenta crear una rama antes de hacer el primer commit recibiremos un error</markdown>
  <markdown>Para crear una rama utilizamos el comando `git branch &lt;nombre de la rama&gt;`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git branch new_branch</input_code>
  <markdown>### Listar ramas (`git branch`)</markdown>
  <markdown>Hemos creado nuestra primera rama, podemos comprobar todas las ramas que tenemos creadas escribiendo solo `git branch`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git branch</input_code>
  <output_code>* [32mmaster[m
  new_branch[m
</output_code>
  <markdown>Adem√°s de listar nos dice con un asterisco `*` en qu√© rama estamos, en este caso en la rama `master`</markdown>
  <markdown>### Renombrar ramas, adios a la rama `master` (`git branch -m &lt;old name&gt; &lt;new name&gt;`)</markdown>
  <markdown>Hist√≥ricamente en git se ha llamado `master` a la rama principal, pero esto tiene unas connotaciones hist√≥ricas malas por el concepto de `master-slave` (`maestro-esclavo`), debido al sufrimiento que recibieron muchas personas, por lo que ahora se suele catalogar la rama principal como `main`, as√≠ que para cambiarle el nombre usamos `git branch -m master main`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git branch -m master main</input_code>
  <markdown>Listamos las ramas</markdown>
  <input_code>!cd notebook_git &amp;&amp; git branch</input_code>
  <output_code>* [32mmain[m
  new_branch[m
</output_code>
  <markdown>Como vemos, hemos podido cambiar el nombre de la rama principal de `master` a `main`</markdown>
  <markdown>### Cambiar de rama (`git switch &lt;branch&gt;`)</markdown>
  <markdown>Si queremos cambiar de rama solo hay que escribir `git switch &lt;nombre de la rama&gt;`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git switch new_branch</input_code>
  <output_code>Cambiado a rama 'new_branch'
</output_code>
  <markdown>Vamos a ver en qu√© rama estamos con `git branch`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git branch</input_code>
  <output_code>  main[m
* [32mnew_branch[m
</output_code>
  <markdown>Como vemos, hemos cambiado de rama a new_branch</markdown>
  <markdown>Si queremos crear y cambiar de rama en un solo comando podemos usar `git switch -c &lt;nombre de la rama&gt;`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git switch -c new_branch2</input_code>
  <output_code>Cambiado a nueva rama 'new_branch2'
</output_code>
  <markdown>Vamos a ver en qu√© rama estamos</markdown>
  <input_code>!cd notebook_git &amp;&amp; git branch</input_code>
  <output_code>  main[m
  new_branch[m
* [32mnew_branch2[m
</output_code>
  <markdown>Hemos creado y cambiado de rama con un solo comando</markdown>
  <markdown>### Obtener la rama en la que estamos (`git branch --show-current`)</markdown>
  <markdown>Como hemos visto hasta ahora con `git branch` podemos obtener una lista de todas las ramas y adem√°s ver en la que estamos actualmente, pero en el caso en el que tengamos una gran cantidad de ramas, cosa que se puede dar en un equipo de trabajo con mucha gente, est√° bien obtener la rama y no obtener una lista de todas, para eso usamos `git branch --show-current`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git branch --show-current</input_code>
  <output_code>new_branch2
</output_code>
  <markdown>### Lista de ramas m√°s recientes (`git branch --sort=-committerdate`)</markdown>
  <markdown>En caso de tener muchas ramas a lo mejor nos interesa saber cu√°les son las m√°s recientes para ver cu√°les han sido las √∫ltimas creadas y d√≥nde deber√≠a estar lo √∫ltimo en desarrollo, para eso usamos `git branch --sort=-committerdate`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git branch --sort=-committerdate</input_code>
  <output_code>* [32mnew_branch2[m
  new_branch[m
  main[m
</output_code>
  <markdown>Como vemos, las ha ordenado en orden inverso a cuando las hemos creado</markdown>
  <markdown>### El comando deprecado `git checkout`</markdown>
  <markdown>Hasta hace un tiempo el comando para crear ramas y cambiar entre ellas era `git checkout`, pero este comando no solo hace esto, sino que tambi√©n restaura el directorio de trabajo. Pero esto va en contra de la filosof√≠a de Linux, por lo que se crearon los comandos `git branch`, `git switch` y `git restore` para dividir esta funcionalidad</markdown>
  <markdown>### Fusionando ramas (`git merge`)</markdown>
  <markdown>Como hemos dicho, el crear ramas es muy √∫til para desarrollar nuevas caracter√≠sticas sin afectar al resto del equipo. Pero cuando estas est√°n terminadas hay que llevarlas a la rama principal, para ello utilizamos el comando `git merge &lt;rama&gt;`

 &gt; **Importante**: Tenemos que estar en la rama que va a adoptar los cambios, es decir, si queremos fusionar los cambios realizados en la rama `new_branch2` en la rama `main`, primero tenemos que asegurarnos de estar en la rama `main`</markdown>
  <markdown>Primero comprobamos en qu√© rama estamos</markdown>
  <input_code>!cd notebook_git &amp;&amp; git branch --show-current</input_code>
  <output_code>new_branch2
</output_code>
  <markdown>Eliminamos `archivo7.py`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git rm archivo7.py</input_code>
  <output_code>rm 'archivo7.py'
</output_code>
  <markdown>Hacemos un commit con los cambios</markdown>
  <input_code>!cd notebook_git &amp;&amp; git commit -am "Eliminado archivo7.py"</input_code>
  <output_code>[new_branch2 5168f78] Eliminado archivo7.py
 1 file changed, 1 deletion(-)
 delete mode 100644 archivo7.py
</output_code>
  <markdown>Si hacemos un `ls` vemos que `archivo7.py` ya no est√°</markdown>
  <input_code>!cd notebook_git &amp;&amp; ls | grep archivo7</input_code>
  <markdown>Creamos un nuevo archivo y hacemos un commit</markdown>
  <input_code>!cd notebook_git &amp;&amp; touch archivo8.py &amp;&amp; git add archivo8.py &amp;&amp; git commit -m "Commit con el archivo 8"</input_code>
  <output_code>[new_branch2 564ccfb] Commit con el archivo 8
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 archivo8.py
</output_code>
  <markdown>Hemos hecho dos commits nuevos en esta rama, veamoslo con `git log`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>* [33m564ccfb[m[33m ([m[1;36mHEAD -&gt; [m[1;32mnew_branch2[m[33m)[m Commit con el archivo 8
* [33m5168f78[m Eliminado archivo7.py
* [33m4bb9d75[m[33m ([m[1;32mnew_branch[m[33m, [m[1;32mmain[m[33m)[m Commit con el archivo 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Cambiamos a la rama principal</markdown>
  <input_code>!cd notebook_git &amp;&amp; git switch main</input_code>
  <output_code>Cambiado a rama 'main'
</output_code>
  <markdown>Si ahora hacemos otra vez `ls` veremos que `archivo7.py` s√≠ est√°</markdown>
  <input_code>!cd notebook_git &amp;&amp; ls | grep archivo7</input_code>
  <output_code>archivo7.py
</output_code>
  <markdown>Fusionamos las ramas, traemos los cambios de `new_branch2` a `main`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git merge new_branch2</input_code>
  <output_code>Actualizando 4bb9d75..564ccfb
Fast-forward
 archivo7.py | 1 [31m-[m
 archivo8.py | 0
 2 files changed, 1 deletion(-)
 delete mode 100644 archivo7.py
 create mode 100644 archivo8.py
</output_code>
  <markdown>Hacemos un `git status`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama main
nada para hacer commit, el √°rbol de trabajo est√° limpio
</output_code>
  <markdown>Vemos que al hacer el merge no es necesario hacer ning√∫n commit, veamos con un `git log` qu√© ha pasado</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>* [33m564ccfb[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmain[m[33m, [m[1;32mnew_branch2[m[33m)[m Commit con el archivo 8
* [33m5168f78[m Eliminado archivo7.py
* [33m4bb9d75[m[33m ([m[1;32mnew_branch[m[33m)[m Commit con el archivo 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Vemos que el commit de la rama `new_branch2` se ha incorporado a esta rama</markdown>
  <markdown>#### Fast-forward</markdown>
  <markdown>Este caso creamos una nueva rama, la principal no la tocamos y solo modificamos la nueva, realizando varios commits. Por lo que al unir la nueva en la principal se ver√°n todos los commits que se hab√≠an hecho en la nueva. Para realizar este tipo de merge escribimos `git merge --ff-only &lt;rama&gt;`</markdown>
  <input_code>### Este c√≥digo es para crear el gr√°fico de las ramas, no es necesario para el curso

import graphviz

# Crear el gr√°fico con la direcci√≥n de las flechas de izquierda a derecha
orin = graphviz.Digraph('G', graph_attr={'rankdir': 'LR'})
fast_foward = graphviz.Digraph('G', graph_attr={'rankdir': 'LR'})

# Agregar nodos (pelotas) A, B, C y D en la rama principal
orin.node('A', shape='circle', label='A', color='blue')
orin.node('B', shape='circle', label='B', color='blue')
orin.node('C', shape='circle', label='C', color='blue')
orin.node('D', shape='circle', label='D', color='blue')
orin.node('E', shape='circle', label='', color='transparent')
fast_foward.node('A', shape='circle', label='A', color='blue')
fast_foward.node('B', shape='circle', label='B', color='blue')
fast_foward.node('C', shape='circle', label='C', color='blue')
fast_foward.node('D', shape='circle', label='D', color='blue')

# Agregar nodos (pelotas) X e Y en la rama secundaria
orin.node('X', shape='circle', label='X', color='green')
orin.node('Y', shape='circle', label='Y', color='green')
fast_foward.node('X', shape='circle', label='X', color='magenta')
fast_foward.node('Y', shape='circle', label='Y', color='magenta')

# Agregar flechas entre los nodos en la rama principal
orin.edges(['AB', 'BC', 'CD'])
orin.edge('D', 'E', color='transparent')  # Hacer la flecha de C a D transparente
fast_foward.edges(['AB', 'BC', 'CD', 'DX', 'XY'])

# Agregar flechas entre los nodos en la rama secundaria
orin.edges(['DX', 'XY'])

# Mostrar el diagrama de flujo en la celda de c√≥digo de Jupyter Notebook
display(orin)
display(fast_foward)</input_code>
  <output_code>&lt;graphviz.graphs.Digraph at 0x7f58f80c09a0&gt;</output_code>
  <output_code>&lt;graphviz.graphs.Digraph at 0x7f58f9203fa0&gt;</output_code>
  <markdown>Vamos primero a comprobar que estamos en la rama principal</markdown>
  <input_code>!cd notebook_git &amp;&amp; git branch --show-current</input_code>
  <output_code>main
</output_code>
  <markdown>Creamos una nueva rama</markdown>
  <input_code>!cd notebook_git &amp;&amp; git branch branch_fast_forward</input_code>
  <markdown>Cambiamos a ella</markdown>
  <input_code>!cd notebook_git &amp;&amp; git switch branch_fast_forward</input_code>
  <output_code>Cambiado a rama 'branch_fast_forward'
</output_code>
  <input_code>!cd notebook_git &amp;&amp; git branch --show-current</input_code>
  <output_code>branch_fast_forward
</output_code>
  <markdown>Vamos a ver el log</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate --all</input_code>
  <output_code>* [33m564ccfb[m[33m ([m[1;36mHEAD -&gt; [m[1;32mbranch_fast_forward[m[33m, [m[1;32mnew_branch2[m[33m, [m[1;32mmain[m[33m)[m Commit con el archivo 8
* [33m5168f78[m Eliminado archivo7.py
* [33m4bb9d75[m[33m ([m[1;32mnew_branch[m[33m)[m Commit con el archivo 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Vale, estamos en una rama creada a partir de la principal con todo su historial de logs, hacemos dos nuevos commits</markdown>
  <input_code>!cd notebook_git &amp;&amp; git rm archivo4.py &amp;&amp; git commit -am "Eliminado archivo4.py"</input_code>
  <output_code>rm 'archivo4.py'
[branch_fast_forward 4484e70] Eliminado archivo4.py
 1 file changed, 1 deletion(-)
 delete mode 100644 archivo4.py
</output_code>
  <input_code>!cd notebook_git &amp;&amp; git rm hola.py &amp;&amp; git commit -am "Eliminado hola.py"</input_code>
  <output_code>rm 'hola.py'
[branch_fast_forward 94149fc] Eliminado hola.py
 1 file changed, 3 deletions(-)
 delete mode 100644 hola.py
</output_code>
  <markdown>Hacemos un nuevo log para ver qu√© en esta nueva rama se han creado</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>* [33m94149fc[m[33m ([m[1;36mHEAD -&gt; [m[1;32mbranch_fast_forward[m[33m)[m Eliminado hola.py
* [33m4484e70[m Eliminado archivo4.py
* [33m564ccfb[m[33m ([m[1;32mnew_branch2[m[33m, [m[1;32mmain[m[33m)[m Commit con el archivo 8
* [33m5168f78[m Eliminado archivo7.py
* [33m4bb9d75[m[33m ([m[1;32mnew_branch[m[33m)[m Commit con el archivo 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Como vemos, los dos √∫ltimos commits son los que hemos creado y podemos comprobar que esos commits no est√°n en la rama principal (para eso especifico que lo haga sobre la rama `main`)</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log main --graph --oneline --decorate</input_code>
  <output_code>* [33m564ccfb[m[33m ([m[1;32mnew_branch2[m[33m, [m[1;32mmain[m[33m)[m Commit con el archivo 8
* [33m5168f78[m Eliminado archivo7.py
* [33m4bb9d75[m[33m ([m[1;32mnew_branch[m[33m)[m Commit con el archivo 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Ahora nos vamos a la rama `main` para hacer el merge</markdown>
  <input_code>!cd notebook_git &amp;&amp; git switch main</input_code>
  <output_code>Cambiado a rama 'main'
</output_code>
  <markdown>Por √∫ltimo, hacemos el merge de tipo fast forward</markdown>
  <input_code>!cd notebook_git &amp;&amp; git merge --ff-only branch_fast_forward</input_code>
  <output_code>Actualizando 564ccfb..94149fc
Fast-forward
 archivo4.py | 1 [31m-[m
 hola.py     | 3 [31m---[m
 2 files changed, 4 deletions(-)
 delete mode 100644 archivo4.py
 delete mode 100644 hola.py
</output_code>
  <markdown>Se ha hecho el merge, veamos qu√© ha pasado con el log en la rama `main`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>* [33m94149fc[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmain[m[33m, [m[1;32mbranch_fast_forward[m[33m)[m Eliminado hola.py
* [33m4484e70[m Eliminado archivo4.py
* [33m564ccfb[m[33m ([m[1;32mnew_branch2[m[33m)[m Commit con el archivo 8
* [33m5168f78[m Eliminado archivo7.py
* [33m4bb9d75[m[33m ([m[1;32mnew_branch[m[33m)[m Commit con el archivo 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Como se ve, se han mantenido los dos commits hechos en la rama `branch_fast_forward`</markdown>
  <markdown>#### No fast-forward o true merge</markdown>
  <markdown>Este caso creamos una nueva rama, la principal no la tocamos y modificamos la nueva, realizando varios commits. A continuaci√≥n realizamos un commit en la principal. Por lo que al unir la nueva en la principal se ver√° un √∫nico commit en la nueva. Para hacer este tipo de merge escribimos `git merge &lt;rama&gt; --no-ff`</markdown>
  <input_code>### Este c√≥digo es para crear el gr√°fico de las ramas, no es necesario para el curso

import graphviz

# Crear el gr√°fico con la direcci√≥n de las flechas de izquierda a derecha
orin = graphviz.Digraph('G', graph_attr={'rankdir': 'LR'})
not_fast_forward = graphviz.Digraph('G', graph_attr={'rankdir': 'LR'})

# Agregar nodos (pelotas) A, B, C y D en la rama principal
orin.node('A', shape='circle', label='A', color='blue')
orin.node('B', shape='circle', label='B', color='blue')
orin.node('C', shape='circle', label='C', color='blue')
orin.node('D', shape='circle', label='D', color='blue')
orin.node('E', shape='circle', label='', color='transparent')
not_fast_forward.node('A', shape='circle', label='A', color='blue')
not_fast_forward.node('B', shape='circle', label='B', color='blue')
not_fast_forward.node('C', shape='circle', label='C', color='blue')
not_fast_forward.node('D', shape='circle', label='D', color='blue')
not_fast_forward.node('E', shape='circle', label='E', color='blue')

# Agregar nodos (pelotas) X e Y en la rama secundaria
orin.node('X', shape='circle', label='X', color='green')
orin.node('Y', shape='circle', label='Y', color='green')
not_fast_forward.node('X', shape='circle', label='X', color='green')
not_fast_forward.node('Y', shape='circle', label='Y', color='green')

# Agregar nodo (pelota) M en la rama principal
not_fast_forward.node('M', shape='circle', label='M', color='magenta')

# Agregar flechas entre los nodos en la rama principal
orin.edges(['AB', 'BC', 'CD'])
orin.edge('D', 'E', color='transparent')  # Hacer la flecha de C a D transparente
not_fast_forward.edges(['AB', 'BC', 'CD', 'DE'])

# Agregar flechas entre los nodos en la rama secundaria
orin.edges(['DX', 'XY'])
not_fast_forward.edges(['DX', 'XY', 'YM'])

# Agregar flechas de la rama principal al nodo M
not_fast_forward.edge('E', 'M')

# Mostrar el diagrama de flujo en la celda de c√≥digo de Jupyter Notebook
display(orin)
display(not_fast_forward)</input_code>
  <output_code>&lt;graphviz.graphs.Digraph at 0x7f58f80c2fb0&gt;</output_code>
  <output_code>&lt;graphviz.graphs.Digraph at 0x7f58f80c2230&gt;</output_code>
  <markdown>Vamos primero a comprobar que estamos en la rama principal</markdown>
  <input_code>!cd notebook_git &amp;&amp; git branch --show-current</input_code>
  <output_code>main
</output_code>
  <markdown>Creamos una nueva rama</markdown>
  <input_code>!cd notebook_git &amp;&amp; git branch branch_no_fast_forward</input_code>
  <markdown>Cambiamos a ella</markdown>
  <input_code>!cd notebook_git &amp;&amp; git switch branch_no_fast_forward</input_code>
  <output_code>Cambiado a rama 'branch_no_fast_forward'
</output_code>
  <input_code>!cd notebook_git &amp;&amp; git branch --show-current</input_code>
  <output_code>branch_no_fast_forward
</output_code>
  <markdown>Vale, estamos en una rama creada a partir de la principal con todo su historial de logs, hacemos dos nuevos commits</markdown>
  <input_code>!cd notebook_git &amp;&amp; touch file1 &amp;&amp; git add file1 &amp;&amp; git commit -m "file1"</input_code>
  <output_code>[branch_no_fast_forward e4e23c9] file1
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 file1
</output_code>
  <input_code>!cd notebook_git &amp;&amp; touch file2 &amp;&amp; git add file2 &amp;&amp; git commit -m "file2"</input_code>
  <output_code>[branch_no_fast_forward 8df3429] file2
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 file2
</output_code>
  <markdown>Hacemos un nuevo log para ver qu√© en esta nueva rama se han creado</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>* [33m8df3429[m[33m ([m[1;36mHEAD -&gt; [m[1;32mbranch_no_fast_forward[m[33m)[m file2
* [33me4e23c9[m file1
* [33m94149fc[m[33m ([m[1;32mmain[m[33m, [m[1;32mbranch_fast_forward[m[33m)[m Eliminado hola.py
* [33m4484e70[m Eliminado archivo4.py
* [33m564ccfb[m[33m ([m[1;32mnew_branch2[m[33m)[m Commit con el archivo 8
* [33m5168f78[m Eliminado archivo7.py
* [33m4bb9d75[m[33m ([m[1;32mnew_branch[m[33m)[m Commit con el archivo 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Como vemos, los dos √∫ltimos commits son los que hemos creado y podemos comprobar que esos commits no est√°n en la rama principal (para eso especifico que lo haga sobre la rama `main`)</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log main --graph --oneline --decorate</input_code>
  <output_code>* [33m94149fc[m[33m ([m[1;32mmain[m[33m, [m[1;32mbranch_fast_forward[m[33m)[m Eliminado hola.py
* [33m4484e70[m Eliminado archivo4.py
* [33m564ccfb[m[33m ([m[1;32mnew_branch2[m[33m)[m Commit con el archivo 8
* [33m5168f78[m Eliminado archivo7.py
* [33m4bb9d75[m[33m ([m[1;32mnew_branch[m[33m)[m Commit con el archivo 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Ahora nos vamos a la rama `main`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git switch main</input_code>
  <output_code>Cambiado a rama 'main'
</output_code>
  <markdown>Creamos un nuevo commit</markdown>
  <input_code>!cd notebook_git &amp;&amp; touch file3 &amp;&amp; git add file3 &amp;&amp; git commit -m "file3"</input_code>
  <output_code>[main 8bdf4d8] file3
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 file3
</output_code>
  <markdown>Por √∫ltimo, hacemos el merge de tipo no fast forward</markdown>
  <input_code>!cd notebook_git &amp;&amp; git merge branch_no_fast_forward --no-ff</input_code>
  <output_code>[2B[m[mommit. comenzando con '#' ser√°n ignoradas, y un mensaje vac√≠o abortasaria esta[m[7m&gt;[4;1H[m[36m# especialmente si esto fusiona un upstream actualizado en una rama de t√≥pico. /home/wallabot/Documentos/web/portafolio/posts/notebook_git/.git/MERGE_MSG   [1;79H[m[22;16H[7m[ l√≠nea 1/7 (14%), col 1/48 (2%), car 0/301 (0%) ][m[22;16H             [7m[ P√°rrafo justificado ][m[K[H[7m...llabot/Documentos/web/portafolio/posts/notebook_git/.git/MERGE_MSG Modificado[1;80H[m</output_code>
  <markdown>Como vemos, nos abre el editor para introducir un mensaje de commit y un mensaje por defecto. Aceptamos el mensaje y vemos qu√© ha pasado</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama main
nada para hacer commit, el √°rbol de trabajo est√° limpio
</output_code>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>*   [33m274529c[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmain[m[33m)[m Merge branch 'branch_no_fast_forward' into main
[31m|[m[32m\[m  
[31m|[m * [33m8df3429[m[33m ([m[1;32mbranch_no_fast_forward[m[33m)[m file2
[31m|[m * [33me4e23c9[m file1
* [32m|[m [33m8bdf4d8[m file3
[32m|[m[32m/[m  
* [33m94149fc[m[33m ([m[1;32mbranch_fast_forward[m[33m)[m Eliminado hola.py
* [33m4484e70[m Eliminado archivo4.py
* [33m564ccfb[m[33m ([m[1;32mnew_branch2[m[33m)[m Commit con el archivo 8
* [33m5168f78[m Eliminado archivo7.py
* [33m4bb9d75[m[33m ([m[1;32mnew_branch[m[33m)[m Commit con el archivo 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <input_code>!cd notebook_git &amp;&amp; ls</input_code>
  <output_code>api_keys.py  archivo1.py  archivo2.py  archivo8.py  file1  file2  file3
</output_code>
  <markdown>Como vemos, se ha creado un nuevo commit con los cambios de la nueva rama en la rama principal</markdown>
  <markdown>#### Squash</markdown>
  <markdown>En este tipo de fusi√≥n, todos los commits de una nueva rama se juntan en uno solo en la rama principal, para esto escribimos `git merge &lt;rama&gt; --squash`</markdown>
  <input_code>### Este c√≥digo es para crear el gr√°fico de las ramas, no es necesario para el curso

import graphviz

# Crear el gr√°fico con la direcci√≥n de las flechas de izquierda a derecha
orin = graphviz.Digraph('G', graph_attr={'rankdir': 'LR'})
squash = graphviz.Digraph('G', graph_attr={'rankdir': 'LR'})

# Agregar nodos (pelotas) A, B, C y D en la rama principal
orin.node('A', shape='circle', label='A', color='blue')
orin.node('B', shape='circle', label='B', color='blue')
orin.node('C', shape='circle', label='C', color='blue')
orin.node('D', shape='circle', label='D', color='blue')
orin.node('E', shape='circle', label='', color='transparent')
squash.node('A', shape='circle', label='A', color='blue')
squash.node('B', shape='circle', label='B', color='blue')
squash.node('C', shape='circle', label='C', color='blue')
squash.node('D', shape='circle', label='D', color='blue')

# Agregar nodos (pelotas) X e Y en la rama secundaria
orin.node('X', shape='circle', label='X', color='green')
orin.node('Y', shape='circle', label='Y', color='green')

# Agregar nodo (pelota) M en la rama principal
squash.node('M', shape='circle', label='M', color='magenta')

# Agregar flechas entre los nodos en la rama principal
orin.edges(['AB', 'BC', 'CD'])
orin.edge('D', 'E', color='transparent')  # Hacer la flecha de C a D transparente
squash.edges(['AB', 'BC', 'CD', 'DM'])

# Agregar flechas entre los nodos en la rama secundaria
orin.edges(['DX', 'XY'])

# Mostrar el diagrama de flujo en la celda de c√≥digo de Jupyter Notebook
display(orin)
display(squash)</input_code>
  <output_code>&lt;graphviz.graphs.Digraph at 0x7f58f80e6470&gt;</output_code>
  <output_code>&lt;graphviz.graphs.Digraph at 0x7f58f80e6f80&gt;</output_code>
  <markdown>Vamos primero a comprobar que estamos en la rama principal</markdown>
  <input_code>!cd notebook_git &amp;&amp; git branch --show-current</input_code>
  <output_code>main
</output_code>
  <markdown>Creamos una nueva rama</markdown>
  <input_code>!cd notebook_git &amp;&amp; git branch branch_squash</input_code>
  <markdown>Cambiamos a ella</markdown>
  <input_code>!cd notebook_git &amp;&amp; git switch branch_squash</input_code>
  <output_code>Cambiado a rama 'branch_squash'
</output_code>
  <input_code>!cd notebook_git &amp;&amp; git branch --show-current</input_code>
  <output_code>branch_squash
</output_code>
  <markdown>Vamos a ver el log</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate --all</input_code>
  <output_code>*   [33m274529c[m[33m ([m[1;36mHEAD -&gt; [m[1;32mbranch_squash[m[33m, [m[1;32mmain[m[33m)[m Merge branch 'branch_no_fast_forward' into main
[31m|[m[32m\[m  
[31m|[m * [33m8df3429[m[33m ([m[1;32mbranch_no_fast_forward[m[33m)[m file2
[31m|[m * [33me4e23c9[m file1
* [32m|[m [33m8bdf4d8[m file3
[32m|[m[32m/[m  
* [33m94149fc[m[33m ([m[1;32mbranch_fast_forward[m[33m)[m Eliminado hola.py
* [33m4484e70[m Eliminado archivo4.py
* [33m564ccfb[m[33m ([m[1;32mnew_branch2[m[33m)[m Commit con el archivo 8
* [33m5168f78[m Eliminado archivo7.py
* [33m4bb9d75[m[33m ([m[1;32mnew_branch[m[33m)[m Commit con el archivo 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Vale, estamos en una rama creada a partir de la principal con todo su historial de logs, hacemos tres nuevos commits</markdown>
  <input_code>!cd notebook_git &amp;&amp; git rm file1 &amp;&amp; git commit -am "Eliminado file1"</input_code>
  <output_code>rm 'file1'
[branch_squash 767b632] Eliminado file1
 1 file changed, 0 insertions(+), 0 deletions(-)
 delete mode 100644 file1
</output_code>
  <input_code>!cd notebook_git &amp;&amp; git rm file2 &amp;&amp; git commit -am "Eliminado file2"</input_code>
  <output_code>rm 'file2'
[branch_squash a47f771] Eliminado file2
 1 file changed, 0 insertions(+), 0 deletions(-)
 delete mode 100644 file2
</output_code>
  <input_code>!cd notebook_git &amp;&amp; git rm file3 &amp;&amp; git commit -am "Eliminado file3"</input_code>
  <output_code>rm 'file3'
[branch_squash 85f8c9f] Eliminado file3
 1 file changed, 0 insertions(+), 0 deletions(-)
 delete mode 100644 file3
</output_code>
  <markdown>Hacemos un nuevo log para ver qu√© en esta nueva rama se han creado</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>* [33m85f8c9f[m[33m ([m[1;36mHEAD -&gt; [m[1;32mbranch_squash[m[33m)[m Eliminado file3
* [33ma47f771[m Eliminado file2
* [33m767b632[m Eliminado file1
*   [33m274529c[m[33m ([m[1;32mmain[m[33m)[m Merge branch 'branch_no_fast_forward' into main
[32m|[m[33m\[m  
[32m|[m * [33m8df3429[m[33m ([m[1;32mbranch_no_fast_forward[m[33m)[m file2
[32m|[m * [33me4e23c9[m file1
* [33m|[m [33m8bdf4d8[m file3
[33m|[m[33m/[m  
* [33m94149fc[m[33m ([m[1;32mbranch_fast_forward[m[33m)[m Eliminado hola.py
* [33m4484e70[m Eliminado archivo4.py
* [33m564ccfb[m[33m ([m[1;32mnew_branch2[m[33m)[m Commit con el archivo 8
* [33m5168f78[m Eliminado archivo7.py
* [33m4bb9d75[m[33m ([m[1;32mnew_branch[m[33m)[m Commit con el archivo 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Como vemos, los tres √∫ltimos commits son los que hemos creado y podemos comprobar que esos commits no est√°n en la rama principal (para eso especifico que lo haga sobre la rama `main`)</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log main --graph --oneline --decorate</input_code>
  <output_code>*   [33m274529c[m[33m ([m[1;32mmain[m[33m)[m Merge branch 'branch_no_fast_forward' into main
[31m|[m[32m\[m  
[31m|[m * [33m8df3429[m[33m ([m[1;32mbranch_no_fast_forward[m[33m)[m file2
[31m|[m * [33me4e23c9[m file1
* [32m|[m [33m8bdf4d8[m file3
[32m|[m[32m/[m  
* [33m94149fc[m[33m ([m[1;32mbranch_fast_forward[m[33m)[m Eliminado hola.py
* [33m4484e70[m Eliminado archivo4.py
* [33m564ccfb[m[33m ([m[1;32mnew_branch2[m[33m)[m Commit con el archivo 8
* [33m5168f78[m Eliminado archivo7.py
* [33m4bb9d75[m[33m ([m[1;32mnew_branch[m[33m)[m Commit con el archivo 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Ahora nos vamos a la rama `main` para hacer el merge</markdown>
  <input_code>!cd notebook_git &amp;&amp; git switch main</input_code>
  <output_code>Cambiado a rama 'main'
</output_code>
  <markdown>Hacemos el merge de tipo squash</markdown>
  <input_code>!cd notebook_git &amp;&amp; git merge branch_squash --squash</input_code>
  <output_code>Actualizando 274529c..85f8c9f
Fast-forward
Commit de aplastamiento -- no actualizando HEAD
 file1 | 0
 file2 | 0
 file3 | 0
 3 files changed, 0 insertions(+), 0 deletions(-)
 delete mode 100644 file1
 delete mode 100644 file2
 delete mode 100644 file3
</output_code>
  <markdown>Se ha hecho el merge, veamos qu√© ha pasado con el log en la rama `main`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>*   [33m274529c[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmain[m[33m)[m Merge branch 'branch_no_fast_forward' into main
[31m|[m[32m\[m  
[31m|[m * [33m8df3429[m[33m ([m[1;32mbranch_no_fast_forward[m[33m)[m file2
[31m|[m * [33me4e23c9[m file1
* [32m|[m [33m8bdf4d8[m file3
[32m|[m[32m/[m  
* [33m94149fc[m[33m ([m[1;32mbranch_fast_forward[m[33m)[m Eliminado hola.py
* [33m4484e70[m Eliminado archivo4.py
* [33m564ccfb[m[33m ([m[1;32mnew_branch2[m[33m)[m Commit con el archivo 8
* [33m5168f78[m Eliminado archivo7.py
* [33m4bb9d75[m[33m ([m[1;32mnew_branch[m[33m)[m Commit con el archivo 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>No aparecen los cambios realizados en la rama, hagamos un `git status`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama main
Cambios a ser confirmados:
  (usa "git restore --staged &lt;archivo&gt;..." para sacar del √°rea de stage)
	[32mborrados:        file1[m
	[32mborrados:        file2[m
	[32mborrados:        file3[m

</output_code>
  <markdown>Vemos que tenemos que hacer el commit con la fusi√≥n. Esto es porque git no sabe qu√© mensaje ponerle y nos deja a nosotros que lo hagamos, de modo que lo hacemos</markdown>
  <input_code>!cd notebook_git &amp;&amp; git commit -m "Merge squash de los commits de la rama branch_squash"</input_code>
  <output_code>[main 52acb97] Merge squash de los commits de la rama branch_squash
 3 files changed, 0 insertions(+), 0 deletions(-)
 delete mode 100644 file1
 delete mode 100644 file2
 delete mode 100644 file3
</output_code>
  <markdown>Volvemos a hacer un `git log`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>* [33m52acb97[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmain[m[33m)[m Merge squash de los commits de la rama branch_squash
*   [33m274529c[m Merge branch 'branch_no_fast_forward' into main
[32m|[m[33m\[m  
[32m|[m * [33m8df3429[m[33m ([m[1;32mbranch_no_fast_forward[m[33m)[m file2
[32m|[m * [33me4e23c9[m file1
* [33m|[m [33m8bdf4d8[m file3
[33m|[m[33m/[m  
* [33m94149fc[m[33m ([m[1;32mbranch_fast_forward[m[33m)[m Eliminado hola.py
* [33m4484e70[m Eliminado archivo4.py
* [33m564ccfb[m[33m ([m[1;32mnew_branch2[m[33m)[m Commit con el archivo 8
* [33m5168f78[m Eliminado archivo7.py
* [33m4bb9d75[m[33m ([m[1;32mnew_branch[m[33m)[m Commit con el archivo 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>### Conflictos a la hora de fusionar</markdown>
  <markdown>Cuando se fusionan ramas puede pasar que un mismo archivo haya sido modificado en varias ramas. Esto puede ser normal en proyectos donde varias personas est√°n desarrollando, as√≠ que vamos a ver c√≥mo solucionarlo</markdown>
  <markdown>#### Creamos un conflicto</markdown>
  <markdown>Comprobamos que estamos en la rama `main`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git branch --show-current</input_code>
  <output_code>main
</output_code>
  <markdown>Creamos una nueva rama a partir de √©sta</markdown>
  <input_code>!cd notebook_git &amp;&amp; git branch rama_con_conflicto</input_code>
  <markdown>A√±adimos una l√≠nea al archivo `archivo1.py`, recordamos que estamos en la rama `main`</markdown>
  <input_code>!cd notebook_git &amp;&amp; echo "print('rama main')" &gt;&gt; archivo1.py</input_code>
  <input_code>!cd notebook_git &amp;&amp; cat archivo1.py</input_code>
  <output_code>print('Este es el archivo 1')
print('rama main')
</output_code>
  <markdown>`archivo1.py` est√° modificado, hacemos un commit</markdown>
  <input_code>!cd notebook_git &amp;&amp; git add archivo1.py &amp;&amp; git commit -m "archivo1.py en rama main"</input_code>
  <output_code>[main 53f909b] archivo1.py en rama main
 1 file changed, 1 insertion(+)
</output_code>
  <markdown>Ahora nos vamos a la rama `rama_con_conflicto` y a√±adimos una nueva l√≠nea a `archivo1.py`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git switch rama_con_conflicto</input_code>
  <output_code>Cambiado a rama 'rama_con_conflicto'
</output_code>
  <input_code>!cd notebook_git &amp;&amp; git branch --show-current</input_code>
  <output_code>rama_con_conflicto
</output_code>
  <input_code>!cd notebook_git &amp;&amp; echo "print('rama rama_con_conflicto')" &gt;&gt; archivo1.py</input_code>
  <input_code>!cd notebook_git &amp;&amp; cat archivo1.py</input_code>
  <output_code>print('Este es el archivo 1')
print('rama rama_con_conflicto')
</output_code>
  <markdown>Como vemos, `archivo1.py` no es igual en la rama `main` y en la rama `rama_con_conflicto`. Hacemos un commit con la modificaci√≥n de `archivo1.py` en la rama `rama_con_conflicto`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git add archivo1.py &amp;&amp; git commit -m "archivo1.py en rama rama_con_conflicto"</input_code>
  <output_code>[rama_con_conflicto 32851c3] archivo1.py en rama rama_con_conflicto
 1 file changed, 1 insertion(+)
</output_code>
  <markdown>Volvemos a la rama `main`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git switch main</input_code>
  <output_code>Cambiado a rama 'main'
</output_code>
  <input_code>!cd notebook_git &amp;&amp; git branch --show-current</input_code>
  <output_code>main
</output_code>
  <markdown>Hacemos un merge de la rama `rama_con_conflicto`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git merge rama_con_conflicto</input_code>
  <output_code>Auto-fusionando archivo1.py
CONFLICTO (contenido): Conflicto de fusi√≥n en archivo1.py
Fusi√≥n autom√°tica fall√≥; arregle los conflictos y luego realice un commit con el resultado.
</output_code>
  <markdown>Al hacer el merge ya nos avisa que hay un conflicto en `archivo1.py` y que no se ha podido hacer el merge. Hacemos un `git status`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama main
Tienes rutas no fusionadas.
  (arregla los conflictos y ejecuta "git commit"
  (usa "git merge --abort" para abortar la fusion)

Rutas no fusionadas:
  (usa "git add &lt;archivo&gt;..." para marcar una resoluci√≥n)
	[31mmodificados por ambos:  archivo1.py[m

sin cambios agregados al commit (usa "git add" y/o "git commit -a")
</output_code>
  <markdown>Nos dice lo mismo, pero nos da m√°s informaci√≥n, nos dice que podemos abortar la fusi√≥n con `git merge --abort`. Pero en lugar de eso vamos a solucionarlo</markdown>
  <markdown>#### Solucionar un conflicto</markdown>
  <markdown>En nuestro caso sabemos d√≥nde est√° el problema, pero en caso de no saberlo, mediante `git diff` podemos encontrar el problema</markdown>
  <input_code>!cd notebook_git &amp;&amp; git diff archivo1.py</input_code>
  <output_code>[1mdiff --cc archivo1.py[m
[1mindex 8b4bf58,b5c003c..0000000[m
[1m--- a/archivo1.py[m
[1m+++ b/archivo1.py[m
[36m@@@ -1,2 -1,2 +1,6 @@@[m
  print('Este es el archivo 1')[m
[32m++&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD[m
[32m +print('rama main')[m
[32m++=======[m
[32m+ print('rama rama_con_conflicto')[m
[32m++&gt;&gt;&gt;&gt;&gt;&gt;&gt; rama_con_conflicto[m
</output_code>
  <markdown>`git diff` nos est√° diciendo que el problema est√° en la √∫ltima l√≠ea. La versi√≥n del archivo de la rama `HEAD` (en la que estamos actualmente `main`) tiene `print('rama main')` en la √∫ltima l√≠nea, mientras que la versi√≥n de la rama `rama_con_conflicto` tiene `print('rama rama_con_conflicto')` en la √∫ltima l√≠nea. De modo que hay que abrir el fichero con cualquier editor y solucionar esto.</markdown>
  <markdown>Tras editar el fichero con mi editor de c√≥digo he quitado todas las l√≠neas que sobran y se ha quedado as√≠</markdown>
  <input_code>!cd notebook_git &amp;&amp; cat archivo1.py</input_code>
  <output_code>print('Este es el archivo 1')
print('rama main')</output_code>
  <markdown>Ahora hacemos un `git status` para ver qu√© tenemos que hacer</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama main
Tienes rutas no fusionadas.
  (arregla los conflictos y ejecuta "git commit"
  (usa "git merge --abort" para abortar la fusion)

Rutas no fusionadas:
  (usa "git add &lt;archivo&gt;..." para marcar una resoluci√≥n)
	[31mmodificados por ambos:  archivo1.py[m

sin cambios agregados al commit (usa "git add" y/o "git commit -a")
</output_code>
  <markdown>Nos dice que tenemos el archivo `archivo1.py` con modificaciones, por lo que lo a√±adimos al √°rea de `staged` y luego hacemos un commit</markdown>
  <input_code>!cd notebook_git &amp;&amp; git add archivo1.py &amp;&amp; git commit -m "archivo1.py con el merge resuelto"</input_code>
  <output_code>[main 679bb49] archivo1.py con el merge resuelto
</output_code>
  <markdown>Volvemos a hacer un `git status` a ver si se ha solucionado</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama main
nada para hacer commit, el √°rbol de trabajo est√° limpio
</output_code>
  <markdown>Parece que se ha resuelto, hacemos un `git log` para comprobarlo</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>*   [33m679bb49[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmain[m[33m)[m archivo1.py con el merge resuelto
[31m|[m[32m\[m  
[31m|[m * [33m32851c3[m[33m ([m[1;32mrama_con_conflicto[m[33m)[m archivo1.py en rama rama_con_conflicto
* [32m|[m [33m53f909b[m archivo1.py en rama main
[32m|[m[32m/[m  
* [33m52acb97[m Merge squash de los commits de la rama branch_squash
*   [33m274529c[m Merge branch 'branch_no_fast_forward' into main
[33m|[m[34m\[m  
[33m|[m * [33m8df3429[m[33m ([m[1;32mbranch_no_fast_forward[m[33m)[m file2
[33m|[m * [33me4e23c9[m file1
* [34m|[m [33m8bdf4d8[m file3
[34m|[m[34m/[m  
* [33m94149fc[m[33m ([m[1;32mbranch_fast_forward[m[33m)[m Eliminado hola.py
* [33m4484e70[m Eliminado archivo4.py
* [33m564ccfb[m[33m ([m[1;32mnew_branch2[m[33m)[m Commit con el archivo 8
* [33m5168f78[m Eliminado archivo7.py
* [33m4bb9d75[m[33m ([m[1;32mnew_branch[m[33m)[m Commit con el archivo 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>### Eliminar ramas</markdown>
  <markdown>La idea de una rama es abrirla para desarrollar una nueva funcionalidad o caracter√≠stica de manera que no afecte al resto del equipo de desarrollo. Por lo tanto cuando esto est√° conseguido se fusiona con la rama principal. As√≠ que despu√©s de la fusi√≥n ya no tiene sentido mantener la rama por lo que hay que eliminarla, pero se har√° de una manera diferente si la rama se ha fusionado o no con la principal</markdown>
  <markdown>#### Eliminar ramas que se han fusionado (`git branch -d &lt;rama&gt;`)</markdown>
  <markdown>Para eliminar una rama sobre la que ya se ha hecho la fusi√≥n con la principal solo hay que hacer `git branch -d &lt;rama&gt;` o `git branch --delete &lt;rama&gt;`. Vamos a eliminar la √∫ltima rama que hemos creado y fusionado</markdown>
  <input_code>!cd notebook_git &amp;&amp; git branch -d rama_con_conflicto</input_code>
  <output_code>Eliminada la rama rama_con_conflicto (era 32851c3).
</output_code>
  <markdown>Si ahora listamos todas las ramas, podemos ver que ya no tendremos `rama_con_conflicto`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git branch</input_code>
  <output_code>  branch_fast_forward[m
  branch_no_fast_forward[m
  branch_squash[m
* [32mmain[m
  new_branch[m
  new_branch2[m
</output_code>
  <markdown>#### Eliminar ramas que no se han fusionado con la rama principal (`git branch -D &lt;rama&gt;`)</markdown>
  <markdown>Si intentamos hacer lo mismo que antes con una rama que nunca se ha fusionado con otra, obtendremos un error</markdown>
  <markdown>Vamos a crear una nueva rama, vamos a hacer un commit y no la vamos a fusionar</markdown>
  <input_code>!cd notebook_git &amp;&amp; git branch branch_sin_fusion</input_code>
  <input_code>!cd notebook_git &amp;&amp; git switch branch_sin_fusion</input_code>
  <output_code>Cambiado a rama 'branch_sin_fusion'
</output_code>
  <input_code>!cd notebook_git &amp;&amp; touch file4 &amp;&amp; git add file4 &amp;&amp; git commit -m "file4"</input_code>
  <output_code>[branch_sin_fusion 9506b0a] file4
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 file4
</output_code>
  <input_code>!cd notebook_git &amp;&amp; git switch main</input_code>
  <output_code>Cambiado a rama 'main'
</output_code>
  <markdown>Con todo lo que hemos aprendido hasta ahora, podemos ver que lo que hemos hecho ha sido crear una nueva rama, cambiar a ella, crear un nuevo archivo, hacer un commit y volver a la rama `main`. Ahora vamos a intentar eliminar esta nueva rama</markdown>
  <input_code>!cd notebook_git &amp;&amp; git branch -d branch_sin_fusion</input_code>
  <output_code>error: La rama 'branch_sin_fusion' no ha sido fusionada completamente.
Si est√°s seguro de querer borrarla, ejecuta 'git branch -D branch_sin_fusion'.
</output_code>
  <markdown>Como vemos, nos dice que `branch_sin_fusion` no ha sido fusionada por lo que no se ha eliminado y que si estamos seguros de eliminarla tenemos que hacer `git branch -D branch_sin_fusion`, de modo que lo hacemos para eliminarla</markdown>
  <input_code>!cd notebook_git &amp;&amp; git branch -D branch_sin_fusion</input_code>
  <output_code>Eliminada la rama branch_sin_fusion (era 9506b0a).
</output_code>
  <markdown>Ahora s√≠ se ha eliminado</markdown>
  <markdown>## Trabajando con repositorios remotos</markdown>
  <markdown>Cuando desarrollamos software no lo solemos hacer solos, solemos trabajar en equipo, por lo que no tiene sentido tener un repositorio local de git, sino tener un repositorio remoto con el que todos trabajemos y compartamos los avances

 &gt; Nota: El objetivo de este post es explicar git. Para la conexi√≥n con repositorios remotos voy a explicarlo con GitHub porque es el servicio de hosting de repositorios git m√°s usado, pero no voy a entrar en profundizar en GitHub</markdown>
  <markdown>### Clonar un repositorio remoto (`git clone &lt;repositorio&gt;`)</markdown>
  <markdown>Si empezamos a trabajar en un repositorio que ya ha sido creado, lo primero que tenemos que hacer es clonarlo, para ello lo que tenemos que hacer es `git clone &lt;repositorio&gt;`, donde `&lt;repositorio&gt;` puede ser una URL o una direcci√≥n SSH. Como ahora mismo todo el tema de los grandes modelos de lenguaje y ChatGPT est√°n muy de moda, vamos a clonar un repositorio opensource creado por la comunidad, [Open-Assistant](https://github.com/LAION-AI/Open-Assistant), para ello haremos `git clone https://github.com/LAION-AI/Open-Assistant`</markdown>
  <input_code>!git clone https://github.com/LAION-AI/Open-Assistant.git</input_code>
  <output_code>Clonando en 'Open-Assistant'...
remote: Enumerating objects: 29769, done.[K
remote: Counting objects: 100% (673/673), done.[K
remote: Compressing objects: 100% (310/310), done.[K
remote: Total 29769 (delta 398), reused 577 (delta 354), pack-reused 29096[K
Recibiendo objetos: 100% (29769/29769), 33.61 MiB | 29.29 MiB/s, listo.
Resolviendo deltas: 100% (19967/19967), listo.
</output_code>
  <markdown>Esto nos crea la carpeta `Open-Assistant` con todo el c√≥digo del repositorio, podemos entrar adentro y ver todo el c√≥digo</markdown>
  <input_code>!cd Open-Assistant &amp;&amp; ls</input_code>
  <output_code>ansible		 deploy		      model	      safety
assets		 discord-bots	      notebooks       scripts
backend		 docker		      oasst-data      setup.cfg
CODEOWNERS	 docker-compose.yaml  oasst-shared    text-frontend
CONTRIBUTING.md  docs		      pyproject.toml  website
copilot		 inference	      README.md
data		 LICENSE	      redis.conf
</output_code>
  <markdown>Elimino la carpeta</markdown>
  <input_code>!rm -r Open-Assistant</input_code>
  <markdown>### Enlazar un repositorio local en uno remoto</markdown>
  <markdown>Si ocurre al rev√©s, si primero empezamos a desarrollar en local y luego lo queremos sincronizar con un repositorio remoto, tenemos que hacer lo siguiente

 * Primero crear un repositorio remoto vac√≠o, en mi caso he creado el repositorio `notebook_git` en GitHub que m√°s tarde borrar√©
 * Obtener la URL del repositorio o direcci√≥n SSH
 * Sincronizarlos mediante `git remote add origin &lt;URL&gt;`

El repositorio vac√≠o que he creado en GitHub se ve as√≠

![notebook git repo](https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/notebook_git_repo.webp)

En mi caso voy a usar la direcci√≥n SSH que es `git@github.com:maximofn/notebook_git.git`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git remote add origin git@github.com:maximofn/notebook_git.git</input_code>
  <markdown>Ya est√°n enlazados, pero para asegurarnos podemos hacer `git remote -v`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git remote -v</input_code>
  <output_code>origin	git@github.com:maximofn/notebook_git.git (fetch)
origin	git@github.com:maximofn/notebook_git.git (push)
</output_code>
  <markdown>### Subir los cambios de un repositorio local a un repositorio remoto (`git push`)</markdown>
  <markdown>Como hemos dicho, est√°n enlazados, pero si voy a mi repositorio en GitHub se sigue viendo as√≠

![notebook git repo](https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/notebook_git_repo.webp)

Est√°n enlazados el repositorio local y el remoto, pero ahora hay que mandar todos los cambios del repositorio local al remoto, para ello habr√≠a que usar `git push origin &lt;rama local&gt;:&lt;rama remota&gt;`, es decir, como nuestra rama principal se llama `main` y la rama principal en GitHub se llama `main` habr√≠a que hacer `git push origin main:main`.
Si te acuerdas git por defecto llamaba a la rama principal `master`, pero GitHub llama por defecto a la rama principal `main` por lo que si cada persona llama en su repositorio local a sus ramas de una manera hay que especificar qu√© rama en local escribe a qu√© rama en remoto</markdown>
  <markdown>Se puede configurar la conexi√≥n por defecto entre ramas en git, para ello hay que hacer `git push --set-upstream origin main`. Esto establece relaci√≥n entre la rama local `main` y la rama remota `main`. Una vez hecha esta relaci√≥n ya solo es necesario hacer `git push` para subir los cambios que se hacen en local al servidor remoto.

De modo que establecemos la conexi√≥n entre ramas</markdown>
  <input_code>!cd notebook_git &amp;&amp; git push --set-upstream origin main</input_code>
  <output_code>Enumerando objetos: 51, listo.
Contando objetos: 100% (51/51), listo.
Compresi√≥n delta usando hasta 12 hilos
Comprimiendo objetos: 100% (38/38), listo.
Escribiendo objetos: 100% (51/51), 4.21 KiB | 2.11 MiB/s, listo.
Total 51 (delta 18), reusado 0 (delta 0)
remote: Resolving deltas: 100% (18/18), done.[K
To github.com:maximofn/notebook_git.git
 * [new branch]      main -&gt; main
Rama 'main' configurada para hacer seguimiento a la rama remota 'main' de 'origin'.
</output_code>
  <markdown>Ahora ya podemos hacer solo `git push` para subir los cambios locales al repositorio remoto</markdown>
  <input_code>!cd notebook_git &amp;&amp; git push</input_code>
  <output_code>Everything up-to-date
</output_code>
  <markdown>Si ahora volvemos a nuestro repositorio de GitHub, se ve as√≠

![notebook git repo push](https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/notebook_git_repo_push.webp)</markdown>
  <markdown>Si hacemos un `ls` en nuestro repositorio local podremos ver que los archivos que tenemos en el repositorio remoto los tenemos en el repositorio local, es decir, hemos sincronizado el repositorio local y remoto</markdown>
  <input_code>!cd notebook_git &amp;&amp; ls -a</input_code>
  <output_code>.  ..  api_keys.py  archivo1.py  archivo2.py  archivo8.py  .git  .gitignore
</output_code>
  <markdown>Los √∫nicos que no est√°n en el repositorio remoto son `api_keys.py`, que es el que a√±adimos al archivo `.gitignore`, es decir, el que dijimos a git que no siguiera. Y `.git` que es donde est√° la configuraci√≥n de nuestro repositorio local y que no se tiene que subir al repositorio remoto, porque cada persona tendr√° su propia configuraci√≥n de git y por tanto no se tiene que sincronizar</markdown>
  <markdown>### Descargar los cambios de un repositorio remoto a un repositorio local (`git pull`)</markdown>
  <markdown>Ahora vamos a hacer al rev√©s, vamos a bajar los nuevos cambios que se hayan hecho en el repositorio remoto. Si nos fijamos en c√≥mo est√° el repositorio remoto podremos ver que hay un bot√≥n que pone `Add a README`, por lo que le damos para a√±adirlo

![notebook git repo push](https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/notebook_git_repo_push.webp)</markdown>
  <markdown>Al hacer clic se nos abrir√° un editor, dejamos lo que ha puesto GitHub y guardamos los cambios d√°ndole al bot√≥n de `Commit changes...`

![noteboot git repo readme](https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/notebook_git_repo_readme.webp)

Nos saldr√° una ventana en la que nos pedir√° un mensaje de commit, dejamos el que viene por defecto y le damos a `Commit changes`

![notebook git repo commit message](https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/notebook_git_repo_commit_message.webp)

Al hacer eso el repositorio se nos quedar√° as√≠

![notebook git repo pull](https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/notebook_git_repo_pull.webp)

Se ha creado un nuevo archivo llamado `README.md`, pero si hacemos `ls` en el repositorio local no lo encontraremos</markdown>
  <input_code>!cd notebook_git &amp;&amp; ls | grep README</input_code>
  <markdown>Por lo que nos tenemos que traer los cambios del repositorio remoto al local, para ello hay que hacer `git pull origin &lt;rama remota&gt;` para decirle a git sobre qu√© rama remota vamos a traer los datos, pero al igual que antes podemos establecer una relaci√≥n entre la rama remota y la rama local de la siguiente manera `git branch --set-upstream-to=origin/&lt;rama local&gt; &lt;rama remota&gt;`, pero como nuestra rama local se llama `main` y la rama remota GitHub la llama `main` habr√≠a que cambiar lo anterior por `git branch --set-upstream-to=origin/main main`.

Una vez hecho esto para descargar los nuevos cambios del repositorio remoto al local solo habr√≠a que hacer `git pull`</markdown>
  <markdown>Vamos a establecer la relaci√≥n entre ramas con `git branch --set-upstream-to=origin/main main`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git branch --set-upstream-to=origin/main main</input_code>
  <output_code>Rama 'main' configurada para hacer seguimiento a la rama remota 'main' de 'origin'.
</output_code>
  <markdown>Ahora podemos traer los cambios del repositorio remoto al repositorio local con `git pull`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git pull</input_code>
  <output_code>remote: Enumerating objects: 4, done.[K
remote: Counting objects: 100% (4/4), done.[K
remote: Compressing objects: 100% (2/2), done.[K
remote: Total 3 (delta 1), reused 0 (delta 0), pack-reused 0[K
Desempaquetando objetos: 100% (3/3), 646 bytes | 646.00 KiB/s, listo.
Desde github.com:maximofn/notebook_git
   679bb49..527e07a  main       -&gt; origin/main
Actualizando 679bb49..527e07a
Fast-forward
 README.md | 1 [32m+[m
 1 file changed, 1 insertion(+)
 create mode 100644 README.md
</output_code>
  <markdown>Como vemos, dice que se ha a√±adido `README.md`, lo comprobamos haciendo `ls`</markdown>
  <input_code>!cd notebook_git &amp;&amp; ls | grep README</input_code>
  <output_code>README.md
</output_code>
  <markdown>Tenemos el archivo en local</markdown>
  <markdown>### Sincronizar las ramas remotas y locales</markdown>
  <markdown>Como hemos visto, hemos tenido que sincronizar las ramas remotas y locales para poder subir y bajar los datos. Sin embargo, si primero creamos el repositorio en GitHub y despu√©s lo clonamos, ya no es necesario dicha sincronizaci√≥n.</markdown>
  <markdown>## Alias</markdown>
  <markdown>Cada vez que hemos querido hacer un log hemos usado este comando `git log --graph --oneline --decorate`, sin embargo acordarse de este comando es bastante complicado, de hecho yo no me acuerdo de √©l, cada vez que lo he querido usar lo he tenido que buscar porque no lo recordaba, por lo que estar√≠a muy bien tener una manera de abreviarlo.</markdown>
  <markdown>Para esto git ofrece los `alias`, de manera que puedes crearte alias de los comandos que t√∫ quieras, para ello tienes que hacer `git config --global alias.&lt;nombre del alias&gt; "comando"`</markdown>
  <markdown>Por tanto vamos a llamar `git tree` al comando `git log --graph --oneline --decorate`, ya que nos permite ver el historial, con la bifurcaci√≥n y fusi√≥n de ramas como si fuese el crecimiento de un √°rbol, por lo que hacemos `git config --global alias.tree "log --graph --oneline --decorate"`

 &gt; **Importante**: No hay que poner la palabra `git` dentro del comando</markdown>
  <input_code>!git config --global alias.tree "log --graph --oneline --decorate"</input_code>
  <markdown>Si ahora nos vamos a nuestro repositorio y hacemos `git tree` veremos el historial como lo hac√≠amos antes</markdown>
  <input_code>!cd notebook_git &amp;&amp; git tree</input_code>
  <output_code>* [33m527e07a[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmain[m[33m, [m[1;31morigin/main[m[33m)[m Create README.md
*   [33m679bb49[m archivo1.py con el merge resuelto
[32m|[m[33m\[m  
[32m|[m * [33m32851c3[m archivo1.py en rama rama_con_conflicto
* [33m|[m [33m53f909b[m archivo1.py en rama main
[33m|[m[33m/[m  
* [33m52acb97[m Merge squash de los commits de la rama branch_squash
*   [33m274529c[m Merge branch 'branch_no_fast_forward' into main
[34m|[m[35m\[m  
[34m|[m * [33m8df3429[m[33m ([m[1;32mbranch_no_fast_forward[m[33m)[m file2
[34m|[m * [33me4e23c9[m file1
* [35m|[m [33m8bdf4d8[m file3
[35m|[m[35m/[m  
* [33m94149fc[m[33m ([m[1;32mbranch_fast_forward[m[33m)[m Eliminado hola.py
* [33m4484e70[m Eliminado archivo4.py
* [33m564ccfb[m[33m ([m[1;32mnew_branch2[m[33m)[m Commit con el archivo 8
* [33m5168f78[m Eliminado archivo7.py
* [33m4bb9d75[m[33m ([m[1;32mnew_branch[m[33m)[m Commit con el archivo 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Como vemos, se ha creado nuestro alias</markdown>
  <markdown>### Alias de comandos existentes de git</markdown>
  <markdown>Se pueden crear alias de comandos que ya existen en git, de hecho, es una pr√°ctica que usa mucha gente, sobre todo para abreviar, por lo que vamos a hacer uno. Vamos a hacer un alias del comando `git status` y lo vamos a renombrar como `git st` de la siguiente manera `git config --global alias.st "status"`</markdown>
  <input_code>!git config --global alias.st "status"</input_code>
  <markdown>Lo probamos ahora</markdown>
  <input_code>!cd notebook_git &amp;&amp; git st</input_code>
  <output_code>En la rama main
Tu rama est√° actualizada con 'origin/main'.

nada para hacer commit, el √°rbol de trabajo est√° limpio
</output_code>
  <markdown>Ya tenemos el comando `git status` simplificado a `git st`</markdown>
  <markdown>### Alias de comandos que no son de git</markdown>
  <markdown>Podemos crearnos alias de comandos que no sean de git, por ejemplo, porque creamos que git necesita ese nuevo comando, se hace igual con la excepci√≥n de que el comando tiene que ir precedido de `!`, es decir, ser√≠a `git config --global alias.&lt;nombre del alias&gt; "!comando"`</markdown>
  <markdown>Cuando hemos visto los conflictos, hemos visto que git nos dec√≠a d√≥nde estaban, pero para solucionarlos tenemos que editar el c√≥digo nosotros mismos, por lo que podemos crear un alias de git de manera que podamos abrir un archivo con el editor de textos que queramos, en mi caso voy a crear un alias que me abrir√° los archivos con `vscode` para ello tengo que hacer `git config --global alias.code "!code"`</markdown>
  <input_code>!git config --global alias.code "!code"</input_code>
  <markdown>Lo probamos</markdown>
  <input_code>!cd notebook_git &amp;&amp; git code README.md</input_code>
  <markdown>Tras hacer esto, se me ha abierto `README.md` en `vscode`</markdown>
  <markdown>### Lista con todos los alias</markdown>
  <markdown>En caso de no acordarnos de los alias que hemos creado podemos ver la configuraci√≥n global de git, pero como esto puede ser un poco abrumador porque nos da mucha informaci√≥n, podemos filtrar para que nos muestre solo los alias que hemos creado, para ello usamos `git config --get-regexp ^alias\.`</markdown>
  <input_code>!git config --get-regexp ^alias\.</input_code>
  <output_code>alias.tree log --graph --oneline --decorate
alias.st status
alias.code !code
</output_code>
  <markdown>Obtenemos los alias que hemos creado</markdown>
  <markdown>Pero aun mejor, podemos crear un alias para obtener los alias, para ello hacemos `git config --global alias.alias "config --get-regexp ^alias\."`</markdown>
  <input_code>!git config --global alias.alias "config --get-regexp ^alias\."</input_code>
  <markdown>Si ahora hacemos `git alias`</markdown>
  <input_code>!git alias</input_code>
  <output_code>alias.tree log --graph --oneline --decorate
alias.st status
alias.code !code
alias.alias config --get-regexp ^alias\.
</output_code>
  <markdown>Obtenemos la lista con todos nuestros alias</markdown>
  <markdown>## Almac√©n stash (`git stash`)</markdown>
  <markdown>Supongamos que estamos trabajando en una rama, tenemos varios archivos modificados, no hemos hecho commit, y por la raz√≥n que sea tenemos que pasar a otra rama. Por ejemplo, estamos en una rama desarrollando una nueva funcionalidad, y la tenemos que dejar a medias porque hay un bug cr√≠tico en la rama main

Una soluci√≥n ser√≠a hacer un commit para guardar los cambios y volver m√°s adelante. Pero a lo mejor hemos dejado el c√≥digo a medias y no queremos hacer un commit. As√≠ que para ello se invent√≥ el stash, que es como un almac√©n, donde dejas almacenado tu c√≥digo para luego poder volver a recuperarlo.

Es una pila, eso quiere decir que lo √∫ltimo que entra es lo primero en salir</markdown>
  <markdown>Veamos c√≥mo hacerlo, en primer lugar creamos una nueva rama que vamos a llamar `new_feature`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git branch new_feature</input_code>
  <markdown>Cambiamos a ella</markdown>
  <input_code>!cd notebook_git &amp;&amp; git switch new_feature</input_code>
  <output_code>Cambiado a rama 'new_feature'
</output_code>
  <markdown>Vamos a modificar `archivo2.py` y `archivo8.py`</markdown>
  <input_code>!cd notebook_git &amp;&amp; echo "print('new_feature')" &gt;&gt; archivo2.py &amp;&amp; echo "print('new_feature')" &gt;&gt; archivo8.py</input_code>
  <markdown>Hacemos un `git status` para comprobar que se hayan modificado</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama new_feature
Cambios no rastreados para el commit:
  (usa "git add &lt;archivo&gt;..." para actualizar lo que ser√° confirmado)
  (usa "git restore &lt;archivo&gt;..." para descartar los cambios en el directorio de trabajo)
	[31mmodificados:     archivo2.py[m
	[31mmodificados:     archivo8.py[m

sin cambios agregados al commit (usa "git add" y/o "git commit -a")
</output_code>
  <markdown>Vamos a meter a `archivo8.py` al √°rea de `staged`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git add archivo8.py</input_code>
  <markdown>Volvemos a hacer un `git status`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama new_feature
Cambios a ser confirmados:
  (usa "git restore --staged &lt;archivo&gt;..." para sacar del √°rea de stage)
	[32mmodificados:     archivo8.py[m

Cambios no rastreados para el commit:
  (usa "git add &lt;archivo&gt;..." para actualizar lo que ser√° confirmado)
  (usa "git restore &lt;archivo&gt;..." para descartar los cambios en el directorio de trabajo)
	[31mmodificados:     archivo2.py[m

</output_code>
  <markdown>Como vemos tenemos dos archivos modificados, de los cuales uno de ellos adem√°s est√° en el √°rea de `staged`. Si ahora tuvi√©semos que cambiar de rama, para no perder los cambios podr√≠amos hacer un commit, o guardarlos en el almac√©n `stash`, as√≠ que vamos a hacer esto √∫ltimo mediante `git stash`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git stash</input_code>
  <output_code>Directorio de trabajo y estado de √≠ndice WIP on new_feature: 527e07a Create README.md guardados
</output_code>
  <markdown>Si ahora volvemos a hacer `git status`, veamos qu√© pasa</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama new_feature
nada para hacer commit, el √°rbol de trabajo est√° limpio
</output_code>
  <markdown>Ya no aparecen los archivos con modificaciones, es como si hubi√©ramos hecho un commit</markdown>
  <markdown> &gt; **Importante**: Los archivos creados nuevos, que nunca han sido seguidos por Git, no se ir√°n al almac√©n, por lo que con los archivos nuevos es necesario, al menos, hacer primero un `git add`</markdown>
  <markdown>Si yo ahora creo un archivo nuevo y lo intento llevar al almac√©n, me dar√° un error</markdown>
  <input_code>!cd notebook_git &amp;&amp; touch archivo9.py</input_code>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama new_feature
Archivos sin seguimiento:
  (usa "git add &lt;archivo&gt;..." para incluirlo a lo que se ser√° confirmado)
	[31marchivo9.py[m

no hay nada agregado al commit pero hay archivos sin seguimiento presentes (usa "git add" para hacerles seguimiento)
</output_code>
  <input_code>!cd notebook_git &amp;&amp; git stash</input_code>
  <output_code>No hay cambios locales para guardar
</output_code>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama new_feature
Archivos sin seguimiento:
  (usa "git add &lt;archivo&gt;..." para incluirlo a lo que se ser√° confirmado)
	[31marchivo9.py[m

no hay nada agregado al commit pero hay archivos sin seguimiento presentes (usa "git add" para hacerles seguimiento)
</output_code>
  <markdown>Como vemos `archivo9.py` no lo ha guardado en el almac√©n, por lo que habr√≠a que haberlo a√±adido con `git add`.</markdown>
  <input_code>!cd notebook_git &amp;&amp; rm archivo9.py</input_code>
  <markdown>### Todo al almac√©n stash (`git stash -u -a`)</markdown>
  <markdown>Como hemos visto solo se mandan al almac√©n los archivos a los que git les est√° haciendo seguimiento, pero si tenemos nuevos archivos creados, o archivos ignorados, no se mandar√°n, as√≠ que para solucionar esto podemos usar los flags `-u` o `--include-untracked` para que mande los nuevos archivos a los que git a√∫n no ha hecho seguimiento, y el flag `-a` o `--all` para incluir todo, incluso los archivos ignorados</markdown>
  <markdown>### Lista de almacenes (`git stash list`)</markdown>
  <markdown>Como hemos comentado el almac√©n act√∫a como una pila, por lo que si hacemos uso de este almac√©n muchas veces, en realidad vamos a tener una lista de almacenes, y para ver los que tenemos almacenados podemos usar `git stash list`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git stash list</input_code>
  <output_code>stash@{0}: WIP on new_feature: 527e07a Create README.md
</output_code>
  <markdown>Como vemos solo tenemos una, que nos indica la rama (`on new_feature`), el √∫ltimo commit (`Create README.md`) y un identificador (`527e07a`)</markdown>
  <markdown>### Almac√©n con descripci√≥n (`git stash push -m &lt;descripci√≥n&gt;)`)</markdown>
  <markdown>Como hemos visto, la lista nos devuelve la rama y el √∫ltimo commit, pero esta informaci√≥n solo nos vale para saber desde d√≥nde hemos empezado a modificar antes de guardar en el historial. Adem√°s nos devuelve un identificador que no nos dice mucho, as√≠ que podemos a√±adir una primera descripci√≥n al stash con `git stash push -m &lt;descripci√≥n&gt;`</markdown>
  <markdown>Primero hacemos un `git status` para ver qu√© tenemos sin commitear</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama new_feature
Archivos sin seguimiento:
  (usa "git add &lt;archivo&gt;..." para incluirlo a lo que se ser√° confirmado)
	[31marchivo9.py[m

no hay nada agregado al commit pero hay archivos sin seguimiento presentes (usa "git add" para hacerles seguimiento)
</output_code>
  <markdown>Tenemos `archivo9.py`, pero recordemos que nunca ha sido seguido por git, por lo que para incluirlo en un stash tenemos que usar el flag `-u` o el flag `-a`, de modo que creamos un nuevo stash con una descripci√≥n con el comando `git stash push -u -m &lt;descripci√≥n&gt;`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git stash push -u -m "archivo9.py"</input_code>
  <output_code>Directorio de trabajo y estado de √≠ndice On new_feature: archivo9.py guardados
</output_code>
  <markdown>Sacamos la lista del stash</markdown>
  <input_code>!cd notebook_git &amp;&amp; git stash list</input_code>
  <output_code>stash@{0}: On new_feature: archivo9.py
stash@{1}: WIP on new_feature: 527e07a Create README.md
</output_code>
  <markdown>Ya aparece el nuevo de manera mucho m√°s clara</markdown>
  <markdown>### Recuperar el √∫ltimo stash (`git stash pop`)</markdown>
  <markdown>Como hemos dicho, el stash es una pila con almacenes, por lo que a la hora de recuperarlos lo haremos igual que una pila, recuperando siempre el √∫ltimo.

![git stash push pop](https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/git-stash-push-pop.webp)

Para recuperar el √∫ltimo stash tenemos que hacer `git stash pop`</markdown>
  <markdown>Primero hacemos un `git status` para ver que no tengamos ning√∫n cambio pendiente</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama new_feature
nada para hacer commit, el √°rbol de trabajo est√° limpio
</output_code>
  <markdown>Ahora recuperamos el √∫ltimo stash</markdown>
  <input_code>!cd notebook_git &amp;&amp; git stash pop</input_code>
  <output_code>En la rama new_feature
Cambios a ser confirmados:
  (usa "git restore --staged &lt;archivo&gt;..." para sacar del √°rea de stage)
	[32mnuevos archivos: archivo9.py[m

Descartado refs/stash@{0} (0246b0e922f654e7fc68cfeaf26e24fc511feb37)
</output_code>
  <markdown>Si volvemos a hacer git status, veremos que volvemos a tener `archivo9.py` pendiente de hacer un commit</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama new_feature
Cambios a ser confirmados:
  (usa "git restore --staged &lt;archivo&gt;..." para sacar del √°rea de stage)
	[32mnuevos archivos: archivo9.py[m

</output_code>
  <markdown>Y si comprobamos la lista de stash veremos que ya solo tenemos uno</markdown>
  <input_code>!cd notebook_git &amp;&amp; git stash list</input_code>
  <output_code>stash@{0}: WIP on new_feature: 527e07a Create README.md
</output_code>
  <markdown>### Eliminar un stash (`git stash drop &lt;posici√≥n&gt;`)</markdown>
  <markdown>Si queremos eliminar un stash, tenemos que hacer `git stash drop &lt;posici√≥n&gt;`, donde `&lt;posici√≥n&gt;` es la posici√≥n que ocupa el stash en la lista.</markdown>
  <markdown>Obtenemos la lista de los stash</markdown>
  <input_code>!cd notebook_git &amp;&amp; git stash list</input_code>
  <output_code>stash@{0}: WIP on new_feature: 527e07a Create README.md
</output_code>
  <markdown>En nuestro caso solo tenemos uno y en la posici√≥n 0 (`stash@{0}`), por lo que para eliminarlo tendr√≠amos que hacer `git stash drop 0`, sin embargo no lo voy a hacer porque lo voy a eliminar ahora despu√©s con otro comando</markdown>
  <markdown>### Eliminar todos los stash (`git stash clear`)</markdown>
  <markdown>Si queremos vaciar la lista entera de stash tenemos que hacer `git stash clear`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git stash clear</input_code>
  <markdown>Si ahora pedimos la lista de stash</markdown>
  <input_code>!cd notebook_git &amp;&amp; git stash list</input_code>
  <markdown>No obtenemos nada porque hemos eliminado todo</markdown>
  <markdown>Vamos a dejar todo como estaba, hacemos un `git status` para recordar los cambios que ten√≠amos pendientes</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama new_feature
Cambios a ser confirmados:
  (usa "git restore --staged &lt;archivo&gt;..." para sacar del √°rea de stage)
	[32mnuevos archivos: archivo9.py[m

</output_code>
  <markdown>Vemos que estamos en la rama `new_feature` y que tenemos `archivo9.py` pendiente de hacer un commit. Como lo hemos creado para el ejemplo, lo eliminamos y volvemos a la rama principal</markdown>
  <input_code>!cd notebook_git &amp;&amp; git reset archivo9.py</input_code>
  <input_code>!cd notebook_git &amp;&amp; rm archivo9.py</input_code>
  <input_code>!cd notebook_git &amp;&amp; git switch main</input_code>
  <output_code>Cambiado a rama 'main'
Tu rama est√° actualizada con 'origin/main'.
</output_code>
  <markdown>## Tags</markdown>
  <markdown>Cuando estamos desarrollando c√≥digo llegan momentos en los que generamos versiones, por ejemplo la `v1.1`, `v1.2`, etc. Para tener esto m√°s controlado git nos proporciona los tags.</markdown>
  <markdown>### Crear un tag nuevo (`git tag -a &lt;nombre_de_etiqueta&gt; -m "&lt;mensaje&gt;"`)</markdown>
  <markdown>Para crear un tag tenemos que hacer `git tag -a &lt;nombre_de_etiqueta&gt; -m "&lt;mensaje&gt;"`</markdown>
  <markdown>Por ejemplo, vamos a crear un tag en la versi√≥n actual del repositorio, para ello har√© `git tag -a v_tag -m "Tag con el repositorio en la parte final, en la que explicamos los tags"`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git tag -a v_tag -m "Tag con el repositorio en la parte final, en la que explicamos los tags"</input_code>
  <markdown>### Lista de tags (`git tag`)</markdown>
  <markdown>Para ver los tags que hemos creado podemos hacer `git tag`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git tag</input_code>
  <output_code>v_tag
</output_code>
  <markdown>### Crear un tag de un commit antiguo (`git tag -a &lt;nombre_de_etiqueta&gt; -m "&lt;mensaje&gt;" &lt;hash&gt;`)</markdown>
  <markdown>Hagamos un `git tree` para ver el hist√≥rico</markdown>
  <input_code>!cd notebook_git &amp;&amp; git tree</input_code>
  <output_code>* [33m527e07a[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmain[m[33m, [m[1;33mtag: v_tag[m[33m, [m[1;31morigin/main[m[33m, [m[1;32mnew_feature[m[33m)[m Create README.md
*   [33m679bb49[m archivo1.py con el merge resuelto
[32m|[m[33m\[m  
[32m|[m * [33m32851c3[m archivo1.py en rama rama_con_conflicto
* [33m|[m [33m53f909b[m archivo1.py en rama main
[33m|[m[33m/[m  
* [33m52acb97[m Merge squash de los commits de la rama branch_squash
*   [33m274529c[m Merge branch 'branch_no_fast_forward' into main
[34m|[m[35m\[m  
[34m|[m * [33m8df3429[m[33m ([m[1;32mbranch_no_fast_forward[m[33m)[m file2
[34m|[m * [33me4e23c9[m file1
* [35m|[m [33m8bdf4d8[m file3
[35m|[m[35m/[m  
* [33m94149fc[m[33m ([m[1;32mbranch_fast_forward[m[33m)[m Eliminado hola.py
* [33m4484e70[m Eliminado archivo4.py
* [33m564ccfb[m[33m ([m[1;32mnew_branch2[m[33m)[m Commit con el archivo 8
* [33m5168f78[m Eliminado archivo7.py
* [33m4bb9d75[m[33m ([m[1;32mnew_branch[m[33m)[m Commit con el archivo 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Aunque no lo pone en la descripci√≥n, cuando hicimos el commit `4bb9d75` fue cuando terminamos la parte de control de versiones de manera local, por lo que tambi√©n estar√≠a bien tener un tag de ese momento. Para ello lo que tenemos que hacer es crear un tag a√±adiendo el hash de ese momento</markdown>
  <input_code>!cd notebook_git &amp;&amp; git tag -a v_local -m "Tag con el repositorio en la parte de control de versiones de manera local" 4bb9d75</input_code>
  <markdown>Si ahora hacemos un listado de los tags, aparece el nuevo</markdown>
  <input_code>!cd notebook_git &amp;&amp; git tag</input_code>
  <output_code>v_local
v_tag
</output_code>
  <markdown>Y si vemos el historial de commits</markdown>
  <input_code>!cd notebook_git &amp;&amp; git tree</input_code>
  <output_code>* [33m527e07a[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmain[m[33m, [m[1;33mtag: v_tag[m[33m, [m[1;31morigin/main[m[33m, [m[1;32mnew_feature[m[33m)[m Create README.md
*   [33m679bb49[m archivo1.py con el merge resuelto
[32m|[m[33m\[m  
[32m|[m * [33m32851c3[m archivo1.py en rama rama_con_conflicto
* [33m|[m [33m53f909b[m archivo1.py en rama main
[33m|[m[33m/[m  
* [33m52acb97[m Merge squash de los commits de la rama branch_squash
*   [33m274529c[m Merge branch 'branch_no_fast_forward' into main
[34m|[m[35m\[m  
[34m|[m * [33m8df3429[m[33m ([m[1;32mbranch_no_fast_forward[m[33m)[m file2
[34m|[m * [33me4e23c9[m file1
* [35m|[m [33m8bdf4d8[m file3
[35m|[m[35m/[m  
* [33m94149fc[m[33m ([m[1;32mbranch_fast_forward[m[33m)[m Eliminado hola.py
* [33m4484e70[m Eliminado archivo4.py
* [33m564ccfb[m[33m ([m[1;32mnew_branch2[m[33m)[m Commit con el archivo 8
* [33m5168f78[m Eliminado archivo7.py
* [33m4bb9d75[m[33m ([m[1;33mtag: v_local[m[33m, [m[1;32mnew_branch[m[33m)[m Commit con el archivo 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>En el punto del historial donde hemos creado el tag, ahora aparece el tag que hemos creado `* 4bb9d75 (tag: v_local, new_branch) Commit con el archivo 7`</markdown>
  <markdown>### Cambiar entre tags (`git reset --hard &lt;tag&gt;` o `git reset --soft &lt;tag&gt;`)</markdown>
  <markdown>Al igual que nos podemos mover entre distintos commits del historial, tambi√©n nos podemos mover entre tags. Esto tiene la ventaja de que podemos movernos a otro momento del historial sin tener que saberse el hash, con saber el nombre del tag que hemos puesto en ese momento podemos movernos simplemente haciendo `git reset --hard &lt;tag&gt;` o `git reset --soft &lt;tag&gt;`</markdown>
  <markdown>Primero vamos a hacer un `ls` para ver los archivos que tenemos</markdown>
  <input_code>!cd notebook_git &amp;&amp; ls</input_code>
  <output_code>api_keys.py  archivo1.py  archivo2.py  archivo8.py  README.md
</output_code>
  <markdown>Hacemos un `git tree` tambi√©n para ver en qu√© momento del historial estamos</markdown>
  <input_code>!cd notebook_git &amp;&amp; git tree</input_code>
  <output_code>* [33m527e07a[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmain[m[33m, [m[1;33mtag: v_tag[m[33m, [m[1;31morigin/main[m[33m, [m[1;32mnew_feature[m[33m)[m Create README.md
*   [33m679bb49[m archivo1.py con el merge resuelto
[32m|[m[33m\[m  
[32m|[m * [33m32851c3[m archivo1.py en rama rama_con_conflicto
* [33m|[m [33m53f909b[m archivo1.py en rama main
[33m|[m[33m/[m  
* [33m52acb97[m Merge squash de los commits de la rama branch_squash
*   [33m274529c[m Merge branch 'branch_no_fast_forward' into main
[34m|[m[35m\[m  
[34m|[m * [33m8df3429[m[33m ([m[1;32mbranch_no_fast_forward[m[33m)[m file2
[34m|[m * [33me4e23c9[m file1
* [35m|[m [33m8bdf4d8[m file3
[35m|[m[35m/[m  
* [33m94149fc[m[33m ([m[1;32mbranch_fast_forward[m[33m)[m Eliminado hola.py
* [33m4484e70[m Eliminado archivo4.py
* [33m564ccfb[m[33m ([m[1;32mnew_branch2[m[33m)[m Commit con el archivo 8
* [33m5168f78[m Eliminado archivo7.py
* [33m4bb9d75[m[33m ([m[1;33mtag: v_local[m[33m, [m[1;32mnew_branch[m[33m)[m Commit con el archivo 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Ahora cambiamos al punto en el que hemos creado el tag `v_local` mediante `git reset --hard v_local`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git reset --hard v_local</input_code>
  <output_code>HEAD est√° ahora en 4bb9d75 Commit con el archivo 7
</output_code>
  <markdown>Si ahora volvemos a hacer un `ls` vemos que no tenemos los mismos archivos</markdown>
  <input_code>!cd notebook_git &amp;&amp; ls</input_code>
  <output_code>api_keys.py  archivo1.py  archivo2.py  archivo4.py  archivo7.py  hola.py
</output_code>
  <markdown>Si adem√°s vemos el historial vemos que hemos cambiado de momento del historial</markdown>
  <input_code>!cd notebook_git &amp;&amp; git tree</input_code>
  <output_code>* [33m4bb9d75[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmain[m[33m, [m[1;33mtag: v_local[m[33m, [m[1;32mnew_branch[m[33m)[m Commit con el archivo 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Para volver al √∫ltimo momento del historial, como hemos creado tambi√©n un tag valdr√° con hacer `git reset --hard v_tag`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git reset --hard v_tag</input_code>
  <output_code>HEAD est√° ahora en 527e07a Create README.md
</output_code>
  <markdown>Volvemos a ver el historial para comprobar que hemos vuelto al √∫ltimo momento del historial</markdown>
  <input_code>!cd notebook_git &amp;&amp; git tree</input_code>
  <output_code>* [33m527e07a[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmain[m[33m, [m[1;33mtag: v_tag[m[33m, [m[1;31morigin/main[m[33m, [m[1;32mnew_feature[m[33m)[m Create README.md
*   [33m679bb49[m archivo1.py con el merge resuelto
[32m|[m[33m\[m  
[32m|[m * [33m32851c3[m archivo1.py en rama rama_con_conflicto
* [33m|[m [33m53f909b[m archivo1.py en rama main
[33m|[m[33m/[m  
* [33m52acb97[m Merge squash de los commits de la rama branch_squash
*   [33m274529c[m Merge branch 'branch_no_fast_forward' into main
[34m|[m[35m\[m  
[34m|[m * [33m8df3429[m[33m ([m[1;32mbranch_no_fast_forward[m[33m)[m file2
[34m|[m * [33me4e23c9[m file1
* [35m|[m [33m8bdf4d8[m file3
[35m|[m[35m/[m  
* [33m94149fc[m[33m ([m[1;32mbranch_fast_forward[m[33m)[m Eliminado hola.py
* [33m4484e70[m Eliminado archivo4.py
* [33m564ccfb[m[33m ([m[1;32mnew_branch2[m[33m)[m Commit con el archivo 8
* [33m5168f78[m Eliminado archivo7.py
* [33m4bb9d75[m[33m ([m[1;33mtag: v_local[m[33m, [m[1;32mnew_branch[m[33m)[m Commit con el archivo 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
</notebook>