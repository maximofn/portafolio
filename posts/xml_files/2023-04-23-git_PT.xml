<?xml version='1.0' encoding='utf-8'?>
<notebook>
  <markdown># Git</markdown>
  <markdown> &gt; Aviso: Este post foi traduzido para o portugu√™s usando um modelo de tradu√ß√£o autom√°tica. Por favor, me avise se encontrar algum erro.</markdown>
  <markdown>## Introdu√ß√£o</markdown>
  <markdown>Git √© um software de controle de vers√µes criado por Linus Torvalds, que o desenvolveu para ter um bom controle de vers√µes ao desenvolver o kernel do Linux.</markdown>
  <markdown>## As √°reas do git</markdown>
  <markdown>Git tem tr√™s √°reas, embora tamb√©m se possa considerar uma quarta.

![git states](https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/git-states.webp)

* A primeira √© nosso espa√ßo de trabalho, onde temos todo o nosso c√≥digo. Aqui, quando modificamos ou criamos um arquivo, ele passa a estar como n√£o rastreado, ent√£o precisamos mov√™-lo para a √°rea de `staged`
* A segunda √°rea √© a de `staged`. Aqui os arquivos que hav√≠amos modificado ou criado e que estavam n√£o *trackeados* passam a estar trackeados, ou seja, git faz um acompanhamento. Aqui enviaremos os arquivos para a pr√≥xima √°rea de `head`
* A terceira √°rea √© a de `head`. Nela registramos uma vers√£o do nosso c√≥digo. Dessa forma, registrando vers√µes podemos voltar a vers√µes anteriores se necess√°rio. A vers√£o registrada do nosso c√≥digo pode ser enviada para um servidor de modo que seja acess√≠vel por v√°rias pessoas.
* As tr√™s √°reas anteriores correspondem ao trabalho local, mas h√° uma √°rea adicional e √© a de `remote server`. Aqui, o que fazemos √© enviar a vers√£o gravada do nosso c√≥digo para um servidor, de modo que tenhamos acesso ao c√≥digo de qualquer lugar ou que mais pessoas tenham acesso.

Para fazer um s√≠mil, √© como um cen√°rio em que voc√™ vai tirar uma foto. Primeiro, voc√™ tem seus arquivos modificados, ent√£o os que quer imortalizar voc√™ envia para a √°rea de `staged`, ou seja, o palco. No momento em que enviou todos os arquivos que considera, tira a foto, portanto, envia todos os arquivos para a √°rea de `head`. Dessa forma, voc√™ pode ir tirando muitas fotos conforme o c√≥digo evolui, de maneira que pode ter um √°lbum de fotos com a evolu√ß√£o do c√≥digo. Por fim, voc√™ pode enviar essa foto para um servidor para que seja acess√≠vel por mais pessoas, ou seja, os envia para a √°rea de `remote server`.
</markdown>
  <markdown>## Instalar git</markdown>
  <markdown>Em maioria das distribui√ß√µes Linux, o Git j√° vem instalado. Podemos verificar isso usando `git --version`.</markdown>
  <input_code>!git --version</input_code>
  <output_code>git version 2.25.1
</output_code>
  <markdown>Se voc√™ n√£o tiver ou quiser atualizar a vers√£o do git, basta executar `sudo apt update` e em seguida `sudo apt install git`</markdown>
  <input_code>!sudo apt update &amp;&amp; sudo apt install git</input_code>
  <output_code>[sudo] password for maximo.fernandez@AEROESPACIAL.SENER: 
</output_code>
  <markdown>Voltamos a verificar a vers√£o</markdown>
  <input_code>!git --version</input_code>
  <output_code>git version 2.25.1
</output_code>
  <markdown>No meu caso, eu j√° tinha a √∫ltima vers√£o.</markdown>
  <markdown>## Configura√ß√£o inicial</markdown>
  <markdown>### Configura√ß√£o do nome e do email</markdown>
  <markdown>Antes de come√ßar a usar o git √© recomend√°vel que fa√ßa algumas configura√ß√µes m√≠nimas, como o nome de usu√°rio e o email. Esta informa√ß√£o ser√° exibida quando for mostrado quem fez altera√ß√µes no c√≥digo. Para fazer isso, √© necess√°rio executar


```bash
git config --global user.name "&lt;nome de usu√°rio&gt;"
git config --global user.email "&lt;email&gt;"
```

No meu caso, eu colocaria

```bash
git config --global user.name "MaximoFN"
git config --global user.email "maximofn@gmail.com"
```
</markdown>
  <markdown>Como se pode ver, a flag `--global` serve para alterar a configura√ß√£o global do git. No entanto, se em um reposit√≥rio espec√≠fico voc√™ precisa fornecer outros dados, basta navegar at√© o reposit√≥rio e remover a flag `--global` dos comandos anteriores.

```bash
git config user.name "&lt;nome do usu√°rio&gt;"
git config user.email "&lt;email&gt;"
```
</markdown>
  <markdown>### Configurar o editor padr√£o</markdown>
  <markdown>Quando explicarmos o que s√£o os `commit`s veremos que em uma das op√ß√µes pode nos abrir um navegador. Por padr√£o, o git tentar√° usar `vim`, mas dado que n√£o √© um editor muito simples de usar, podemos modific√°-lo. A seguir, mostramos como fazer isso com alguns editores comuns.

```bash
git config --global core.editor "code"  # vscode como editor
git config --global core.editor "atom"  # Atom como editor
git config --global core.editor "subl"  # Sublime Text como editor
git config --global core.editor "nano"  # Nano como editor
```
</markdown>
  <markdown>### Verificar configura√ß√£o do git</markdown>
  <markdown>Para verificar a configura√ß√£o do git, podemos usar `git config --list`</markdown>
  <input_code>!git config --list</input_code>
  <output_code>user.name=maximofn
user.email=maximofn@gmail.com
user.user=maximofn
http.sslverify=true
core.repositoryformatversion=0
core.filemode=true
core.bare=false
core.logallrefupdates=true
remote.origin.url=https://github.com/maximofn/portafolio.git
remote.origin.fetch=+refs/heads/*:refs/remotes/origin/*
branch.main.remote=origin
branch.main.merge=refs/heads/main
</output_code>
  <markdown>Podemos usar os flags `--global`, `--local` e `--system` para ver apenas a configura√ß√£o global, local (se existir) e do sistema (se existir).</markdown>
  <input_code>!git config --global --list</input_code>
  <output_code>user.name=maximofn
user.email=maximofn@gmail.com
user.user=maximofn
http.sslverify=true
</output_code>
  <input_code>!git config --local --list</input_code>
  <output_code>core.repositoryformatversion=0
core.filemode=true
core.bare=false
core.logallrefupdates=true
remote.origin.url=https://github.com/maximofn/portafolio.git
remote.origin.fetch=+refs/heads/*:refs/remotes/origin/*
branch.main.remote=origin
branch.main.merge=refs/heads/main
</output_code>
  <input_code>!git config --system --list</input_code>
  <output_code>fatal: unable to read config file '/etc/gitconfig': No such file or directory
</output_code>
  <markdown>No existe configura√ß√£o de sistema no meu caso</markdown>
  <markdown>Se quiser saber apenas o valor de um par√¢metro da configura√ß√£o, basta inserir `git config &lt;parameter&gt;`</markdown>
  <input_code>!git config user.name</input_code>
  <output_code>maximofn
</output_code>
  <markdown>## Controle de vers√µes localmente</markdown>
  <markdown>### Inicializar um novo reposit√≥rio (`git init`)</markdown>
  <markdown>H√° duas maneiras de inicializar um novo reposit√≥rio fazendo
* Uma √© fazendo `git init &lt;nome do reposit√≥rio&gt;`. Isso criar√° uma nova pasta com o nome do reposit√≥rio.
* Outra √© navegar at√© a pasta onde queremos criar um reposit√≥rio e fazer `git init`
Vou criar um novo reposit√≥rio
</markdown>
  <input_code>!git init notebook_git</input_code>
  <output_code>Inicializado repositorio Git vac√≠o en /home/wallabot/Documentos/web/portafolio/posts/notebook_git/.git/
</output_code>
  <markdown>Se agora fizermos `ls` veremos que foi criada uma nova pasta chamada `notebook_git`</markdown>
  <input_code>!ls | grep notebook_git</input_code>
  <output_code>notebook_git
</output_code>
  <markdown>N√≥s nos movemos para ela</markdown>
  <input_code>!cd notebook_git</input_code>
  <markdown>Agora dentro da pasta temos duas maneiras de saber que o reposit√≥rio foi criado, uma fazendo `ls -a` que mostrar√° todos os arquivos e veremos que h√° uma pasta chamada `.git`. A outra maneira √© fazendo `git status` que nos dir√° o estado do reposit√≥rio.</markdown>
  <input_code>!cd notebook_git &amp;&amp; ls -a</input_code>
  <output_code>.  ..  .git
</output_code>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama master

No hay commits todav√≠a

no hay nada para confirmar (crea/copia archivos y usa "git add" para hacerles seguimiento)
</output_code>
  <markdown>Como estamos em um notebook, cada c√©lula tem seu `path` no `path` do notebook, por isso as duas vezes tive que fazer `cd notebook_git &amp;&amp;`, para mudar para a pasta com o reposit√≥rio que acabamos de criar.</markdown>
  <markdown>Se agora eu testar `git status` em outro `path` onde n√£o tenha sido inicializado um reposit√≥rio, isso resultar√° em um erro.</markdown>
  <input_code>!cd ~/ &amp;&amp; git status</input_code>
  <output_code>fatal: no es un repositorio git (ni ninguno de los directorios superiores): .git
</output_code>
  <markdown>### Criar novos arquivos</markdown>
  <markdown>No momento em que inicializamos um reposit√≥rio, podemos come√ßar a criar novos arquivos, ent√£o criamos um e vemos o que acontece.</markdown>
  <input_code>!cd notebook_git &amp;&amp; echo "print('Hello World')" &gt; hello.py</input_code>
  <markdown>Se agora executarmos `git status`, veremos que aparece</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama master

No hay commits todav√≠a

Archivos sin seguimiento:
  (usa "git add &lt;archivo&gt;..." para incluirlo a lo que se ser√° confirmado)
	[31mhello.py[m

no hay nada agregado al commit pero hay archivos sin seguimiento presentes (usa "git add" para hacerles seguimiento)
</output_code>
  <markdown>Como se pode ver agora nos est√° dizendo que o arquivo `hello.py` n√£o tem acompanhamento. Ou seja, temos que adicionar `hello.py` √† √°rea de `staged`, que lembramos ser como o palco onde vamos colocar tudo o que mais tarde faremos um instant√¢neo.</markdown>
  <markdown>### Desfazer a cria√ß√£o de um novo arquivo</markdown>
  <markdown>Neste caso, como s√£o arquivos que o Git ainda n√£o est√° acompanhando, ou seja, que ainda n√£o est√£o na √°rea de `staged`, ter√≠amos tr√™s maneiras de fazer isso.</markdown>
  <markdown>* Apagando-o simplesmente: Como o git ainda n√£o est√° seguindo o arquivo, podemos fazer `rm hello.py` e pronto.
* Excluindo-o com um comando do Git: Antes exclu√≠mos com `rm`, mas pode ser que voc√™ esteja em um sistema que n√£o tenha o comando `rm`. Portanto, nesse caso, pode-se usar o comando do Git `git rm hello.py`* Por √∫ltimo, podemos usar `git clean`. Este √© √∫til, por exemplo, quando h√° muitos arquivos novos, e assim, em um √∫nico comando, removemos todos.
</markdown>
  <markdown>#### `git clean`</markdown>
  <markdown>Se executarmos `git clean` sem nenhum argumento, receberemos um erro.</markdown>
  <input_code>!cd notebook_git &amp;&amp; git clean</input_code>
  <output_code>fatal: clean.requireForce default en true y ninguno de -i, -n, ni -f entregado; rehusando el clean
</output_code>
  <markdown>Ele nos diz que √© necess√°rio adicionar um desses flags `-n`, `-i` ou `-f`. Al√©m disso, vamos ver o flag `-d`.

* `-n` (execu√ß√£o simulada): Ditar√° quais arquivos ser√£o exclu√≠dos, mas n√£o os excluir√°
* `-i`: Perguntar√° por cada arquivo que vai ser apagado* `-f`: For√ßar√° a exclus√£o dos arquivos
* `-d`: Tamb√©m excluir√° pastas
</markdown>
  <markdown>Vamos testar, primeiro fazemos `git clean -n` para saber quais arquivos seriam deletados</markdown>
  <input_code>!cd notebook_git &amp;&amp; git clean -n</input_code>
  <output_code>Ser√° borrado hello.py
</output_code>
  <markdown>Agora fazemos `git clean -f` para que ele apague, j√° que concordamos em apag√°-lo.</markdown>
  <input_code>!cd notebook_git &amp;&amp; git clean -f</input_code>
  <output_code>Borrando hello.py
</output_code>
  <markdown>Como vemos, ele apagou `hello.py`</markdown>
  <markdown>### Adicionar um arquivo √† √°rea de staged (`git add`)</markdown>
  <markdown>Voltamos a criar um arquivo</markdown>
  <input_code>!cd notebook_git &amp;&amp; echo "print('Hola mundo')" &gt; hola.py</input_code>
  <markdown>Voltamos a fazer um `git status` para verificar que temos o arquivo</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama master

No hay commits todav√≠a

Archivos sin seguimiento:
  (usa "git add &lt;archivo&gt;..." para incluirlo a lo que se ser√° confirmado)
	[31mhola.py[m

no hay nada agregado al commit pero hay archivos sin seguimiento presentes (usa "git add" para hacerles seguimiento)
</output_code>
  <markdown>Vemos que temos o arquivo `hola.py` mas o git n√£o est√° fazendo um acompanhamento. Al√©m disso, vemos que ele ajuda e diz `use "git add" para fazer o acompanhamento`

A sintaxe √© a seguinte `git add &lt;arquivo&gt;`, mas podemos faz√™-lo de v√°rias maneiras

* Se quisermos adicionar mais de um arquivo, podemos fazer isso colocando todos os arquivos que desejamos adicionar √† √°rea de staged, separados por um espa√ßo: `git add &lt;arquivo1&gt; &lt;arquivo2&gt; &lt;arquivo3&gt;`
* Se quisermos adicionar todos os arquivos do mesmo formato, por exemplo, se quisermos adicionar todos os arquivos de Python seria `git add *.py`
* Se quisermos adicionar todos os arquivos de uma pasta `git add &lt;folder&gt;/`
* Se quisermos adicionar todos os arquivos temos tr√™s maneiras: `git add --all`, `git add -A` ou `git add .`
</markdown>
  <markdown>Vamos a adicionar o novo arquivo criado</markdown>
  <input_code>!cd notebook_git &amp;&amp; git add hola.py</input_code>
  <markdown>Fazemos um `git status` para ver o que aconteceu</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama master

No hay commits todav√≠a

Cambios a ser confirmados:
  (usa "git rm --cached &lt;archivo&gt;..." para sacar del √°rea de stage)
	[32mnuevos archivos: hola.py[m

</output_code>
  <markdown>Como vemos, nos diz que temos um novo arquivo ao qual ele faz o acompanhamento e que est√° pendente de ser confirmado `hola.py`</markdown>
  <markdown>### Retirar um arquivo da √°rea staged (`git reset`)</markdown>
  <markdown>Caso adicionemos um arquivo √† √°rea de staged e quisermos remov√™-lo, temos que usar `git reset &lt;arquivo&gt;`, vamos ver isso.</markdown>
  <markdown>Criamos e adicionamos √† √°rea de stage um novo arquivo</markdown>
  <input_code>!cd notebook_git &amp;&amp; echo "print('Este no')" &gt; adios.py &amp;&amp; git add adios.py</input_code>
  <markdown>Fazemos `git status` para verificar que est√° na √°rea de stage</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama master

No hay commits todav√≠a

Cambios a ser confirmados:
  (usa "git rm --cached &lt;archivo&gt;..." para sacar del √°rea de stage)
	[32mnuevos archivos: adios.py[m
	[32mnuevos archivos: hola.py[m

</output_code>
  <markdown>Como vemos, est√£o `hola.py` e `adios.py`, ent√£o usamos `git reset adios.py` para remov√™-lo da √°rea de staged</markdown>
  <input_code>!cd notebook_git &amp;&amp; git reset adios.py</input_code>
  <markdown>Fazemos um `git status` para verificar que saiu</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama master

No hay commits todav√≠a

Cambios a ser confirmados:
  (usa "git rm --cached &lt;archivo&gt;..." para sacar del √°rea de stage)
	[32mnuevos archivos: hola.py[m

Archivos sin seguimiento:
  (usa "git add &lt;archivo&gt;..." para incluirlo a lo que se ser√° confirmado)
	[31madios.py[m

</output_code>
  <markdown>Podemos ver que `adios.py` j√° n√£o tem acompanhamento por parte do git, foi removido da √°rea de stage.</markdown>
  <markdown>Fazemos `git clean -f` para apag√°-lo.</markdown>
  <input_code>!cd notebook_git &amp;&amp; git clean -f &amp;&amp; git status</input_code>
  <output_code>Borrando adios.py
En la rama master

No hay commits todav√≠a

Cambios a ser confirmados:
  (usa "git rm --cached &lt;archivo&gt;..." para sacar del √°rea de stage)
	[32mnuevos archivos: hola.py[m

</output_code>
  <markdown>### Commit (`git commit`)</markdown>
  <markdown>Se voltarmos ao s√≠mil em que dissemos que a √°rea de staged era o palco onde envi√°vamos os arquivos aos quais quer√≠amos tirar uma foto, agora √© hora de tirar a foto para imortalizar o estado atual. Isso √© fazer um `commit`

Desta forma, registra-se o estado atual do c√≥digo, assim, com cada commit, teremos um registro da evolu√ß√£o do c√≥digo. Assim como em um √°lbum de fotos, com cada foto vamos tendo um registro da evolu√ß√£o do que colocamos em cena.
</markdown>
  <markdown>Como na hora de fazer o commit est√° sendo registrado a mudan√ßa do c√≥digo, o git n√£o permite fazer o commit sem um coment√°rio m√≠nimo. Portanto, h√° duas maneiras de fazer commit

* `git commit` desta forma, ser√° aberto o editor que tivermos configurado no git. Se n√£o tivermos configurado um editor padr√£o, ser√° aberto `vi`. Se quisermos mudar a configura√ß√£o do editor, podemos fazer, por exemplo, `git config --global core.editor "code"` ou `git config core.editor "code"` para definir o vscode como o editor padr√£o de forma global ou local.
* `git commit -m "Mensagem de commit"`. Dessa forma adicionamos a mensagem diretamente
Ao fazer o commit da primeira forma, podemos ter uma primeira linha que ser√° o t√≠tulo do commit e v√°rias linhas adicionais onde se explica com mais detalhes. Se quisermos poder fazer isso com a flag `-m`, basta adicionar v√°rios flags `-m` seguidos: `git commit -m "T√≠tulo do commit" -m "Primeira linha explicando mais" -m "Segunda linha explicando mais"`
</markdown>
  <markdown>Uma vez que fizemos o commit, isso salvar√° um registro da mudan√ßa do nosso reposit√≥rio de maneira local. Ainda n√£o nos conectamos com um servidor remoto.</markdown>
  <markdown>Vamos tentar fazer o commit</markdown>
  <input_code>!cd notebook_git &amp;&amp; git commit -m "Primer commit, hola.py"</input_code>
  <output_code>[master (commit-ra√≠z) 1c95e4f] Primer commit, hola.py
 1 file changed, 1 insertion(+)
 create mode 100644 hola.py
</output_code>
  <markdown>Fazemos um `git status`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama master
nada para hacer commit, el √°rbol de trabajo est√° limpio
</output_code>
  <markdown>Vemos que nos diz que n√£o h√° nada novo, temos todo o nosso reposit√≥rio totally controlado.</markdown>
  <markdown>#### Commit pulando add (`git commit -a -m` ou `git commit -am`)</markdown>
  <markdown>No caso de querermos levar todos os arquivos que modificamos para a √°rea de staged e depois fazer um commit, podemos fazer tudo isso em um √∫nico passo usando `git commit -a -m "mensagem"`, `git commit --all -m "mensagem"` ou `git commit -am "mensagem"`

&gt; Nota: Isso s√≥ √© v√°lido se um arquivo for modificado. Se o arquivo for novo e o git n√£o estiver fazendo acompanhamento, isso n√£o √© v√°lido.

Vamos ver um exemplo, vamos modificar `hola.py`
</markdown>
  <input_code>!cd notebook_git &amp;&amp; echo "print('He a√±adido una nueva linea')" &gt;&gt; hola.py</input_code>
  <markdown>Vamos fazer um `git status` para nos assegurar</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama master
Cambios no rastreados para el commit:
  (usa "git add &lt;archivo&gt;..." para actualizar lo que ser√° confirmado)
  (usa "git restore &lt;archivo&gt;..." para descartar los cambios en el directorio de trabajo)
	[31mmodificados:     hola.py[m

sin cambios agregados al commit (usa "git add" y/o "git commit -a")
</output_code>
  <markdown>Podemos ver que na pr√≥pria ajuda do git j√° nos sugere usar `git commit -a`, ent√£o vamos fazer isso.</markdown>
  <input_code>!cd notebook_git &amp;&amp; git commit -am "Segundo commit, hola.py"</input_code>
  <output_code>[master 6e99e73] Segundo commit, hola.py
 1 file changed, 1 insertion(+)
</output_code>
  <markdown>Fazemos novamente um `git status`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama master
nada para hacer commit, el √°rbol de trabajo est√° limpio
</output_code>
  <markdown>N√£o h√° nada para fazer commit, j√° foi feito o commit da altera√ß√£o</markdown>
  <markdown>### Modificar um arquivo ao qual foi feito commit</markdown>
  <markdown>Como enquanto desenvolvemos estamos modificando arquivos, pode ser que em algum arquivo ao qual j√° fizemos commit o modifiquemos. No nosso caso, vamos adicionar uma linha a `hola.py`</markdown>
  <input_code>!cd notebook_git &amp;&amp; echo "print('He a√±adido una tercera linea')" &gt;&gt; hola.py</input_code>
  <input_code>!cd notebook_git &amp;&amp; cat hola.py</input_code>
  <output_code>print('Hola mundo')
print('He a√±adido una nueva linea')
print('He a√±adido una tercera linea')
</output_code>
  <markdown>Se fizermos `git status` veremos que `hola.py` tem modifica√ß√µes</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama master
Cambios no rastreados para el commit:
  (usa "git add &lt;archivo&gt;..." para actualizar lo que ser√° confirmado)
  (usa "git restore &lt;archivo&gt;..." para descartar los cambios en el directorio de trabajo)
	[31mmodificados:     hola.py[m

sin cambios agregados al commit (usa "git add" y/o "git commit -a")
</output_code>
  <markdown>### Ver altera√ß√µes em um arquivo (`git diff &lt;arquivo&gt;`)</markdown>
  <markdown>Talvez tenhamos passado um tempo desenvolvendo desde o √∫ltimo commit e n√£o saibamos quais modifica√ß√µes fizemos, para isso usamos `git diff &lt;arquivo&gt;` que nos dir√° as mudan√ßas que fizemos.</markdown>
  <input_code>!cd notebook_git &amp;&amp; git diff hola.py</input_code>
  <output_code>[1mdiff --git a/hola.py b/hola.py[m
[1mindex 91dee80..fba0d22 100644[m
[1m--- a/hola.py[m
[1m+++ b/hola.py[m
[36m@@ -1,2 +1,3 @@[m
 print('Hola mundo')[m
 print('He a√±adido una nueva linea')[m
[32m+[m[32mprint('He a√±adido una tercera linea')[m
</output_code>
  <markdown>Embora n√£o seja muito intuitivo, podemos ver que adicionamos a √∫ltima linha em `hola.py`</markdown>
  <markdown>### Desfazer modifica√ß√µes em um arquivo (`git restore &lt;arquivo&gt;`)</markdown>
  <markdown>Se as altera√ß√µes que fizemos n√£o nos agradarem e quisermos remov√™-las, podemos fazer `git restore &lt;arquivo&gt;`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git restore hola.py</input_code>
  <markdown>Vamos ver o que aconteceu com um `git status`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama master
nada para hacer commit, el √°rbol de trabajo est√° limpio
</output_code>
  <markdown>Vemos que se han descartado os cambios em `hola.py` desde o √∫ltimo commit</markdown>
  <markdown>### Hist√≥rico de altera√ß√µes (`git log`)</markdown>
  <markdown>Com o git podemos ver o hist√≥rico de todas as mudan√ßas que fomos commitando, para isso usamos `git log`. √â como se coloc√°ssemos a revisar nosso √°lbum de fotos.</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log</input_code>
  <output_code>[33mcommit 6e99e73cf0c5474078cc9f328ee6a54fb9ffb169[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmaster[m[33m)[m
Author: maximofn &lt;maximofn@gmail.com&gt;
Date:   Sun Apr 16 02:29:04 2023 +0200

    Segundo commit, hola.py

[33mcommit 1c95e4fd8388ceedee368e0121c4b0ef4900c2ac[m
Author: maximofn &lt;maximofn@gmail.com&gt;
Date:   Sun Apr 16 02:28:44 2023 +0200

    Primer commit, hola.py
</output_code>
  <markdown>Podemos ver o hist√≥rico de mudan√ßas, temos que l√™-lo de baixo para cima.

Primeiro vemos o commit com a mensagem `Primeiro commit, hola.py`, podemos ver a data, o autor e o hash, que √© seu identificador √∫nico.

A seguir vemos o segundo commit com a mensagem `Segundo commit, hola.py`, com sua data, autor e hash. Al√©m disso, mostra onde est√° o `HEAD` e em qual branch estamos.
</markdown>
  <markdown>SeÊàë‰ª¨ÂèØ‰ª•‰ΩøÁî®Ê†áÂøó‰ª•‰∏çÂêåÁöÑÊñπÂºèËé∑Âèñ‰ø°ÊÅØÔºå‰ΩÜÊ†πÊçÆÊàë‰ª¨‰ΩøÁî®ÁöÑÊ†áÂøóÔºåÊüê‰∫õÊñπÂºèÂèØËÉΩÊõ¥ÈÄÇÂêàÊàë‰ª¨„ÄÇ‰∏ãË°®ÊòæÁ§∫‰∫Ü‰∏Ä‰∫õÊúâÁî®ÁöÑÊ†áÂøóÔºö

Note: The above sentence is not translated to Portuguese as requested, here's the correct translation:

Se usarmos flags, podemos obter informa√ß√µes de maneiras diferentes, mas dependendo das flags que usarmos, algumas podem ser mais adequadas. A seguir, s√£o mostradas algumas flags √∫teis:

* `git log --oneline`: Mostra os commits em uma √∫nica linha, com o hash abreviado e a mensagem do commit.
* `git log --graph`: Mostra um gr√°fico de texto da hist√≥ria do reposit√≥rio, incluindo ramos e fus√µes.
* `git log --decorate`: Mostra as refer√™ncias (ramos, tags, HEAD, etc.) no log juntamente com o commit para o qual elas apontam.
* `git log --author="&lt;autor&gt;"`: Filtra o hist√≥rico de commits para mostrar apenas aqueles realizados por um autor espec√≠fico.
* `git log --since="&lt;data&gt;"`: Mostra os commits realizados desde uma data espec√≠fica. Voc√™ pode usar diferentes formatos de data, como "1 week ago" ou "2023-01-01".
* `git log --until="&lt;data&gt;"`: Mostra os commits realizados at√© uma data espec√≠fica.
* `git log &lt;rama&gt;`: Mostra os commits de uma ramifica√ß√£o espec√≠fica.* `git log &lt;commit1&gt;..&lt;commit2&gt;`: Mostra os commits que est√£o no intervalo entre dois commits espec√≠ficos.
* `git log --grep="&lt;palavra&gt;"`: Procura nos mensagens de commit por uma palavra ou frase espec√≠fica.
* `git log -p`: Mostra as diferen√ßas (em forma de patch) introduzidas em cada commit.
* `git log -n &lt;n√∫mero&gt;`: Mostra os √∫ltimos n√∫mero de commits. Por exemplo, git log -n 5 mostrar√° os √∫ltimos 5 commits.
* `git log --stat`: Mostra as estat√≠sticas de altera√ß√µes em arquivos para cada commit, como o n√∫mero de linhas adicionadas e removidas.

Por exemplo, uma maneira confort√°vel de ver o hist√≥rico √© usar `git log --graph --oneline --decorate`
</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>* [33m6e99e73[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmaster[m[33m)[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Podemos ver que, em vez de nos dar o hash inteiro, nos d√° apenas alguns n√∫meros. Isso ocorre porque, por enquanto, o reposit√≥rio tem t√£o pouca hist√≥ria que esses poucos n√∫meros s√£o suficientes. Se quisermos voltar ao ponto anterior, em vez de introduzir o hash inteiro (`7c448f69e30ab1b5783f5cf9ee3ae5bc362ecd4d`), bastaria introduzir apenas `7c448f6`.</markdown>
  <markdown>Mais tarde falaremos sobre as branches, mas agora vamos ver o que √© o `HEAD`</markdown>
  <markdown>### CABE√áALHO</markdown>
  <markdown>Enquanto desenvolv√≠amos, conseguimos fazer altera√ß√µes e commit√°-las, ou seja, fomos preenchendo o √°lbum de fotos do nosso c√≥digo. `HEAD` √© a posi√ß√£o no √°lbum em que estamos.

Normalmente √© a √∫ltima posi√ß√£o de todos os commits.
</markdown>
  <markdown>Se quisermos saber em qual ponto estamos, podemos fazer isso atrav√©s de `git rev-parse HEAD`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git rev-parse HEAD</input_code>
  <output_code>6e99e73cf0c5474078cc9f328ee6a54fb9ffb169
</output_code>
  <markdown>Como pode ser visto, o hash obtido coincide com o √∫ltimo obtido ao fazer `git log`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log</input_code>
  <output_code>[33mcommit 6e99e73cf0c5474078cc9f328ee6a54fb9ffb169[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmaster[m[33m)[m
Author: maximofn &lt;maximofn@gmail.com&gt;
Date:   Sun Apr 16 02:29:04 2023 +0200

    Segundo commit, hola.py

[33mcommit 1c95e4fd8388ceedee368e0121c4b0ef4900c2ac[m
Author: maximofn &lt;maximofn@gmail.com&gt;
Date:   Sun Apr 16 02:28:44 2023 +0200

    Primer commit, hola.py
</output_code>
  <markdown>### Modificar um commit (`git commit --amend`)</markdown>
  <markdown>Podemos querer modificar um commit, porque queremos mudar a mensagem, ou porque queremos adicionar mais arquivos ao commit, ent√£o veremos os dois casos</markdown>
  <markdown>#### Modificar a mensagem de commit</markdown>
  <markdown>Se apenas quisermos modificar a mensagem, o que temos que fazer √© `git commit --amend -m "Nova mensagem"`, vejamos um exemplo, vamos modificar `hola.py`</markdown>
  <input_code>!cd notebook_git &amp;&amp; echo "print('Esta es la tercera linea')" &gt;&gt; hola.py</input_code>
  <markdown>Fazemos um `git status`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama master
Cambios no rastreados para el commit:
  (usa "git add &lt;archivo&gt;..." para actualizar lo que ser√° confirmado)
  (usa "git restore &lt;archivo&gt;..." para descartar los cambios en el directorio de trabajo)
	[31mmodificados:     hola.py[m

sin cambios agregados al commit (usa "git add" y/o "git commit -a")
</output_code>
  <markdown>Efetivamente vemos que `hola.py` tem modifica√ß√µes, de modo que fazemos um commit com essas modifica√ß√µes.</markdown>
  <input_code>!cd notebook_git &amp;&amp; git commit -am "Tercer commot, hola.py"</input_code>
  <output_code>[master 60e2ffd] Tercer commot, hola.py
 1 file changed, 1 insertion(+)
</output_code>
  <markdown>Vamos ver o hist√≥rico de commits</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>* [33m60e2ffd[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmaster[m[33m)[m Tercer commot, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>**Oh n√£o!** escrevemos `commot` em vez de `commit`, ent√£o vamos modificar a mensagem</markdown>
  <input_code>!cd notebook_git &amp;&amp; git commit --amend -m "Tercer commit, hola.py"</input_code>
  <output_code>[master c4930d7] Tercer commit, hola.py
 Date: Sun Apr 16 02:29:59 2023 +0200
 1 file changed, 1 insertion(+)
</output_code>
  <markdown>Voltamos a ver o hist√≥rico</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>* [33mc4930d7[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmaster[m[33m)[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Vemos que agora est√° bem.</markdown>
  <markdown>#### Adicionar arquivos ao √∫ltimo commit</markdown>
  <markdown>Suponhamos que esquecemos de adicionar um arquivo ao √∫ltimo commit, simplesmente fazemos um `git add` com esse arquivo e fazemos `git commit --amend -m "mensagem"`</markdown>
  <markdown>Vamos a criar dois arquivos novos</markdown>
  <input_code>!cd notebook_git &amp;&amp; echo "print('Este es el archivo 1')" &gt; archivo1.py</input_code>
  <input_code>!cd notebook_git &amp;&amp; echo "print('Este es el archivo 2')" &gt; archivo2.py</input_code>
  <markdown>Agora fazemos commit apenas de um</markdown>
  <input_code>!cd notebook_git &amp;&amp; git add archivo1.py &amp;&amp; git commit -m "Commit con el archivo 1"</input_code>
  <output_code>[master 285b243] Commit con el archivo 1
 1 file changed, 1 insertion(+)
 create mode 100644 archivo1.py
</output_code>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama master
Archivos sin seguimiento:
  (usa "git add &lt;archivo&gt;..." para incluirlo a lo que se ser√° confirmado)
	[31marchivo2.py[m

no hay nada agregado al commit pero hay archivos sin seguimiento presentes (usa "git add" para hacerles seguimiento)
</output_code>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>* [33m285b243[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmaster[m[33m)[m Commit con el archivo 1
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Como vemos, nos esquecemos do arquivo 2, ent√£o modificamos o commit e adicionamos o arquivo 2</markdown>
  <input_code>!cd notebook_git &amp;&amp; git add archivo2.py</input_code>
  <input_code>!cd notebook_git &amp;&amp; git commit --amend -m "Commit con los archivos 1 y 2"</input_code>
  <output_code>[master 04ebd1f] Commit con los archivos 1 y 2
 Date: Sun Apr 16 02:30:26 2023 +0200
 2 files changed, 2 insertions(+)
 create mode 100644 archivo1.py
 create mode 100644 archivo2.py
</output_code>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama master
nada para hacer commit, el √°rbol de trabajo est√° limpio
</output_code>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>* [33m04ebd1f[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmaster[m[33m)[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Agora o √∫ltimo commit tem os dois novos arquivos</markdown>
  <markdown>### Desfazer um commit (`git reset HEAD~1`)</markdown>
  <markdown>Com este comando, dizemos ao git para voltar uma posi√ß√£o no hist√≥rico de commits. H√° duas op√ß√µes: `--soft`, que n√£o apagar√° as altera√ß√µes que tenhamos feito, e `--hard`, que o far√°.</markdown>
  <markdown>#### Desfazer um commit mantendo as altera√ß√µes (`git reset --soft HEAD~1`)</markdown>
  <markdown>Vamos a criar um novo arquivo</markdown>
  <input_code>!cd notebook_git &amp;&amp; echo "print('Este es el archivo 3')" &gt; archivo3.py</input_code>
  <markdown>Fazemos um `git status`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama master
Archivos sin seguimiento:
  (usa "git add &lt;archivo&gt;..." para incluirlo a lo que se ser√° confirmado)
	[31marchivo3.py[m

no hay nada agregado al commit pero hay archivos sin seguimiento presentes (usa "git add" para hacerles seguimiento)
</output_code>
  <markdown>Fazemos um commit adicionando este arquivo</markdown>
  <input_code>!cd notebook_git &amp;&amp; git add archivo3.py &amp;&amp; git commit -m "Commit con el archivos 3"</input_code>
  <output_code>[master 6dc7be6] Commit con el archivos 3
 1 file changed, 1 insertion(+)
 create mode 100644 archivo3.py
</output_code>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>* [33m6dc7be6[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmaster[m[33m)[m Commit con el archivos 3
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Vemos que no o √∫ltimo commit se encontra `arquivo3.py`, vamos a eliminar o commit mantendo `arquivo3.py`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git reset --soft HEAD~1</input_code>
  <markdown>Fazemos agora um `git log` para ver se o √∫ltimo commit foi removido.</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>* [33m04ebd1f[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmaster[m[33m)[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Efetivamente, vemos que foi removido o √∫ltimo commit</markdown>
  <markdown>Fazemos um `git status` para ver se foi preservado o `arquivo3.py`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama master
Cambios a ser confirmados:
  (usa "git restore --staged &lt;archivo&gt;..." para sacar del √°rea de stage)
	[32mnuevos archivos: archivo3.py[m

</output_code>
  <markdown>Manteve-se</markdown>
  <markdown>#### Desfazer um commit descartando as altera√ß√µes (`git reset --hard HEAD~1`)</markdown>
  <markdown>Temos `arquivo3.py` que criamos e est√° na √°rea de stage</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama master
Cambios a ser confirmados:
  (usa "git restore --staged &lt;archivo&gt;..." para sacar del √°rea de stage)
	[32mnuevos archivos: archivo3.py[m

</output_code>
  <markdown>Portanto, fazemos um commit</markdown>
  <input_code>!cd notebook_git &amp;&amp; git commit -m "Commit con el archivo 3"</input_code>
  <output_code>[master 0147d65] Commit con el archivo 3
 1 file changed, 1 insertion(+)
 create mode 100644 archivo3.py
</output_code>
  <markdown>Fazemos um `git log` para verificar que h√° um commit com este arquivo.</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>* [33m0147d65[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmaster[m[33m)[m Commit con el archivo 3
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Efetivamente h√° um commit adicionando `arquivo3.py`. Agora removemos este commit descartando `arquivo3.py`.</markdown>
  <input_code>!cd notebook_git &amp;&amp; git reset --hard HEAD~1</input_code>
  <output_code>HEAD est√° ahora en 04ebd1f Commit con los archivos 1 y 2
</output_code>
  <markdown>Fazemos um `git log` para verificar que foi removido o √∫ltimo commit</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>* [33m04ebd1f[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmaster[m[33m)[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>O commit com `arquivo3.py` foi removido, agora fazemos um `git status` para verificar o que aconteceu com `arquivo3.py`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama master
nada para hacer commit, el √°rbol de trabajo est√° limpio
</output_code>
  <markdown>N√£o aparece `arquivo3.py` como um arquivo ao qual devemos fazer commit, vamos verificar se ele foi realmente exclu√≠do por completo.</markdown>
  <input_code>!cd notebook_git &amp;&amp; ls | grep archivo3</input_code>
  <markdown>Efetivamente, o `arquivo3.py` foi removido do sistema de arquivos.</markdown>
  <markdown>### Modificar um commit remoto (`git push --force`)</markdown>
  <markdown>Embora veremos mais adiante como sincronizarmo-nos com reposit√≥rios remotos, no caso de ter feito um commit, t√™-lo subido a um reposit√≥rio remoto (`git push`) e t√™-lo modificado localmente (porque modificou a mensagem ou desfez o commit), para reverter as altera√ß√µes no reposit√≥rio remoto voc√™ precisa fazer `git push --force`

&gt; **Cuidado!**: Este comando modifica o hist√≥rico do reposit√≥rio remoto, ent√£o pode afetar o resto das pessoas que estejam trabalhando com esse reposit√≥rio. Use este comando com muito cuidado e seguran√ßa. √â melhor ter um hist√≥rico de commits no qual primeiro est√° o commit em que voc√™ colocou a descri√ß√£o errada e depois o novo commit com a nova descri√ß√£o correta, do que ficar modificando o hist√≥rico.
</markdown>
  <markdown>### Modificar um commit remoto (`git push --force-with-lease`)</markdown>
  <markdown>Se voc√™ est√° convencido de alterar o hist√≥rico, pelo menos use `git push --force-with-lease`, que n√£o modificar√° os commits que tenham sido feitos posteriormente.</markdown>
  <markdown>### Ignorar arquivos (`.gitignore`)</markdown>
  <markdown>Suponhamos que temos um arquivo com `API key`s, este arquivo na verdade n√£o queremos que seja salvo no reposit√≥rio, porque se depois compartilharmos este reposit√≥rio, qualquer pessoa teria acesso a essas chaves, por isso √© necess√°rio dizer ao git para n√£o fazer o acompanhamento deste arquivo

Isso √© feito com o arquivo `.gitignore`, nele adicionamos o caminho dos arquivos ou diret√≥rios que n√£o queremos que o git fa√ßa o acompanhamento.

Vamos v√™-lo
</markdown>
  <markdown>Criamos o arquivo com as chaves</markdown>
  <input_code>!cd notebook_git &amp;&amp; touch api_keys.py</input_code>
  <markdown>Se fazemos `git status` vemos que o Git o considera</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama master
Archivos sin seguimiento:
  (usa "git add &lt;archivo&gt;..." para incluirlo a lo que se ser√° confirmado)
	[31mapi_keys.py[m

no hay nada agregado al commit pero hay archivos sin seguimiento presentes (usa "git add" para hacerles seguimiento)
</output_code>
  <markdown>Se n√£o fizermos nada, pode ser que um dia fa√ßamos um `git add .` e o incluamos no reposit√≥rio, ent√£o, por seguran√ßa, temos que dizer ao git para n√£o seguir este arquivo. Para isso, criamos o `.gitignore` adicionando este arquivo.</markdown>
  <input_code>!cd notebook_git &amp;&amp; echo "api_keys.py" &gt;&gt; .gitignore</input_code>
  <markdown>Vamos ver o que acontece se agora fizermos `git status`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama master
Archivos sin seguimiento:
  (usa "git add &lt;archivo&gt;..." para incluirlo a lo que se ser√° confirmado)
	[31m.gitignore[m

no hay nada agregado al commit pero hay archivos sin seguimiento presentes (usa "git add" para hacerles seguimiento)
</output_code>
  <markdown>Vemos que o git deixou de considerar `api_keys.py`, mas ainda considera `.gitignore`, ent√£o fazemos um commit para adicionar `.gitignore`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git add .gitignore &amp;&amp; git commit -m "A√±adido .gitignore"</input_code>
  <output_code>[master 0b09cfa] A√±adido .gitignore
 1 file changed, 1 insertion(+)
 create mode 100644 .gitignore
</output_code>
  <markdown>#### Quais arquivos adicionar ao `.gitignore`?</markdown>
  <markdown>* Arquivos que tenham credenciais ou chaves de API (voc√™ n√£o deveria envi√°-los para o reposit√≥rio, simplesmente injete-os por vari√°vel de ambiente)
* Pastas de configura√ß√£o do seu editor (`/.vscode`)
* Arquivos de registro (log files)
* Arquivos do sistema como `.DS_Store`* Pastas geradas com arquivos est√°ticos ou compila√ß√µes como `/dist` ou `/build`
* Depend√™ncias que podem ser baixadas (`/node_modules`)
* Cobertura do teste (`/coverage`)
</markdown>
  <markdown>#### Como ignorar sempre os mesmos arquivos?</markdown>
  <markdown>Se seu IDE sempre gera os mesmos arquivos de configura√ß√£o, seria bom poder dizer ao git para sempre ignorar esses arquivos. Para isso, criamos um `.gitignore` global.</markdown>
  <input_code>!touch ~/.gitignore_global</input_code>
  <markdown>No meu caso, vou adicionar o diret√≥rio `__pycache__/`</markdown>
  <input_code>!echo "__pycache__/" &gt;&gt; ~/.gitignore_global</input_code>
  <markdown>Agora temos que indicar ao Git que esse √© o nosso `.gitignore` global</markdown>
  <input_code>!git config --global core.excludesfile ~/.gitignore_global</input_code>
  <markdown>Pronto, o diret√≥rio `__pycache__/` sempre ser√° ignorado</markdown>
  <markdown>O GitHub tem um [reposit√≥rio](https://github.com/github/gitignore) com `.gitignore`s para muitas linguagens, eu me baseei no [deste](https://github.com/github/gitignore/blob/main/Python.gitignore) para Python.</markdown>
  <markdown>### Remover um arquivo de um commit</markdown>
  <markdown>Vamos a ver como remover um arquivo de um commit que fizemos. Primeiro criamos dois arquivos e fazemos commit</markdown>
  <input_code>!cd notebook_git &amp;&amp; echo "print('Este es el archivo 4')" &gt; archivo4.py</input_code>
  <input_code>!cd notebook_git &amp;&amp; echo "print('Este es el archivo 5')" &gt; archivo5.py</input_code>
  <markdown>Fazemos um commit com os dois arquivos</markdown>
  <input_code>!cd notebook_git &amp;&amp; git add archivo4.py archivo5.py &amp;&amp; git commit -m "Commit con los archivos 4 y 5"</input_code>
  <output_code>[master e3153a5] Commit con los archivos 4 y 5
 2 files changed, 2 insertions(+)
 create mode 100644 archivo4.py
 create mode 100644 archivo5.py
</output_code>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>* [33me3153a5[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmaster[m[33m)[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>A partir de aqui h√° duas op√ß√µes para remover um arquivo de um commit:
* Excluir o arquivo e criar um novo commit* Desfazer o commit e cri√°-lo novamente sem o arquivo
</markdown>
  <markdown>#### Excluir o arquivo e criar um novo commit</markdown>
  <markdown>Suponhamos que queremos eliminar o arquivo `arquivo5.py`, ent√£o o removemos com `git rm arquivo5.py`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git rm archivo5.py</input_code>
  <output_code>rm 'archivo5.py'
</output_code>
  <markdown>Vamos fazer um `git status` para ver o que acontece</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama master
Cambios a ser confirmados:
  (usa "git restore --staged &lt;archivo&gt;..." para sacar del √°rea de stage)
	[32mborrados:        archivo5.py[m

</output_code>
  <markdown>Como vemos, foi exclu√≠do `archivo5.py`. Agora criamos um novo commit</markdown>
  <input_code>!cd notebook_git &amp;&amp; git commit -m "Eliminado archivo5.py"</input_code>
  <output_code>[master ea615a9] Eliminado archivo5.py
 1 file changed, 1 deletion(-)
 delete mode 100644 archivo5.py
</output_code>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>* [33mea615a9[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmaster[m[33m)[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>#### Desfazer o commit e cri√°-lo novamente sem o arquivo</markdown>
  <markdown>Voltamos a criar dois arquivos e fazer um commit</markdown>
  <input_code>!cd notebook_git &amp;&amp; echo "print('Este es el archivo 6')" &gt; archivo6.py &amp;&amp; echo "print('Este es el archivo 7')" &gt; archivo7.py</input_code>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama master
Archivos sin seguimiento:
  (usa "git add &lt;archivo&gt;..." para incluirlo a lo que se ser√° confirmado)
	[31marchivo6.py[m
	[31marchivo7.py[m

no hay nada agregado al commit pero hay archivos sin seguimiento presentes (usa "git add" para hacerles seguimiento)
</output_code>
  <input_code>!cd notebook_git &amp;&amp; git add archivo6.py archivo7.py &amp;&amp; git commit -m "Commit con los archivos 6 y 7"</input_code>
  <output_code>[master d6dc485] Commit con los archivos 6 y 7
 2 files changed, 2 insertions(+)
 create mode 100644 archivo6.py
 create mode 100644 archivo7.py
</output_code>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>* [33md6dc485[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmaster[m[33m)[m Commit con los archivos 6 y 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Primeiro desfazemos o √∫ltimo commit com `git reset --soft HEAD~1`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git reset --soft HEAD~1</input_code>
  <markdown>Fazemos um `git status` para ver o que ocorreu</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama master
Cambios a ser confirmados:
  (usa "git restore --staged &lt;archivo&gt;..." para sacar del √°rea de stage)
	[32mnuevos archivos: archivo6.py[m
	[32mnuevos archivos: archivo7.py[m

</output_code>
  <markdown>Vemos que desfizemos o commit, mas os dois arquivos se encontram na √°rea de staged, portanto, para remover um dos arquivos do commit, primeiro √© necess√°rio remov√™-lo da √°rea de staged. Para isso, fazemos `git reset arquivo6.py`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git reset archivo6.py</input_code>
  <markdown>Fazemos novamente um `git status`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama master
Cambios a ser confirmados:
  (usa "git restore --staged &lt;archivo&gt;..." para sacar del √°rea de stage)
	[32mnuevos archivos: archivo7.py[m

Archivos sin seguimiento:
  (usa "git add &lt;archivo&gt;..." para incluirlo a lo que se ser√° confirmado)
	[31marchivo6.py[m

</output_code>
  <markdown>Vemos que `arquivo7.py` est√° na √°rea de staged, enquanto `arquivo6.py` j√° n√£o est√°. Agora podemos apagar o arquivo 6, para isso usamos `git clean`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git clean -n</input_code>
  <output_code>Ser√° borrado archivo6.py
</output_code>
  <input_code>!cd notebook_git &amp;&amp; git clean -f</input_code>
  <output_code>Borrando archivo6.py
</output_code>
  <markdown>Fazemos novamente um `git status`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama master
Cambios a ser confirmados:
  (usa "git restore --staged &lt;archivo&gt;..." para sacar del √°rea de stage)
	[32mnuevos archivos: archivo7.py[m

</output_code>
  <markdown>Como vemos `arquivo.py` j√° n√£o est√°, ent√£o podemos fazer um novo commit</markdown>
  <input_code>!cd notebook_git &amp;&amp; git commit -m "Commit con el archivo 7"</input_code>
  <output_code>[master 4bb9d75] Commit con el archivo 7
 1 file changed, 1 insertion(+)
 create mode 100644 archivo7.py
</output_code>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>* [33m4bb9d75[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmaster[m[33m)[m Commit con el archivo 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Removemos o √∫ltimo commit e o substitu√≠mos por um novo, removendo o arquivo que quer√≠amos.</markdown>
  <markdown>### Hist√≥rico de altera√ß√µes de um arquivo (`git log &lt;arquivo&gt;`)</markdown>
  <markdown>Embora antes tenhamos visto como podemos ver o hist√≥rico do reposit√≥rio com `git log`, pode ser que n√£o nos interesse o hist√≥rico de todo o reposit√≥rio. Pode ser que tenhamos um bug em um arquivo de c√≥digo que no in√≠cio n√£o t√≠nhamos, por isso √© poss√≠vel que queiramos ver apenas o hist√≥rico desse arquivo. Para isso, usamos `git log &lt;arquivo&gt;`</markdown>
  <markdown>Primeiro vemos os arquivos que temos</markdown>
  <input_code>!cd notebook_git &amp;&amp; ls</input_code>
  <output_code>api_keys.py  archivo1.py  archivo2.py  archivo4.py  archivo7.py  hola.py
</output_code>
  <markdown>Suponhamos que queremos ver apenas as mudan√ßas em `hola.py`, ent√£o fazemos `git log hola.py`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate hola.py</input_code>
  <output_code>* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Podemos ver que aparecem muitos menos resultados do que se tiv√©ssemos feito `git log`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>* [33m4bb9d75[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmaster[m[33m)[m Commit con el archivo 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>### Ver modifica√ß√µes de um arquivo em um ponto espec√≠fico do hist√≥rico (`git show &lt;hash&gt; &lt;arquivo&gt;` ou `git diff &lt;arquivo&gt;`)</markdown>
  <markdown>Suponhamos que j√° sabemos em qual ponto uma altera√ß√£o foi feita no arquivo que cont√©m um bug, ent√£o agora queremos saber quais altera√ß√µes foram feitas para descobrir o que pode estar causando o bug. Para isso, podemos usar `git show &lt;hash&gt; &lt;arquivo&gt;`</markdown>
  <markdown>Vamos ver quais mudan√ßas ocorreram em `hola.py` no hash `c4930d7`, ou seja, quando foi feito o terceiro commit</markdown>
  <input_code>!cd notebook_git &amp;&amp; git show c4930d7 hola.py</input_code>
  <output_code>[33mcommit c4930d7267c3f8df389ab0cb1bda0b5fceabb5c2[m
Author: maximofn &lt;maximofn@gmail.com&gt;
Date:   Sun Apr 16 02:29:59 2023 +0200

    Tercer commit, hola.py

[1mdiff --git a/hola.py b/hola.py[m
[1mindex 91dee80..33bdb99 100644[m
[1m--- a/hola.py[m
[1m+++ b/hola.py[m
[36m@@ -1,2 +1,3 @@[m
 print('Hola mundo')[m
 print('He a√±adido una nueva linea')[m
[32m+[m[32mprint('Esta es la tercera linea')[m
</output_code>
  <markdown>A maneira de ver as mudan√ßas no git n√£o √© muito intuitiva, mas podemos ver que foi adicionada a linha `print('Esta √© a terceira linha')`</markdown>
  <markdown>Outra maneira de ver altera√ß√µes √© com `git diff`, temos duas op√ß√µes, podemos ver as altera√ß√µes do arquivo no momento atual em rela√ß√£o a um ponto espec√≠fico do hist√≥rico, para isso fazemos `git diff &lt;hash&gt; &lt;arquivo&gt;`.

Por exemplo, se quisermos ver as mudan√ßas de `hola.py` desde quando foi feito o primeiro commit (hash `1c95e4f`) at√© a situa√ß√£o atual, devemos inserir (`git diff 1c95e4f hola.py`)
</markdown>
  <input_code>!cd notebook_git &amp;&amp; git diff 1c95e4f hola.py</input_code>
  <output_code>[1mdiff --git a/hola.py b/hola.py[m
[1mindex f140969..33bdb99 100644[m
[1m--- a/hola.py[m
[1m+++ b/hola.py[m
[36m@@ -1 +1,3 @@[m
 print('Hola mundo')[m
[32m+[m[32mprint('He a√±adido una nueva linea')[m
[32m+[m[32mprint('Esta es la tercera linea')[m
</output_code>
  <markdown>Mas se quisermos ver a diferen√ßa entre um ponto espec√≠fico do hist√≥rico e outro ponto espec√≠fico, temos que introduzir os hashes dos dois momentos, ou seja `git diff &lt;hash1&gt; &lt;hash2&gt; &lt;arquivo&gt;`

Se quisermos ver as mudan√ßas de `hola.py` entre o segundo commit (hash `6e99e73`) e o primeiro commit (hash `1c95e4f`), ter√≠amos que introduzir `git diff 1c95e4f 6e99e73 hola.py`
</markdown>
  <input_code>!cd notebook_git &amp;&amp; git diff 1c95e4f 6e99e73 hola.py</input_code>
  <output_code>[1mdiff --git a/hola.py b/hola.py[m
[1mindex f140969..91dee80 100644[m
[1m--- a/hola.py[m
[1m+++ b/hola.py[m
[36m@@ -1 +1,2 @@[m
 print('Hola mundo')[m
[32m+[m[32mprint('He a√±adido una nueva linea')[m
</output_code>
  <markdown>O anterior nos mostra as mudan√ßas do segundo commit em rela√ß√£o ao primeiro, mas se o que queremos s√£o as mudan√ßas do primeiro commit em rela√ß√£o ao segundo, basta colocar os hashes ao contr√°rio de como os colocamos, ou seja `git diff 6e99e73 1c95e4f hola.py`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git diff 6e99e73 1c95e4f hola.py</input_code>
  <output_code>[1mdiff --git a/hola.py b/hola.py[m
[1mindex 91dee80..f140969 100644[m
[1m--- a/hola.py[m
[1m+++ b/hola.py[m
[36m@@ -1,2 +1 @@[m
 print('Hola mundo')[m
[31m-print('He a√±adido una nueva linea')[m
</output_code>
  <markdown>### Viagem ao passado (`git reset --hard &lt;hash&gt;` ou `git reset --soft &lt;hash&gt;`)</markdown>
  <markdown>Imaginemos que encontramos que tudo o que fizemos ap√≥s gerar o bug n√£o serve e temos que voltar a trabalhar a partir desse ponto, podemos voltar a uma posi√ß√£o do hist√≥rico por meio de `git reset --hard &lt;hash&gt;` (isso n√£o manter√° as altera√ß√µes) ou `git reset --soft &lt;hash&gt;` (isso sim manter√° as altera√ß√µes).</markdown>
  <markdown>Primeiro vejamos o hist√≥rico</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>* [33m4bb9d75[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmaster[m[33m)[m Commit con el archivo 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Suponhamos que queremos voltar ao momento em que fizemos o terceiro commit (hash `c4930d7`), al√©m disso, fazemos isso sem manter as altera√ß√µes, ou seja, todas as modifica√ß√µes que fizemos depois ser√£o apagadas, fazemos `git reset --hard c4930d7`</markdown>
  <markdown>Primeiro fazemos `ls` para ver os arquivos que temos agora</markdown>
  <input_code>!cd notebook_git &amp;&amp; ls</input_code>
  <output_code>api_keys.py  archivo1.py  archivo2.py  archivo4.py  archivo7.py  hola.py
</output_code>
  <markdown>Vamos ao terceiro commit</markdown>
  <input_code>!cd notebook_git &amp;&amp; git reset --hard c4930d7</input_code>
  <output_code>HEAD est√° ahora en c4930d7 Tercer commit, hola.py
</output_code>
  <markdown>Se fazemos `ls` veremos que j√° n√£o temos nem `archivo1.py`, nem `archivo2.py`, nem `archivo4.py`, nem `archivo7.py`</markdown>
  <input_code>!cd notebook_git &amp;&amp; ls</input_code>
  <output_code>api_keys.py  hola.py
</output_code>
  <markdown>### Volta ao futuro (`git reflog`)</markdown>
  <markdown>Suponhamos que nos arrependemos e queremos voltar ao ponto onde est√°vamos, ao √∫ltimo punto no hist√≥rico. Uma maneira seria fazer `git reset --hard &lt;hash&gt;`. Mas imaginemos que n√£o sabemos o hash, porque n√£o fizemos `git log` antes e se o fizermos agora s√≥ nos d√° informa√ß√£o do hist√≥rico at√© o terceiro commit.</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>* [33mc4930d7[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmaster[m[33m)[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Aqui o que podemos fazer √© `git reflog`, que nos dar√° um hist√≥rico incluindo os saltos</markdown>
  <input_code>!cd notebook_git &amp;&amp; git reflog</input_code>
  <output_code>[33mc4930d7[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmaster[m[33m)[m HEAD@{0}: reset: moving to c4930d7
[33m4bb9d75[m HEAD@{1}: commit: Commit con el archivo 7
[33mea615a9[m HEAD@{2}: reset: moving to HEAD~1
[33md6dc485[m HEAD@{3}: commit: Commit con los archivos 6 y 7
[33mea615a9[m HEAD@{4}: commit: Eliminado archivo5.py
[33me3153a5[m HEAD@{5}: commit: Commit con los archivos 4 y 5
[33m0b09cfa[m HEAD@{6}: commit: A√±adido .gitignore
[33m04ebd1f[m HEAD@{7}: reset: moving to HEAD~1
[33m0147d65[m HEAD@{8}: commit: Commit con el archivo 3
[33m04ebd1f[m HEAD@{9}: reset: moving to HEAD~1
[33m6dc7be6[m HEAD@{10}: commit: Commit con el archivos 3
[33m04ebd1f[m HEAD@{11}: commit (amend): Commit con los archivos 1 y 2
[33m285b243[m HEAD@{12}: commit: Commit con el archivo 1
[33mc4930d7[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmaster[m[33m)[m HEAD@{13}: commit (amend): Tercer commit, hola.py
[33m60e2ffd[m HEAD@{14}: commit: Tercer commot, hola.py
[33m6e99e73[m HEAD@{15}: commit: Segundo commit, hola.py
[33m1c95e4f[m HEAD@{16}: commit (initial): Primer commit, hola.py
</output_code>
  <markdown>Podemos ver que nos diz que est√°vamos no commit com hash `4bb9d75`, ou seja, o √∫ltimo commit que fizemos, e de l√° fomos at√© o commit com hash `c4930d7`, que se voc√™ reparar, √© o mesmo hash do commit com mensagem `Tercer commit, hola.py`. Portanto, j√° sabemos o hash do √∫ltimo commit, o `4bb9d75`, assim para voltar √† posi√ß√£o do √∫ltimo commit fazemos `git reset --hard 4bb9d75`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git reset --hard 4bb9d75</input_code>
  <output_code>HEAD est√° ahora en 4bb9d75 Commit con el archivo 7
</output_code>
  <markdown>Se agora voltarmos a fazer um log</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>* [33m4bb9d75[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmaster[m[33m)[m Commit con el archivo 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Vemos que efectivamente estamos na posi√ß√£o do √∫ltimo commit, *voltamos para o futuro*</markdown>
  <markdown>### Pesquisa em arquivos (`git grep &lt;palavra&gt;`)</markdown>
  <markdown>Se quisermos procurar em arquivos, podemos faz√™-lo com o comando `git grep`. Como no reposit√≥rio que estamos construindo √© muito pequeno e tem poucos arquivos, vamos baixar um novo por meio de um comando que veremos com mais detalhes posteriormente.</markdown>
  <input_code>!git clone https://github.com/facebookresearch/segment-anything.git</input_code>
  <output_code>Clonando en 'segment-anything'...
remote: Enumerating objects: 279, done.[K
remote: Counting objects: 100% (181/181), done.[K
remote: Compressing objects: 100% (77/77), done.[K
remote: Total 279 (delta 116), reused 104 (delta 104), pack-reused 98[K
Recibiendo objetos: 100% (279/279), 18.31 MiB | 21.25 MiB/s, listo.
Resolviendo deltas: 100% (140/140), listo.
</output_code>
  <markdown>O reposit√≥rio que baixamos √© o do c√≥digo-fonte do SAM, uma rede neural da Meta para segmentar qualquer objeto. Entramos na pasta do reposit√≥rio e procuramos, por exemplo, quantas vezes a palavra `softmax` foi escrita.</markdown>
  <input_code>!cd segment-anything &amp;&amp; git grep softmax</input_code>
  <output_code>segment_anything/modeling/image_encoder.py[36m:[m        attn = attn.[1;31msoftmax[m(dim=-1)
segment_anything/modeling/transformer.py[36m:[m        attn = torch.[1;31msoftmax[m(attn, dim=-1)
</output_code>
  <markdown>Vemos que se escreveu nos arquivos `segment_anything/modeling/image_encoder.py` e `segment_anything/modeling/transformer.py`.</markdown>
  <markdown>Se quisermos saber em quais linhas dos arquivos foi escrito, usamos a flag `-n`</markdown>
  <input_code>!cd segment-anything &amp;&amp; git grep -n softmax</input_code>
  <output_code>segment_anything/modeling/image_encoder.py[36m:[m236[36m:[m        attn = attn.[1;31msoftmax[m(dim=-1)
segment_anything/modeling/transformer.py[36m:[m233[36m:[m        attn = torch.[1;31msoftmax[m(attn, dim=-1)
</output_code>
  <markdown>Se quisermos contar quantas vezes uma palavra aparece, podemos usar a flag `-c`</markdown>
  <input_code>!cd segment-anything &amp;&amp; git grep -c softmax</input_code>
  <output_code>segment_anything/modeling/image_encoder.py[36m:[m1
segment_anything/modeling/transformer.py[36m:[m1
</output_code>
  <markdown>E vemos que aparece uma vez em cada arquivo</markdown>
  <markdown>E nos diz que est√£o nas linhas 236 e 233, respectivamente.</markdown>
  <markdown>### Busca em commits (`git log -S &lt;palavra&gt;`)</markdown>
  <markdown>Se quisermos buscar no hist√≥rico de commits, podemos usar o comando `git log -S &lt;palavra&gt;`. Por exemplo, busquemos no hist√≥rico de commits do reposit√≥rio que baixamos anteriormente a palavra `fix`.</markdown>
  <input_code>!cd segment-anything &amp;&amp; git log -S "collab"</input_code>
  <output_code>[33mcommit 2780a301de4483e5c46edb230ea781556159c658[m
Author: Eric Mintun &lt;eric.mintun@gmail.com&gt;
Date:   Mon Apr 10 10:50:17 2023 -0700

    Fix typo in notebook 'using_collab'-&gt;'using_colab' in other two notebooks.

[33mcommit 2c11ea23525970ac288f23dc74b203bcbfb4cc6a[m
Author: jp-x-g &lt;jpxg-dev@protonmail.com&gt;
Date:   Thu Apr 6 20:00:04 2023 -0700

    fix parameter name
    
    "using_collab" does not appear in subsequent text, replacing with "using_colab"

[33mcommit b47d02d68c308672751be29742fcef02a86e2f02[m
Author: Eric Mintun &lt;eric.mintun@gmail.com&gt;
Date:   Wed Apr 5 06:13:09 2023 -0700

    Fix broken links in notebook Colab setup.

[33mcommit 571794162e0887c15d12b809505b902c7bf8b4db[m
Author: Eric Mintun &lt;eric.mintun@gmail.com&gt;
Date:   Tue Apr 4 22:25:49 2023 -0700

    Initial commit
</output_code>
  <markdown>Apagamos a pasta do SAM</markdown>
  <input_code>!rm -r segment-anything</input_code>
  <markdown>## Ramas</markdown>
  <markdown>![branches](https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/GIT-Branchand-its-Operations.webp)

O uso de branches √© muito √∫til, pois podemos come√ßar a desenvolver um novo recurso sem ter que modificar o c√≥digo original
</markdown>
  <markdown>### Criar uma branch (`git branch &lt;nome-da-branch&gt;`)</markdown>
  <markdown>&gt; **Nota**: Antes de tudo, √© preciso dizer que para criar uma branch em um reposit√≥rio deve haver pelo menos um commit. Se tentarmos criar uma branch antes de fazer o primeiro commit, receberemos um erro.</markdown>
  <markdown>Para criar uma branch usamos o comando `git branch &lt;nome da branch&gt;`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git branch new_branch</input_code>
  <markdown>### Listar ramos (`git branch`)</markdown>
  <markdown>Criamos nossa primeira branch, podemos verificar todas as branches criadas apenas escrevendo `git branch`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git branch</input_code>
  <output_code>* [32mmaster[m
  new_branch[m
</output_code>
  <markdown>Al√©m de listar, ele indica com um asterisco `*` em qual ramo estamos, neste caso na ramo `master`.</markdown>
  <markdown>### Renomear ramos, adeus √† ramo `master` (`git branch -m &lt;nome antigo&gt; &lt;novo nome&gt;`)</markdown>
  <markdown>Hist√≥ricamente no git a ramifica√ß√£o principal era chamada de `master`, mas isso tem conota√ß√µes hist√≥ricas negativas devido ao conceito de `master-slave` (`maestro-escravo`), em raz√£o do sofrimento que muitas pessoas enfrentaram. Por isso, agora a ramifica√ß√£o principal costuma ser denominada `main`, ent√£o para renome√°-la usamos `git branch -m master main`.</markdown>
  <input_code>!cd notebook_git &amp;&amp; git branch -m master main</input_code>
  <markdown>Listamos as ramas</markdown>
  <input_code>!cd notebook_git &amp;&amp; git branch</input_code>
  <output_code>* [32mmain[m
  new_branch[m
</output_code>
  <markdown>Como vemos, conseguimos mudar o nome da branch principal de `master` para `main`</markdown>
  <markdown>### Mudar de ramo (`git switch &lt;branch&gt;`)</markdown>
  <markdown>Se quisermos mudar de branch, basta escrever `git switch &lt;nome da branch&gt;`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git switch new_branch</input_code>
  <output_code>Cambiado a rama 'new_branch'
</output_code>
  <markdown>Vamos ver em qual ramo estamos com `git branch`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git branch</input_code>
  <output_code>  main[m
* [32mnew_branch[m
</output_code>
  <markdown>Como vemos, mudamos de branch para new_branch</markdown>
  <markdown>Se quisermos criar e mudar para uma branch em um √∫nico comando, podemos usar `git switch -c &lt;nome da branch&gt;`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git switch -c new_branch2</input_code>
  <output_code>Cambiado a nueva rama 'new_branch2'
</output_code>
  <markdown>Vamos ver em qual branch estamos</markdown>
  <input_code>!cd notebook_git &amp;&amp; git branch</input_code>
  <output_code>  main[m
  new_branch[m
* [32mnew_branch2[m
</output_code>
  <markdown>N√≥s criamos e mudamos de branch com um √∫nico comando</markdown>
  <markdown>### Obter a branch em que estamos (`git branch --show-current`)</markdown>
  <markdown>Como vimos at√© agora com `git branch` podemos obter uma lista de todas as ramas e ainda ver em qual estamos atualmente, mas no caso de termos uma grande quantidade de ramas, algo que pode acontecer em uma equipe de trabalho com muita gente, √© bom obter apenas a rama e n√£o uma lista de todas. Para isso usamos `git branch --show-current`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git branch --show-current</input_code>
  <output_code>new_branch2
</output_code>
  <markdown>### Lista de ramas mais recentes (`git branch --sort=-committerdate`)</markdown>
  <markdown>Em caso de ter muitas branches, talvez seja interessante saber quais s√£o as mais recentes para ver quais foram as √∫ltimas criadas e onde deve estar o √∫ltimo desenvolvimento. Para isso, usamos `git branch --sort=-committerdate`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git branch --sort=-committerdate</input_code>
  <output_code>* [32mnew_branch2[m
  new_branch[m
  main[m
</output_code>
  <markdown>Como vemos, as ordenou em ordem inversa √† que foram criadas.</markdown>
  <markdown>### O comando preterido `git checkout`</markdown>
  <markdown>At√© recentemente, o comando para criar ramifica√ß√µes e alternar entre elas era `git checkout`, mas este comando n√£o fazia apenas isso, tamb√©m restaurava o diret√≥rio de trabalho. No entanto, isso vai contra a filosofia do Linux, por isso foram criados os comandos `git branch`, `git switch` e `git restore` para dividir essa funcionalidade.</markdown>
  <markdown>### Fundindo branches (`git merge`)</markdown>
  <markdown>Como dissem, criar branches √© muito √∫til para desenvolver novas funcionalidades sem afetar o resto da equipe. Mas quando elas est√£o conclu√≠das, √© necess√°rio lev√°-las para a branch principal, para isso usamos o comando `git merge &lt;branch&gt;`

&gt; **Importante**: Temos que estar na branch que vai adotar as mudan√ßas, ou seja, se quisermos mesclar as mudan√ßas realizadas na branch `new_branch2` na branch `main`, primeiro temos que nos certificar de estar na branch `main`
</markdown>
  <markdown>Primeiro verificamos em qual branch estamos</markdown>
  <input_code>!cd notebook_git &amp;&amp; git branch --show-current</input_code>
  <output_code>new_branch2
</output_code>
  <markdown>Eliminamos `arquivo7.py`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git rm archivo7.py</input_code>
  <output_code>rm 'archivo7.py'
</output_code>
  <markdown>Fazemos um commit com as mudan√ßas</markdown>
  <input_code>!cd notebook_git &amp;&amp; git commit -am "Eliminado archivo7.py"</input_code>
  <output_code>[new_branch2 5168f78] Eliminado archivo7.py
 1 file changed, 1 deletion(-)
 delete mode 100644 archivo7.py
</output_code>
  <markdown>Se fazemos um `ls` vemos que `arquivo7.py` j√° n√£o est√°</markdown>
  <input_code>!cd notebook_git &amp;&amp; ls | grep archivo7</input_code>
  <markdown>Criamos um novo arquivo e fazemos um commit</markdown>
  <input_code>!cd notebook_git &amp;&amp; touch archivo8.py &amp;&amp; git add archivo8.py &amp;&amp; git commit -m "Commit con el archivo 8"</input_code>
  <output_code>[new_branch2 564ccfb] Commit con el archivo 8
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 archivo8.py
</output_code>
  <markdown>Fizemos dois commits novos nesta branch, vamos ver com `git log`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>* [33m564ccfb[m[33m ([m[1;36mHEAD -&gt; [m[1;32mnew_branch2[m[33m)[m Commit con el archivo 8
* [33m5168f78[m Eliminado archivo7.py
* [33m4bb9d75[m[33m ([m[1;32mnew_branch[m[33m, [m[1;32mmain[m[33m)[m Commit con el archivo 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Mudamos para a branch principal</markdown>
  <input_code>!cd notebook_git &amp;&amp; git switch main</input_code>
  <output_code>Cambiado a rama 'main'
</output_code>
  <markdown>Se agora fizermos de novo `ls` veremos que `arquivo7.py` sim est√°</markdown>
  <input_code>!cd notebook_git &amp;&amp; ls | grep archivo7</input_code>
  <output_code>archivo7.py
</output_code>
  <markdown>Fusamos as branches, trazendo as mudan√ßas de `new_branch2` para `main`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git merge new_branch2</input_code>
  <output_code>Actualizando 4bb9d75..564ccfb
Fast-forward
 archivo7.py | 1 [31m-[m
 archivo8.py | 0
 2 files changed, 1 deletion(-)
 delete mode 100644 archivo7.py
 create mode 100644 archivo8.py
</output_code>
  <markdown>Fazemos um `git status`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama main
nada para hacer commit, el √°rbol de trabajo est√° limpio
</output_code>
  <markdown>Vemos que ao fazer o merge n√£o √© necess√°rio fazer nenhum commit, vejamos com um `git log` o que aconteceu.</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>* [33m564ccfb[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmain[m[33m, [m[1;32mnew_branch2[m[33m)[m Commit con el archivo 8
* [33m5168f78[m Eliminado archivo7.py
* [33m4bb9d75[m[33m ([m[1;32mnew_branch[m[33m)[m Commit con el archivo 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Vemos que o commit da branch `new_branch2` foi incorporado a esta branch</markdown>
  <markdown>#### Avan√ßo r√°pido</markdown>
  <markdown>Neste caso criamos uma nova branch, a principal n√£o √© afetada e apenas modificamos a nova, realizando v√°rios commits. Portanto, ao unir a nova na principal, todos os commits feitos na nova ser√£o vis√≠veis. Para realizar este tipo de merge, escrevemos `git merge --ff-only &lt;branch&gt;`</markdown>
  <input_code>### Este c√≥digo es para crear el gr√°fico de las ramas, no es necesario para el curso

import graphviz

# Crear el gr√°fico con la direcci√≥n de las flechas de izquierda a derecha
orin = graphviz.Digraph('G', graph_attr={'rankdir': 'LR'})
fast_foward = graphviz.Digraph('G', graph_attr={'rankdir': 'LR'})

# Agregar nodos (pelotas) A, B, C y D en la rama principal
orin.node('A', shape='circle', label='A', color='blue')
orin.node('B', shape='circle', label='B', color='blue')
orin.node('C', shape='circle', label='C', color='blue')
orin.node('D', shape='circle', label='D', color='blue')
orin.node('E', shape='circle', label='', color='transparent')
fast_foward.node('A', shape='circle', label='A', color='blue')
fast_foward.node('B', shape='circle', label='B', color='blue')
fast_foward.node('C', shape='circle', label='C', color='blue')
fast_foward.node('D', shape='circle', label='D', color='blue')

# Agregar nodos (pelotas) X e Y en la rama secundaria
orin.node('X', shape='circle', label='X', color='green')
orin.node('Y', shape='circle', label='Y', color='green')
fast_foward.node('X', shape='circle', label='X', color='magenta')
fast_foward.node('Y', shape='circle', label='Y', color='magenta')

# Agregar flechas entre los nodos en la rama principal
orin.edges(['AB', 'BC', 'CD'])
orin.edge('D', 'E', color='transparent')  # Hacer la flecha de C a D transparente
fast_foward.edges(['AB', 'BC', 'CD', 'DX', 'XY'])

# Agregar flechas entre los nodos en la rama secundaria
orin.edges(['DX', 'XY'])

# Mostrar el diagrama de flujo en la celda de c√≥digo de Jupyter Notebook
display(orin)
display(fast_foward)</input_code>
  <output_code>&lt;graphviz.graphs.Digraph at 0x7f58f80c09a0&gt;</output_code>
  <output_code>&lt;graphviz.graphs.Digraph at 0x7f58f9203fa0&gt;</output_code>
  <markdown>Vamos primeiro a verificar que estamos na branch principal</markdown>
  <input_code>!cd notebook_git &amp;&amp; git branch --show-current</input_code>
  <output_code>main
</output_code>
  <markdown>Criamos uma nova branch</markdown>
  <input_code>!cd notebook_git &amp;&amp; git branch branch_fast_forward</input_code>
  <markdown>Mudamos para ela</markdown>
  <input_code>!cd notebook_git &amp;&amp; git switch branch_fast_forward</input_code>
  <output_code>Cambiado a rama 'branch_fast_forward'
</output_code>
  <input_code>!cd notebook_git &amp;&amp; git branch --show-current</input_code>
  <output_code>branch_fast_forward
</output_code>
  <markdown>Vamos ver o log</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate --all</input_code>
  <output_code>* [33m564ccfb[m[33m ([m[1;36mHEAD -&gt; [m[1;32mbranch_fast_forward[m[33m, [m[1;32mnew_branch2[m[33m, [m[1;32mmain[m[33m)[m Commit con el archivo 8
* [33m5168f78[m Eliminado archivo7.py
* [33m4bb9d75[m[33m ([m[1;32mnew_branch[m[33m)[m Commit con el archivo 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Ok, estamos em um branch criado a partir do principal com todo o seu hist√≥rico de logs, fazemos dois novos commits</markdown>
  <input_code>!cd notebook_git &amp;&amp; git rm archivo4.py &amp;&amp; git commit -am "Eliminado archivo4.py"</input_code>
  <output_code>rm 'archivo4.py'
[branch_fast_forward 4484e70] Eliminado archivo4.py
 1 file changed, 1 deletion(-)
 delete mode 100644 archivo4.py
</output_code>
  <input_code>!cd notebook_git &amp;&amp; git rm hola.py &amp;&amp; git commit -am "Eliminado hola.py"</input_code>
  <output_code>rm 'hola.py'
[branch_fast_forward 94149fc] Eliminado hola.py
 1 file changed, 3 deletions(-)
 delete mode 100644 hola.py
</output_code>
  <markdown>Fazemos um novo log para ver o que foi criado nesta nova branch.</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>* [33m94149fc[m[33m ([m[1;36mHEAD -&gt; [m[1;32mbranch_fast_forward[m[33m)[m Eliminado hola.py
* [33m4484e70[m Eliminado archivo4.py
* [33m564ccfb[m[33m ([m[1;32mnew_branch2[m[33m, [m[1;32mmain[m[33m)[m Commit con el archivo 8
* [33m5168f78[m Eliminado archivo7.py
* [33m4bb9d75[m[33m ([m[1;32mnew_branch[m[33m)[m Commit con el archivo 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>ComoÊàë‰ª¨ÂèØ‰ª•ÁúãÂà∞ÔºåÊúÄÂêé‰∏§‰∏™Êèê‰∫§ÊòØÊàë‰ª¨ÂàõÂª∫ÁöÑÔºåÊàë‰ª¨ÂèØ‰ª•Ê£ÄÊü•Ëøô‰∫õÊèê‰∫§‰∏çÂú®‰∏ªÂàÜÊîØ‰∏äÔºà‰∏∫Ê≠§ÊàëÊåáÂÆöË¶ÅÂú® `main` ÂàÜÊîØ‰∏äËøõË°åÊìç‰ΩúÔºâ  

Note: The provided translation is in Chinese instead of Portuguese. Here is the correct Portuguese translation:

Como podemos ver, os dois √∫ltimos commits s√£o aqueles que criamos e podemos verificar que esses commits n√£o est√£o na branch principal (para isso especifico que seja feito sobre a branch `main`)</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log main --graph --oneline --decorate</input_code>
  <output_code>* [33m564ccfb[m[33m ([m[1;32mnew_branch2[m[33m, [m[1;32mmain[m[33m)[m Commit con el archivo 8
* [33m5168f78[m Eliminado archivo7.py
* [33m4bb9d75[m[33m ([m[1;32mnew_branch[m[33m)[m Commit con el archivo 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Agora vamos para a branch `main` fazer o merge.</markdown>
  <input_code>!cd notebook_git &amp;&amp; git switch main</input_code>
  <output_code>Cambiado a rama 'main'
</output_code>
  <markdown>Por √∫ltimo, fazemos o merge do tipo fast forward</markdown>
  <input_code>!cd notebook_git &amp;&amp; git merge --ff-only branch_fast_forward</input_code>
  <output_code>Actualizando 564ccfb..94149fc
Fast-forward
 archivo4.py | 1 [31m-[m
 hola.py     | 3 [31m---[m
 2 files changed, 4 deletions(-)
 delete mode 100644 archivo4.py
 delete mode 100644 hola.py
</output_code>
  <markdown>O merge foi feito, vamos ver o que aconteceu com o log na branch `main`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>* [33m94149fc[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmain[m[33m, [m[1;32mbranch_fast_forward[m[33m)[m Eliminado hola.py
* [33m4484e70[m Eliminado archivo4.py
* [33m564ccfb[m[33m ([m[1;32mnew_branch2[m[33m)[m Commit con el archivo 8
* [33m5168f78[m Eliminado archivo7.py
* [33m4bb9d75[m[33m ([m[1;32mnew_branch[m[33m)[m Commit con el archivo 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Como se v√™, foram mantidos os dois commits realizados na branch `branch_fast_forward`</markdown>
  <markdown>#### Sem avan√ßo r√°pido ou mesclagem verdadeira</markdown>
  <markdown>Neste caso, criamos uma nova branch, a principal n√£o foi tocada e modificamos a nova, realizando v√°rios commits. Em seguida, realizamos um commit na principal. Portanto, ao unir a nova na principal, ser√° visto um √∫nico commit na nova. Para fazer este tipo de merge, escrevemos `git merge &lt;branch&gt; --no-ff`</markdown>
  <input_code>### Este c√≥digo es para crear el gr√°fico de las ramas, no es necesario para el curso

import graphviz

# Crear el gr√°fico con la direcci√≥n de las flechas de izquierda a derecha
orin = graphviz.Digraph('G', graph_attr={'rankdir': 'LR'})
not_fast_forward = graphviz.Digraph('G', graph_attr={'rankdir': 'LR'})

# Agregar nodos (pelotas) A, B, C y D en la rama principal
orin.node('A', shape='circle', label='A', color='blue')
orin.node('B', shape='circle', label='B', color='blue')
orin.node('C', shape='circle', label='C', color='blue')
orin.node('D', shape='circle', label='D', color='blue')
orin.node('E', shape='circle', label='', color='transparent')
not_fast_forward.node('A', shape='circle', label='A', color='blue')
not_fast_forward.node('B', shape='circle', label='B', color='blue')
not_fast_forward.node('C', shape='circle', label='C', color='blue')
not_fast_forward.node('D', shape='circle', label='D', color='blue')
not_fast_forward.node('E', shape='circle', label='E', color='blue')

# Agregar nodos (pelotas) X e Y en la rama secundaria
orin.node('X', shape='circle', label='X', color='green')
orin.node('Y', shape='circle', label='Y', color='green')
not_fast_forward.node('X', shape='circle', label='X', color='green')
not_fast_forward.node('Y', shape='circle', label='Y', color='green')

# Agregar nodo (pelota) M en la rama principal
not_fast_forward.node('M', shape='circle', label='M', color='magenta')

# Agregar flechas entre los nodos en la rama principal
orin.edges(['AB', 'BC', 'CD'])
orin.edge('D', 'E', color='transparent')  # Hacer la flecha de C a D transparente
not_fast_forward.edges(['AB', 'BC', 'CD', 'DE'])

# Agregar flechas entre los nodos en la rama secundaria
orin.edges(['DX', 'XY'])
not_fast_forward.edges(['DX', 'XY', 'YM'])

# Agregar flechas de la rama principal al nodo M
not_fast_forward.edge('E', 'M')

# Mostrar el diagrama de flujo en la celda de c√≥digo de Jupyter Notebook
display(orin)
display(not_fast_forward)</input_code>
  <output_code>&lt;graphviz.graphs.Digraph at 0x7f58f80c2fb0&gt;</output_code>
  <output_code>&lt;graphviz.graphs.Digraph at 0x7f58f80c2230&gt;</output_code>
  <markdown>Vamos primeiro a verificar que estamos na branch principal</markdown>
  <input_code>!cd notebook_git &amp;&amp; git branch --show-current</input_code>
  <output_code>main
</output_code>
  <markdown>Criamos uma nova branch</markdown>
  <input_code>!cd notebook_git &amp;&amp; git branch branch_no_fast_forward</input_code>
  <markdown>Mudamos para ela</markdown>
  <input_code>!cd notebook_git &amp;&amp; git switch branch_no_fast_forward</input_code>
  <output_code>Cambiado a rama 'branch_no_fast_forward'
</output_code>
  <input_code>!cd notebook_git &amp;&amp; git branch --show-current</input_code>
  <output_code>branch_no_fast_forward
</output_code>
  <markdown>Claro, estamos em um branch criado a partir do principal com todo o seu hist√≥rico de logs, fazemos dois novos commits.</markdown>
  <input_code>!cd notebook_git &amp;&amp; touch file1 &amp;&amp; git add file1 &amp;&amp; git commit -m "file1"</input_code>
  <output_code>[branch_no_fast_forward e4e23c9] file1
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 file1
</output_code>
  <input_code>!cd notebook_git &amp;&amp; touch file2 &amp;&amp; git add file2 &amp;&amp; git commit -m "file2"</input_code>
  <output_code>[branch_no_fast_forward 8df3429] file2
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 file2
</output_code>
  <markdown>Fazemos um novo log para ver o que foi criado nesta nova branch.</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>* [33m8df3429[m[33m ([m[1;36mHEAD -&gt; [m[1;32mbranch_no_fast_forward[m[33m)[m file2
* [33me4e23c9[m file1
* [33m94149fc[m[33m ([m[1;32mmain[m[33m, [m[1;32mbranch_fast_forward[m[33m)[m Eliminado hola.py
* [33m4484e70[m Eliminado archivo4.py
* [33m564ccfb[m[33m ([m[1;32mnew_branch2[m[33m)[m Commit con el archivo 8
* [33m5168f78[m Eliminado archivo7.py
* [33m4bb9d75[m[33m ([m[1;32mnew_branch[m[33m)[m Commit con el archivo 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Como vemos, os dois √∫ltimos commits s√£o os que criamos e podemos verificar que esses commits n√£o est√£o na branch principal (para isso especifico que seja feito sobre a branch `main`).</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log main --graph --oneline --decorate</input_code>
  <output_code>* [33m94149fc[m[33m ([m[1;32mmain[m[33m, [m[1;32mbranch_fast_forward[m[33m)[m Eliminado hola.py
* [33m4484e70[m Eliminado archivo4.py
* [33m564ccfb[m[33m ([m[1;32mnew_branch2[m[33m)[m Commit con el archivo 8
* [33m5168f78[m Eliminado archivo7.py
* [33m4bb9d75[m[33m ([m[1;32mnew_branch[m[33m)[m Commit con el archivo 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Agora vamos para o branch `main`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git switch main</input_code>
  <output_code>Cambiado a rama 'main'
</output_code>
  <markdown>Criamos um novo commit</markdown>
  <input_code>!cd notebook_git &amp;&amp; touch file3 &amp;&amp; git add file3 &amp;&amp; git commit -m "file3"</input_code>
  <output_code>[main 8bdf4d8] file3
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 file3
</output_code>
  <markdown>Por √∫ltimo, fazemos o merge do tipo n√£o fast forward</markdown>
  <input_code>!cd notebook_git &amp;&amp; git merge branch_no_fast_forward --no-ff</input_code>
  <output_code>[2B[m[mommit. comenzando con '#' ser√°n ignoradas, y un mensaje vac√≠o abortasaria esta[m[7m&gt;[4;1H[m[36m# especialmente si esto fusiona un upstream actualizado en una rama de t√≥pico. /home/wallabot/Documentos/web/portafolio/posts/notebook_git/.git/MERGE_MSG   [1;79H[m[22;16H[7m[ l√≠nea 1/7 (14%), col 1/48 (2%), car 0/301 (0%) ][m[22;16H             [7m[ P√°rrafo justificado ][m[K[H[7m...llabot/Documentos/web/portafolio/posts/notebook_git/.git/MERGE_MSG Modificado[1;80H[m</output_code>
  <markdown>Como vemos, nos abre o editor para introduzir uma mensagem de commit e uma mensagem por padr√£o. Aceitamos a mensagem e vemos o que aconteceu.</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama main
nada para hacer commit, el √°rbol de trabajo est√° limpio
</output_code>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>*   [33m274529c[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmain[m[33m)[m Merge branch 'branch_no_fast_forward' into main
[31m|[m[32m\[m  
[31m|[m * [33m8df3429[m[33m ([m[1;32mbranch_no_fast_forward[m[33m)[m file2
[31m|[m * [33me4e23c9[m file1
* [32m|[m [33m8bdf4d8[m file3
[32m|[m[32m/[m  
* [33m94149fc[m[33m ([m[1;32mbranch_fast_forward[m[33m)[m Eliminado hola.py
* [33m4484e70[m Eliminado archivo4.py
* [33m564ccfb[m[33m ([m[1;32mnew_branch2[m[33m)[m Commit con el archivo 8
* [33m5168f78[m Eliminado archivo7.py
* [33m4bb9d75[m[33m ([m[1;32mnew_branch[m[33m)[m Commit con el archivo 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <input_code>!cd notebook_git &amp;&amp; ls</input_code>
  <output_code>api_keys.py  archivo1.py  archivo2.py  archivo8.py  file1  file2  file3
</output_code>
  <markdown>Como podemos ver, foi criado um novo commit com as mudan√ßas da nova branch na branch principal.</markdown>
  <markdown>#### Squash</markdown>
  <markdown>Neste tipo de fus√£o, todos os commits de uma nova ramifica√ß√£o s√£o reunidos em um √∫nico commit na ramifica√ß√£o principal. Para isso, escrevemos `git merge &lt;rama&gt; --squash`</markdown>
  <input_code>### Este c√≥digo es para crear el gr√°fico de las ramas, no es necesario para el curso

import graphviz

# Crear el gr√°fico con la direcci√≥n de las flechas de izquierda a derecha
orin = graphviz.Digraph('G', graph_attr={'rankdir': 'LR'})
squash = graphviz.Digraph('G', graph_attr={'rankdir': 'LR'})

# Agregar nodos (pelotas) A, B, C y D en la rama principal
orin.node('A', shape='circle', label='A', color='blue')
orin.node('B', shape='circle', label='B', color='blue')
orin.node('C', shape='circle', label='C', color='blue')
orin.node('D', shape='circle', label='D', color='blue')
orin.node('E', shape='circle', label='', color='transparent')
squash.node('A', shape='circle', label='A', color='blue')
squash.node('B', shape='circle', label='B', color='blue')
squash.node('C', shape='circle', label='C', color='blue')
squash.node('D', shape='circle', label='D', color='blue')

# Agregar nodos (pelotas) X e Y en la rama secundaria
orin.node('X', shape='circle', label='X', color='green')
orin.node('Y', shape='circle', label='Y', color='green')

# Agregar nodo (pelota) M en la rama principal
squash.node('M', shape='circle', label='M', color='magenta')

# Agregar flechas entre los nodos en la rama principal
orin.edges(['AB', 'BC', 'CD'])
orin.edge('D', 'E', color='transparent')  # Hacer la flecha de C a D transparente
squash.edges(['AB', 'BC', 'CD', 'DM'])

# Agregar flechas entre los nodos en la rama secundaria
orin.edges(['DX', 'XY'])

# Mostrar el diagrama de flujo en la celda de c√≥digo de Jupyter Notebook
display(orin)
display(squash)</input_code>
  <output_code>&lt;graphviz.graphs.Digraph at 0x7f58f80e6470&gt;</output_code>
  <output_code>&lt;graphviz.graphs.Digraph at 0x7f58f80e6f80&gt;</output_code>
  <markdown>Vamos primeiro a verificar que estamos na branch principal</markdown>
  <input_code>!cd notebook_git &amp;&amp; git branch --show-current</input_code>
  <output_code>main
</output_code>
  <markdown>Criamos uma nova branch</markdown>
  <input_code>!cd notebook_git &amp;&amp; git branch branch_squash</input_code>
  <markdown>Mudamos para ela</markdown>
  <input_code>!cd notebook_git &amp;&amp; git switch branch_squash</input_code>
  <output_code>Cambiado a rama 'branch_squash'
</output_code>
  <input_code>!cd notebook_git &amp;&amp; git branch --show-current</input_code>
  <output_code>branch_squash
</output_code>
  <markdown>Vamos ver o log</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate --all</input_code>
  <output_code>*   [33m274529c[m[33m ([m[1;36mHEAD -&gt; [m[1;32mbranch_squash[m[33m, [m[1;32mmain[m[33m)[m Merge branch 'branch_no_fast_forward' into main
[31m|[m[32m\[m  
[31m|[m * [33m8df3429[m[33m ([m[1;32mbranch_no_fast_forward[m[33m)[m file2
[31m|[m * [33me4e23c9[m file1
* [32m|[m [33m8bdf4d8[m file3
[32m|[m[32m/[m  
* [33m94149fc[m[33m ([m[1;32mbranch_fast_forward[m[33m)[m Eliminado hola.py
* [33m4484e70[m Eliminado archivo4.py
* [33m564ccfb[m[33m ([m[1;32mnew_branch2[m[33m)[m Commit con el archivo 8
* [33m5168f78[m Eliminado archivo7.py
* [33m4bb9d75[m[33m ([m[1;32mnew_branch[m[33m)[m Commit con el archivo 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Ok, estamos em um branch criado a partir do principal com todo o seu hist√≥rico de logs, fazemos tr√™s novos commits</markdown>
  <input_code>!cd notebook_git &amp;&amp; git rm file1 &amp;&amp; git commit -am "Eliminado file1"</input_code>
  <output_code>rm 'file1'
[branch_squash 767b632] Eliminado file1
 1 file changed, 0 insertions(+), 0 deletions(-)
 delete mode 100644 file1
</output_code>
  <input_code>!cd notebook_git &amp;&amp; git rm file2 &amp;&amp; git commit -am "Eliminado file2"</input_code>
  <output_code>rm 'file2'
[branch_squash a47f771] Eliminado file2
 1 file changed, 0 insertions(+), 0 deletions(-)
 delete mode 100644 file2
</output_code>
  <input_code>!cd notebook_git &amp;&amp; git rm file3 &amp;&amp; git commit -am "Eliminado file3"</input_code>
  <output_code>rm 'file3'
[branch_squash 85f8c9f] Eliminado file3
 1 file changed, 0 insertions(+), 0 deletions(-)
 delete mode 100644 file3
</output_code>
  <markdown>Fazemos um novo log para ver o que foi criado nesta nova branch.</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>* [33m85f8c9f[m[33m ([m[1;36mHEAD -&gt; [m[1;32mbranch_squash[m[33m)[m Eliminado file3
* [33ma47f771[m Eliminado file2
* [33m767b632[m Eliminado file1
*   [33m274529c[m[33m ([m[1;32mmain[m[33m)[m Merge branch 'branch_no_fast_forward' into main
[32m|[m[33m\[m  
[32m|[m * [33m8df3429[m[33m ([m[1;32mbranch_no_fast_forward[m[33m)[m file2
[32m|[m * [33me4e23c9[m file1
* [33m|[m [33m8bdf4d8[m file3
[33m|[m[33m/[m  
* [33m94149fc[m[33m ([m[1;32mbranch_fast_forward[m[33m)[m Eliminado hola.py
* [33m4484e70[m Eliminado archivo4.py
* [33m564ccfb[m[33m ([m[1;32mnew_branch2[m[33m)[m Commit con el archivo 8
* [33m5168f78[m Eliminado archivo7.py
* [33m4bb9d75[m[33m ([m[1;32mnew_branch[m[33m)[m Commit con el archivo 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Como vemos, os tr√™s √∫ltimos commits s√£o os que criamos e podemos verificar que esses commits n√£o est√£o na branch principal (para isso especifico que seja feito sobre a branch `main`)</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log main --graph --oneline --decorate</input_code>
  <output_code>*   [33m274529c[m[33m ([m[1;32mmain[m[33m)[m Merge branch 'branch_no_fast_forward' into main
[31m|[m[32m\[m  
[31m|[m * [33m8df3429[m[33m ([m[1;32mbranch_no_fast_forward[m[33m)[m file2
[31m|[m * [33me4e23c9[m file1
* [32m|[m [33m8bdf4d8[m file3
[32m|[m[32m/[m  
* [33m94149fc[m[33m ([m[1;32mbranch_fast_forward[m[33m)[m Eliminado hola.py
* [33m4484e70[m Eliminado archivo4.py
* [33m564ccfb[m[33m ([m[1;32mnew_branch2[m[33m)[m Commit con el archivo 8
* [33m5168f78[m Eliminado archivo7.py
* [33m4bb9d75[m[33m ([m[1;32mnew_branch[m[33m)[m Commit con el archivo 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Agora vamos para a branch `main` para fazer o merge.</markdown>
  <input_code>!cd notebook_git &amp;&amp; git switch main</input_code>
  <output_code>Cambiado a rama 'main'
</output_code>
  <markdown>Fazemos o merge do tipo squash</markdown>
  <input_code>!cd notebook_git &amp;&amp; git merge branch_squash --squash</input_code>
  <output_code>Actualizando 274529c..85f8c9f
Fast-forward
Commit de aplastamiento -- no actualizando HEAD
 file1 | 0
 file2 | 0
 file3 | 0
 3 files changed, 0 insertions(+), 0 deletions(-)
 delete mode 100644 file1
 delete mode 100644 file2
 delete mode 100644 file3
</output_code>
  <markdown>O merge foi feito, vamos ver o que aconteceu com o log na branch `main`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>*   [33m274529c[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmain[m[33m)[m Merge branch 'branch_no_fast_forward' into main
[31m|[m[32m\[m  
[31m|[m * [33m8df3429[m[33m ([m[1;32mbranch_no_fast_forward[m[33m)[m file2
[31m|[m * [33me4e23c9[m file1
* [32m|[m [33m8bdf4d8[m file3
[32m|[m[32m/[m  
* [33m94149fc[m[33m ([m[1;32mbranch_fast_forward[m[33m)[m Eliminado hola.py
* [33m4484e70[m Eliminado archivo4.py
* [33m564ccfb[m[33m ([m[1;32mnew_branch2[m[33m)[m Commit con el archivo 8
* [33m5168f78[m Eliminado archivo7.py
* [33m4bb9d75[m[33m ([m[1;32mnew_branch[m[33m)[m Commit con el archivo 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>As altera√ß√µes feitas n√£o est√£o aparecendo na branch, vamos fazer um `git status`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama main
Cambios a ser confirmados:
  (usa "git restore --staged &lt;archivo&gt;..." para sacar del √°rea de stage)
	[32mborrados:        file1[m
	[32mborrados:        file2[m
	[32mborrados:        file3[m

</output_code>
  <markdown>Vemos que temos que fazer o commit com a fus√£o. Isso √© porque o git n√£o sabe qual mensagem colocar e nos deixa fazer isso, ent√£o o fazemos.</markdown>
  <input_code>!cd notebook_git &amp;&amp; git commit -m "Merge squash de los commits de la rama branch_squash"</input_code>
  <output_code>[main 52acb97] Merge squash de los commits de la rama branch_squash
 3 files changed, 0 insertions(+), 0 deletions(-)
 delete mode 100644 file1
 delete mode 100644 file2
 delete mode 100644 file3
</output_code>
  <markdown>Fazemos novamente um `git log`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>* [33m52acb97[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmain[m[33m)[m Merge squash de los commits de la rama branch_squash
*   [33m274529c[m Merge branch 'branch_no_fast_forward' into main
[32m|[m[33m\[m  
[32m|[m * [33m8df3429[m[33m ([m[1;32mbranch_no_fast_forward[m[33m)[m file2
[32m|[m * [33me4e23c9[m file1
* [33m|[m [33m8bdf4d8[m file3
[33m|[m[33m/[m  
* [33m94149fc[m[33m ([m[1;32mbranch_fast_forward[m[33m)[m Eliminado hola.py
* [33m4484e70[m Eliminado archivo4.py
* [33m564ccfb[m[33m ([m[1;32mnew_branch2[m[33m)[m Commit con el archivo 8
* [33m5168f78[m Eliminado archivo7.py
* [33m4bb9d75[m[33m ([m[1;32mnew_branch[m[33m)[m Commit con el archivo 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>### Conflitos ao mesclar</markdown>
  <markdown>Quando branches s√£o mescladas, pode acontecer que o mesmo arquivo tenha sido modificado em v√°rias branches. Isso √© comum em projetos onde v√°rias pessoas est√£o desenvolvendo, ent√£o vamos ver como resolver isso.</markdown>
  <markdown>#### Criamos um conflito</markdown>
  <markdown>Verificamos que estamos na branch `main`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git branch --show-current</input_code>
  <output_code>main
</output_code>
  <markdown>Criamos uma nova branch a partir desta.</markdown>
  <input_code>!cd notebook_git &amp;&amp; git branch rama_con_conflicto</input_code>
  <markdown>Adicionamos uma linha ao arquivo `arquivo1.py`, lembrando que estamos na branch `main`</markdown>
  <input_code>!cd notebook_git &amp;&amp; echo "print('rama main')" &gt;&gt; archivo1.py</input_code>
  <input_code>!cd notebook_git &amp;&amp; cat archivo1.py</input_code>
  <output_code>print('Este es el archivo 1')
print('rama main')
</output_code>
  <markdown>`arquivo1.py` foi modificado, fazemos um commit</markdown>
  <input_code>!cd notebook_git &amp;&amp; git add archivo1.py &amp;&amp; git commit -m "archivo1.py en rama main"</input_code>
  <output_code>[main 53f909b] archivo1.py en rama main
 1 file changed, 1 insertion(+)
</output_code>
  <markdown>Agora vamos para o branch `rama_con_conflicto` e adicionamos uma nova linha a `archivo1.py`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git switch rama_con_conflicto</input_code>
  <output_code>Cambiado a rama 'rama_con_conflicto'
</output_code>
  <input_code>!cd notebook_git &amp;&amp; git branch --show-current</input_code>
  <output_code>rama_con_conflicto
</output_code>
  <input_code>!cd notebook_git &amp;&amp; echo "print('rama rama_con_conflicto')" &gt;&gt; archivo1.py</input_code>
  <input_code>!cd notebook_git &amp;&amp; cat archivo1.py</input_code>
  <output_code>print('Este es el archivo 1')
print('rama rama_con_conflicto')
</output_code>
  <markdown>Como vemos, `arquivo1.py` n√£o √© igual na branch `main` e na branch `rama_con_conflicto`. Fazemos um commit com a modifica√ß√£o de `arquivo1.py` na branch `rama_con_conflicto`.</markdown>
  <input_code>!cd notebook_git &amp;&amp; git add archivo1.py &amp;&amp; git commit -m "archivo1.py en rama rama_con_conflicto"</input_code>
  <output_code>[rama_con_conflicto 32851c3] archivo1.py en rama rama_con_conflicto
 1 file changed, 1 insertion(+)
</output_code>
  <markdown>Voltamos para o branch `main`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git switch main</input_code>
  <output_code>Cambiado a rama 'main'
</output_code>
  <input_code>!cd notebook_git &amp;&amp; git branch --show-current</input_code>
  <output_code>main
</output_code>
  <markdown>Fazemos um merge da branch `rama_con_conflicto`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git merge rama_con_conflicto</input_code>
  <output_code>Auto-fusionando archivo1.py
CONFLICTO (contenido): Conflicto de fusi√≥n en archivo1.py
Fusi√≥n autom√°tica fall√≥; arregle los conflictos y luego realice un commit con el resultado.
</output_code>
  <markdown>Ao fazer o merge, j√° somos avisados de que h√° um conflito em `archivo1.py` e que n√£o foi poss√≠vel realizar o merge. Fazemos um `git status`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama main
Tienes rutas no fusionadas.
  (arregla los conflictos y ejecuta "git commit"
  (usa "git merge --abort" para abortar la fusion)

Rutas no fusionadas:
  (usa "git add &lt;archivo&gt;..." para marcar una resoluci√≥n)
	[31mmodificados por ambos:  archivo1.py[m

sin cambios agregados al commit (usa "git add" y/o "git commit -a")
</output_code>
  <markdown>Diz-nos o mesmo, mas nos d√° mais informa√ß√µes, diz-nos que podemos abortar a fus√£o com `git merge --abort`. Mas em vez disso, vamos resolv√™-lo.</markdown>
  <markdown>#### Resolver um conflito</markdown>
  <markdown>No nosso caso, sabemos onde est√° o problema, mas em caso de n√£o saber, atrav√©s do `git diff` podemos encontrar o problema.</markdown>
  <input_code>!cd notebook_git &amp;&amp; git diff archivo1.py</input_code>
  <output_code>[1mdiff --cc archivo1.py[m
[1mindex 8b4bf58,b5c003c..0000000[m
[1m--- a/archivo1.py[m
[1m+++ b/archivo1.py[m
[36m@@@ -1,2 -1,2 +1,6 @@@[m
  print('Este es el archivo 1')[m
[32m++&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD[m
[32m +print('rama main')[m
[32m++=======[m
[32m+ print('rama rama_con_conflicto')[m
[32m++&gt;&gt;&gt;&gt;&gt;&gt;&gt; rama_con_conflicto[m
</output_code>
  <markdown>`git diff` est√° nos dizendo que o problema est√° na √∫ltima linha. A vers√£o do arquivo da branch `HEAD` (na qual estamos atualmente `main`) tem `print('rama main')` na √∫ltima linha, enquanto a vers√£o da branch `rama_con_conflicto` tem `print('rama rama_con_conflicto')` na √∫ltima linha. Ent√£o, √© preciso abrir o arquivo com qualquer editor e resolver isso.</markdown>
  <markdown>Ap√≥s editar o arquivo com meu editor de c√≥digo, removi todas as linhas desnecess√°rias e ficou assim</markdown>
  <input_code>!cd notebook_git &amp;&amp; cat archivo1.py</input_code>
  <output_code>print('Este es el archivo 1')
print('rama main')</output_code>
  <markdown>Agora fazemos um `git status` para ver o que temos a fazer</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama main
Tienes rutas no fusionadas.
  (arregla los conflictos y ejecuta "git commit"
  (usa "git merge --abort" para abortar la fusion)

Rutas no fusionadas:
  (usa "git add &lt;archivo&gt;..." para marcar una resoluci√≥n)
	[31mmodificados por ambos:  archivo1.py[m

sin cambios agregados al commit (usa "git add" y/o "git commit -a")
</output_code>
  <markdown>Diz que temos o arquivo `arquivo1.py` com modifica√ß√µes, portanto o adicionamos √† √°rea de `staged` e depois fazemos um commit.</markdown>
  <input_code>!cd notebook_git &amp;&amp; git add archivo1.py &amp;&amp; git commit -m "archivo1.py con el merge resuelto"</input_code>
  <output_code>[main 679bb49] archivo1.py con el merge resuelto
</output_code>
  <markdown>Voltamos a fazer um `git status` para ver se foi resolvido.</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama main
nada para hacer commit, el √°rbol de trabajo est√° limpio
</output_code>
  <markdown>Parece que foi resolvido, fazemos um `git log` para verificar.</markdown>
  <input_code>!cd notebook_git &amp;&amp; git log --graph --oneline --decorate</input_code>
  <output_code>*   [33m679bb49[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmain[m[33m)[m archivo1.py con el merge resuelto
[31m|[m[32m\[m  
[31m|[m * [33m32851c3[m[33m ([m[1;32mrama_con_conflicto[m[33m)[m archivo1.py en rama rama_con_conflicto
* [32m|[m [33m53f909b[m archivo1.py en rama main
[32m|[m[32m/[m  
* [33m52acb97[m Merge squash de los commits de la rama branch_squash
*   [33m274529c[m Merge branch 'branch_no_fast_forward' into main
[33m|[m[34m\[m  
[33m|[m * [33m8df3429[m[33m ([m[1;32mbranch_no_fast_forward[m[33m)[m file2
[33m|[m * [33me4e23c9[m file1
* [34m|[m [33m8bdf4d8[m file3
[34m|[m[34m/[m  
* [33m94149fc[m[33m ([m[1;32mbranch_fast_forward[m[33m)[m Eliminado hola.py
* [33m4484e70[m Eliminado archivo4.py
* [33m564ccfb[m[33m ([m[1;32mnew_branch2[m[33m)[m Commit con el archivo 8
* [33m5168f78[m Eliminado archivo7.py
* [33m4bb9d75[m[33m ([m[1;32mnew_branch[m[33m)[m Commit con el archivo 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>### Remover ramos</markdown>
  <markdown>A ideia de uma branch √© abri-la para desenvolver uma nova funcionalidade ou caracter√≠stica de maneira que n√£o afete o resto da equipe de desenvolvimento. Portanto, quando isso for alcan√ßado, ela √© mesclada com a branch principal. Assim, ap√≥s a fus√£o, j√° n√£o faz sentido manter a branch, ent√£o ela deve ser exclu√≠da, mas isso ser√° feito de uma maneira diferente se a branch foi ou n√£o mesclada com a principal.</markdown>
  <markdown>#### Excluir branches mescladas (`git branch -d &lt;branch&gt;`)</markdown>
  <markdown>Para eliminar uma ramifica√ß√£o que j√° foi mesclada com a principal, basta fazer `git branch -d &lt;rama&gt;` ou `git branch --delete &lt;rama&gt;`. Vamos eliminar a √∫ltima ramifica√ß√£o que criamos e mesclamos.</markdown>
  <input_code>!cd notebook_git &amp;&amp; git branch -d rama_con_conflicto</input_code>
  <output_code>Eliminada la rama rama_con_conflicto (era 32851c3).
</output_code>
  <markdown>Se agora listarmos todas as branches, podemos ver que j√° n√£o teremos `rama_con_conflicto`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git branch</input_code>
  <output_code>  branch_fast_forward[m
  branch_no_fast_forward[m
  branch_squash[m
* [32mmain[m
  new_branch[m
  new_branch2[m
</output_code>
  <markdown>#### Excluir branches que n√£o foram mesclados com a branch principal (`git branch -D &lt;branch&gt;`)</markdown>
  <markdown>Se tentarmos fazer o mesmo que antes com uma branch que nunca foi mesclada com outra, obteremos um erro</markdown>
  <markdown>Vamos a criar uma nova branch, vamos fazer um commit e n√£o vamos mescl√°-la.</markdown>
  <input_code>!cd notebook_git &amp;&amp; git branch branch_sin_fusion</input_code>
  <input_code>!cd notebook_git &amp;&amp; git switch branch_sin_fusion</input_code>
  <output_code>Cambiado a rama 'branch_sin_fusion'
</output_code>
  <input_code>!cd notebook_git &amp;&amp; touch file4 &amp;&amp; git add file4 &amp;&amp; git commit -m "file4"</input_code>
  <output_code>[branch_sin_fusion 9506b0a] file4
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 file4
</output_code>
  <input_code>!cd notebook_git &amp;&amp; git switch main</input_code>
  <output_code>Cambiado a rama 'main'
</output_code>
  <markdown>Com tudo o que aprendemos at√© agora, podemos ver que o que fizemos foi criar uma nova branch, mudar para ela, criar um novo arquivo, fazer um commit e voltar para a branch `main`. Agora vamos tentar deletar essa nova branch.</markdown>
  <input_code>!cd notebook_git &amp;&amp; git branch -d branch_sin_fusion</input_code>
  <output_code>error: La rama 'branch_sin_fusion' no ha sido fusionada completamente.
Si est√°s seguro de querer borrarla, ejecuta 'git branch -D branch_sin_fusion'.
</output_code>
  <markdown>Como vemos, nos diz que `branch_sem_fusao` n√£o foi mesclada e, portanto, n√£o foi exclu√≠da. Se temos certeza de querer exclu√≠-la, precisamos fazer `git branch -D branch_sem_fusao`, ent√£o o fazemos para exclu√≠-la.</markdown>
  <input_code>!cd notebook_git &amp;&amp; git branch -D branch_sin_fusion</input_code>
  <output_code>Eliminada la rama branch_sin_fusion (era 9506b0a).
</output_code>
  <markdown>Agora sim, foi removido.</markdown>
  <markdown>## Trabalhando com reposit√≥rios remotos</markdown>
  <markdown>Quando desenvolvemos software, geralmente n√£o o fazemos sozinhos, mas trabalhamos em equipe. Por isso, n√£o faz sentido ter um reposit√≥rio local do Git; √© melhor ter um reposit√≥rio remoto com o qual todos possam trabalhar e compartilhar os avan√ßos.

&gt; Nota: O objetivo deste post √© explicar git. Para a conex√£o com reposit√≥rios remotos vou explic√°-lo usando o GitHub, pois √© o servi√ßo de hospedagem de reposit√≥rios git mais utilizado, mas n√£o vou aprofundar no GitHub.
</markdown>
  <markdown>### Clonar um reposit√≥rio remoto (`git clone &lt;reposit√≥rio&gt;`)</markdown>
  <markdown>Se come√ßarmos a trabalhar em um reposit√≥rio que j√° foi criado, o primeiro passo √© clon√°-lo. Para isso, usamos `git clone &lt;repositorio&gt;`, onde `&lt;repositorio&gt;` pode ser uma URL ou um endere√ßo SSH. Como atualmente os grandes modelos de linguagem e o ChatGPT est√£o muito em voga, vamos clonar um reposit√≥rio opensource criado pela comunidade, [Open-Assistant](https://github.com/LAION-AI/Open-Assistant), para isso faremos `git clone https://github.com/LAION-AI/Open-Assistant`</markdown>
  <input_code>!git clone https://github.com/LAION-AI/Open-Assistant.git</input_code>
  <output_code>Clonando en 'Open-Assistant'...
remote: Enumerating objects: 29769, done.[K
remote: Counting objects: 100% (673/673), done.[K
remote: Compressing objects: 100% (310/310), done.[K
remote: Total 29769 (delta 398), reused 577 (delta 354), pack-reused 29096[K
Recibiendo objetos: 100% (29769/29769), 33.61 MiB | 29.29 MiB/s, listo.
Resolviendo deltas: 100% (19967/19967), listo.
</output_code>
  <markdown>Isso cria a pasta `Open-Assistant` com todo o c√≥digo do reposit√≥rio, podemos entrar dentro e ver todo o c√≥digo.</markdown>
  <input_code>!cd Open-Assistant &amp;&amp; ls</input_code>
  <output_code>ansible		 deploy		      model	      safety
assets		 discord-bots	      notebooks       scripts
backend		 docker		      oasst-data      setup.cfg
CODEOWNERS	 docker-compose.yaml  oasst-shared    text-frontend
CONTRIBUTING.md  docs		      pyproject.toml  website
copilot		 inference	      README.md
data		 LICENSE	      redis.conf
</output_code>
  <markdown>Excluo a pasta</markdown>
  <input_code>!rm -r Open-Assistant</input_code>
  <markdown>### Vincular um reposit√≥rio local a um remoto</markdown>
  <markdown>Se ocorrer o contr√°rio, se primeiro come√ßarmos a desenvolver localmente e depois quisermos sincroniz√°-lo com um reposit√≥rio remoto, temos que fazer o seguinte

* Primeiro crie um reposit√≥rio remoto vazio, no meu caso criei o reposit√≥rio `notebook_git` no GitHub que deletarei mais tarde
* Obter a URL do reposit√≥rio ou endere√ßo SSH
* Sincroniz√°-los atrav√©s de `git remote add origin &lt;URL&gt;`

O reposit√≥rio vazio que criei no GitHub parece assim
![notebook git repo](https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/notebook_git_repo.webp)

No meu caso, vou usar o endere√ßo SSH que √© `git@github.com:maximofn/notebook_git.git`
</markdown>
  <input_code>!cd notebook_git &amp;&amp; git remote add origin git@github.com:maximofn/notebook_git.git</input_code>
  <markdown>J√° est√£o vinculados, mas para garantir podemos fazer `git remote -v`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git remote -v</input_code>
  <output_code>origin	git@github.com:maximofn/notebook_git.git (fetch)
origin	git@github.com:maximofn/notebook_git.git (push)
</output_code>
  <markdown>### Enviar as altera√ß√µes de um reposit√≥rio local para um reposit√≥rio remoto (`git push`)</markdown>
  <markdown>Como dissem, eles est√£o vinculados, mas se eu for ao meu reposit√≥rio no GitHub, ainda parece assim

![notebook git repo](https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/notebook_git_repo.webp)

Est√£o vinculados o reposit√≥rio local e o remoto, mas agora √© necess√°rio enviar todas as altera√ß√µes do reposit√≥rio local para o remoto. Para isso, seria necess√°rio usar `git push origin &lt;rama local&gt;:&lt;rama remota&gt;`, ou seja, como nossa ramo principal se chama `main` e a ramo principal no GitHub se chama `main`, seria necess√°rio fazer `git push origin main:main`.
Se voc√™ se lembra, o Git por padr√£o chamava a branch principal de `master`, mas o GitHub chama por padr√£o a branch principal de `main`. Portanto, se cada pessoa nomear suas branches no reposit√≥rio local de maneira diferente, √© necess√°rio especificar qual branch local escreve em qual branch remota.
</markdown>
  <markdown>Pode configurar a conex√£o padr√£o entre branches no git, para isso √© necess√°rio fazer `git push --set-upstream origin main`. Isso estabelece uma rela√ß√£o entre a branch local `main` e a branch remota `main`. Uma vez feita essa rela√ß√£o, basta fazer `git push` para enviar as altera√ß√µes feitas localmente para o servidor remoto.

Ent√£o estabelecemos a conex√£o entre as branches.
</markdown>
  <input_code>!cd notebook_git &amp;&amp; git push --set-upstream origin main</input_code>
  <output_code>Enumerando objetos: 51, listo.
Contando objetos: 100% (51/51), listo.
Compresi√≥n delta usando hasta 12 hilos
Comprimiendo objetos: 100% (38/38), listo.
Escribiendo objetos: 100% (51/51), 4.21 KiB | 2.11 MiB/s, listo.
Total 51 (delta 18), reusado 0 (delta 0)
remote: Resolving deltas: 100% (18/18), done.[K
To github.com:maximofn/notebook_git.git
 * [new branch]      main -&gt; main
Rama 'main' configurada para hacer seguimiento a la rama remota 'main' de 'origin'.
</output_code>
  <markdown>Agora podemos fazer apenas `git push` para enviar as altera√ß√µes locais ao reposit√≥rio remoto.</markdown>
  <input_code>!cd notebook_git &amp;&amp; git push</input_code>
  <output_code>Everything up-to-date
</output_code>
  <markdown>Se agora voltarmos ao nosso reposit√≥rio do GitHub, ele parece assim

![notebook git repo push](https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/notebook_git_repo_push.webp)
</markdown>
  <markdown>Se fizermos um `ls` no nosso reposit√≥rio local, poderemos ver que os arquivos que temos no reposit√≥rio remoto tamb√©m est√£o presentes no reposit√≥rio local, ou seja, sincronizamos o reposit√≥rio local e remoto.</markdown>
  <input_code>!cd notebook_git &amp;&amp; ls -a</input_code>
  <output_code>.  ..  api_keys.py  archivo1.py  archivo2.py  archivo8.py  .git  .gitignore
</output_code>
  <markdown>Os √∫nicos que n√£o est√£o no reposit√≥rio remoto s√£o `api_keys.py`, que √© o que adicionamos ao arquivo `.gitignore`, ou seja, o que dissemos ao git para n√£o seguir. E `.git` que √© onde est√° a configura√ß√£o do nosso reposit√≥rio local e que n√£o deve ser enviado ao reposit√≥rio remoto, porque cada pessoa ter√° sua pr√≥pria configura√ß√£o de git e, portanto, n√£o deve ser sincronizada.</markdown>
  <markdown>### Baixar as altera√ß√µes de um reposit√≥rio remoto para um reposit√≥rio local (`git pull`)</markdown>
  <markdown>Agora vamos a fazer ao contr√°rio, vamos baixar as novas altera√ß√µes que tenham sido feitas no reposit√≥rio remoto. Se observarmos como est√° o reposit√≥rio remoto, poderemos ver que h√° um bot√£o que diz `Add a README`, ent√£o clicamos para adicion√°-lo.

![notebook git repo push](https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/notebook_git_repo_push.webp)
</markdown>
  <markdown>Ao clicar, ser√° aberto um editor, deixamos o que o GitHub colocou e salvamos as altera√ß√µes clicando no bot√£o de `Commit changes...`

![noteboot git repo readme](https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/notebook_git_repo_readme.webp)

Nos sair√° uma janela na qual nos ser√° pedido uma mensagem de commit, deixamos a que vem por padr√£o e clicamos em `Commit changes`

![notebook git repo commit message](https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/notebook_git_repo_commit_message.webp)

Ao fazer isso, o reposit√≥rio ficar√° assim
![notebook git repo pull](https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/notebook_git_repo_pull.webp)

Foi criado um novo arquivo chamado `README.md`, mas se fizermos `ls` no reposit√≥rio local, n√£o o encontraremos.
</markdown>
  <input_code>!cd notebook_git &amp;&amp; ls | grep README</input_code>
  <markdown>Ent√£o, temos que trazer as altera√ß√µes do reposit√≥rio remoto para o local. Para isso, precisamos fazer `git pull origin &lt;rama remota&gt;` para informar ao Git sobre qual ramo remoto vamos trazer os dados. Da mesma forma que antes, podemos estabelecer uma rela√ß√£o entre o ramo remoto e o ramo local da seguinte maneira: `git branch --set-upstream-to=origin/&lt;rama local&gt; &lt;rama remota&gt;`. Como nossa rama local se chama `main` e a rama remota do GitHub tamb√©m se chama `main`, ter√≠amos que alterar o anterior para `git branch --set-upstream-to=origin/main main`.

Uma vez feito isso, para baixar as novas altera√ß√µes do reposit√≥rio remoto para o local, basta fazer `git pull`
</markdown>
  <markdown>Vamos a estabelecer a rela√ß√£o entre as branches com `git branch --set-upstream-to=origin/main main`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git branch --set-upstream-to=origin/main main</input_code>
  <output_code>Rama 'main' configurada para hacer seguimiento a la rama remota 'main' de 'origin'.
</output_code>
  <markdown>Agora podemos trazer as altera√ß√µes do reposit√≥rio remoto para o reposit√≥rio local com `git pull`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git pull</input_code>
  <output_code>remote: Enumerating objects: 4, done.[K
remote: Counting objects: 100% (4/4), done.[K
remote: Compressing objects: 100% (2/2), done.[K
remote: Total 3 (delta 1), reused 0 (delta 0), pack-reused 0[K
Desempaquetando objetos: 100% (3/3), 646 bytes | 646.00 KiB/s, listo.
Desde github.com:maximofn/notebook_git
   679bb49..527e07a  main       -&gt; origin/main
Actualizando 679bb49..527e07a
Fast-forward
 README.md | 1 [32m+[m
 1 file changed, 1 insertion(+)
 create mode 100644 README.md
</output_code>
  <markdown>Como vemos, diz que foi adicionado `README.md`, verificamos isso fazendo `ls`</markdown>
  <input_code>!cd notebook_git &amp;&amp; ls | grep README</input_code>
  <output_code>README.md
</output_code>
  <markdown>Temos o arquivo localmente</markdown>
  <markdown>### Sincronizar as branches remotas e locais</markdown>
  <markdown>Como vimos, tivemos que sincronizar as branches remotas e locais para poder fazer o upload e download dos dados. No entanto, se primeiro criarmos o reposit√≥rio no GitHub e depois o clonarmos, n√£o ser√° mais necess√°rio essa sincroniza√ß√£o.</markdown>
  <markdown>## Alias</markdown>
  <markdown>Cada vez que quisemos fazer um log temos usado este comando `git log --graph --oneline --decorate`, no entanto lembrar-se deste comando √© bastante complicado, na verdade eu n√£o me lembro dele, toda vez que quero us√°-lo tenho que procur√°-lo porque n√£o o lembro, por isso seria muito bom ter uma maneira de abrevi√°-lo.</markdown>
  <markdown>Para isso, o git oferece os `alias`, de forma que voc√™ pode criar aliases dos comandos que desejar. Para fazer isso, voc√™ precisa executar `git config --global alias.&lt;nome do alias&gt; "comando"`</markdown>
  <markdown>Portanto, vamos chamar `git tree` ao comando `git log --graph --oneline --decorate`, pois nos permite ver o hist√≥rico, com a bifurca√ß√£o e fus√£o de branches como se fosse o crescimento de uma √°rvore, ent√£o fazemos `git config --global alias.tree "log --graph --oneline --decorate"`

&gt; **Importante**: N√£o se deve colocar a palavra `git` dentro do comando
</markdown>
  <input_code>!git config --global alias.tree "log --graph --oneline --decorate"</input_code>
  <markdown>Se agora formos ao nosso reposit√≥rio e fizermos `git tree`, veremos o hist√≥rico como faz√≠amos antes.</markdown>
  <input_code>!cd notebook_git &amp;&amp; git tree</input_code>
  <output_code>* [33m527e07a[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmain[m[33m, [m[1;31morigin/main[m[33m)[m Create README.md
*   [33m679bb49[m archivo1.py con el merge resuelto
[32m|[m[33m\[m  
[32m|[m * [33m32851c3[m archivo1.py en rama rama_con_conflicto
* [33m|[m [33m53f909b[m archivo1.py en rama main
[33m|[m[33m/[m  
* [33m52acb97[m Merge squash de los commits de la rama branch_squash
*   [33m274529c[m Merge branch 'branch_no_fast_forward' into main
[34m|[m[35m\[m  
[34m|[m * [33m8df3429[m[33m ([m[1;32mbranch_no_fast_forward[m[33m)[m file2
[34m|[m * [33me4e23c9[m file1
* [35m|[m [33m8bdf4d8[m file3
[35m|[m[35m/[m  
* [33m94149fc[m[33m ([m[1;32mbranch_fast_forward[m[33m)[m Eliminado hola.py
* [33m4484e70[m Eliminado archivo4.py
* [33m564ccfb[m[33m ([m[1;32mnew_branch2[m[33m)[m Commit con el archivo 8
* [33m5168f78[m Eliminado archivo7.py
* [33m4bb9d75[m[33m ([m[1;32mnew_branch[m[33m)[m Commit con el archivo 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Como vemos, foi criado nosso alias</markdown>
  <markdown>### Alias de comandos existentes de git

(No se ha proporcionado texto adicional para traducir, por lo que esta es la traducci√≥n del t√≠tulo solo.)</markdown>
  <markdown>√â poss√≠vel criar aliases para comandos que j√° existem no git, na verdade, √© uma pr√°tica muito usada, especialmente para abreviar, ent√£o vamos fazer um. Vamos criar um alias para o comando `git status` e renome√°-lo como `git st` da seguinte maneira: `git config --global alias.st "status"`</markdown>
  <input_code>!git config --global alias.st "status"</input_code>
  <markdown>Vamos test√°-lo agora.</markdown>
  <input_code>!cd notebook_git &amp;&amp; git st</input_code>
  <output_code>En la rama main
Tu rama est√° actualizada con 'origin/main'.

nada para hacer commit, el √°rbol de trabajo est√° limpio
</output_code>
  <markdown>J√° temos o comando `git status` simplificado para `git st`</markdown>
  <markdown>### Alias de comandos que n√£o s√£o do git</markdown>
  <markdown>Podemos criar aliases de comandos que n√£o sejam do git, por exemplo, porque achamos que o git precisa desse novo comando, faz-se da mesma forma com a exce√ß√£o de que o comando deve ser precedido de `!`, ou seja, seria `git config --global alias.&lt;nome do alias&gt; "!comando"`</markdown>
  <markdown>Quando vimos os conflitos, vimos que o git nos dizia onde estavam, mas para resolv√™-los temos que editar o c√≥digo n√≥s mesmos, por isso podemos criar um alias do git de maneira que possamos abrir um arquivo com o editor de textos que quisermos, no meu caso vou criar um alias que me abrir√° os arquivos com `vscode` para isso tenho que fazer `git config --global alias.code "!code"`</markdown>
  <input_code>!git config --global alias.code "!code"</input_code>
  <markdown>O testamos</markdown>
  <input_code>!cd notebook_git &amp;&amp; git code README.md</input_code>
  <markdown>Depois de fazer isso, o `README.md` foi aberto no `vscode`.</markdown>
  <markdown>### Lista com todos os aliases</markdown>
  <markdown>Caso n√£o nos lembremos dos aliases que criamos, podemos ver a configura√ß√£o global do git, mas como isso pode ser um pouco avassalador porque nos d√° muita informa√ß√£o, podemos filtrar para que nos mostre apenas os aliases que criamos, para isso usamos `git config --get-regexp ^alias\.`</markdown>
  <input_code>!git config --get-regexp ^alias\.</input_code>
  <output_code>alias.tree log --graph --oneline --decorate
alias.st status
alias.code !code
</output_code>
  <markdown>Obtemos os aliases que n√≥s criamos</markdown>
  <markdown>Mas ainda, podemos criar um alias para obter os aliases, para isso fazemos `git config --global alias.alias "config --get-regexp ^alias\."`</markdown>
  <input_code>!git config --global alias.alias "config --get-regexp ^alias\."</input_code>
  <markdown>Se agora fizermos `git alias`</markdown>
  <input_code>!git alias</input_code>
  <output_code>alias.tree log --graph --oneline --decorate
alias.st status
alias.code !code
alias.alias config --get-regexp ^alias\.
</output_code>
  <markdown>Obtemos a lista com todos os nossos alias</markdown>
  <markdown>## Armazenamento tempor√°rio (`git stash`)</markdown>
  <markdown>Suponhamos que estamos trabalhando em um branch, temos v√°rios arquivos modificados, n√£o fizemos commit, e por algum motivo temos que passar para outro branch. Por exemplo, estamos em um branch desenvolvendo uma nova funcionalidade, e temos que deix√°-la pela metade porque h√° um bug cr√≠tico no branch main

Uma solu√ß√£o seria fazer um commit para salvar as altera√ß√µes e voltar mais tarde. Mas talvez tenhamos deixado o c√≥digo pela metade e n√£o queremos fazer um commit. Ent√£o, para isso, foi inventado o stash, que √© como um armaz√©m, onde voc√™ deixa seu c√≥digo armazenado para poder recuper√°-lo posteriormente.

√â uma pilha, isso significa que o √∫ltimo a entrar √© o primeiro a sair.
</markdown>
  <markdown>Vamos ver como fazer isso, em primeiro lugar criamos uma nova branch que vamos chamar de `new_feature`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git branch new_feature</input_code>
  <markdown>Mudamos para ela</markdown>
  <input_code>!cd notebook_git &amp;&amp; git switch new_feature</input_code>
  <output_code>Cambiado a rama 'new_feature'
</output_code>
  <markdown>Vamos a modificar `arquivo2.py` e `arquivo8.py`</markdown>
  <input_code>!cd notebook_git &amp;&amp; echo "print('new_feature')" &gt;&gt; archivo2.py &amp;&amp; echo "print('new_feature')" &gt;&gt; archivo8.py</input_code>
  <markdown>Fazemos um `git status` para verificar que tenham sido modificados.</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama new_feature
Cambios no rastreados para el commit:
  (usa "git add &lt;archivo&gt;..." para actualizar lo que ser√° confirmado)
  (usa "git restore &lt;archivo&gt;..." para descartar los cambios en el directorio de trabajo)
	[31mmodificados:     archivo2.py[m
	[31mmodificados:     archivo8.py[m

sin cambios agregados al commit (usa "git add" y/o "git commit -a")
</output_code>
  <markdown>Vamos a adicionar `arquivo8.py` √† √°rea de `staged`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git add archivo8.py</input_code>
  <markdown>Fazemos novamente um `git status`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama new_feature
Cambios a ser confirmados:
  (usa "git restore --staged &lt;archivo&gt;..." para sacar del √°rea de stage)
	[32mmodificados:     archivo8.py[m

Cambios no rastreados para el commit:
  (usa "git add &lt;archivo&gt;..." para actualizar lo que ser√° confirmado)
  (usa "git restore &lt;archivo&gt;..." para descartar los cambios en el directorio de trabajo)
	[31mmodificados:     archivo2.py[m

</output_code>
  <markdown>Como vemos temos dois arquivos modificados, dos quais um deles tamb√©m est√° na √°rea de `staged`. Se agora tiv√©ssemos que mudar de branch, para n√£o perder as altera√ß√µes poder√≠amos fazer um commit, ou guard√°-las no reposit√≥rio `stash`, ent√£o vamos fazer isso √∫ltimo atrav√©s de `git stash`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git stash</input_code>
  <output_code>Directorio de trabajo y estado de √≠ndice WIP on new_feature: 527e07a Create README.md guardados
</output_code>
  <markdown>Se agora voltarmos a fazer `git status`, vejamos o que acontece</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama new_feature
nada para hacer commit, el √°rbol de trabajo est√° limpio
</output_code>
  <markdown>Os arquivos com modifica√ß√µes n√£o aparecem mais, √© como se tiv√©ssemos feito um commit</markdown>
  <markdown>&gt; **Importante**: Os arquivos criados novos, que nunca foram rastreados pelo Git, n√£o ser√£o enviados para o reposit√≥rio, portanto, com os arquivos novos √© necess√°rio, pelo menos, fazer primeiro um `git add`</markdown>
  <markdown>Se eu criar um novo arquivo e tentar envi√°-lo para o reposit√≥rio, receberei um erro.</markdown>
  <input_code>!cd notebook_git &amp;&amp; touch archivo9.py</input_code>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama new_feature
Archivos sin seguimiento:
  (usa "git add &lt;archivo&gt;..." para incluirlo a lo que se ser√° confirmado)
	[31marchivo9.py[m

no hay nada agregado al commit pero hay archivos sin seguimiento presentes (usa "git add" para hacerles seguimiento)
</output_code>
  <input_code>!cd notebook_git &amp;&amp; git stash</input_code>
  <output_code>No hay cambios locales para guardar
</output_code>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama new_feature
Archivos sin seguimiento:
  (usa "git add &lt;archivo&gt;..." para incluirlo a lo que se ser√° confirmado)
	[31marchivo9.py[m

no hay nada agregado al commit pero hay archivos sin seguimiento presentes (usa "git add" para hacerles seguimiento)
</output_code>
  <markdown>Como vemos `arquivo9.py` n√£o foi salvo no reposit√≥rio, portanto seria necess√°rio adicion√°-lo com `git add`.</markdown>
  <input_code>!cd notebook_git &amp;&amp; rm archivo9.py</input_code>
  <markdown>### Tudo para o stash (`git stash -u -a`)</markdown>
  <markdown>Como vimos, apenas s√£o enviados ao reposit√≥rio os arquivos que o git est√° rastreando. Se tivermos novos arquivos criados ou arquivos ignorados, eles n√£o ser√£o enviados. Para resolver isso, podemos usar as op√ß√µes `-u` ou `--include-untracked` para enviar os novos arquivos que ainda n√£o est√£o sendo rastreados pelo git, e a op√ß√£o `-a` ou `--all` para incluir tudo, inclusive os arquivos ignorados.</markdown>
  <markdown>### Lista de dep√≥sitos (`git stash list`)</markdown>
  <markdown>Como comentamos, o armazenamento atua como uma pilha, portanto, se fizermos uso desse armazenamento muitas vezes, na verdade teremos uma lista de armazenamentos, e para ver os que temos armazenados podemos usar `git stash list`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git stash list</input_code>
  <output_code>stash@{0}: WIP on new_feature: 527e07a Create README.md
</output_code>
  <markdown>Como vemos s√≥ temos uma, que nos indica a branch (`on new_feature`), o √∫ltimo commit (`Create README.md`) e um identificador (`527e07a`)</markdown>
  <markdown>### Armazenamento com descri√ß√£o (`git stash push -m &lt;descri√ß√£o&gt;`)</markdown>
  <markdown>Como vimos, a lista retorna o branch e o √∫ltimo commit, mas esta informa√ß√£o s√≥ serve para saber de onde come√ßamos a modificar antes de salvar no hist√≥rico. Al√©m disso, ela retorna um identificador que n√£o nos diz muito, ent√£o podemos adicionar uma primeira descri√ß√£o ao stash com `git stash push -m &lt;descri√ß√£o&gt;`</markdown>
  <markdown>Primeiro fazemos um `git status` para ver o que temos sem commitear</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama new_feature
Archivos sin seguimiento:
  (usa "git add &lt;archivo&gt;..." para incluirlo a lo que se ser√° confirmado)
	[31marchivo9.py[m

no hay nada agregado al commit pero hay archivos sin seguimiento presentes (usa "git add" para hacerles seguimiento)
</output_code>
  <markdown>Temos `arquivo9.py`, mas lembremos que ele nunca foi rastreado pelo git, portanto para inclu√≠-lo em um stash temos que usar a flag `-u` ou a flag `-a`, de modo que criamos um novo stash com uma descri√ß√£o com o comando `git stash push -u -m &lt;descri√ß√£o&gt;`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git stash push -u -m "archivo9.py"</input_code>
  <output_code>Directorio de trabajo y estado de √≠ndice On new_feature: archivo9.py guardados
</output_code>
  <markdown>Sacamos a lista do stash</markdown>
  <input_code>!cd notebook_git &amp;&amp; git stash list</input_code>
  <output_code>stash@{0}: On new_feature: archivo9.py
stash@{1}: WIP on new_feature: 527e07a Create README.md
</output_code>
  <markdown>J√° aparece o novo de maneira muito mais clara</markdown>
  <markdown>### Recuperar o √∫ltimo stash (`git stash pop`)</markdown>
  <markdown>Como dissem, o stash √© uma pilha com armazenamentos, portanto, na hora de recuper√°-los faremos da mesma forma que uma pilha, sempre recuperando o √∫ltimo.

![git stash push pop](https://pub-fb664c455eca46a2ba762a065ac900f7.r2.dev/git-stash-push-pop.webp)

Para recuperar o √∫ltimo stash temos que fazer `git stash pop`
</markdown>
  <markdown>Primeiro fazemos um `git status` para ver que n√£o tenhamos nenhum mudan√ßa pendente</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama new_feature
nada para hacer commit, el √°rbol de trabajo est√° limpio
</output_code>
  <markdown>Agora recuperamos o √∫ltimo stash</markdown>
  <input_code>!cd notebook_git &amp;&amp; git stash pop</input_code>
  <output_code>En la rama new_feature
Cambios a ser confirmados:
  (usa "git restore --staged &lt;archivo&gt;..." para sacar del √°rea de stage)
	[32mnuevos archivos: archivo9.py[m

Descartado refs/stash@{0} (0246b0e922f654e7fc68cfeaf26e24fc511feb37)
</output_code>
  <markdown>Se voltarmos a fazer `git status`, veremos que temos novamente `arquivo9.py` pendente de fazer um commit.</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama new_feature
Cambios a ser confirmados:
  (usa "git restore --staged &lt;archivo&gt;..." para sacar del √°rea de stage)
	[32mnuevos archivos: archivo9.py[m

</output_code>
  <markdown>E se verificarmos a lista de stash, veremos que agora s√≥ temos um.</markdown>
  <input_code>!cd notebook_git &amp;&amp; git stash list</input_code>
  <output_code>stash@{0}: WIP on new_feature: 527e07a Create README.md
</output_code>
  <markdown>### Remover um stash (`git stash drop &lt;posi√ß√£o&gt;`)</markdown>
  <markdown>Se quisermos remover um stash, temos que fazer `git stash drop &lt;posi√ß√£o&gt;`, onde `&lt;posi√ß√£o&gt;` √© a posi√ß√£o que o stash ocupa na lista.</markdown>
  <markdown>Obtemos a lista dos stash</markdown>
  <input_code>!cd notebook_git &amp;&amp; git stash list</input_code>
  <output_code>stash@{0}: WIP on new_feature: 527e07a Create README.md
</output_code>
  <markdown>No nosso caso, temos apenas um e na posi√ß√£o 0 (`stash@{0}`), ent√£o para remov√™-lo ter√≠amos que fazer `git stash drop 0`, mas n√£o vou fazer isso porque vou remov√™-lo agora com outro comando.</markdown>
  <markdown>### Remover todos os stashes (`git stash clear`)</markdown>
  <markdown>Se quisermos esvaziar a lista inteira do stash, temos que fazer `git stash clear`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git stash clear</input_code>
  <markdown>Se agora solicitarmos a lista de stash</markdown>
  <input_code>!cd notebook_git &amp;&amp; git stash list</input_code>
  <markdown>N√£o obtemos nada porque removemos tudo.</markdown>
  <markdown>Vamos deixar tudo como estava, fazemos um `git status` para lembrar das mudan√ßas que t√≠nhamos pendentes</markdown>
  <input_code>!cd notebook_git &amp;&amp; git status</input_code>
  <output_code>En la rama new_feature
Cambios a ser confirmados:
  (usa "git restore --staged &lt;archivo&gt;..." para sacar del √°rea de stage)
	[32mnuevos archivos: archivo9.py[m

</output_code>
  <markdown>Vemos que estamos no ramo `new_feature` e que temos `archivo9.py` pendente de fazer um commit. Como o criamos para o exemplo, o exclu√≠mos e voltamos ao ramo principal.</markdown>
  <input_code>!cd notebook_git &amp;&amp; git reset archivo9.py</input_code>
  <input_code>!cd notebook_git &amp;&amp; rm archivo9.py</input_code>
  <input_code>!cd notebook_git &amp;&amp; git switch main</input_code>
  <output_code>Cambiado a rama 'main'
Tu rama est√° actualizada con 'origin/main'.
</output_code>
  <markdown>## Tags</markdown>
  <markdown>Quando estamos desenvolvendo c√≥digo, chegam momentos em que geramos vers√µes, por exemplo a `v1.1`, `v1.2`, etc. Para ter isso mais controlado, o git nos fornece os tags.</markdown>
  <markdown>### Criar uma nova tag (`git tag -a &lt;nome_da_tag&gt; -m "&lt;mensagem&gt;"`)</markdown>
  <markdown>Para criar uma tag temos que fazer `git tag -a &lt;nome_da_tag&gt; -m "&lt;mensagem&gt;"`</markdown>
  <markdown>Por exemplo, vamos criar um tag na vers√£o atual do reposit√≥rio, para isso farei `git tag -a v_tag -m "Tag com o reposit√≥rio na parte final, onde explicamos os tags"`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git tag -a v_tag -m "Tag con el repositorio en la parte final, en la que explicamos los tags"</input_code>
  <markdown>### Lista de tags (`git tag`)</markdown>
  <markdown>Para ver os tags que criamos podemos fazer `git tag`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git tag</input_code>
  <output_code>v_tag
</output_code>
  <markdown>### Criar uma tag a partir de um commit antigo (`git tag -a &lt;nome_da_tag&gt; -m "&lt;mensagem&gt;" &lt;hash&gt;`)</markdown>
  <markdown>Vamos fazer um `git tree` para ver o hist√≥rico</markdown>
  <input_code>!cd notebook_git &amp;&amp; git tree</input_code>
  <output_code>* [33m527e07a[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmain[m[33m, [m[1;33mtag: v_tag[m[33m, [m[1;31morigin/main[m[33m, [m[1;32mnew_feature[m[33m)[m Create README.md
*   [33m679bb49[m archivo1.py con el merge resuelto
[32m|[m[33m\[m  
[32m|[m * [33m32851c3[m archivo1.py en rama rama_con_conflicto
* [33m|[m [33m53f909b[m archivo1.py en rama main
[33m|[m[33m/[m  
* [33m52acb97[m Merge squash de los commits de la rama branch_squash
*   [33m274529c[m Merge branch 'branch_no_fast_forward' into main
[34m|[m[35m\[m  
[34m|[m * [33m8df3429[m[33m ([m[1;32mbranch_no_fast_forward[m[33m)[m file2
[34m|[m * [33me4e23c9[m file1
* [35m|[m [33m8bdf4d8[m file3
[35m|[m[35m/[m  
* [33m94149fc[m[33m ([m[1;32mbranch_fast_forward[m[33m)[m Eliminado hola.py
* [33m4484e70[m Eliminado archivo4.py
* [33m564ccfb[m[33m ([m[1;32mnew_branch2[m[33m)[m Commit con el archivo 8
* [33m5168f78[m Eliminado archivo7.py
* [33m4bb9d75[m[33m ([m[1;32mnew_branch[m[33m)[m Commit con el archivo 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Embora n√£o esteja na descri√ß√£o, quando fizemos o commit `4bb9d75` foi quando terminamos a parte de controle de vers√µes localmente, por isso tamb√©m seria bom ter um tag desse momento. Para isso, precisamos criar uma tag adicionando o hash daquele momento.</markdown>
  <input_code>!cd notebook_git &amp;&amp; git tag -a v_local -m "Tag con el repositorio en la parte de control de versiones de manera local" 4bb9d75</input_code>
  <markdown>Se agora fizermos um listagem dos tags, aparece o novo</markdown>
  <input_code>!cd notebook_git &amp;&amp; git tag</input_code>
  <output_code>v_local
v_tag
</output_code>
  <markdown>E se vemos o hist√≥rico de commits</markdown>
  <input_code>!cd notebook_git &amp;&amp; git tree</input_code>
  <output_code>* [33m527e07a[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmain[m[33m, [m[1;33mtag: v_tag[m[33m, [m[1;31morigin/main[m[33m, [m[1;32mnew_feature[m[33m)[m Create README.md
*   [33m679bb49[m archivo1.py con el merge resuelto
[32m|[m[33m\[m  
[32m|[m * [33m32851c3[m archivo1.py en rama rama_con_conflicto
* [33m|[m [33m53f909b[m archivo1.py en rama main
[33m|[m[33m/[m  
* [33m52acb97[m Merge squash de los commits de la rama branch_squash
*   [33m274529c[m Merge branch 'branch_no_fast_forward' into main
[34m|[m[35m\[m  
[34m|[m * [33m8df3429[m[33m ([m[1;32mbranch_no_fast_forward[m[33m)[m file2
[34m|[m * [33me4e23c9[m file1
* [35m|[m [33m8bdf4d8[m file3
[35m|[m[35m/[m  
* [33m94149fc[m[33m ([m[1;32mbranch_fast_forward[m[33m)[m Eliminado hola.py
* [33m4484e70[m Eliminado archivo4.py
* [33m564ccfb[m[33m ([m[1;32mnew_branch2[m[33m)[m Commit con el archivo 8
* [33m5168f78[m Eliminado archivo7.py
* [33m4bb9d75[m[33m ([m[1;33mtag: v_local[m[33m, [m[1;32mnew_branch[m[33m)[m Commit con el archivo 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>No ponto do hist√≥rico onde criamos a tag, agora aparece a tag que criamos `* 4bb9d75 (tag: v_local, new_branch) Commit com o arquivo 7`</markdown>
  <markdown>### Mudar entre tags (`git reset --hard &lt;tag&gt;` ou `git reset --soft &lt;tag&gt;`)</markdown>
  <markdown>Assim como podemos nos mover entre diferentes commits do hist√≥rico, tamb√©m podemos nos mover entre tags. Isso tem a vantagem de podermos nos mover para outro momento do hist√≥rico sem precisar saber o hash, basta conhecer o nome da tag que colocamos naquele momento para nos movermos simplesmente fazendo `git reset --hard &lt;tag&gt;` ou `git reset --soft &lt;tag&gt;`</markdown>
  <markdown>Primeiro vamos fazer um `ls` para ver os arquivos que temos</markdown>
  <input_code>!cd notebook_git &amp;&amp; ls</input_code>
  <output_code>api_keys.py  archivo1.py  archivo2.py  archivo8.py  README.md
</output_code>
  <markdown>Fazemos um `git tree` tamb√©m para ver em que momento do hist√≥rico estamos</markdown>
  <input_code>!cd notebook_git &amp;&amp; git tree</input_code>
  <output_code>* [33m527e07a[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmain[m[33m, [m[1;33mtag: v_tag[m[33m, [m[1;31morigin/main[m[33m, [m[1;32mnew_feature[m[33m)[m Create README.md
*   [33m679bb49[m archivo1.py con el merge resuelto
[32m|[m[33m\[m  
[32m|[m * [33m32851c3[m archivo1.py en rama rama_con_conflicto
* [33m|[m [33m53f909b[m archivo1.py en rama main
[33m|[m[33m/[m  
* [33m52acb97[m Merge squash de los commits de la rama branch_squash
*   [33m274529c[m Merge branch 'branch_no_fast_forward' into main
[34m|[m[35m\[m  
[34m|[m * [33m8df3429[m[33m ([m[1;32mbranch_no_fast_forward[m[33m)[m file2
[34m|[m * [33me4e23c9[m file1
* [35m|[m [33m8bdf4d8[m file3
[35m|[m[35m/[m  
* [33m94149fc[m[33m ([m[1;32mbranch_fast_forward[m[33m)[m Eliminado hola.py
* [33m4484e70[m Eliminado archivo4.py
* [33m564ccfb[m[33m ([m[1;32mnew_branch2[m[33m)[m Commit con el archivo 8
* [33m5168f78[m Eliminado archivo7.py
* [33m4bb9d75[m[33m ([m[1;33mtag: v_local[m[33m, [m[1;32mnew_branch[m[33m)[m Commit con el archivo 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Agora mudamos para o ponto em que criamos a tag `v_local` atrav√©s de `git reset --hard v_local`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git reset --hard v_local</input_code>
  <output_code>HEAD est√° ahora en 4bb9d75 Commit con el archivo 7
</output_code>
  <markdown>Se agora fizermos um `ls` vemos que n√£o temos os mesmos arquivos</markdown>
  <input_code>!cd notebook_git &amp;&amp; ls</input_code>
  <output_code>api_keys.py  archivo1.py  archivo2.py  archivo4.py  archivo7.py  hola.py
</output_code>
  <markdown>Se additionally vemos o hist√≥rico, vemos que mudamos de momento do hist√≥rico.</markdown>
  <input_code>!cd notebook_git &amp;&amp; git tree</input_code>
  <output_code>* [33m4bb9d75[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmain[m[33m, [m[1;33mtag: v_local[m[33m, [m[1;32mnew_branch[m[33m)[m Commit con el archivo 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
  <markdown>Para voltar ao √∫ltimo momento do hist√≥rico, como tamb√©m criamos um tag, basta fazer `git reset --hard v_tag`</markdown>
  <input_code>!cd notebook_git &amp;&amp; git reset --hard v_tag</input_code>
  <output_code>HEAD est√° ahora en 527e07a Create README.md
</output_code>
  <markdown>Voltamos a ver o hist√≥rico para verificar que retornamos ao √∫ltimo momento do hist√≥rico</markdown>
  <input_code>!cd notebook_git &amp;&amp; git tree</input_code>
  <output_code>* [33m527e07a[m[33m ([m[1;36mHEAD -&gt; [m[1;32mmain[m[33m, [m[1;33mtag: v_tag[m[33m, [m[1;31morigin/main[m[33m, [m[1;32mnew_feature[m[33m)[m Create README.md
*   [33m679bb49[m archivo1.py con el merge resuelto
[32m|[m[33m\[m  
[32m|[m * [33m32851c3[m archivo1.py en rama rama_con_conflicto
* [33m|[m [33m53f909b[m archivo1.py en rama main
[33m|[m[33m/[m  
* [33m52acb97[m Merge squash de los commits de la rama branch_squash
*   [33m274529c[m Merge branch 'branch_no_fast_forward' into main
[34m|[m[35m\[m  
[34m|[m * [33m8df3429[m[33m ([m[1;32mbranch_no_fast_forward[m[33m)[m file2
[34m|[m * [33me4e23c9[m file1
* [35m|[m [33m8bdf4d8[m file3
[35m|[m[35m/[m  
* [33m94149fc[m[33m ([m[1;32mbranch_fast_forward[m[33m)[m Eliminado hola.py
* [33m4484e70[m Eliminado archivo4.py
* [33m564ccfb[m[33m ([m[1;32mnew_branch2[m[33m)[m Commit con el archivo 8
* [33m5168f78[m Eliminado archivo7.py
* [33m4bb9d75[m[33m ([m[1;33mtag: v_local[m[33m, [m[1;32mnew_branch[m[33m)[m Commit con el archivo 7
* [33mea615a9[m Eliminado archivo5.py
* [33me3153a5[m Commit con los archivos 4 y 5
* [33m0b09cfa[m A√±adido .gitignore
* [33m04ebd1f[m Commit con los archivos 1 y 2
* [33mc4930d7[m Tercer commit, hola.py
* [33m6e99e73[m Segundo commit, hola.py
* [33m1c95e4f[m Primer commit, hola.py
</output_code>
</notebook>